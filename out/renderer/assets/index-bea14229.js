function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map2[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE$1 = /^on[^a-z]/;
const isOn$1 = (key) => onRE$1.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$2 = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$3 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$2 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$5 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$5(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value2) => objectToString.call(value2);
const toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize(str)}` : ``
);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value2) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value: value2
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$2(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value2) {
  if (isArray$3(value2)) {
    const res = {};
    for (let i2 = 0; i2 < value2.length; i2++) {
      const item = value2[i2];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value2)) {
    return value2;
  } else if (isObject$5(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$2(value2)) {
    res = value2;
  } else if (isArray$3(value2)) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      const normalized = normalizeClass(value2[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$5(value2)) {
    for (const name in value2) {
      if (value2[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
const toDisplayString = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$3(val) || isObject$5(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$5(val) && !isArray$3(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$3(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$3(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get22(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$3(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$5(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value2, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value2)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray$3(target) && isRef(oldValue) && !isRef(value2)) {
        oldValue.value = value2;
        return true;
      }
    }
    const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value2, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger(target, "set", key, value2);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$3(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1$1,
  set: set$1$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$2(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value2) => value2;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$2(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$2(value2) {
  value2 = toRaw(value2);
  const target = toRaw(this);
  const proto2 = getProto(target);
  const hadKey = proto2.has.call(target, value2);
  if (!hadKey) {
    target.add(value2);
    trigger(target, "add", value2, value2);
  }
  return this;
}
function set$2(key, value2) {
  value2 = toRaw(value2);
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get22.call(target, key);
  target.set(key, value2);
  if (!hadKey) {
    trigger(target, "add", key, value2);
  } else if (hasChanged(value2, oldValue)) {
    trigger(target, "set", key, value2);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get22 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get22 ? get22.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value2, key) => {
      return callback.call(thisArg, wrap(value2), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$3(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$2,
    add: add$2,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$3(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$2,
    add: add$2,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$3(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$2.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$3(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$2.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$5(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return isReactive(value2) || isReadonly(value2);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  def(value2, "__v_skip", true);
  return value2;
}
const toReactive = (value2) => isObject$5(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$5(value2) ? readonly(value2) : value2;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value2 : toRaw(value2);
    this._value = __v_isShallow ? value2 : toReactive(value2);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value2, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target, key, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$3(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$2(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$5(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(
    source,
    key,
    defaultValue
  );
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn$1(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$3(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff2 = getId(a) - getId(b);
  if (diff2 === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff2;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$2(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$5(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$2(normalized, raw);
  }
  if (isObject$5(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn$1(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev2 = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev2;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    data: data2,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev2 = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data2,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev2);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn$1(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v, i2) => hasChanged(v, oldValue[i2])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value2, seen2) {
  if (!isObject$5(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value2)) {
    return value2;
  }
  seen2.add(value2);
  if (isRef(value2)) {
    traverse(value2.value, seen2);
  } else if (isArray$3(value2)) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      traverse(value2[i2], seen2);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject$1(value2)) {
    for (const key in value2) {
      traverse(value2[key], seen2);
    }
  }
  return value2;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance$1();
    const state2 = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state2,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state2,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state2,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state2, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$3(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks2 = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks2.delayedLeave) {
          hooks2.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state2.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state2, instance);
    }
  };
  return hooks2;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks2) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks2);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks2;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent$1(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$2({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks2 = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks2.unshift(wrappedHook);
    } else {
      hooks2.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  if (isArray$3(source) || isString$2(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$5(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
    $nextTick: (i2) => i2.n || (i2.n = nextTick$1.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state2, key) => state2 !== EMPTY_OBJ && !state2.__isScriptSetup && hasOwn(state2, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data2[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data2 !== EMPTY_OBJ && hasOwn(data2, key)) {
        accessCache[key] = 2;
        return data2[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value2) {
    const { data: data2, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value2;
      return true;
    } else if (data2 !== EMPTY_OBJ && hasOwn(data2, key)) {
      data2[key] = value2;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value2;
      }
    }
    return true;
  },
  has({
    _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn(data2, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$3(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted: mounted2,
    beforeUpdate,
    updated: updated2,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted: unmounted2,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data2 = dataOptions.call(publicThis, publicThis);
    if (!isObject$5(data2))
      ;
    else {
      instance.data = reactive(data2);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get3 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get3,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted2);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated2);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted2);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$5(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$5(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$5(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to2, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions$1(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to2, m, strats, true)
    );
  }
  for (const key in from2) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from2) {
  if (!from2) {
    return to2;
  }
  if (!to2) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$2(
      isFunction$2(to2) ? to2.call(this, this) : to2,
      isFunction$2(from2) ? from2.call(this, this) : from2
    );
  };
}
function mergeInject(to2, from2) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from2) {
  return to2 ? [...new Set([].concat(to2, from2))] : from2;
}
function mergeObjectOptions(to2, from2) {
  return to2 ? extend$2(/* @__PURE__ */ Object.create(null), to2, from2) : from2;
}
function mergeEmitsOrPropsOptions(to2, from2) {
  if (to2) {
    if (isArray$3(to2) && isArray$3(from2)) {
      return [.../* @__PURE__ */ new Set([...to2, ...from2])];
    }
    return extend$2(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to2),
      normalizePropsOrEmits(from2 != null ? from2 : {})
    );
  } else {
    return from2;
  }
}
function mergeWatchOptions(to2, from2) {
  if (!to2)
    return from2;
  if (!from2)
    return to2;
  const merged = extend$2(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from2) {
    merged[key] = mergeAsArray(to2[key], from2[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend$2({}, rootComponent);
    }
    if (rootProps != null && !isObject$5(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive2) {
        if (!directive2) {
          return context.directives[name];
        }
        context.directives[name] = directive2;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value2) {
        context.provides[key] = value2;
        return app2;
      },
      runWithContext(fn) {
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value2) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value2;
  }
}
function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value2 = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value2 !== attrs[key]) {
              attrs[key] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value2,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value2 !== attrs[key]) {
            attrs[key] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value2 = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value2 !== attrs[key]) {
          attrs[key] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value2, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value2 = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value2 = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value2 = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value2 === "" || value2 === hyphenate(key))) {
        value2 = true;
      }
    }
  }
  return value2;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$2(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$5(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$2(opt) ? { type: opt } : extend$2({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$5(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$3(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value2) => isArray$3(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value2 = rawSlots[key];
    if (isFunction$2(value2)) {
      slots[key] = normalizeSlot$1(key, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$2(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$3(existing) && remove(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value2;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value2;
          }
        } else if (_isRef) {
          ref2.value = value2;
          if (rawRef.k)
            refs[rawRef.k] = value2;
        } else
          ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev2 = oldProps[key];
            const next = newProps[key];
            if (next !== prev2 || key === "value") {
              hostPatchProp(
                el,
                key,
                prev2,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev2 = oldProps[key];
        if (next !== prev2 && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev2,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update3),
      instance.scope
      // track it in component's effect scope
    );
    const update3 = instance.update = () => effect.run();
    update3.id = instance.uid;
    toggleRecurse(instance, true);
    update3();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update3, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update3) {
      update3.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update: update3 }, allowed) {
  effect.allowRecurse = update3.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u, v, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            true,
            !!child.dynamicChildren
          );
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2) {
  isBlockTreeEnabled += value2;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$5(style)) {
      if (isProxy(style) && !isArray$3(style)) {
        style = extend$2({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$5(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray$3(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$3(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn$1(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance$1 = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$5(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$2(
          extend$2(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value2) {
  return isFunction$2(value2) && "__vccOpts" in value2;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$5(propsOrChildren) && !isArray$3(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
const version$1 = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value2, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
function patchStyle(el, prev2, next) {
  const style = el.style;
  const isCssString = isString$2(next);
  if (next && !isCssString) {
    if (prev2 && !isString$2(prev2)) {
      for (const key in prev2) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev2 !== next) {
        style.cssText = next;
      }
    } else if (prev2) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$3(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value2, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value2);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value2 == null || isBoolean && !includeBooleanAttr(value2)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value2);
    }
  }
}
function patchDOMProp(el, key, value2, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value2 == null ? "" : value2;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value2;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value2 == null ? "" : value2;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value2 === "" || value2 == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value2 = includeBooleanAttr(value2);
    } else if (value2 == null && type === "string") {
      value2 = "";
      needRemove = true;
    } else if (type === "number") {
      value2 = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value2;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value2) {
  if (isArray$3(value2)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value2.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value2;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn$1(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value2, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$2(value2)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$2(value2)) {
    return false;
  }
  return key in el;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$2(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$3(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$3(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$2(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$5(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance$1();
    const state2 = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state2, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state2, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone2 = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const vShow = {
  beforeMount(el, { value: value2 }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value2) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value2);
    }
  },
  mounted(el, { value: value2 }, { transition }) {
    if (transition && value2) {
      transition.enter(el);
    }
  },
  updated(el, { value: value2, oldValue }, { transition }) {
    if (!value2 === !oldValue)
      return;
    if (transition) {
      if (value2) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value2);
    }
  },
  beforeUnmount(el, { value: value2 }) {
    setDisplay(el, value2);
  }
};
function setDisplay(el, value2) {
  el.style.display = value2 ? el._vod : "none";
}
const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now$1() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data2 = JSON.parse(raw);
      Object.assign(currentSettings, data2);
    } catch (e) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value2) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value2));
        } catch (e) {
        }
        currentSettings = value2;
      },
      now() {
        return now$1();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value2) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value2);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value2 = params[key];
    newParams[key] = isArray$2(value2) ? value2.map(fn) : fn(value2);
  }
  return newParams;
}
const noop = () => {
};
const isArray$2 = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray$2(a) ? isEquivalentArray(a, b) : isArray$2(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray$2(b) ? a.length === b.length && a.every((value2, i2) => value2 === b[i2]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to2, from2) {
  if (to2.startsWith("/"))
    return to2;
  if (!to2)
    return from2;
  const fromSegments = from2.split("/");
  const toSegments = to2.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset2) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset2.behavior,
    left: elRect.left - docRect.left - (offset2.left || 0),
    top: elRect.top - docRect.top - (offset2.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta2) {
  const position = history.state ? history.state.position - delta2 : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace2) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state: state2 }) => {
    const to2 = createCurrentLocation(base, location);
    const from2 = currentLocation.value;
    const fromState = historyState.value;
    let delta2 = 0;
    if (state2) {
      currentLocation.value = to2;
      historyState.value = state2;
      if (pauseState && pauseState === from2) {
        pauseState = null;
        return;
      }
      delta2 = fromState ? state2.position - fromState.position : 0;
    } else {
      replace2(to2);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from2, {
        delta: delta2,
        type: NavigationType.pop,
        direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to2, state2, replace3) {
    const hashIndex = base.indexOf("#");
    const url2 = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to2 : createBaseLocation() + base + to2;
    try {
      history2[replace3 ? "replaceState" : "pushState"](state2, "", url2);
      historyState.value = state2;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace3 ? "replace" : "assign"](url2);
    }
  }
  function replace2(to2, data2) {
    const state2 = assign({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to2,
      historyState.value.forward,
      true
    ), data2, { position: historyState.value.position });
    changeLocation(to2, state2, true);
    currentLocation.value = to2;
  }
  function push(to2, data2) {
    const currentState = assign(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to2,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state2 = assign({}, buildState(currentLocation.value, to2, null), { position: currentState.position + 1 }, data2);
    changeLocation(to2, state2, false);
    currentLocation.value = to2;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace: replace2
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta2, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta2);
  }
  const routerHistory = assign({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token2 = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token2.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token2.type === 1) {
        const { value: value2, repeatable, optional, regexp } = token2;
        keys2.push({
          name: value2,
          repeatable,
          optional
        });
        const re3 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re3 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re3})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value2}" (${re3}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re3})(?:/(?:${re3}))*)` : `(${re3})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re3 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re2);
    const params = {};
    if (!match)
      return null;
    for (let i2 = 1; i2 < match.length; i2++) {
      const value2 = match[i2] || "";
      const key = keys2[i2 - 1];
      params[key.name] = value2 && key.repeatable ? value2.split("/") : value2;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token2 of segment) {
        if (token2.type === 0) {
          path += token2.value;
        } else if (token2.type === 1) {
          const { value: value2, repeatable, optional } = token2;
          const param = value2 in params ? params[value2] : "";
          if (isArray$2(param) && !repeatable) {
            throw new Error(`Provided param "${value2}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray$2(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value2}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re: re2,
    score,
    keys: keys2,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i2 = 0;
  while (i2 < a.length && i2 < b.length) {
    const diff2 = b[i2] - a[i2];
    if (diff2)
      return diff2;
    i2++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i2 = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state2})/"${buffer}": ${message}`);
  }
  let state2 = 0;
  let previousState = state2;
  const tokens2 = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens2.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state2 === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state2 === 1 || state2 === 2 || state2 === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state2 !== 2) {
      previousState = state2;
      state2 = 4;
      continue;
    }
    switch (state2) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state2 = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state2 = previousState;
        break;
      case 1:
        if (char === "(") {
          state2 = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state2 = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state2 = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state2 = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state2 === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens2;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser2 = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser2, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases2) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
        insertMatcher(matcher);
      }
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (matcher.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher, matchers[i2])))
      i2++;
    matchers.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // TODO: only keep optional params coming from a parent record
          matcher.keys.filter((k2) => !k2.optional).map((k2) => k2.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "object" ? props[name] : props;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults2, partialOptions) {
  const options = {};
  for (const key in defaults2) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode$2(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode$2(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value2 = eqPos < 0 ? null : decode$2(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$2(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value2);
    } else {
      query[key] = value2;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value2 = query[key];
    key = encodeQueryKey(key);
    if (value2 == null) {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray$2(value2) ? value2.map((v) => v && encodeQueryValue(v)) : [value2 && encodeQueryValue(value2)];
    values.forEach((value3) => {
      if (value3 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value3 != null)
          search += "=" + value3;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value2 = query[key];
    if (value2 !== void 0) {
      normalizedQuery[key] = isArray$2(value2) ? value2.map((v) => v == null ? null : "" + v) : value2 == null ? value2 : "" + value2;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler) {
    handlers2.push(handler);
    return () => {
      const i2 = handlers2.indexOf(handler);
      if (i2 > -1)
        handlers2.splice(i2, 1);
    };
  }
  function reset() {
    handlers2 = [];
  }
  return {
    add: add2,
    list: () => handlers2.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to2, from2, record, name) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from: from2,
          to: to2
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to2,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to2, from2, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to2, from2) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to2, from2, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to2, from2, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink$1(props) {
  const router2 = inject$1(routerKey);
  const currentRoute = inject$1(routeLocationKey);
  const route = computed(() => router2.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length: length2 } = matched;
    const routeMatched = matched[length2 - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length2 - 2]);
    return (
      // we are dealing with nested routes
      length2 > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length2 - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router2[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent$1({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink: useLink$1,
  setup(props, { slots }) {
    const link = reactive(useLink$1(props));
    const { options } = inject$1(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$2(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value2, i2) => value2 !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent$1({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject$1(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject$1(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to2, name], [oldInstance, from2, oldName]) => {
      if (to2) {
        to2.instances[name] = instance;
        if (from2 && from2 !== to2 && instance && instance === oldInstance) {
          if (!to2.leaveGuards.size) {
            to2.leaveGuards = from2.leaveGuards;
          }
          if (!to2.updateGuards.size) {
            to2.updateGuards = from2.updateGuards;
          }
        }
      }
      if (instance && to2 && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from2 || !isSameRouteRecord(to2, from2) || !oldInstance)) {
        (to2.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data2) {
  if (!slot)
    return null;
  const slotContent = slot(data2);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode$2)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$2(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to2) {
    return typeof to2 === "string" ? parseURL(parseQuery$1, to2, currentRoute.value.path) : assign({}, to2);
  }
  function checkCanceledNavigation(to2, from2) {
    if (pendingLocation !== to2) {
      return createRouterError(8, {
        from: from2,
        to: to2
      });
    }
  }
  function push(to2) {
    return pushWithRedirect(to2);
  }
  function replace2(to2) {
    return push(assign(locationAsObject(to2), { replace: true }));
  }
  function handleRedirectRecord(to2) {
    const lastMatched = to2.matched[to2.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to2) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign({
        query: to2.query,
        hash: to2.hash,
        // avoid transferring params if the redirect has a path
        params: "path" in newTargetLocation ? {} : to2.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to2, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to2);
    const from2 = currentRoute.value;
    const data2 = to2.state;
    const force = to2.force;
    const replace3 = to2.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data2, shouldRedirect.state) : data2,
          force,
          replace: replace3
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from: from2 });
      handleScroll(
        from2,
        from2,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from2)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace3
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data2, failure2.to.state) : data2,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from2, true, replace3, data2);
      }
      triggerAfterEach(toLocation, from2, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to2, from2) {
    const error = checkCanceledNavigation(to2, from2);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app2 = installedApps.values().next().value;
    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
  }
  function navigate(to2, from2) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to2, from2);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to2, from2);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to2, from2));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to2, from2);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to2, from2);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to2, from2));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray$2(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to2, from2));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to2, from2));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to2.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to2, from2);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to2, from2, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to2, from2, failure)));
  }
  function finalizeNavigation(toLocation, from2, isPush, replace3, data2) {
    const error = checkCanceledNavigation(toLocation, from2);
    if (error)
      return error;
    const isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
    const state2 = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace3 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state2 && state2.scroll
        }, data2));
      else
        routerHistory.push(toLocation.fullPath, data2);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from2, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to2, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to2);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from2 = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from2.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from2).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from2);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from2,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from2, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to2, from2) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to2, from2));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to2, from2, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to2.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick$1().then(() => scrollBehavior(to2, from2, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to2, from2));
  }
  const go = (delta2) => routerHistory.go(delta2);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace: replace2,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router3 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router3;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app2.provide(routerKey, router3);
      app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router2;
}
function extractChangingRecords(to2, from2) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from2.matched.length, to2.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from2.matched[i2];
    if (recordFrom) {
      if (to2.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to2.matched[i2];
    if (recordTo) {
      if (!from2.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var js_cookie = { exports: {} };
/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function(module2, exports) {
  (function(factory) {
    var registeredInModuleLoader;
    {
      module2.exports = factory();
      registeredInModuleLoader = true;
    }
    if (!registeredInModuleLoader) {
      var OldCookies = window.Cookies;
      var api = window.Cookies = factory();
      api.noConflict = function() {
        window.Cookies = OldCookies;
        return api;
      };
    }
  })(function() {
    function extend2() {
      var i2 = 0;
      var result = {};
      for (; i2 < arguments.length; i2++) {
        var attributes = arguments[i2];
        for (var key in attributes) {
          result[key] = attributes[key];
        }
      }
      return result;
    }
    function decode2(s) {
      return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    }
    function init(converter) {
      function api() {
      }
      function set2(key, value2, attributes) {
        if (typeof document === "undefined") {
          return;
        }
        attributes = extend2({
          path: "/"
        }, api.defaults, attributes);
        if (typeof attributes.expires === "number") {
          attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);
        }
        attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
        try {
          var result = JSON.stringify(value2);
          if (/^[\{\[]/.test(result)) {
            value2 = result;
          }
        } catch (e) {
        }
        value2 = converter.write ? converter.write(value2, key) : encodeURIComponent(String(value2)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
        key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
        var stringifiedAttributes = "";
        for (var attributeName in attributes) {
          if (!attributes[attributeName]) {
            continue;
          }
          stringifiedAttributes += "; " + attributeName;
          if (attributes[attributeName] === true) {
            continue;
          }
          stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
        }
        return document.cookie = key + "=" + value2 + stringifiedAttributes;
      }
      function get3(key, json) {
        if (typeof document === "undefined") {
          return;
        }
        var jar = {};
        var cookies2 = document.cookie ? document.cookie.split("; ") : [];
        var i2 = 0;
        for (; i2 < cookies2.length; i2++) {
          var parts2 = cookies2[i2].split("=");
          var cookie = parts2.slice(1).join("=");
          if (!json && cookie.charAt(0) === '"') {
            cookie = cookie.slice(1, -1);
          }
          try {
            var name = decode2(parts2[0]);
            cookie = (converter.read || converter)(cookie, name) || decode2(cookie);
            if (json) {
              try {
                cookie = JSON.parse(cookie);
              } catch (e) {
              }
            }
            jar[name] = cookie;
            if (key === name) {
              break;
            }
          } catch (e) {
          }
        }
        return key ? jar[key] : jar;
      }
      api.set = set2;
      api.get = function(key) {
        return get3(
          key,
          false
          /* read as raw */
        );
      };
      api.getJSON = function(key) {
        return get3(
          key,
          true
          /* read as json */
        );
      };
      api.remove = function(key, attributes) {
        set2(key, "", extend2(attributes, {
          expires: -1
        }));
      };
      api.defaults = {};
      api.withConverter = init;
      return api;
    }
    return init(function() {
    });
  });
})(js_cookie);
var js_cookieExports = js_cookie.exports;
const SplashScreen_vue_vue_type_style_index_0_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const VApp$1 = "";
function propsFactory(props, source) {
  return (defaults2) => {
    return Object.keys(props).reduce((obj, prop) => {
      const isObjectDefinition = typeof props[prop] === "object" && props[prop] != null && !Array.isArray(props[prop]);
      const definition = isObjectDefinition ? props[prop] : {
        type: props[prop]
      };
      if (defaults2 && prop in defaults2) {
        obj[prop] = {
          ...definition,
          default: defaults2[prop]
        };
      } else {
        obj[prop] = definition;
      }
      if (source && !obj[prop].source) {
        obj[prop].source = source;
      }
      return obj;
    }, {});
  };
}
const makeComponentProps = propsFactory({
  class: [String, Array],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
const IN_BROWSER = typeof window !== "undefined";
const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
function getNestedValue(obj, path, fallback) {
  const last = path.length - 1;
  if (last < 0)
    return obj === void 0 ? fallback : obj;
  for (let i2 = 0; i2 < last; i2++) {
    if (obj == null) {
      return fallback;
    }
    obj = obj[path[i2]];
  }
  if (obj == null)
    return fallback;
  return obj[path[last]] === void 0 ? fallback : obj[path[last]];
}
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
    return false;
  }
  if (a !== Object(a) || b !== Object(b)) {
    return false;
  }
  const props = Object.keys(a);
  if (props.length !== Object.keys(b).length) {
    return false;
  }
  return props.every((p2) => deepEqual(a[p2], b[p2]));
}
function getObjectValueByPath(obj, path, fallback) {
  if (obj == null || !path || typeof path !== "string")
    return fallback;
  if (obj[path] !== void 0)
    return obj[path];
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  return getNestedValue(obj, path.split("."), fallback);
}
function getPropertyFromItem(item, property, fallback) {
  if (property == null)
    return item === void 0 ? fallback : item;
  if (item !== Object(item)) {
    if (typeof property !== "function")
      return fallback;
    const value3 = property(item, fallback);
    return typeof value3 === "undefined" ? fallback : value3;
  }
  if (typeof property === "string")
    return getObjectValueByPath(item, property, fallback);
  if (Array.isArray(property))
    return getNestedValue(item, property, fallback);
  if (typeof property !== "function")
    return fallback;
  const value2 = property(item, fallback);
  return typeof value2 === "undefined" ? fallback : value2;
}
function createRange(length2) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: length2
  }, (v, k2) => start + k2);
}
function convertToUnit(str) {
  let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (str == null || str === "") {
    return void 0;
  } else if (isNaN(+str)) {
    return String(str);
  } else if (!isFinite(+str)) {
    return void 0;
  } else {
    return `${Number(str)}${unit}`;
  }
}
function isObject$4(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
function refElement(obj) {
  return obj && "$el" in obj ? obj.$el : obj;
}
const keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
function keys$1(o) {
  return Object.keys(o);
}
function has(obj, key) {
  return key.every((k2) => obj.hasOwnProperty(k2));
}
function pick$1(obj, paths, exclude) {
  const found = /* @__PURE__ */ Object.create(null);
  const rest = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    if (paths.some((path) => path instanceof RegExp ? path.test(key) : path === key) && !exclude?.some((path) => path === key)) {
      found[key] = obj[key];
    } else {
      rest[key] = obj[key];
    }
  }
  return [found, rest];
}
function omit(obj, exclude) {
  const clone2 = {
    ...obj
  };
  exclude.forEach((prop) => delete clone2[prop]);
  return clone2;
}
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
function filterInputAttrs(attrs) {
  const [events, props] = pick$1(attrs, [onRE]);
  const inputEvents = omit(events, bubblingEvents);
  const [rootAttrs, inputAttrs] = pick$1(props, ["class", "style", "id", /^data-/]);
  Object.assign(rootAttrs, events);
  Object.assign(inputAttrs, inputEvents);
  return [rootAttrs, inputAttrs];
}
function wrapInArray(v) {
  return v == null ? [] : Array.isArray(v) ? v : [v];
}
function clamp(value2) {
  let min2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let max2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(min2, Math.min(max2, value2));
}
function padEnd(str, length2) {
  let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return str + char.repeat(Math.max(0, length2 - str.length));
}
function chunk(str) {
  let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const chunked = [];
  let index = 0;
  while (index < str.length) {
    chunked.push(str.substr(index, size2));
    index += size2;
  }
  return chunked;
}
function mergeDeep() {
  let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
  const out = {};
  for (const key in source) {
    out[key] = source[key];
  }
  for (const key in target) {
    const sourceProperty = source[key];
    const targetProperty = target[key];
    if (isObject$4(sourceProperty) && isObject$4(targetProperty)) {
      out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
      continue;
    }
    if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
      out[key] = arrayFn(sourceProperty, targetProperty);
      continue;
    }
    out[key] = targetProperty;
  }
  return out;
}
function flattenFragments(nodes) {
  return nodes.map((node) => {
    if (node.type === Fragment) {
      return flattenFragments(node.children);
    } else {
      return node;
    }
  }).flat();
}
function toKebabCase() {
  let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (toKebabCase.cache.has(str))
    return toKebabCase.cache.get(str);
  const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  toKebabCase.cache.set(str, kebab);
  return kebab;
}
toKebabCase.cache = /* @__PURE__ */ new Map();
function findChildrenWithProvide(key, vnode) {
  if (!vnode || typeof vnode !== "object")
    return [];
  if (Array.isArray(vnode)) {
    return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
  } else if (Array.isArray(vnode.children)) {
    return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
  } else if (vnode.component) {
    if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
      return [vnode.component];
    } else if (vnode.component.subTree) {
      return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
    }
  }
  return [];
}
function destructComputed(getter) {
  const refs = reactive({});
  const base = computed(getter);
  watchEffect(() => {
    for (const key in base.value) {
      refs[key] = base.value[key];
    }
  }, {
    flush: "sync"
  });
  return toRefs(refs);
}
function includes(arr, val) {
  return arr.includes(val);
}
function eventName(propName) {
  return propName[2].toLowerCase() + propName.slice(3);
}
const EventProp = () => [Function, Array];
function hasEvent(props, name) {
  name = "on" + capitalize(name);
  return !!(props[name] || props[`${name}Once`] || props[`${name}Capture`] || props[`${name}OnceCapture`] || props[`${name}CaptureOnce`]);
}
function callEvent(handler) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  if (Array.isArray(handler)) {
    for (const h2 of handler) {
      h2(...args);
    }
  } else if (typeof handler === "function") {
    handler(...args);
  }
}
function focusableChildren(el) {
  let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...el.querySelectorAll(targets)];
}
function getNextElement(elements, location2, condition) {
  let _el;
  let idx = elements.indexOf(document.activeElement);
  const inc = location2 === "next" ? 1 : -1;
  do {
    idx += inc;
    _el = elements[idx];
  } while ((!_el || _el.offsetParent == null || !(condition?.(_el) ?? true)) && idx < elements.length && idx >= 0);
  return _el;
}
function focusChild(el, location2) {
  const focusable = focusableChildren(el);
  if (!location2) {
    if (el === document.activeElement || !el.contains(document.activeElement)) {
      focusable[0]?.focus();
    }
  } else if (location2 === "first") {
    focusable[0]?.focus();
  } else if (location2 === "last") {
    focusable.at(-1)?.focus();
  } else if (typeof location2 === "number") {
    focusable[location2]?.focus();
  } else {
    const _el = getNextElement(focusable, location2);
    if (_el)
      _el.focus();
    else
      focusChild(el, location2 === "next" ? "first" : "last");
  }
}
function matchesSelector(el, selector) {
  const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
  if (!supportsSelector)
    return null;
  try {
    return !!el && el.matches(selector);
  } catch (err) {
    return null;
  }
}
const block = ["top", "bottom"];
const inline = ["start", "end", "left", "right"];
function parseAnchor(anchor, isRtl) {
  let [side, align] = anchor.split(" ");
  if (!align) {
    align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
  }
  return {
    side: toPhysical(side, isRtl),
    align: toPhysical(align, isRtl)
  };
}
function toPhysical(str, isRtl) {
  if (str === "start")
    return isRtl ? "right" : "left";
  if (str === "end")
    return isRtl ? "left" : "right";
  return str;
}
function flipSide(anchor) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.side],
    align: anchor.align
  };
}
function flipAlign(anchor) {
  return {
    side: anchor.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.align]
  };
}
function flipCorner(anchor) {
  return {
    side: anchor.align,
    align: anchor.side
  };
}
function getAxis(anchor) {
  return includes(block, anchor.side) ? "y" : "x";
}
class Box {
  constructor(_ref) {
    let {
      x: x2,
      y,
      width,
      height
    } = _ref;
    this.x = x2;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function getOverflow(a, b) {
  return {
    x: {
      before: Math.max(0, b.left - a.left),
      after: Math.max(0, a.right - b.right)
    },
    y: {
      before: Math.max(0, b.top - a.top),
      after: Math.max(0, a.bottom - b.bottom)
    }
  };
}
function nullifyTransforms(el) {
  const rect = el.getBoundingClientRect();
  const style = getComputedStyle(el);
  const tx = style.transform;
  if (tx) {
    let ta, sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return new Box(rect);
    }
    const to2 = style.transformOrigin;
    const x2 = rect.x - dx - (1 - sx) * parseFloat(to2);
    const y = rect.y - dy - (1 - sy) * parseFloat(to2.slice(to2.indexOf(" ") + 1));
    const w2 = sx ? rect.width / sx : el.offsetWidth + 1;
    const h2 = sy ? rect.height / sy : el.offsetHeight + 1;
    return new Box({
      x: x2,
      y,
      width: w2,
      height: h2
    });
  } else {
    return new Box(rect);
  }
}
function animate(el, keyframes, options) {
  if (typeof el.animate === "undefined")
    return {
      finished: Promise.resolve()
    };
  let animation;
  try {
    animation = el.animate(keyframes, options);
  } catch (err) {
    return {
      finished: Promise.resolve()
    };
  }
  if (typeof animation.finished === "undefined") {
    animation.finished = new Promise((resolve2) => {
      animation.onfinish = () => {
        resolve2(animation);
      };
    });
  }
  return animation;
}
const handlers = /* @__PURE__ */ new WeakMap();
function bindProps(el, props) {
  Object.keys(props).forEach((k2) => {
    if (isOn(k2)) {
      const name = eventName(k2);
      const handler = handlers.get(el);
      if (props[k2] == null) {
        handler?.forEach((v) => {
          const [n, fn] = v;
          if (n === name) {
            el.removeEventListener(name, fn);
            handler.delete(v);
          }
        });
      } else if (!handler || ![...handler]?.some((v) => v[0] === name && v[1] === props[k2])) {
        el.addEventListener(name, props[k2]);
        const _handler = handler || /* @__PURE__ */ new Set();
        _handler.add([name, props[k2]]);
        if (!handlers.has(el))
          handlers.set(el, _handler);
      }
    } else {
      if (props[k2] == null) {
        el.removeAttribute(k2);
      } else {
        el.setAttribute(k2, props[k2]);
      }
    }
  });
}
function unbindProps(el, props) {
  Object.keys(props).forEach((k2) => {
    if (isOn(k2)) {
      const name = eventName(k2);
      const handler = handlers.get(el);
      handler?.forEach((v) => {
        const [n, fn] = v;
        if (n === name) {
          el.removeEventListener(name, fn);
          handler.delete(v);
        }
      });
    } else {
      el.removeAttribute(k2);
    }
  });
}
const mainTRC = 2.4;
const Rco = 0.2126729;
const Gco = 0.7151522;
const Bco = 0.072175;
const normBG = 0.55;
const normTXT = 0.58;
const revTXT = 0.57;
const revBG = 0.62;
const blkThrs = 0.03;
const blkClmp = 1.45;
const deltaYmin = 5e-4;
const scaleBoW = 1.25;
const scaleWoB = 1.25;
const loConThresh = 0.078;
const loConFactor = 12.82051282051282;
const loConOffset = 0.06;
const loClip = 1e-3;
function APCAcontrast(text, background) {
  const Rtxt = (text.r / 255) ** mainTRC;
  const Gtxt = (text.g / 255) ** mainTRC;
  const Btxt = (text.b / 255) ** mainTRC;
  const Rbg = (background.r / 255) ** mainTRC;
  const Gbg = (background.g / 255) ** mainTRC;
  const Bbg = (background.b / 255) ** mainTRC;
  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
  if (Ytxt <= blkThrs)
    Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs)
    Ybg += (blkThrs - Ybg) ** blkClmp;
  if (Math.abs(Ybg - Ytxt) < deltaYmin)
    return 0;
  let outputContrast;
  if (Ybg > Ytxt) {
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
    outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }
  return outputContrast * 100;
}
function consoleWarn(message) {
}
function deprecate$1(original, replacement) {
  replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
}
const delta = 0.20689655172413793;
const cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
const cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ$1(xyz) {
  const transform2 = cielabForwardTransform;
  const transformedY = transform2(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
}
function toXYZ$1(lab) {
  const transform2 = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
}
const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
const srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
const srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
  const rgb = Array(3);
  const transform2 = srgbForwardTransform;
  const matrix = srgbForwardMatrix;
  for (let i2 = 0; i2 < 3; ++i2) {
    rgb[i2] = Math.round(clamp(transform2(matrix[i2][0] * xyz[0] + matrix[i2][1] * xyz[1] + matrix[i2][2] * xyz[2])) * 255);
  }
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2]
  };
}
function toXYZ(_ref) {
  let {
    r,
    g,
    b
  } = _ref;
  const xyz = [0, 0, 0];
  const transform2 = srgbReverseTransform;
  const matrix = srgbReverseMatrix;
  r = transform2(r / 255);
  g = transform2(g / 255);
  b = transform2(b / 255);
  for (let i2 = 0; i2 < 3; ++i2) {
    xyz[i2] = matrix[i2][0] * r + matrix[i2][1] * g + matrix[i2][2] * b;
  }
  return xyz;
}
function isCssColor(color) {
  return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
const mappers = {
  rgb: (r, g, b, a) => ({
    r,
    g,
    b,
    a
  }),
  rgba: (r, g, b, a) => ({
    r,
    g,
    b,
    a
  }),
  hsl: (h2, s, l, a) => HSLtoRGB({
    h: h2,
    s,
    l,
    a
  }),
  hsla: (h2, s, l, a) => HSLtoRGB({
    h: h2,
    s,
    l,
    a
  }),
  hsv: (h2, s, v, a) => HSVtoRGB({
    h: h2,
    s,
    v,
    a
  }),
  hsva: (h2, s, v, a) => HSVtoRGB({
    h: h2,
    s,
    v,
    a
  })
};
function parseColor(color) {
  if (typeof color === "number") {
    return {
      r: (color & 16711680) >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  } else if (typeof color === "string" && cssColorRe.test(color)) {
    const {
      groups
    } = color.match(cssColorRe);
    const {
      fn,
      values
    } = groups;
    const realValues = values.split(/,\s*/).map((v) => {
      if (v.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
        return parseFloat(v) / 100;
      } else {
        return parseFloat(v);
      }
    });
    return mappers[fn](...realValues);
  } else if (typeof color === "string") {
    let hex = color.startsWith("#") ? color.slice(1) : color;
    if ([3, 4].includes(hex.length)) {
      hex = hex.split("").map((char) => char + char).join("");
    } else if (![6, 8].includes(hex.length))
      ;
    return HexToRGB(hex);
  } else if (typeof color === "object") {
    if (has(color, ["r", "g", "b"])) {
      return color;
    } else if (has(color, ["h", "s", "l"])) {
      return HSVtoRGB(HSLtoHSV(color));
    } else if (has(color, ["h", "s", "v"])) {
      return HSVtoRGB(color);
    }
  }
  throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function HSVtoRGB(hsva) {
  const {
    h: h2,
    s,
    v,
    a
  } = hsva;
  const f = (n) => {
    const k2 = (n + h2 / 60) % 6;
    return v - v * s * Math.max(Math.min(k2, 4 - k2, 1), 0);
  };
  const rgb = [f(5), f(3), f(1)].map((v2) => Math.round(v2 * 255));
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2],
    a
  };
}
function HSLtoRGB(hsla) {
  return HSVtoRGB(HSLtoHSV(hsla));
}
function HSLtoHSV(hsl) {
  const {
    h: h2,
    s,
    l,
    a
  } = hsl;
  const v = l + s * Math.min(l, 1 - l);
  const sprime = v === 0 ? 0 : 2 - 2 * l / v;
  return {
    h: h2,
    s: sprime,
    v,
    a
  };
}
function toHex(v) {
  const h2 = Math.round(v).toString(16);
  return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
}
function RGBtoHex(_ref2) {
  let {
    r,
    g,
    b,
    a
  } = _ref2;
  return `#${[toHex(r), toHex(g), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
}
function HexToRGB(hex) {
  hex = parseHex(hex);
  let [r, g, b, a] = chunk(hex, 2).map((c) => parseInt(c, 16));
  a = a === void 0 ? a : a / 255;
  return {
    r,
    g,
    b,
    a
  };
}
function parseHex(hex) {
  if (hex.startsWith("#")) {
    hex = hex.slice(1);
  }
  hex = hex.replace(/([^0-9a-f])/gi, "F");
  if (hex.length === 3 || hex.length === 4) {
    hex = hex.split("").map((x2) => x2 + x2).join("");
  }
  if (hex.length !== 6) {
    hex = padEnd(padEnd(hex, 6), 8, "F");
  }
  return hex;
}
function lighten(value2, amount) {
  const lab = fromXYZ$1(toXYZ(value2));
  lab[0] = lab[0] + amount * 10;
  return fromXYZ(toXYZ$1(lab));
}
function darken(value2, amount) {
  const lab = fromXYZ$1(toXYZ(value2));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ(toXYZ$1(lab));
}
function getLuma(color) {
  const rgb = parseColor(color);
  return toXYZ(rgb)[1];
}
function getForeground(color) {
  const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
  const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
  return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
}
const DefaultsSymbol = Symbol.for("vuetify:defaults");
function createDefaults(options) {
  return ref(options);
}
function injectDefaults() {
  const defaults2 = inject$1(DefaultsSymbol);
  if (!defaults2)
    throw new Error("[Vuetify] Could not find defaults instance");
  return defaults2;
}
function provideDefaults(defaults2, options) {
  const injectedDefaults = injectDefaults();
  const providedDefaults = ref(defaults2);
  const newDefaults = computed(() => {
    const disabled = unref(options?.disabled);
    if (disabled)
      return injectedDefaults.value;
    const scoped = unref(options?.scoped);
    const reset = unref(options?.reset);
    const root = unref(options?.root);
    if (providedDefaults.value == null && !(scoped || reset || root))
      return injectedDefaults.value;
    let properties = mergeDeep(providedDefaults.value, {
      prev: injectedDefaults.value
    });
    if (scoped)
      return properties;
    if (reset || root) {
      const len = Number(reset || Infinity);
      for (let i2 = 0; i2 <= len; i2++) {
        if (!properties || !("prev" in properties)) {
          break;
        }
        properties = properties.prev;
      }
      if (properties && typeof root === "string" && root in properties) {
        properties = mergeDeep(mergeDeep(properties, {
          prev: properties
        }), properties[root]);
      }
      return properties;
    }
    return properties.prev ? mergeDeep(properties.prev, properties) : properties;
  });
  provide(DefaultsSymbol, newDefaults);
  return newDefaults;
}
function propIsDefined(vnode, prop) {
  return typeof vnode.props?.[prop] !== "undefined" || typeof vnode.props?.[toKebabCase(prop)] !== "undefined";
}
function internalUseDefaults() {
  let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let name = arguments.length > 1 ? arguments[1] : void 0;
  let defaults2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
  const vm = getCurrentInstance("useDefaults");
  name = name ?? vm.type.name ?? vm.type.__name;
  if (!name) {
    throw new Error("[Vuetify] Could not determine component name");
  }
  const componentDefaults = computed(() => defaults2.value?.[props._as ?? name]);
  const _props = new Proxy(props, {
    get(target, prop) {
      const propValue = Reflect.get(target, prop);
      if (prop === "class" || prop === "style") {
        return [componentDefaults.value?.[prop], propValue].filter((v) => v != null);
      } else if (typeof prop === "string" && !propIsDefined(vm.vnode, prop)) {
        return componentDefaults.value?.[prop] ?? defaults2.value?.global?.[prop] ?? propValue;
      }
      return propValue;
    }
  });
  const _subcomponentDefaults = shallowRef();
  watchEffect(() => {
    if (componentDefaults.value) {
      const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
        let [key] = _ref;
        return key.startsWith(key[0].toUpperCase());
      });
      _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
    } else {
      _subcomponentDefaults.value = void 0;
    }
  });
  function provideSubDefaults() {
    const injected = injectSelf(DefaultsSymbol, vm);
    provide(DefaultsSymbol, computed(() => {
      return _subcomponentDefaults.value ? mergeDeep(injected?.value ?? {}, _subcomponentDefaults.value) : injected?.value;
    }));
  }
  return {
    props: _props,
    provideSubDefaults
  };
}
function defineComponent(options) {
  options._setup = options._setup ?? options.setup;
  if (!options.name) {
    return options;
  }
  if (options._setup) {
    options.props = propsFactory(options.props ?? {}, options.name)();
    const propKeys = Object.keys(options.props);
    options.filterProps = function filterProps(props) {
      return pick$1(props, propKeys, ["class", "style"]);
    };
    options.props._as = String;
    options.setup = function setup(props, ctx) {
      const defaults2 = injectDefaults();
      if (!defaults2.value)
        return options._setup(props, ctx);
      const {
        props: _props,
        provideSubDefaults
      } = internalUseDefaults(props, props._as ?? options.name, defaults2);
      const setupBindings = options._setup(_props, ctx);
      provideSubDefaults();
      return setupBindings;
    };
  }
  return options;
}
function genericComponent() {
  let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  return (options) => (exposeDefaults ? defineComponent : defineComponent$1)(options);
}
function createSimpleFunctional(klass) {
  let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
  let name = arguments.length > 2 ? arguments[2] : void 0;
  return genericComponent()({
    name: name ?? capitalize(camelize(klass.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: tag
      },
      ...makeComponentProps()
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        return h(props.tag, {
          class: [klass, props.class],
          style: props.style
        }, slots.default?.());
      };
    }
  });
}
function attachedRoot(node) {
  if (typeof node.getRootNode !== "function") {
    while (node.parentNode)
      node = node.parentNode;
    if (node !== document)
      return null;
    return document;
  }
  const root = node.getRootNode();
  if (root !== document && root.getRootNode({
    composed: true
  }) !== document)
    return null;
  return root;
}
const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
function getCurrentInstance(name, message) {
  const vm = getCurrentInstance$1();
  if (!vm) {
    throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
  }
  return vm;
}
function getCurrentInstanceName() {
  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const vm = getCurrentInstance(name).type;
  return toKebabCase(vm?.aliasName || vm?.name);
}
let _uid = 0;
let _map = /* @__PURE__ */ new WeakMap();
function getUid() {
  const vm = getCurrentInstance("getUid");
  if (_map.has(vm))
    return _map.get(vm);
  else {
    const uid2 = _uid++;
    _map.set(vm, uid2);
    return uid2;
  }
}
getUid.reset = () => {
  _uid = 0;
  _map = /* @__PURE__ */ new WeakMap();
};
function getScrollParent(el) {
  let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  while (el) {
    if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el))
      return el;
    el = el.parentElement;
  }
  return document.scrollingElement;
}
function getScrollParents(el, stopAt) {
  const elements = [];
  if (stopAt && el && !stopAt.contains(el))
    return elements;
  while (el) {
    if (hasScrollbar(el))
      elements.push(el);
    if (el === stopAt)
      break;
    el = el.parentElement;
  }
  return elements;
}
function hasScrollbar(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style = window.getComputedStyle(el);
  return style.overflowY === "scroll" || style.overflowY === "auto" && el.scrollHeight > el.clientHeight;
}
function isPotentiallyScrollable(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style = window.getComputedStyle(el);
  return ["scroll", "auto"].includes(style.overflowY);
}
function injectSelf(key) {
  let vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance("injectSelf");
  const {
    provides
  } = vm;
  if (provides && key in provides) {
    return provides[key];
  }
  return void 0;
}
function isFixedPosition(el) {
  while (el) {
    if (window.getComputedStyle(el).position === "fixed") {
      return true;
    }
    el = el.offsetParent;
  }
  return false;
}
function useRender(render) {
  const vm = getCurrentInstance("useRender");
  vm.render = render;
}
function useResizeObserver(callback) {
  let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const resizeRef = ref();
  const contentRect = ref();
  if (IN_BROWSER) {
    const observer = new ResizeObserver((entries) => {
      callback?.(entries, observer);
      if (!entries.length)
        return;
      if (box === "content") {
        contentRect.value = entries[0].contentRect;
      } else {
        contentRect.value = entries[0].target.getBoundingClientRect();
      }
    });
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(resizeRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(refElement(oldValue));
        contentRect.value = void 0;
      }
      if (newValue)
        observer.observe(refElement(newValue));
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef,
    contentRect: readonly(contentRect)
  };
}
const VuetifyLayoutKey = Symbol.for("vuetify:layout");
const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
const ROOT_ZINDEX = 1e3;
const makeLayoutProps = propsFactory({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout");
const makeLayoutItemProps = propsFactory({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function useLayout() {
  const layout = inject$1(VuetifyLayoutKey);
  if (!layout)
    throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: layout.getLayoutItem,
    mainRect: layout.mainRect,
    mainStyles: layout.mainStyles
  };
}
function useLayoutItem(options) {
  const layout = inject$1(VuetifyLayoutKey);
  if (!layout)
    throw new Error("[Vuetify] Could not find injected layout");
  const id = options.id ?? `layout-item-${getUid()}`;
  const vm = getCurrentInstance("useLayoutItem");
  provide(VuetifyLayoutItemKey, {
    id
  });
  const isKeptAlive = shallowRef(false);
  onDeactivated(() => isKeptAlive.value = true);
  onActivated(() => isKeptAlive.value = false);
  const {
    layoutItemStyles,
    layoutItemScrimStyles
  } = layout.register(vm, {
    ...options,
    active: computed(() => isKeptAlive.value ? false : options.active.value),
    id
  });
  onBeforeUnmount(() => layout.unregister(id));
  return {
    layoutItemStyles,
    layoutRect: layout.layoutRect,
    layoutItemScrimStyles
  };
}
const generateLayers = (layout, positions, layoutSizes, activeItems) => {
  let previousLayer = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const layers = [{
    id: "",
    layer: {
      ...previousLayer
    }
  }];
  for (const id of layout) {
    const position = positions.get(id);
    const amount = layoutSizes.get(id);
    const active = activeItems.get(id);
    if (!position || !amount || !active)
      continue;
    const layer = {
      ...previousLayer,
      [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
    };
    layers.push({
      id,
      layer
    });
    previousLayer = layer;
  }
  return layers;
};
function createLayout(props) {
  const parentLayout = inject$1(VuetifyLayoutKey, null);
  const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
  const registered = ref([]);
  const positions = reactive(/* @__PURE__ */ new Map());
  const layoutSizes = reactive(/* @__PURE__ */ new Map());
  const priorities2 = reactive(/* @__PURE__ */ new Map());
  const activeItems = reactive(/* @__PURE__ */ new Map());
  const disabledTransitions = reactive(/* @__PURE__ */ new Map());
  const {
    resizeRef,
    contentRect: layoutRect
  } = useResizeObserver();
  const computedOverlaps = computed(() => {
    const map2 = /* @__PURE__ */ new Map();
    const overlaps = props.overlaps ?? [];
    for (const overlap of overlaps.filter((item) => item.includes(":"))) {
      const [top, bottom] = overlap.split(":");
      if (!registered.value.includes(top) || !registered.value.includes(bottom))
        continue;
      const topPosition = positions.get(top);
      const bottomPosition = positions.get(bottom);
      const topAmount = layoutSizes.get(top);
      const bottomAmount = layoutSizes.get(bottom);
      if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
        continue;
      map2.set(bottom, {
        position: topPosition.value,
        amount: parseInt(topAmount.value, 10)
      });
      map2.set(top, {
        position: bottomPosition.value,
        amount: -parseInt(bottomAmount.value, 10)
      });
    }
    return map2;
  });
  const layers = computed(() => {
    const uniquePriorities = [...new Set([...priorities2.values()].map((p2) => p2.value))].sort((a, b) => a - b);
    const layout = [];
    for (const p2 of uniquePriorities) {
      const items2 = registered.value.filter((id) => priorities2.get(id)?.value === p2);
      layout.push(...items2);
    }
    return generateLayers(layout, positions, layoutSizes, activeItems);
  });
  const transitionsEnabled = computed(() => {
    return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
  });
  const mainRect = computed(() => {
    return layers.value[layers.value.length - 1].layer;
  });
  const mainStyles = computed(() => {
    return {
      "--v-layout-left": convertToUnit(mainRect.value.left),
      "--v-layout-right": convertToUnit(mainRect.value.right),
      "--v-layout-top": convertToUnit(mainRect.value.top),
      "--v-layout-bottom": convertToUnit(mainRect.value.bottom),
      ...transitionsEnabled.value ? void 0 : {
        transition: "none"
      }
    };
  });
  const items = computed(() => {
    return layers.value.slice(1).map((_ref, index) => {
      let {
        id
      } = _ref;
      const {
        layer
      } = layers.value[index];
      const size2 = layoutSizes.get(id);
      const position = positions.get(id);
      return {
        id,
        ...layer,
        size: Number(size2.value),
        position: position.value
      };
    });
  });
  const getLayoutItem = (id) => {
    return items.value.find((item) => item.id === id);
  };
  const rootVm = getCurrentInstance("createLayout");
  const isMounted = shallowRef(false);
  onMounted(() => {
    isMounted.value = true;
  });
  provide(VuetifyLayoutKey, {
    register: (vm, _ref2) => {
      let {
        id,
        order,
        position,
        layoutSize,
        elementSize,
        active,
        disableTransitions,
        absolute
      } = _ref2;
      priorities2.set(id, order);
      positions.set(id, position);
      layoutSizes.set(id, layoutSize);
      activeItems.set(id, active);
      disableTransitions && disabledTransitions.set(id, disableTransitions);
      const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm?.vnode);
      const instanceIndex = instances.indexOf(vm);
      if (instanceIndex > -1)
        registered.value.splice(instanceIndex, 0, id);
      else
        registered.value.push(id);
      const index = computed(() => items.value.findIndex((i2) => i2.id === id));
      const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index.value * 2);
      const layoutItemStyles = computed(() => {
        const isHorizontal = position.value === "left" || position.value === "right";
        const isOppositeHorizontal = position.value === "right";
        const isOppositeVertical = position.value === "bottom";
        const styles = {
          [position.value]: 0,
          zIndex: zIndex.value,
          transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
          position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
          ...transitionsEnabled.value ? void 0 : {
            transition: "none"
          }
        };
        if (!isMounted.value)
          return styles;
        const item = items.value[index.value];
        if (!item)
          throw new Error(`[Vuetify] Could not find layout item "${id}"`);
        const overlap = computedOverlaps.value.get(id);
        if (overlap) {
          item[overlap.position] += overlap.amount;
        }
        return {
          ...styles,
          height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
          left: isOppositeHorizontal ? void 0 : `${item.left}px`,
          right: isOppositeHorizontal ? `${item.right}px` : void 0,
          top: position.value !== "bottom" ? `${item.top}px` : void 0,
          bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
          width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
        };
      });
      const layoutItemScrimStyles = computed(() => ({
        zIndex: zIndex.value - 1
      }));
      return {
        layoutItemStyles,
        layoutItemScrimStyles,
        zIndex
      };
    },
    unregister: (id) => {
      priorities2.delete(id);
      positions.delete(id);
      layoutSizes.delete(id);
      activeItems.delete(id);
      disabledTransitions.delete(id);
      registered.value = registered.value.filter((v) => v !== id);
    },
    mainRect,
    mainStyles,
    getLayoutItem,
    items,
    layoutRect,
    rootZIndex
  });
  const layoutClasses = computed(() => ["v-layout", {
    "v-layout--full-height": props.fullHeight
  }]);
  const layoutStyles = computed(() => ({
    zIndex: parentLayout ? rootZIndex.value : void 0,
    position: parentLayout ? "relative" : void 0,
    overflow: parentLayout ? "hidden" : void 0
  }));
  return {
    layoutClasses,
    layoutStyles,
    getLayoutItem,
    items,
    layoutRect,
    layoutRef: resizeRef
  };
}
const en = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    ok: "OK",
    cancel: "Cancel",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
};
const defaultRtl = {
  af: false,
  ar: true,
  bg: false,
  ca: false,
  ckb: false,
  cs: false,
  de: false,
  el: false,
  en: false,
  es: false,
  et: false,
  fa: true,
  fi: false,
  fr: false,
  hr: false,
  hu: false,
  he: true,
  id: false,
  it: false,
  ja: false,
  ko: false,
  lv: false,
  lt: false,
  nl: false,
  no: false,
  pl: false,
  pt: false,
  ro: false,
  ru: false,
  sk: false,
  sl: false,
  srCyrl: false,
  srLatn: false,
  sv: false,
  th: false,
  tr: false,
  az: false,
  uk: false,
  vi: false,
  zhHans: false,
  zhHant: false
};
function useToggleScope(source, fn) {
  let scope;
  function start() {
    scope = effectScope();
    scope.run(() => fn.length ? fn(() => {
      scope?.stop();
      start();
    }) : fn());
  }
  watch(source, (active) => {
    if (active && !scope) {
      start();
    } else if (!active) {
      scope?.stop();
      scope = void 0;
    }
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    scope?.stop();
  });
}
function useProxiedModel(props, prop, defaultValue) {
  let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
  let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
  const vm = getCurrentInstance("useProxiedModel");
  const internal = ref(props[prop] !== void 0 ? props[prop] : defaultValue);
  const kebabProp = toKebabCase(prop);
  const checkKebab = kebabProp !== prop;
  const isControlled = checkKebab ? computed(() => {
    void props[prop];
    return !!((vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) && (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`)));
  }) : computed(() => {
    void props[prop];
    return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`));
  });
  useToggleScope(() => !isControlled.value, () => {
    watch(() => props[prop], (val) => {
      internal.value = val;
    });
  });
  const model = computed({
    get() {
      const externalValue = props[prop];
      return transformIn(isControlled.value ? externalValue : internal.value);
    },
    set(internalValue) {
      const newValue = transformOut(internalValue);
      const value2 = toRaw(isControlled.value ? props[prop] : internal.value);
      if (value2 === newValue || transformIn(value2) === internalValue) {
        return;
      }
      internal.value = newValue;
      vm?.emit(`update:${prop}`, newValue);
    }
  });
  Object.defineProperty(model, "externalValue", {
    get: () => isControlled.value ? props[prop] : internal.value
  });
  return model;
}
const LANG_PREFIX = "$vuetify.";
const replace = (str, params) => {
  return str.replace(/\{(\d+)\}/g, (match, index) => {
    return String(params[+index]);
  });
};
const createTranslateFunction = (current, fallback, messages) => {
  return function(key) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (!key.startsWith(LANG_PREFIX)) {
      return replace(key, params);
    }
    const shortKey = key.replace(LANG_PREFIX, "");
    const currentLocale = current.value && messages.value[current.value];
    const fallbackLocale = fallback.value && messages.value[fallback.value];
    let str = getObjectValueByPath(currentLocale, shortKey, null);
    if (!str) {
      consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
      str = getObjectValueByPath(fallbackLocale, shortKey, null);
    }
    if (!str) {
      str = key;
    }
    if (typeof str !== "string") {
      str = key;
    }
    return replace(str, params);
  };
};
function createNumberFunction(current, fallback) {
  return (value2, options) => {
    const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
    return numberFormat.format(value2);
  };
}
function useProvided(props, prop, provided) {
  const internal = useProxiedModel(props, prop, props[prop] ?? provided.value);
  internal.value = props[prop] ?? provided.value;
  watch(provided, (v) => {
    if (props[prop] == null) {
      internal.value = provided.value;
    }
  });
  return internal;
}
function createProvideFunction(state2) {
  return (props) => {
    const current = useProvided(props, "locale", state2.current);
    const fallback = useProvided(props, "fallback", state2.fallback);
    const messages = useProvided(props, "messages", state2.messages);
    return {
      name: "vuetify",
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current,
        fallback,
        messages
      })
    };
  };
}
function createVuetifyAdapter(options) {
  const current = shallowRef(options?.locale ?? "en");
  const fallback = shallowRef(options?.fallback ?? "en");
  const messages = ref({
    en,
    ...options?.messages
  });
  return {
    name: "vuetify",
    current,
    fallback,
    messages,
    t: createTranslateFunction(current, fallback, messages),
    n: createNumberFunction(current, fallback),
    provide: createProvideFunction({
      current,
      fallback,
      messages
    })
  };
}
const LocaleSymbol = Symbol.for("vuetify:locale");
function isLocaleInstance(obj) {
  return obj.name != null;
}
function createLocale(options) {
  const i18n = options?.adapter && isLocaleInstance(options?.adapter) ? options?.adapter : createVuetifyAdapter(options);
  const rtl = createRtl(i18n, options);
  return {
    ...i18n,
    ...rtl
  };
}
function useLocale() {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return locale2;
}
function createRtl(i18n, options) {
  const rtl = ref(options?.rtl ?? defaultRtl);
  const isRtl = computed(() => rtl.value[i18n.current.value] ?? false);
  return {
    isRtl,
    rtl,
    rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
  };
}
function useRtl() {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: locale2.isRtl,
    rtlClasses: locale2.rtlClasses
  };
}
const ThemeSymbol = Symbol.for("vuetify:theme");
const makeThemeProps = propsFactory({
  theme: String
}, "theme");
const defaultThemeOptions = {
  defaultTheme: "light",
  variations: {
    colors: [],
    lighten: 0,
    darken: 0
  },
  themes: {
    light: {
      dark: false,
      colors: {
        background: "#FFFFFF",
        surface: "#FFFFFF",
        "surface-bright": "#FFFFFF",
        "surface-variant": "#424242",
        "on-surface-variant": "#EEEEEE",
        primary: "#6200EE",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC6",
        "secondary-darken-1": "#018786",
        error: "#B00020",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#000000",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "idle-opacity": 0.04,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.12,
        "dragged-opacity": 0.08,
        "theme-kbd": "#212529",
        "theme-on-kbd": "#FFFFFF",
        "theme-code": "#F5F5F5",
        "theme-on-code": "#000000"
      }
    },
    dark: {
      dark: true,
      colors: {
        background: "#121212",
        surface: "#212121",
        "surface-bright": "#ccbfd6",
        "surface-variant": "#a3a3a3",
        "on-surface-variant": "#424242",
        primary: "#BB86FC",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC5",
        "secondary-darken-1": "#03DAC5",
        error: "#CF6679",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#FFFFFF",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 1,
        "medium-emphasis-opacity": 0.7,
        "disabled-opacity": 0.5,
        "idle-opacity": 0.1,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.16,
        "dragged-opacity": 0.08,
        "theme-kbd": "#212529",
        "theme-on-kbd": "#FFFFFF",
        "theme-code": "#343434",
        "theme-on-code": "#CCCCCC"
      }
    }
  }
};
function parseThemeOptions() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultThemeOptions;
  if (!options)
    return {
      ...defaultThemeOptions,
      isDisabled: true
    };
  const themes = {};
  for (const [key, theme] of Object.entries(options.themes ?? {})) {
    const defaultTheme = theme.dark || key === "dark" ? defaultThemeOptions.themes?.dark : defaultThemeOptions.themes?.light;
    themes[key] = mergeDeep(defaultTheme, theme);
  }
  return mergeDeep(defaultThemeOptions, {
    ...options,
    themes
  });
}
function createTheme(options) {
  const parsedOptions = parseThemeOptions(options);
  const name = ref(parsedOptions.defaultTheme);
  const themes = ref(parsedOptions.themes);
  const computedThemes = computed(() => {
    const acc = {};
    for (const [name2, original] of Object.entries(themes.value)) {
      const theme = acc[name2] = {
        ...original,
        colors: {
          ...original.colors
        }
      };
      if (parsedOptions.variations) {
        for (const name3 of parsedOptions.variations.colors) {
          const color = theme.colors[name3];
          if (!color)
            continue;
          for (const variation of ["lighten", "darken"]) {
            const fn = variation === "lighten" ? lighten : darken;
            for (const amount of createRange(parsedOptions.variations[variation], 1)) {
              theme.colors[`${name3}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
            }
          }
        }
      }
      for (const color of Object.keys(theme.colors)) {
        if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
          continue;
        const onColor = `on-${color}`;
        const colorVal = parseColor(theme.colors[color]);
        theme.colors[onColor] = getForeground(colorVal);
      }
    }
    return acc;
  });
  const current = computed(() => computedThemes.value[name.value]);
  const styles = computed(() => {
    const lines = [];
    if (current.value.dark) {
      createCssClass(lines, ":root", ["color-scheme: dark"]);
    }
    createCssClass(lines, ":root", genCssVariables(current.value));
    for (const [themeName, theme] of Object.entries(computedThemes.value)) {
      createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)]);
    }
    const bgLines = [];
    const fgLines = [];
    const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
    for (const key of colors) {
      if (/^on-[a-z]/.test(key)) {
        createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
      } else {
        createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]);
        createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
        createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]);
      }
    }
    lines.push(...bgLines, ...fgLines);
    return lines.map((str, i2) => i2 === 0 ? str : `    ${str}`).join("");
  });
  function getHead() {
    return {
      style: [{
        children: styles.value,
        id: "vuetify-theme-stylesheet",
        nonce: parsedOptions.cspNonce || false
      }]
    };
  }
  function install2(app2) {
    if (parsedOptions.isDisabled)
      return;
    const head = app2._context.provides.usehead;
    if (head) {
      if (head.push) {
        const entry = head.push(getHead);
        if (IN_BROWSER) {
          watch(styles, () => {
            entry.patch(getHead);
          });
        }
      } else {
        if (IN_BROWSER) {
          head.addHeadObjs(computed(getHead));
          watchEffect(() => head.updateDOM());
        } else {
          head.addHeadObjs(getHead());
        }
      }
    } else {
      let updateStyles = function() {
        if (typeof document !== "undefined" && !styleEl) {
          const el = document.createElement("style");
          el.type = "text/css";
          el.id = "vuetify-theme-stylesheet";
          if (parsedOptions.cspNonce)
            el.setAttribute("nonce", parsedOptions.cspNonce);
          styleEl = el;
          document.head.appendChild(styleEl);
        }
        if (styleEl)
          styleEl.innerHTML = styles.value;
      };
      let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
      if (IN_BROWSER) {
        watch(styles, updateStyles, {
          immediate: true
        });
      } else {
        updateStyles();
      }
    }
  }
  const themeClasses = computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
  return {
    install: install2,
    isDisabled: parsedOptions.isDisabled,
    name,
    themes,
    current,
    computedThemes,
    themeClasses,
    styles,
    global: {
      name,
      current
    }
  };
}
function provideTheme(props) {
  getCurrentInstance("provideTheme");
  const theme = inject$1(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  const name = computed(() => {
    return props.theme ?? theme.name.value;
  });
  const current = computed(() => theme.themes.value[name.value]);
  const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
  const newTheme = {
    ...theme,
    name,
    current,
    themeClasses
  };
  provide(ThemeSymbol, newTheme);
  return newTheme;
}
function createCssClass(lines, selector, content) {
  lines.push(`${selector} {
`, ...content.map((line) => `  ${line};
`), "}\n");
}
function genCssVariables(theme) {
  const lightOverlay = theme.dark ? 2 : 1;
  const darkOverlay = theme.dark ? 1 : 2;
  const variables = [];
  for (const [key, value2] of Object.entries(theme.colors)) {
    const rgb = parseColor(value2);
    variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
    if (!key.startsWith("on-")) {
      variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value2) > 0.18 ? lightOverlay : darkOverlay}`);
    }
  }
  for (const [key, value2] of Object.entries(theme.variables)) {
    const color = typeof value2 === "string" && value2.startsWith("#") ? parseColor(value2) : void 0;
    const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
    variables.push(`--v-${key}: ${rgb ?? value2}`);
  }
  return variables;
}
const makeVAppProps = propsFactory({
  ...makeComponentProps(),
  ...makeLayoutProps({
    fullHeight: true
  }),
  ...makeThemeProps()
}, "VApp");
const VApp = genericComponent()({
  name: "VApp",
  props: makeVAppProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const theme = provideTheme(props);
    const {
      layoutClasses,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props);
    const {
      rtlClasses
    } = useRtl();
    useRender(() => createVNode("div", {
      "ref": layoutRef,
      "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props.class],
      "style": [props.style]
    }, [createVNode("div", {
      "class": "v-application__wrap"
    }, [slots.default?.()])]));
    return {
      getLayoutItem,
      items,
      theme
    };
  }
});
const VGrid = "";
const makeTagProps = propsFactory({
  tag: {
    type: String,
    default: "div"
  }
}, "tag");
const makeVContainerProps = propsFactory({
  fluid: {
    type: Boolean,
    default: false
  },
  ...makeComponentProps(),
  ...makeTagProps()
}, "VContainer");
const VContainer = genericComponent()({
  name: "VContainer",
  props: makeVContainerProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      rtlClasses
    } = useRtl();
    useRender(() => createVNode(props.tag, {
      "class": ["v-container", {
        "v-container--fluid": props.fluid
      }, rtlClasses.value, props.class],
      "style": props.style
    }, slots));
    return {};
  }
});
const breakpoints = ["sm", "md", "lg", "xl", "xxl"];
const DisplaySymbol = Symbol.for("vuetify:display");
const defaultDisplayOptions = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
};
const parseDisplayOptions = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
  return mergeDeep(defaultDisplayOptions, options);
};
function getClientWidth(ssr) {
  return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
}
function getClientHeight(ssr) {
  return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
}
function getPlatform(ssr) {
  const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
  function match(regexp) {
    return Boolean(userAgent.match(regexp));
  }
  const android = match(/android/i);
  const ios = match(/iphone|ipad|ipod/i);
  const cordova = match(/cordova/i);
  const electron = match(/electron/i);
  const chrome2 = match(/chrome/i);
  const edge = match(/edge/i);
  const firefox = match(/firefox/i);
  const opera = match(/opera/i);
  const win = match(/win/i);
  const mac = match(/mac/i);
  const linux = match(/linux/i);
  return {
    android,
    ios,
    cordova,
    electron,
    chrome: chrome2,
    edge,
    firefox,
    opera,
    win,
    mac,
    linux,
    touch: SUPPORTS_TOUCH,
    ssr: userAgent === "ssr"
  };
}
function createDisplay(options, ssr) {
  const {
    thresholds: thresholds2,
    mobileBreakpoint
  } = parseDisplayOptions(options);
  const height = shallowRef(getClientHeight(ssr));
  const platform = shallowRef(getPlatform(ssr));
  const state2 = reactive({});
  const width = shallowRef(getClientWidth(ssr));
  function updateSize() {
    height.value = getClientHeight();
    width.value = getClientWidth();
  }
  function update3() {
    updateSize();
    platform.value = getPlatform();
  }
  watchEffect(() => {
    const xs = width.value < thresholds2.sm;
    const sm = width.value < thresholds2.md && !xs;
    const md = width.value < thresholds2.lg && !(sm || xs);
    const lg = width.value < thresholds2.xl && !(md || sm || xs);
    const xl = width.value < thresholds2.xxl && !(lg || md || sm || xs);
    const xxl = width.value >= thresholds2.xxl;
    const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
    const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds2[mobileBreakpoint];
    const mobile = width.value < breakpointValue;
    state2.xs = xs;
    state2.sm = sm;
    state2.md = md;
    state2.lg = lg;
    state2.xl = xl;
    state2.xxl = xxl;
    state2.smAndUp = !xs;
    state2.mdAndUp = !(xs || sm);
    state2.lgAndUp = !(xs || sm || md);
    state2.xlAndUp = !(xs || sm || md || lg);
    state2.smAndDown = !(md || lg || xl || xxl);
    state2.mdAndDown = !(lg || xl || xxl);
    state2.lgAndDown = !(xl || xxl);
    state2.xlAndDown = !xxl;
    state2.name = name;
    state2.height = height.value;
    state2.width = width.value;
    state2.mobile = mobile;
    state2.mobileBreakpoint = mobileBreakpoint;
    state2.platform = platform.value;
    state2.thresholds = thresholds2;
  });
  if (IN_BROWSER) {
    window.addEventListener("resize", updateSize, {
      passive: true
    });
  }
  return {
    ...toRefs(state2),
    update: update3,
    ssr: !!ssr
  };
}
function useDisplay() {
  const display = inject$1(DisplaySymbol);
  if (!display)
    throw new Error("Could not find Vuetify display injection");
  return display;
}
const breakpointProps = (() => {
  return breakpoints.reduce((props, val) => {
    props[val] = {
      type: [Boolean, String, Number],
      default: false
    };
    return props;
  }, {});
})();
const offsetProps = (() => {
  return breakpoints.reduce((props, val) => {
    const offsetKey = "offset" + capitalize(val);
    props[offsetKey] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();
const orderProps = (() => {
  return breakpoints.reduce((props, val) => {
    const orderKey = "order" + capitalize(val);
    props[orderKey] = {
      type: [String, Number],
      default: null
    };
    return props;
  }, {});
})();
const propMap$1 = {
  col: Object.keys(breakpointProps),
  offset: Object.keys(offsetProps),
  order: Object.keys(orderProps)
};
function breakpointClass$1(type, prop, val) {
  let className = type;
  if (val == null || val === false) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type, "");
    className += `-${breakpoint}`;
  }
  if (type === "col") {
    className = "v-" + className;
  }
  if (type === "col" && (val === "" || val === true)) {
    return className.toLowerCase();
  }
  className += `-${val}`;
  return className.toLowerCase();
}
const ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
const makeVColProps = propsFactory({
  cols: {
    type: [Boolean, String, Number],
    default: false
  },
  ...breakpointProps,
  offset: {
    type: [String, Number],
    default: null
  },
  ...offsetProps,
  order: {
    type: [String, Number],
    default: null
  },
  ...orderProps,
  alignSelf: {
    type: String,
    default: null,
    validator: (str) => ALIGN_SELF_VALUES.includes(str)
  },
  ...makeComponentProps(),
  ...makeTagProps()
}, "VCol");
const VCol = genericComponent()({
  name: "VCol",
  props: makeVColProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const classes = computed(() => {
      const classList = [];
      let type;
      for (type in propMap$1) {
        propMap$1[type].forEach((prop) => {
          const value2 = props[prop];
          const className = breakpointClass$1(type, prop, value2);
          if (className)
            classList.push(className);
        });
      }
      const hasColClasses = classList.some((className) => className.startsWith("v-col-"));
      classList.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !hasColClasses || !props.cols,
        [`v-col-${props.cols}`]: props.cols,
        [`offset-${props.offset}`]: props.offset,
        [`order-${props.order}`]: props.order,
        [`align-self-${props.alignSelf}`]: props.alignSelf
      });
      return classList;
    });
    return () => h(props.tag, {
      class: [classes.value, props.class],
      style: props.style
    }, slots.default?.());
  }
});
const ALIGNMENT = ["start", "end", "center"];
const SPACE = ["space-between", "space-around", "space-evenly"];
function makeRowProps(prefix, def2) {
  return breakpoints.reduce((props, val) => {
    const prefixKey = prefix + capitalize(val);
    props[prefixKey] = def2();
    return props;
  }, {});
}
const ALIGN_VALUES = [...ALIGNMENT, "baseline", "stretch"];
const alignValidator = (str) => ALIGN_VALUES.includes(str);
const alignProps = makeRowProps("align", () => ({
  type: String,
  default: null,
  validator: alignValidator
}));
const JUSTIFY_VALUES = [...ALIGNMENT, ...SPACE];
const justifyValidator = (str) => JUSTIFY_VALUES.includes(str);
const justifyProps = makeRowProps("justify", () => ({
  type: String,
  default: null,
  validator: justifyValidator
}));
const ALIGN_CONTENT_VALUES = [...ALIGNMENT, ...SPACE, "stretch"];
const alignContentValidator = (str) => ALIGN_CONTENT_VALUES.includes(str);
const alignContentProps = makeRowProps("alignContent", () => ({
  type: String,
  default: null,
  validator: alignContentValidator
}));
const propMap = {
  align: Object.keys(alignProps),
  justify: Object.keys(justifyProps),
  alignContent: Object.keys(alignContentProps)
};
const classMap = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function breakpointClass(type, prop, val) {
  let className = classMap[type];
  if (val == null) {
    return void 0;
  }
  if (prop) {
    const breakpoint = prop.replace(type, "");
    className += `-${breakpoint}`;
  }
  className += `-${val}`;
  return className.toLowerCase();
}
const makeVRowProps = propsFactory({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: alignValidator
  },
  ...alignProps,
  justify: {
    type: String,
    default: null,
    validator: justifyValidator
  },
  ...justifyProps,
  alignContent: {
    type: String,
    default: null,
    validator: alignContentValidator
  },
  ...alignContentProps,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VRow");
const VRow = genericComponent()({
  name: "VRow",
  props: makeVRowProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const classes = computed(() => {
      const classList = [];
      let type;
      for (type in propMap) {
        propMap[type].forEach((prop) => {
          const value2 = props[prop];
          const className = breakpointClass(type, prop, value2);
          if (className)
            classList.push(className);
        });
      }
      classList.push({
        "v-row--no-gutters": props.noGutters,
        "v-row--dense": props.dense,
        [`align-${props.align}`]: props.align,
        [`justify-${props.justify}`]: props.justify,
        [`align-content-${props.alignContent}`]: props.alignContent
      });
      return classList;
    });
    return () => h(props.tag, {
      class: ["v-row", classes.value, props.class],
      style: props.style
    }, slots.default?.());
  }
});
const VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");
const VImg$1 = "";
const VResponsive$1 = "";
const makeDimensionProps = propsFactory({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function useDimension(props) {
  const dimensionStyles = computed(() => ({
    height: convertToUnit(props.height),
    maxHeight: convertToUnit(props.maxHeight),
    maxWidth: convertToUnit(props.maxWidth),
    minHeight: convertToUnit(props.minHeight),
    minWidth: convertToUnit(props.minWidth),
    width: convertToUnit(props.width)
  }));
  return {
    dimensionStyles
  };
}
function useAspectStyles(props) {
  return {
    aspectStyles: computed(() => {
      const ratio = Number(props.aspectRatio);
      return ratio ? {
        paddingBottom: String(1 / ratio * 100) + "%"
      } : void 0;
    })
  };
}
const makeVResponsiveProps = propsFactory({
  aspectRatio: [String, Number],
  contentClass: String,
  inline: Boolean,
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VResponsive");
const VResponsive = genericComponent()({
  name: "VResponsive",
  props: makeVResponsiveProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      aspectStyles
    } = useAspectStyles(props);
    const {
      dimensionStyles
    } = useDimension(props);
    useRender(() => createVNode("div", {
      "class": ["v-responsive", {
        "v-responsive--inline": props.inline
      }, props.class],
      "style": [dimensionStyles.value, props.style]
    }, [createVNode("div", {
      "class": "v-responsive__sizer",
      "style": aspectStyles.value
    }, null), slots.additional?.(), slots.default && createVNode("div", {
      "class": ["v-responsive__content", props.contentClass]
    }, [slots.default()])]));
    return {};
  }
});
const makeTransitionProps$1 = propsFactory({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (val) => val !== true
  }
}, "transition");
const MaybeTransition = (props, _ref) => {
  let {
    slots
  } = _ref;
  const {
    transition,
    disabled,
    ...rest
  } = props;
  const {
    component = Transition,
    ...customProps
  } = typeof transition === "object" ? transition : {};
  return h(component, mergeProps(typeof transition === "string" ? {
    name: disabled ? "" : transition
  } : customProps, rest, {
    disabled
  }), slots);
};
function mounted$2(el, binding) {
  if (!SUPPORTS_INTERSECTION)
    return;
  const modifiers = binding.modifiers || {};
  const value2 = binding.value;
  const {
    handler,
    options
  } = typeof value2 === "object" ? value2 : {
    handler: value2,
    options: {}
  };
  const observer = new IntersectionObserver(function() {
    let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let observer2 = arguments.length > 1 ? arguments[1] : void 0;
    const _observe = el._observe?.[binding.instance.$.uid];
    if (!_observe)
      return;
    const isIntersecting = entries.some((entry) => entry.isIntersecting);
    if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
      handler(isIntersecting, entries, observer2);
    }
    if (isIntersecting && modifiers.once)
      unmounted$2(el, binding);
    else
      _observe.init = true;
  }, options);
  el._observe = Object(el._observe);
  el._observe[binding.instance.$.uid] = {
    init: false,
    observer
  };
  observer.observe(el);
}
function unmounted$2(el, binding) {
  const observe = el._observe?.[binding.instance.$.uid];
  if (!observe)
    return;
  observe.observer.unobserve(el);
  delete el._observe[binding.instance.$.uid];
}
const Intersect = {
  mounted: mounted$2,
  unmounted: unmounted$2
};
const Intersect$1 = Intersect;
const makeVImgProps = propsFactory({
  alt: String,
  cover: Boolean,
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  srcset: String,
  ...makeVResponsiveProps(),
  ...makeComponentProps(),
  ...makeTransitionProps$1()
}, "VImg");
const VImg = genericComponent()({
  name: "VImg",
  directives: {
    intersect: Intersect$1
  },
  props: makeVImgProps(),
  emits: {
    loadstart: (value2) => true,
    load: (value2) => true,
    error: (value2) => true
  },
  setup(props, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const currentSrc = shallowRef("");
    const image = ref();
    const state2 = shallowRef(props.eager ? "loading" : "idle");
    const naturalWidth = shallowRef();
    const naturalHeight = shallowRef();
    const normalisedSrc = computed(() => {
      return props.src && typeof props.src === "object" ? {
        src: props.src.src,
        srcset: props.srcset || props.src.srcset,
        lazySrc: props.lazySrc || props.src.lazySrc,
        aspect: Number(props.aspectRatio || props.src.aspect || 0)
      } : {
        src: props.src,
        srcset: props.srcset,
        lazySrc: props.lazySrc,
        aspect: Number(props.aspectRatio || 0)
      };
    });
    const aspectRatio = computed(() => {
      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
    });
    watch(() => props.src, () => {
      init(state2.value !== "idle");
    });
    watch(aspectRatio, (val, oldVal) => {
      if (!val && oldVal && image.value) {
        pollForSize(image.value);
      }
    });
    onBeforeMount(() => init());
    function init(isIntersecting) {
      if (props.eager && isIntersecting)
        return;
      if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
        return;
      state2.value = "loading";
      if (normalisedSrc.value.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = normalisedSrc.value.lazySrc;
        pollForSize(lazyImg, null);
      }
      if (!normalisedSrc.value.src)
        return;
      nextTick$1(() => {
        emit2("loadstart", image.value?.currentSrc || normalisedSrc.value.src);
        if (image.value?.complete) {
          if (!image.value.naturalWidth) {
            onError();
          }
          if (state2.value === "error")
            return;
          if (!aspectRatio.value)
            pollForSize(image.value, null);
          onLoad();
        } else {
          if (!aspectRatio.value)
            pollForSize(image.value);
          getSrc();
        }
      });
    }
    function onLoad() {
      getSrc();
      state2.value = "loaded";
      emit2("load", image.value?.currentSrc || normalisedSrc.value.src);
    }
    function onError() {
      state2.value = "error";
      emit2("error", image.value?.currentSrc || normalisedSrc.value.src);
    }
    function getSrc() {
      const img = image.value;
      if (img)
        currentSrc.value = img.currentSrc || img.src;
    }
    let timer = -1;
    function pollForSize(img) {
      let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const poll = () => {
        clearTimeout(timer);
        const {
          naturalHeight: imgHeight,
          naturalWidth: imgWidth
        } = img;
        if (imgHeight || imgWidth) {
          naturalWidth.value = imgWidth;
          naturalHeight.value = imgHeight;
        } else if (!img.complete && state2.value === "loading" && timeout != null) {
          timer = window.setTimeout(poll, timeout);
        } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
          naturalWidth.value = 1;
          naturalHeight.value = 1;
        }
      };
      poll();
    }
    const containClasses = computed(() => ({
      "v-img__img--cover": props.cover,
      "v-img__img--contain": !props.cover
    }));
    const __image = () => {
      if (!normalisedSrc.value.src || state2.value === "idle")
        return null;
      const img = createVNode("img", {
        "class": ["v-img__img", containClasses.value],
        "src": normalisedSrc.value.src,
        "srcset": normalisedSrc.value.srcset,
        "alt": props.alt,
        "sizes": props.sizes,
        "ref": image,
        "onLoad": onLoad,
        "onError": onError
      }, null);
      const sources = slots.sources?.();
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [withDirectives(sources ? createVNode("picture", {
          "class": "v-img__picture"
        }, [sources, img]) : img, [[vShow, state2.value === "loaded"]])]
      });
    };
    const __preloadImage = () => createVNode(MaybeTransition, {
      "transition": props.transition
    }, {
      default: () => [normalisedSrc.value.lazySrc && state2.value !== "loaded" && createVNode("img", {
        "class": ["v-img__img", "v-img__img--preload", containClasses.value],
        "src": normalisedSrc.value.lazySrc,
        "alt": props.alt
      }, null)]
    });
    const __placeholder = () => {
      if (!slots.placeholder)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [(state2.value === "loading" || state2.value === "error" && !slots.error) && createVNode("div", {
          "class": "v-img__placeholder"
        }, [slots.placeholder()])]
      });
    };
    const __error = () => {
      if (!slots.error)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [state2.value === "error" && createVNode("div", {
          "class": "v-img__error"
        }, [slots.error()])]
      });
    };
    const __gradient = () => {
      if (!props.gradient)
        return null;
      return createVNode("div", {
        "class": "v-img__gradient",
        "style": {
          backgroundImage: `linear-gradient(${props.gradient})`
        }
      }, null);
    };
    const isBooted = shallowRef(false);
    {
      const stop = watch(aspectRatio, (val) => {
        if (val) {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              isBooted.value = true;
            });
          });
          stop();
        }
      });
    }
    useRender(() => {
      const [responsiveProps] = VResponsive.filterProps(props);
      return withDirectives(createVNode(VResponsive, mergeProps({
        "class": ["v-img", {
          "v-img--booting": !isBooted.value
        }, props.class],
        "style": [{
          width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
        }, props.style]
      }, responsiveProps, {
        "aspectRatio": aspectRatio.value,
        "aria-label": props.alt,
        "role": props.alt ? "img" : void 0
      }), {
        additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
        default: slots.default
      }), [[resolveDirective("intersect"), {
        handler: init,
        options: props.options
      }, null, {
        once: true
      }]]);
    });
    return {
      currentSrc,
      image,
      state: state2,
      naturalWidth,
      naturalHeight
    };
  }
});
const _sfc_main$e = {
  name: "App",
  data: () => ({
    channel: "",
    baseMode: "avc",
    transcode: "live",
    codec: "h264",
    attendeeMode: "video",
    videoProfile: "360p_8",
    assistantId: "",
    entityId: "",
    message: ""
  }),
  created() {
    this.handleJoin();
    this.assistantId = localStorage.getItem("idAssistant");
    this.entityId = localStorage.getItem("entity_id");
  },
  methods: {
    handleJoin() {
      const path = `/login`;
      setTimeout(
        function() {
          js_cookieExports.set("channel", this.channel);
          js_cookieExports.set("baseMode", this.baseMode);
          js_cookieExports.set("transcode", this.transcode);
          js_cookieExports.set("codec", this.codec);
          js_cookieExports.set("attendeeMode", this.attendeeMode);
          js_cookieExports.set("videoProfile", this.videoProfile);
          if (localStorage.getItem("is_demo") || localStorage.getItem("is_testing") || localStorage.getItem("is_installer") || localStorage.getItem("is_operations") || localStorage.getItem("idAssistant")) {
            if (this.$route.path !== path)
              this.$router.push(`/dashboard/assistant-${this.assistantId}/ent-${this.entityId}`);
          } else {
            if (this.$route.path !== path)
              this.$router.push(path);
          }
        }.bind(this),
        5e3
      );
    }
  },
  mounted() {
    this.$nextTick(() => {
      window.addEventListener("keypress", (e) => {
        e.keyCode === 13 && this.handleJoin();
      });
    });
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(VApp, null, {
    default: withCtx(() => [
      createVNode(VContainer, {
        "fill-height": "",
        fluid: ""
      }, {
        default: withCtx(() => [
          createVNode(VRow, {
            align: "center",
            justify: "center"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", null, [
                createVNode(VImg, {
                  height: "100%",
                  src: "../assets/bitmec.png"
                })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
const SplashScreen = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$1(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject$3(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k2;
    for (k2 in obj) {
      if (hasOwnProp(obj, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined$1(input) {
  return input === void 0;
}
function isNumber$1(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate$1(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map$1(arr, fn) {
  var res = [], i2, arrLen = arr.length;
  for (i2 = 0; i2 < arrLen; ++i2) {
    res.push(fn(arr[i2], i2));
  }
  return res;
}
function extend$1(a, b) {
  for (var i2 in b) {
    if (hasOwnProp(b, i2)) {
      a[i2] = b[i2];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t = Object(this), len = t.length >>> 0, i2;
    for (i2 = 0; i2 < len; i2++) {
      if (i2 in t && fun.call(this, t[i2], i2, t)) {
        return true;
      }
    }
    return false;
  };
}
function isValid$1(m) {
  if (m._isValid == null) {
    var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i2) {
      return i2 != null;
    }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m)) {
      m._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend$1(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i2, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined$1(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined$1(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined$1(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined$1(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined$1(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined$1(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined$1(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined$1(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined$1(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined$1(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
      prop = momentProperties[i2];
      val = from2[prop];
      if (!isUndefined$1(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend$1(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key, argLen = arguments.length;
      for (i2 = 0; i2 < argLen; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$1(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i2;
  for (i2 in config) {
    if (hasOwnProp(config, i2)) {
      prop = config[i2];
      if (isFunction$1(prop)) {
        this[i2] = prop;
      } else {
        this["_" + i2] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend$1({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject$3(parentConfig[prop]) && isObject$3(childConfig[prop])) {
        res[prop] = {};
        extend$1(res[prop], parentConfig[prop]);
        extend$1(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$3(parentConfig[prop])) {
      res[prop] = extend$1({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i2, res = [];
    for (i2 in obj) {
      if (hasOwnProp(obj, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$1(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i2, length2;
  for (i2 = 0, length2 = array.length; i2 < length2; i2++) {
    if (formatTokenFunctions[array[i2]]) {
      array[i2] = formatTokenFunctions[array[i2]];
    } else {
      array[i2] = removeFormattingTokens(array[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length2; i3++) {
      output += isFunction$1(array[i3]) ? array[i3].call(mom, format2) : array[i3];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction$1(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$1(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases$1 = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases$1[lowerCase] = aliases$1[lowerCase + "s"] = aliases$1[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases$1[units] || aliases$1[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value2 = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value2 = absFloor(coercedNumber);
  }
  return value2;
}
function makeGetSet(unit, keepTime) {
  return function(value2) {
    if (value2 != null) {
      set$1(this, unit, value2);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value2) {
  if (mom.isValid() && !isNaN(value2)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value2 = toInt(value2);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value2,
        mom.month(),
        daysInMonth(value2, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$1(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value2) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
    for (i2 = 0; i2 < prioritizedLen; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$1(this[units])) {
      return this[units](value2);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction$1(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i2, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber$1(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n, x2) {
  return (n % x2 + x2) % x2;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m, format2) {
  if (!m) {
    return isArray$1(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$1(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray$1(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$1(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i2, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i2, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i2] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i2]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value2) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value2 === "string") {
    if (/^\d+$/.test(value2)) {
      value2 = toInt(value2);
    } else {
      value2 = mom.localeData().monthsParse(value2);
      if (!isNumber$1(value2)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value2));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value2, dayOfMonth);
  return mom;
}
function getSetMonth(value2) {
  if (value2 != null) {
    setMonth(this, value2);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i2 = 0; i2 < 12; i2++) {
    shortPieces[i2] = regexEscape(shortPieces[i2]);
    longPieces[i2] = regexEscape(longPieces[i2]);
  }
  for (i2 = 0; i2 < 24; i2++) {
    mixedPieces[i2] = regexEscape(mixedPieces[i2]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate$1(y, m, d, h2, M, s, ms) {
  var date2;
  if (y < 100 && y >= 0) {
    date2 = new Date(y + 400, m, d, h2, M, s, ms);
    if (isFinite(date2.getFullYear())) {
      date2.setFullYear(y);
    }
  } else {
    date2 = new Date(y, m, d, h2, M, s, ms);
  }
  return date2;
}
function createUTCDate(y) {
  var date2, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date2 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date2.getUTCFullYear())) {
      date2.setUTCFullYear(y);
    }
  } else {
    date2 = new Date(Date.UTC.apply(null, arguments));
  }
  return date2;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format2) {
  var weekdays = isArray$1(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i2, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i2]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i2 = 0, j2, next, locale2, split;
  while (i2 < names.length) {
    split = normalizeLocale(names[i2]).split("-");
    j2 = split.length;
    next = normalizeLocale(names[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j2 > 0) {
      locale2 = loadLocale(split.slice(0, j2).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
        break;
      }
      j2--;
    }
    i2++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data2;
  if (key) {
    if (isUndefined$1(values)) {
      data2 = getLocale(key);
    } else {
      data2 = defineLocale(key, values);
    }
    if (data2) {
      globalLocale = data2;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x2) {
        defineLocale(x2.name, x2.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$1(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i2, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
      if (isoDates[i2][1].exec(match[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
        if (isoTimes[i2][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
    return h2 * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);
function defaults$4(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i2, date2, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults$4(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date2 = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date2.getUTCMonth();
    config._a[DATE] = date2.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
    config._a[i2] = input[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate$1).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w2 = config._w;
  if (w2.GG != null || w2.W != null || w2.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults$4(
      w2.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults$4(w2.W, 1);
    weekday = defaults$4(w2.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults$4(w2.gg, config._a[YEAR], curWeek.year);
    week = defaults$4(w2.w, curWeek.week);
    if (w2.d != null) {
      weekday = w2.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w2.e != null) {
      weekday = w2.e + dow;
      if (w2.e < 0 || w2.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < configfLen; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid$1(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend$1(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config._a = map$1(
    [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate$1(input)) {
    config._d = input;
  } else if (isArray$1(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid$1(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined$1(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate$1(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray$1(input)) {
    config._a = map$1(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject$3(input)) {
    configFromObject(config);
  } else if (isNumber$1(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$3(input) && isObjectEmpty(input) || isArray$1(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i2;
  if (moments.length === 1 && isArray$1(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i2, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < orderLen; ++i2) {
    if (m[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len; i2++) {
    if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches = (string || "").match(matcher), chunk2, parts2, minutes2;
  if (matches === null) {
    return null;
  }
  chunk2 = matches[matches.length - 1] || [];
  parts2 = (chunk2 + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts2[1] * 60) + toInt(parts2[2]);
  return minutes2 === 0 ? 0 : parts2[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate$1(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined$1(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber$1(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString$1(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate$1(input) || isString$1(input) || isNumber$1(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject$3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property, propertyLen = properties.length;
  for (i2 = 0; i2 < propertyLen; i2 += 1) {
    property = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray$1(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber$1(item) && isString$1(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject$3(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$1(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter$1(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore$1(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$2() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction$1(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format$1(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray$2() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid$1(this);
}
function parsingFlags() {
  return extend$1({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array, config, token2) {
    var era = config._locale.erasParse(input, token2, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match;
  if (config._locale._eraYearOrdinalRegex) {
    match = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m, format2) {
  var i2, l, date2, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date2 = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date2.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date2 = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date2.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i2, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    name = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, eras = this.eras();
  for (i2 = 0, l = eras.length; i2 < l; ++i2) {
    namePieces.push(regexEscape(eras[i2].name));
    abbrPieces.push(regexEscape(eras[i2].abbr));
    narrowPieces.push(regexEscape(eras[i2].narrow));
    mixedPieces.push(regexEscape(eras[i2].name));
    mixedPieces.push(regexEscape(eras[i2].abbr));
    mixedPieces.push(regexEscape(eras[i2].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date2.getUTCFullYear());
  this.month(date2.getUTCMonth());
  this.date(date2.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format$1;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter$1;
proto.isBefore = isBefore$1;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray$2;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString$2;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber$1(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1(format2, index, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1(format2, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber$1(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber$1(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index != null) {
    return get$1(format2, (index + shift) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data2 = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data2.milliseconds = mathAbs(data2.milliseconds);
  data2.seconds = mathAbs(data2.seconds);
  data2.minutes = mathAbs(data2.minutes);
  data2.hours = mathAbs(data2.hours);
  data2.months = mathAbs(data2.months);
  data2.years = mathAbs(data2.years);
  return this;
}
function addSubtract$1(duration, input, value2, direction) {
  var other = createDuration(input, value2);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value2) {
  return addSubtract$1(this, input, value2, 1);
}
function subtract$1(input, value2) {
  return addSubtract$1(this, input, value2, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data2.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data2.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data2.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data2.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data2.days = days2;
  data2.months = months2;
  data2.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate$1;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var axios$3 = { exports: {} };
var bind$2 = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString$1 = Object.prototype.toString;
var kindOf = function(cache2) {
  return function(thing) {
    var str = toString$1.call(thing);
    return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}
function isArray(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject$2(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction(val) {
  return toString$1.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$2(val) && isFunction(val.pipe);
}
function isFormData(thing) {
  var pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString$1.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (var i2 = 0, l = obj.length; i2 < l; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    forEach(arguments[i2], assignValue);
  }
  return result;
}
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
function inherits(constructor, superConstructor, props, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}
function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i2;
  var prop;
  var merged = {};
  destObj = destObj || {};
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
function toArray$1(thing) {
  if (!thing)
    return null;
  var i2 = thing.length;
  if (isUndefined(i2))
    return null;
  var arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
}
var isTypedArray = function(TypedArray) {
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
var utils$b = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  isTypedArray,
  isFileList
};
var utils$a = utils$b;
function encode$2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL(url2, params, paramsSerializer) {
  if (!params) {
    return url2;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$a.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts2 = [];
    utils$a.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$a.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$a.forEach(val, function parseValue(v) {
        if (utils$a.isDate(v)) {
          v = v.toISOString();
        } else if (utils$a.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts2.push(encode$2(key) + "=" + encode$2(v));
      });
    });
    serializedParams = parts2.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
};
var utils$9 = utils$b;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn) {
  utils$9.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$8 = utils$b;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$8.forEach(headers, function processHeader(value2, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value2;
      delete headers[name];
    }
  });
};
var utils$7 = utils$b;
function AxiosError$2(message, code, config, request2, response) {
  Error.call(this);
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils$7.inherits(AxiosError$2, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError$2.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
  // eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError$2.from = function(error, code, config, request2, response, customProps) {
  var axiosError = Object.create(prototype);
  utils$7.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });
  AxiosError$2.call(axiosError, error.message, code, config, request2, response);
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError$2;
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var utils$6 = utils$b;
function toFormData$1(obj, formData) {
  formData = formData || new FormData();
  var stack = [];
  function convertValue(value2) {
    if (value2 === null)
      return "";
    if (utils$6.isDate(value2)) {
      return value2.toISOString();
    }
    if (utils$6.isArrayBuffer(value2) || utils$6.isTypedArray(value2)) {
      return typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function build(data2, parentKey) {
    if (utils$6.isPlainObject(data2) || utils$6.isArray(data2)) {
      if (stack.indexOf(data2) !== -1) {
        throw Error("Circular reference detected in " + parentKey);
      }
      stack.push(data2);
      utils$6.forEach(data2, function each(value2, key) {
        if (utils$6.isUndefined(value2))
          return;
        var fullKey = parentKey ? parentKey + "." + key : key;
        var arr;
        if (value2 && !parentKey && typeof value2 === "object") {
          if (utils$6.endsWith(key, "{}")) {
            value2 = JSON.stringify(value2);
          } else if (utils$6.endsWith(key, "[]") && (arr = utils$6.toArray(value2))) {
            arr.forEach(function(el) {
              !utils$6.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }
        build(value2, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data2));
    }
  }
  build(obj);
  return formData;
}
var toFormData_1 = toFormData$1;
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var AxiosError2 = AxiosError_1;
  settle = function settle2(resolve2, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve2(response);
    } else {
      reject(new AxiosError2(
        "Request failed with status code " + response.status,
        [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$b;
  cookies = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value2, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value2));
          if (utils2.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils2.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils2.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove2(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove2() {
        }
      };
    }()
  );
  return cookies;
}
var isAbsoluteURL$1 = function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$b;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser2(line) {
      i2 = line.indexOf(":");
      key = utils2.trim(line.substr(0, i2)).toLowerCase();
      val = utils2.trim(line.substr(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$b;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url2) {
        var href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError2 = AxiosError_1;
  var utils2 = utils$b;
  function CanceledError2(message) {
    AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError2, AxiosError2, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError2;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url2) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match && match[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$b;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath3 = buildFullPath$1;
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults2 = transitional;
  var AxiosError2 = AxiosError_1;
  var CanceledError2 = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve2, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL3(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(function _resolve(value2) {
          resolve2(value2);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config, request2));
        request2 = null;
      };
      request2.onerror = function handleError2() {
        reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config, request2, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config.transitional || transitionalDefaults2;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError2(
          timeoutErrorMessage,
          transitional3.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
          config,
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError2() : cancel);
          request2.abort();
          request2 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol2 = parseProtocol2(fullPath);
      if (protocol2 && ["http", "https", "file"].indexOf(protocol2) === -1) {
        reject(new AxiosError2("Unsupported protocol " + protocol2 + ":", AxiosError2.ERR_BAD_REQUEST, config));
        return;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  _null = null;
  return _null;
}
var utils$5 = utils$b;
var normalizeHeaderName2 = normalizeHeaderName$1;
var AxiosError$1 = AxiosError_1;
var transitionalDefaults = transitional;
var toFormData = toFormData_1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value2) {
  if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value2;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$5.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$5.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$3 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$5.isFormData(data2) || utils$5.isArrayBuffer(data2) || utils$5.isBuffer(data2) || utils$5.isStream(data2) || utils$5.isFile(data2) || utils$5.isBlob(data2)) {
      return data2;
    }
    if (utils$5.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$5.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    var isObjectPayload = utils$5.isObject(data2);
    var contentType = headers && headers["Content-Type"];
    var isFileList2;
    if ((isFileList2 = utils$5.isFileList(data2)) || isObjectPayload && contentType === "multipart/form-data") {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList2 ? { "files[]": data2 } : data2, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional3 = this.transitional || defaults$3.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: require_null()
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3;
var utils$4 = utils$b;
var defaults$2 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context = this || defaults$2;
  utils$4.forEach(fns, function transform2(fn) {
    data2 = fn.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value2) {
    return !!(value2 && value2.__CANCEL__);
  };
  return isCancel$1;
}
var utils$3 = utils$b;
var transformData2 = transformData$1;
var isCancel = requireIsCancel();
var defaults$1 = defaults_1;
var CanceledError = requireCanceledError();
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData2.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$3.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults$1.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData2.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$2 = utils$b;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge(target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$2.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$2.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data;
  hasRequiredData = 1;
  data = {
    "version": "0.27.2"
  };
  return data;
}
var VERSION = requireData().version;
var AxiosError = AxiosError_1;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value2, opt, opts) {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value2 = options[opt];
      var result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$1 = utils$b;
var buildURL2 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath2 = buildFullPath$1;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config) {
  if (typeof configOrUrl === "string") {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional3 = config.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  var fullPath = buildFullPath2(config.baseURL, config.url);
  return buildURL2(fullPath, config.params, config.paramsSerializer);
};
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError2 = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    var token2 = this;
    this.promise.then(function(cancel) {
      if (!token2._listeners)
        return;
      var i2;
      var l = token2._listeners.length;
      for (i2 = 0; i2 < l; i2++) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve2) {
        token2.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError2(message);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe2(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token2 = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$b;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils = utils$b;
var bind2 = bind$2;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind2(Axios.prototype.request, context);
  utils.extend(instance, Axios.prototype, context);
  utils.extend(instance, context);
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios$2 = createInstance(defaults);
axios$2.Axios = Axios;
axios$2.CanceledError = requireCanceledError();
axios$2.CancelToken = requireCancelToken();
axios$2.isCancel = requireIsCancel();
axios$2.VERSION = requireData().version;
axios$2.toFormData = toFormData_1;
axios$2.AxiosError = AxiosError_1;
axios$2.Cancel = axios$2.CanceledError;
axios$2.all = function all(promises) {
  return Promise.all(promises);
};
axios$2.spread = requireSpread();
axios$2.isAxiosError = requireIsAxiosError();
axios$3.exports = axios$2;
axios$3.exports.default = axios$2;
var axiosExports = axios$3.exports;
var axios = axiosExports;
const axios$1 = /* @__PURE__ */ getDefaultExportFromCjs(axios);
const AGORA_APP_ID = "10d5ec86b71f43da879117c0e5c2b6e1";
const TOKEN = "528b956e7d1d09d25e6e37c7d042a6e828f231c1";
const API_URL = "https://api2.bitmec.com/";
const _sfc_main$d = {
  props: {
    time: {
      type: Number,
      default: 0
    }
  },
  data: function() {
    return {
      total: "",
      minutes: "--",
      seconds: "--",
      interval: 0
    };
  },
  mounted: function() {
    this.total = parseInt(this.time, 10);
    this.interval = setInterval(() => {
      this.tick();
    }, 1e3);
  },
  methods: {
    str_pad_left: function(string, pad, length2) {
      return (new Array(length2 + 1).join(pad) + string).slice(-length2);
    },
    tick: function() {
      var minutes2 = Math.floor(this.total / 60);
      var seconds2 = this.total - minutes2 * 60;
      this.minutes = this.str_pad_left(minutes2, "0", 2);
      this.seconds = this.str_pad_left(seconds2, "0", 2);
      if (this.total <= 0) {
        clearInterval(this.interval);
        this.$bus.$emit("Timer/stop");
      }
      this.total -= 1;
    }
  }
};
const _hoisted_1$b = /* @__PURE__ */ createBaseVNode("strong", null, ":", -1);
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    createBaseVNode("div", {
      class: normalizeClass({ "text-danger": _ctx.total <= 0 })
    }, [
      createBaseVNode("strong", null, toDisplayString(_ctx.minutes), 1),
      _hoisted_1$b,
      createBaseVNode("strong", null, toDisplayString(_ctx.seconds), 1)
    ], 2)
  ]);
}
const TimeComponent = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
const VProgressLinear$1 = "";
function useColor(colors) {
  return destructComputed(() => {
    const classes = [];
    const styles = {};
    if (colors.value.background) {
      if (isCssColor(colors.value.background)) {
        styles.backgroundColor = colors.value.background;
        if (!colors.value.text) {
          const backgroundColor = parseColor(colors.value.background);
          if (backgroundColor.a == null || backgroundColor.a === 1) {
            const textColor = getForeground(backgroundColor);
            styles.color = textColor;
            styles.caretColor = textColor;
          }
        }
      } else {
        classes.push(`bg-${colors.value.background}`);
      }
    }
    if (colors.value.text) {
      if (isCssColor(colors.value.text)) {
        styles.color = colors.value.text;
        styles.caretColor = colors.value.text;
      } else {
        classes.push(`text-${colors.value.text}`);
      }
    }
    return {
      colorClasses: classes,
      colorStyles: styles
    };
  });
}
function useTextColor(props, name) {
  const colors = computed(() => ({
    text: isRef(props) ? props.value : name ? props[name] : null
  }));
  const {
    colorClasses: textColorClasses,
    colorStyles: textColorStyles
  } = useColor(colors);
  return {
    textColorClasses,
    textColorStyles
  };
}
function useBackgroundColor(props, name) {
  const colors = computed(() => ({
    background: isRef(props) ? props.value : name ? props[name] : null
  }));
  const {
    colorClasses: backgroundColorClasses,
    colorStyles: backgroundColorStyles
  } = useColor(colors);
  return {
    backgroundColorClasses,
    backgroundColorStyles
  };
}
function useIntersectionObserver(callback, options) {
  const intersectionRef = ref();
  const isIntersecting = shallowRef(false);
  if (SUPPORTS_INTERSECTION) {
    const observer = new IntersectionObserver((entries) => {
      callback?.(entries, observer);
      isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
    }, options);
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(intersectionRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(oldValue);
        isIntersecting.value = false;
      }
      if (newValue)
        observer.observe(newValue);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef,
    isIntersecting
  };
}
const oppositeMap = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const makeLocationProps = propsFactory({
  location: String
}, "location");
function useLocation(props) {
  let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let offset2 = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl
  } = useRtl();
  const locationStyles = computed(() => {
    if (!props.location)
      return {};
    const {
      side,
      align
    } = parseAnchor(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
    function getOffset2(side2) {
      return offset2 ? offset2(side2) : 0;
    }
    const styles = {};
    if (side !== "center") {
      if (opposite)
        styles[oppositeMap[side]] = `calc(100% - ${getOffset2(side)}px)`;
      else
        styles[side] = 0;
    }
    if (align !== "center") {
      if (opposite)
        styles[oppositeMap[align]] = `calc(100% - ${getOffset2(align)}px)`;
      else
        styles[align] = 0;
    } else {
      if (side === "center")
        styles.top = styles.left = "50%";
      else {
        styles[{
          top: "left",
          bottom: "left",
          left: "top",
          right: "top"
        }[side]] = "50%";
      }
      styles.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[side];
    }
    return styles;
  });
  return {
    locationStyles
  };
}
const makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function useRounded(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const roundedClasses = computed(() => {
    const rounded = isRef(props) ? props.value : props.rounded;
    const classes = [];
    if (rounded === true || rounded === "") {
      classes.push(`${name}--rounded`);
    } else if (typeof rounded === "string" || rounded === 0) {
      for (const value2 of String(rounded).split(" ")) {
        classes.push(`rounded-${value2}`);
      }
    }
    return classes;
  });
  return {
    roundedClasses
  };
}
const makeVProgressLinearProps = propsFactory({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: true
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VProgressLinear");
const VProgressLinear = genericComponent()({
  name: "VProgressLinear",
  props: makeVProgressLinearProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const progress = useProxiedModel(props, "modelValue");
    const {
      isRtl,
      rtlClasses
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(props, "color");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed(() => props.bgColor || props.color));
    const {
      backgroundColorClasses: barColorClasses,
      backgroundColorStyles: barColorStyles
    } = useBackgroundColor(props, "color");
    const {
      roundedClasses
    } = useRounded(props);
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const max2 = computed(() => parseInt(props.max, 10));
    const height = computed(() => parseInt(props.height, 10));
    const normalizedBuffer = computed(() => parseFloat(props.bufferValue) / max2.value * 100);
    const normalizedValue = computed(() => parseFloat(progress.value) / max2.value * 100);
    const isReversed = computed(() => isRtl.value !== props.reverse);
    const transition = computed(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
    const opacity = computed(() => {
      return props.bgOpacity == null ? props.bgOpacity : parseFloat(props.bgOpacity);
    });
    function handleClick(e) {
      if (!intersectionRef.value)
        return;
      const {
        left,
        right,
        width
      } = intersectionRef.value.getBoundingClientRect();
      const value2 = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
      progress.value = Math.round(value2 / width * max2.value);
    }
    useRender(() => createVNode(props.tag, {
      "ref": intersectionRef,
      "class": ["v-progress-linear", {
        "v-progress-linear--absolute": props.absolute,
        "v-progress-linear--active": props.active && isIntersecting.value,
        "v-progress-linear--reverse": isReversed.value,
        "v-progress-linear--rounded": props.rounded,
        "v-progress-linear--rounded-bar": props.roundedBar,
        "v-progress-linear--striped": props.striped
      }, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
      "style": [{
        bottom: props.location === "bottom" ? 0 : void 0,
        top: props.location === "top" ? 0 : void 0,
        height: props.active ? convertToUnit(height.value) : 0,
        "--v-progress-linear-height": convertToUnit(height.value),
        ...locationStyles.value
      }, props.style],
      "role": "progressbar",
      "aria-hidden": props.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": props.max,
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
      "onClick": props.clickable && handleClick
    }, {
      default: () => [props.stream && createVNode("div", {
        "key": "stream",
        "class": ["v-progress-linear__stream", textColorClasses.value],
        "style": {
          ...textColorStyles.value,
          [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
          borderTop: `${convertToUnit(height.value / 2)} dotted`,
          opacity: opacity.value,
          top: `calc(50% - ${convertToUnit(height.value / 4)})`,
          width: convertToUnit(100 - normalizedBuffer.value, "%"),
          "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
        }
      }, null), createVNode("div", {
        "class": ["v-progress-linear__background", backgroundColorClasses.value],
        "style": [backgroundColorStyles.value, {
          opacity: opacity.value,
          width: convertToUnit(!props.stream ? 100 : normalizedBuffer.value, "%")
        }]
      }, null), createVNode(Transition, {
        "name": transition.value
      }, {
        default: () => [!props.indeterminate ? createVNode("div", {
          "class": ["v-progress-linear__determinate", barColorClasses.value],
          "style": [barColorStyles.value, {
            width: convertToUnit(normalizedValue.value, "%")
          }]
        }, null) : createVNode("div", {
          "class": "v-progress-linear__indeterminate"
        }, [["long", "short"].map((bar) => createVNode("div", {
          "key": bar,
          "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
          "style": barColorStyles.value
        }, null))])]
      }), slots.default && createVNode("div", {
        "class": "v-progress-linear__content"
      }, [slots.default({
        value: normalizedValue.value,
        buffer: normalizedBuffer.value
      })])]
    }));
    return {};
  }
});
const _sfc_main$c = {};
function _sfc_render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, [
    createVNode(VProgressLinear, {
      indeterminate: "",
      color: "white",
      class: "mb-0"
    })
  ]);
}
const ProgressLinearComponent = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
var AgoraRTC_NProduction = { exports: {} };
(function(module2, exports) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal$1, function() {
    function e(e2, t2) {
      return t2.forEach(function(t3) {
        t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i3) {
          if ("default" !== i3 && !(i3 in e2)) {
            var n2 = Object.getOwnPropertyDescriptor(t3, i3);
            Object.defineProperty(e2, i3, n2.get ? n2 : { enumerable: true, get: function() {
              return t3[i3];
            } });
          }
        });
      }), Object.freeze(e2);
    }
    var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof commonjsGlobal$1 ? commonjsGlobal$1 : "undefined" != typeof self ? self : {}, i2 = function(e2) {
      try {
        return !!e2();
      } catch (e3) {
        return true;
      }
    }, n = !i2(function() {
      var e2 = function() {
      }.bind();
      return "function" != typeof e2 || e2.hasOwnProperty("prototype");
    }), r = n, o = Function.prototype, s = o.bind, a = o.call, c = r && s.bind(a, a), d = r ? function(e2) {
      return e2 && c(e2);
    } : function(e2) {
      return e2 && function() {
        return a.apply(e2, arguments);
      };
    }, u = d({}.isPrototypeOf), l = function(e2) {
      return e2 && e2.Math == Math && e2;
    }, h2 = l("object" == typeof globalThis && globalThis) || l("object" == typeof window && window) || l("object" == typeof self && self) || l("object" == typeof t && t) || function() {
      return this;
    }() || Function("return this")(), p2 = n, _ = Function.prototype, E = _.apply, m = _.call, f = "object" == typeof Reflect && Reflect.apply || (p2 ? m.bind(E) : function() {
      return m.apply(E, arguments);
    }), S = function(e2) {
      return "function" == typeof e2;
    }, T = {}, g = !i2(function() {
      return 7 != Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1];
    }), R = n, I = Function.prototype.call, C = R ? I.bind(I) : function() {
      return I.apply(I, arguments);
    }, v = {}, y = {}.propertyIsEnumerable, A = Object.getOwnPropertyDescriptor, O = A && !y.call({ 1: 2 }, 1);
    v.f = O ? function(e2) {
      var t2 = A(this, e2);
      return !!t2 && t2.enumerable;
    } : y;
    var N, b, w2 = function(e2, t2) {
      return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
    }, D = d, P = D({}.toString), L2 = D("".slice), k2 = function(e2) {
      return L2(P(e2), 8, -1);
    }, M = d, U = i2, x2 = k2, V = h2.Object, j2 = M("".split), F2 = U(function() {
      return !V("z").propertyIsEnumerable(0);
    }) ? function(e2) {
      return "String" == x2(e2) ? j2(e2, "") : V(e2);
    } : V, B = h2.TypeError, G2 = function(e2) {
      if (null == e2)
        throw B("Can't call method on " + e2);
      return e2;
    }, W = F2, H = G2, K = function(e2) {
      return W(H(e2));
    }, Y = S, q = function(e2) {
      return "object" == typeof e2 ? null !== e2 : Y(e2);
    }, J = {}, X = J, z = h2, Q = S, Z = function(e2) {
      return Q(e2) ? e2 : void 0;
    }, $ = function(e2, t2) {
      return arguments.length < 2 ? Z(X[e2]) || Z(z[e2]) : X[e2] && X[e2][t2] || z[e2] && z[e2][t2];
    }, ee = $("navigator", "userAgent") || "", te = h2, ie = ee, ne = te.process, re2 = te.Deno, oe = ne && ne.versions || re2 && re2.version, se = oe && oe.v8;
    se && (b = (N = se.split("."))[0] > 0 && N[0] < 4 ? 1 : +(N[0] + N[1])), !b && ie && (!(N = ie.match(/Edge\/(\d+)/)) || N[1] >= 74) && (N = ie.match(/Chrome\/(\d+)/)) && (b = +N[1]);
    var ae = b, ce = ae, de = i2, ue = !!Object.getOwnPropertySymbols && !de(function() {
      var e2 = Symbol();
      return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && ce && ce < 41;
    }), le = ue && !Symbol.sham && "symbol" == typeof Symbol.iterator, he = $, pe = S, _e = u, Ee = le, me = h2.Object, fe = Ee ? function(e2) {
      return "symbol" == typeof e2;
    } : function(e2) {
      var t2 = he("Symbol");
      return pe(t2) && _e(t2.prototype, me(e2));
    }, Se = h2.String, Te = function(e2) {
      try {
        return Se(e2);
      } catch (e3) {
        return "Object";
      }
    }, ge = S, Re = Te, Ie = h2.TypeError, Ce = function(e2) {
      if (ge(e2))
        return e2;
      throw Ie(Re(e2) + " is not a function");
    }, ve = Ce, ye = function(e2, t2) {
      var i3 = e2[t2];
      return null == i3 ? void 0 : ve(i3);
    }, Ae = C, Oe = S, Ne = q, be = h2.TypeError, we = { exports: {} }, De = h2, Pe = Object.defineProperty, Le = function(e2, t2) {
      try {
        Pe(De, e2, { value: t2, configurable: true, writable: true });
      } catch (i3) {
        De[e2] = t2;
      }
      return t2;
    }, ke = "__core-js_shared__", Me = h2[ke] || Le(ke, {}), Ue = Me;
    (we.exports = function(e2, t2) {
      return Ue[e2] || (Ue[e2] = void 0 !== t2 ? t2 : {});
    })("versions", []).push({ version: "3.20.3", mode: "pure", copyright: "© 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE", source: "https://github.com/zloirock/core-js" });
    var xe = G2, Ve = h2.Object, je = function(e2) {
      return Ve(xe(e2));
    }, Fe = je, Be = d({}.hasOwnProperty), Ge = Object.hasOwn || function(e2, t2) {
      return Be(Fe(e2), t2);
    }, We = d, He = 0, Ke = Math.random(), Ye = We(1 .toString), qe = function(e2) {
      return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + Ye(++He + Ke, 36);
    }, Je = h2, Xe = we.exports, ze = Ge, Qe = qe, Ze = ue, $e = le, et = Xe("wks"), tt = Je.Symbol, it = tt && tt.for, nt = $e ? tt : tt && tt.withoutSetter || Qe, rt = function(e2) {
      if (!ze(et, e2) || !Ze && "string" != typeof et[e2]) {
        var t2 = "Symbol." + e2;
        Ze && ze(tt, e2) ? et[e2] = tt[e2] : et[e2] = $e && it ? it(t2) : nt(t2);
      }
      return et[e2];
    }, ot = C, st = q, at = fe, ct = ye, dt2 = function(e2, t2) {
      var i3, n2;
      if ("string" === t2 && Oe(i3 = e2.toString) && !Ne(n2 = Ae(i3, e2)))
        return n2;
      if (Oe(i3 = e2.valueOf) && !Ne(n2 = Ae(i3, e2)))
        return n2;
      if ("string" !== t2 && Oe(i3 = e2.toString) && !Ne(n2 = Ae(i3, e2)))
        return n2;
      throw be("Can't convert object to primitive value");
    }, ut = rt, lt = h2.TypeError, ht2 = ut("toPrimitive"), pt2 = function(e2, t2) {
      if (!st(e2) || at(e2))
        return e2;
      var i3, n2 = ct(e2, ht2);
      if (n2) {
        if (void 0 === t2 && (t2 = "default"), i3 = ot(n2, e2, t2), !st(i3) || at(i3))
          return i3;
        throw lt("Can't convert object to primitive value");
      }
      return void 0 === t2 && (t2 = "number"), dt2(e2, t2);
    }, _t2 = fe, Et2 = function(e2) {
      var t2 = pt2(e2, "string");
      return _t2(t2) ? t2 : t2 + "";
    }, mt2 = q, ft = h2.document, St = mt2(ft) && mt2(ft.createElement), Tt2 = function(e2) {
      return St ? ft.createElement(e2) : {};
    }, gt2 = Tt2, Rt = !g && !i2(function() {
      return 7 != Object.defineProperty(gt2("div"), "a", { get: function() {
        return 7;
      } }).a;
    }), It2 = g, Ct2 = C, vt2 = v, yt2 = w2, At2 = K, Ot = Et2, Nt = Ge, bt = Rt, wt2 = Object.getOwnPropertyDescriptor;
    T.f = It2 ? wt2 : function(e2, t2) {
      if (e2 = At2(e2), t2 = Ot(t2), bt)
        try {
          return wt2(e2, t2);
        } catch (e3) {
        }
      if (Nt(e2, t2))
        return yt2(!Ct2(vt2.f, e2, t2), e2[t2]);
    };
    var Dt2 = i2, Pt = S, Lt = /#|\.prototype\./, kt2 = function(e2, t2) {
      var i3 = Ut[Mt(e2)];
      return i3 == Vt || i3 != xt2 && (Pt(t2) ? Dt2(t2) : !!t2);
    }, Mt = kt2.normalize = function(e2) {
      return String(e2).replace(Lt, ".").toLowerCase();
    }, Ut = kt2.data = {}, xt2 = kt2.NATIVE = "N", Vt = kt2.POLYFILL = "P", jt = kt2, Ft = Ce, Bt = n, Gt = d(d.bind), Wt = function(e2, t2) {
      return Ft(e2), void 0 === t2 ? e2 : Bt ? Gt(e2, t2) : function() {
        return e2.apply(t2, arguments);
      };
    }, Ht = {}, Kt = g && i2(function() {
      return 42 != Object.defineProperty(function() {
      }, "prototype", { value: 42, writable: false }).prototype;
    }), Yt = h2, qt = q, Jt = Yt.String, Xt = Yt.TypeError, zt = function(e2) {
      if (qt(e2))
        return e2;
      throw Xt(Jt(e2) + " is not an object");
    }, Qt = g, Zt = Rt, $t2 = Kt, ei = zt, ti = Et2, ii = h2.TypeError, ni = Object.defineProperty, ri = Object.getOwnPropertyDescriptor, oi = "enumerable", si = "configurable", ai = "writable";
    Ht.f = Qt ? $t2 ? function(e2, t2, i3) {
      if (ei(e2), t2 = ti(t2), ei(i3), "function" == typeof e2 && "prototype" === t2 && "value" in i3 && ai in i3 && !i3.writable) {
        var n2 = ri(e2, t2);
        n2 && n2.writable && (e2[t2] = i3.value, i3 = { configurable: si in i3 ? i3.configurable : n2.configurable, enumerable: oi in i3 ? i3.enumerable : n2.enumerable, writable: false });
      }
      return ni(e2, t2, i3);
    } : ni : function(e2, t2, i3) {
      if (ei(e2), t2 = ti(t2), ei(i3), Zt)
        try {
          return ni(e2, t2, i3);
        } catch (e3) {
        }
      if ("get" in i3 || "set" in i3)
        throw ii("Accessors not supported");
      return "value" in i3 && (e2[t2] = i3.value), e2;
    };
    var ci = Ht, di = w2, ui = g ? function(e2, t2, i3) {
      return ci.f(e2, t2, di(1, i3));
    } : function(e2, t2, i3) {
      return e2[t2] = i3, e2;
    }, li = h2, hi = f, pi = d, _i = S, Ei = T.f, mi = jt, fi = J, Si = Wt, Ti = ui, gi = Ge, Ri = function(e2) {
      var t2 = function(i3, n2, r2) {
        if (this instanceof t2) {
          switch (arguments.length) {
            case 0:
              return new e2();
            case 1:
              return new e2(i3);
            case 2:
              return new e2(i3, n2);
          }
          return new e2(i3, n2, r2);
        }
        return hi(e2, this, arguments);
      };
      return t2.prototype = e2.prototype, t2;
    }, Ii = function(e2, t2) {
      var i3, n2, r2, o2, s2, a2, c2, d2, u2 = e2.target, l2 = e2.global, h3 = e2.stat, p3 = e2.proto, _2 = l2 ? li : h3 ? li[u2] : (li[u2] || {}).prototype, E2 = l2 ? fi : fi[u2] || Ti(fi, u2, {})[u2], m2 = E2.prototype;
      for (r2 in t2)
        i3 = !mi(l2 ? r2 : u2 + (h3 ? "." : "#") + r2, e2.forced) && _2 && gi(_2, r2), s2 = E2[r2], i3 && (a2 = e2.noTargetGet ? (d2 = Ei(_2, r2)) && d2.value : _2[r2]), o2 = i3 && a2 ? a2 : t2[r2], i3 && typeof s2 == typeof o2 || (c2 = e2.bind && i3 ? Si(o2, li) : e2.wrap && i3 ? Ri(o2) : p3 && _i(o2) ? pi(o2) : o2, (e2.sham || o2 && o2.sham || s2 && s2.sham) && Ti(c2, "sham", true), Ti(E2, r2, c2), p3 && (gi(fi, n2 = u2 + "Prototype") || Ti(fi, n2, {}), Ti(fi[n2], r2, o2), e2.real && m2 && !m2[r2] && Ti(m2, r2, o2)));
    }, Ci = Math.ceil, vi = Math.floor, yi = function(e2) {
      var t2 = +e2;
      return t2 != t2 || 0 === t2 ? 0 : (t2 > 0 ? vi : Ci)(t2);
    }, Ai = yi, Oi = Math.min, Ni = function(e2) {
      return e2 > 0 ? Oi(Ai(e2), 9007199254740991) : 0;
    }, bi = function(e2) {
      return Ni(e2.length);
    }, wi = Ce, Di = je, Pi = F2, Li = bi, ki = h2.TypeError, Mi = function(e2) {
      return function(t2, i3, n2, r2) {
        wi(i3);
        var o2 = Di(t2), s2 = Pi(o2), a2 = Li(o2), c2 = e2 ? a2 - 1 : 0, d2 = e2 ? -1 : 1;
        if (n2 < 2)
          for (; ; ) {
            if (c2 in s2) {
              r2 = s2[c2], c2 += d2;
              break;
            }
            if (c2 += d2, e2 ? c2 < 0 : a2 <= c2)
              throw ki("Reduce of empty array with no initial value");
          }
        for (; e2 ? c2 >= 0 : a2 > c2; c2 += d2)
          c2 in s2 && (r2 = i3(r2, s2[c2], c2, o2));
        return r2;
      };
    }, Ui = { left: Mi(false), right: Mi(true) }, xi = i2, Vi = function(e2, t2) {
      var i3 = [][e2];
      return !!i3 && xi(function() {
        i3.call(null, t2 || function() {
          throw 1;
        }, 1);
      });
    }, ji = "process" == k2(h2.process), Fi = Ui.left, Bi = ae, Gi = ji;
    Ii({ target: "Array", proto: true, forced: !Vi("reduce") || !Gi && Bi > 79 && Bi < 83 }, { reduce: function(e2) {
      var t2 = arguments.length;
      return Fi(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
    } });
    var Wi = J, Hi = function(e2) {
      return Wi[e2 + "Prototype"];
    }, Ki = Hi("Array").reduce, Yi = u, qi = Ki, Ji = Array.prototype, Xi = function(e2) {
      var t2 = e2.reduce;
      return e2 === Ji || Yi(Ji, e2) && t2 === Ji.reduce ? qi : t2;
    }, zi = Xi;
    let Qi = true, Zi = true;
    function $i(e2, t2, i3) {
      const n2 = e2.match(t2);
      return n2 && n2.length >= i3 && parseInt(n2[i3], 10);
    }
    function en2(e2, t2, i3) {
      if (!e2.RTCPeerConnection)
        return;
      const n2 = e2.RTCPeerConnection.prototype, r2 = n2.addEventListener;
      n2.addEventListener = function(e3, n3) {
        if (e3 !== t2)
          return r2.apply(this, arguments);
        const o3 = (e4) => {
          const t3 = i3(e4);
          t3 && (n3.handleEvent ? n3.handleEvent(t3) : n3(t3));
        };
        return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(n3, o3), r2.apply(this, [e3, o3]);
      };
      const o2 = n2.removeEventListener;
      n2.removeEventListener = function(e3, i4) {
        if (e3 !== t2 || !this._eventMap || !this._eventMap[t2])
          return o2.apply(this, arguments);
        if (!this._eventMap[t2].has(i4))
          return o2.apply(this, arguments);
        const n3 = this._eventMap[t2].get(i4);
        return this._eventMap[t2].delete(i4), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e3, n3]);
      }, Object.defineProperty(n2, "on" + t2, { get() {
        return this["_on" + t2];
      }, set(e3) {
        this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
      }, enumerable: true, configurable: true });
    }
    function tn(e2) {
      return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Qi = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
    }
    function nn(e2) {
      return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (Zi = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
    }
    function rn() {
      if ("object" == typeof window) {
        if (Qi)
          return;
        "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
      }
    }
    function on2(e2, t2) {
      Zi && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
    }
    function sn(e2) {
      const t2 = { browser: null, version: null };
      if (void 0 === e2 || !e2.navigator)
        return t2.browser = "Not a browser.", t2;
      const { navigator: i3 } = e2;
      if (i3.mozGetUserMedia)
        t2.browser = "firefox", t2.version = $i(i3.userAgent, /Firefox\/(\d+)\./, 1);
      else if (i3.webkitGetUserMedia || false === e2.isSecureContext && e2.webkitRTCPeerConnection)
        t2.browser = "chrome", t2.version = $i(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
      else {
        if (!e2.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./))
          return t2.browser = "Not a supported browser.", t2;
        t2.browser = "safari", t2.version = $i(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t2.supportsUnifiedPlan = e2.RTCRtpTransceiver && "currentDirection" in e2.RTCRtpTransceiver.prototype;
      }
      return t2;
    }
    function an(e2) {
      return "[object Object]" === Object.prototype.toString.call(e2);
    }
    function cn(e2) {
      var t2;
      return an(e2) ? zi(t2 = Object.keys(e2)).call(t2, function(t3, i3) {
        const n2 = an(e2[i3]), r2 = n2 ? cn(e2[i3]) : e2[i3], o2 = n2 && !Object.keys(r2).length;
        return void 0 === r2 || o2 ? t3 : Object.assign(t3, { [i3]: r2 });
      }, {}) : e2;
    }
    function dn(e2, t2, i3) {
      const n2 = i3 ? "outbound-rtp" : "inbound-rtp", r2 = /* @__PURE__ */ new Map();
      if (null === t2)
        return r2;
      const o2 = [];
      return e2.forEach((e3) => {
        "track" === e3.type && e3.trackIdentifier === t2.id && o2.push(e3);
      }), o2.forEach((t3) => {
        e2.forEach((i4) => {
          i4.type === n2 && i4.trackId === t3.id && function e3(t4, i5, n3) {
            i5 && !n3.has(i5.id) && (n3.set(i5.id, i5), Object.keys(i5).forEach((r3) => {
              r3.endsWith("Id") ? e3(t4, t4.get(i5[r3]), n3) : r3.endsWith("Ids") && i5[r3].forEach((i6) => {
                e3(t4, t4.get(i6), n3);
              });
            }));
          }(e2, i4, r2);
        });
      }), r2;
    }
    var un = we.exports, ln = qe, hn = un("keys"), pn = function(e2) {
      return hn[e2] || (hn[e2] = ln(e2));
    }, _n = !i2(function() {
      function e2() {
      }
      return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
    }), En = h2, mn = Ge, fn = S, Sn = je, Tn = _n, gn = pn("IE_PROTO"), Rn = En.Object, In = Rn.prototype, Cn = Tn ? Rn.getPrototypeOf : function(e2) {
      var t2 = Sn(e2);
      if (mn(t2, gn))
        return t2[gn];
      var i3 = t2.constructor;
      return fn(i3) && t2 instanceof i3 ? i3.prototype : t2 instanceof Rn ? In : null;
    }, vn = h2, yn = S, An = vn.String, On = vn.TypeError, Nn = d, bn = zt, wn = function(e2) {
      if ("object" == typeof e2 || yn(e2))
        return e2;
      throw On("Can't set " + An(e2) + " as a prototype");
    }, Dn = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var e2, t2 = false, i3 = {};
      try {
        (e2 = Nn(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(i3, []), t2 = i3 instanceof Array;
      } catch (e3) {
      }
      return function(i4, n2) {
        return bn(i4), wn(n2), t2 ? e2(i4, n2) : i4.__proto__ = n2, i4;
      };
    }() : void 0), Pn = {}, Ln = yi, kn = Math.max, Mn = Math.min, Un = function(e2, t2) {
      var i3 = Ln(e2);
      return i3 < 0 ? kn(i3 + t2, 0) : Mn(i3, t2);
    }, xn = K, Vn = Un, jn = bi, Fn = function(e2) {
      return function(t2, i3, n2) {
        var r2, o2 = xn(t2), s2 = jn(o2), a2 = Vn(n2, s2);
        if (e2 && i3 != i3) {
          for (; s2 > a2; )
            if ((r2 = o2[a2++]) != r2)
              return true;
        } else
          for (; s2 > a2; a2++)
            if ((e2 || a2 in o2) && o2[a2] === i3)
              return e2 || a2 || 0;
        return !e2 && -1;
      };
    }, Bn = { includes: Fn(true), indexOf: Fn(false) }, Gn = {}, Wn = Ge, Hn = K, Kn = Bn.indexOf, Yn = Gn, qn = d([].push), Jn = function(e2, t2) {
      var i3, n2 = Hn(e2), r2 = 0, o2 = [];
      for (i3 in n2)
        !Wn(Yn, i3) && Wn(n2, i3) && qn(o2, i3);
      for (; t2.length > r2; )
        Wn(n2, i3 = t2[r2++]) && (~Kn(o2, i3) || qn(o2, i3));
      return o2;
    }, Xn = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], zn = Jn, Qn = Xn.concat("length", "prototype");
    Pn.f = Object.getOwnPropertyNames || function(e2) {
      return zn(e2, Qn);
    };
    var Zn = {};
    Zn.f = Object.getOwnPropertySymbols;
    var $n = $, er = Pn, tr = Zn, ir = zt, nr = d([].concat), rr = $n("Reflect", "ownKeys") || function(e2) {
      var t2 = er.f(ir(e2)), i3 = tr.f;
      return i3 ? nr(t2, i3(e2)) : t2;
    }, or = Ge, sr = rr, ar = T, cr = Ht, dr = {}, ur = Jn, lr = Xn, hr = Object.keys || function(e2) {
      return ur(e2, lr);
    }, pr = g, _r = Kt, Er = Ht, mr = zt, fr = K, Sr = hr;
    dr.f = pr && !_r ? Object.defineProperties : function(e2, t2) {
      mr(e2);
      for (var i3, n2 = fr(t2), r2 = Sr(t2), o2 = r2.length, s2 = 0; o2 > s2; )
        Er.f(e2, i3 = r2[s2++], n2[i3]);
      return e2;
    };
    var Tr, gr = $("document", "documentElement"), Rr = zt, Ir = dr, Cr = Xn, vr = Gn, yr = gr, Ar = Tt2, Or = pn("IE_PROTO"), Nr = function() {
    }, br = function(e2) {
      return "<script>" + e2 + "<\/script>";
    }, wr = function(e2) {
      e2.write(br("")), e2.close();
      var t2 = e2.parentWindow.Object;
      return e2 = null, t2;
    }, Dr = function() {
      try {
        Tr = new ActiveXObject("htmlfile");
      } catch (e3) {
      }
      var e2, t2;
      Dr = "undefined" != typeof document ? document.domain && Tr ? wr(Tr) : ((t2 = Ar("iframe")).style.display = "none", yr.appendChild(t2), t2.src = String("javascript:"), (e2 = t2.contentWindow.document).open(), e2.write(br("document.F=Object")), e2.close(), e2.F) : wr(Tr);
      for (var i3 = Cr.length; i3--; )
        delete Dr.prototype[Cr[i3]];
      return Dr();
    };
    vr[Or] = true;
    var Pr = Object.create || function(e2, t2) {
      var i3;
      return null !== e2 ? (Nr.prototype = Rr(e2), i3 = new Nr(), Nr.prototype = null, i3[Or] = e2) : i3 = Dr(), void 0 === t2 ? i3 : Ir.f(i3, t2);
    }, Lr = d("".replace), kr = String(Error("zxcasd").stack), Mr = /\n\s*at [^:]*:[^\n]*/, Ur = Mr.test(kr), xr = q, Vr = ui, jr = {}, Fr = jr, Br = rt("iterator"), Gr = Array.prototype, Wr = {};
    Wr[rt("toStringTag")] = "z";
    var Hr = "[object z]" === String(Wr), Kr = h2, Yr = Hr, qr = S, Jr = k2, Xr = rt("toStringTag"), zr = Kr.Object, Qr = "Arguments" == Jr(function() {
      return arguments;
    }()), Zr = Yr ? Jr : function(e2) {
      var t2, i3, n2;
      return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i3 = function(e3, t3) {
        try {
          return e3[t3];
        } catch (e4) {
        }
      }(t2 = zr(e2), Xr)) ? i3 : Qr ? Jr(t2) : "Object" == (n2 = Jr(t2)) && qr(t2.callee) ? "Arguments" : n2;
    }, $r = Zr, eo = ye, to2 = jr, io = rt("iterator"), no = function(e2) {
      if (null != e2)
        return eo(e2, io) || eo(e2, "@@iterator") || to2[$r(e2)];
    }, ro = C, oo = Ce, so = zt, ao = Te, co = no, uo = h2.TypeError, lo = C, ho = zt, po = ye, _o = Wt, Eo = C, mo = zt, fo = Te, So = function(e2) {
      return void 0 !== e2 && (Fr.Array === e2 || Gr[Br] === e2);
    }, To = bi, go = u, Ro = function(e2, t2) {
      var i3 = arguments.length < 2 ? co(e2) : t2;
      if (oo(i3))
        return so(ro(i3, e2));
      throw uo(ao(e2) + " is not iterable");
    }, Io = no, Co = function(e2, t2, i3) {
      var n2, r2;
      ho(e2);
      try {
        if (!(n2 = po(e2, "return"))) {
          if ("throw" === t2)
            throw i3;
          return i3;
        }
        n2 = lo(n2, e2);
      } catch (e3) {
        r2 = true, n2 = e3;
      }
      if ("throw" === t2)
        throw i3;
      if (r2)
        throw n2;
      return ho(n2), i3;
    }, vo = h2.TypeError, yo = function(e2, t2) {
      this.stopped = e2, this.result = t2;
    }, Ao = yo.prototype, Oo = function(e2, t2, i3) {
      var n2, r2, o2, s2, a2, c2, d2, u2 = i3 && i3.that, l2 = !(!i3 || !i3.AS_ENTRIES), h3 = !(!i3 || !i3.IS_ITERATOR), p3 = !(!i3 || !i3.INTERRUPTED), _2 = _o(t2, u2), E2 = function(e3) {
        return n2 && Co(n2, "normal", e3), new yo(true, e3);
      }, m2 = function(e3) {
        return l2 ? (mo(e3), p3 ? _2(e3[0], e3[1], E2) : _2(e3[0], e3[1])) : p3 ? _2(e3, E2) : _2(e3);
      };
      if (h3)
        n2 = e2;
      else {
        if (!(r2 = Io(e2)))
          throw vo(fo(e2) + " is not iterable");
        if (So(r2)) {
          for (o2 = 0, s2 = To(e2); s2 > o2; o2++)
            if ((a2 = m2(e2[o2])) && go(Ao, a2))
              return a2;
          return new yo(false);
        }
        n2 = Ro(e2, r2);
      }
      for (c2 = n2.next; !(d2 = Eo(c2, n2)).done; ) {
        try {
          a2 = m2(d2.value);
        } catch (e3) {
          Co(n2, "throw", e3);
        }
        if ("object" == typeof a2 && a2 && go(Ao, a2))
          return a2;
      }
      return new yo(false);
    }, No = Zr, bo = h2.String, wo = function(e2) {
      if ("Symbol" === No(e2))
        throw TypeError("Cannot convert a Symbol value to a string");
      return bo(e2);
    }, Do = wo, Po = w2, Lo = !i2(function() {
      var e2 = Error("a");
      return !("stack" in e2) || (Object.defineProperty(e2, "stack", Po(1, 7)), 7 !== e2.stack);
    }), ko = Ii, Mo = h2, Uo = u, xo = Cn, Vo = Dn, jo = function(e2, t2, i3) {
      for (var n2 = sr(t2), r2 = cr.f, o2 = ar.f, s2 = 0; s2 < n2.length; s2++) {
        var a2 = n2[s2];
        or(e2, a2) || i3 && or(i3, a2) || r2(e2, a2, o2(t2, a2));
      }
    }, Fo = Pr, Bo = ui, Go = w2, Wo = function(e2, t2) {
      if (Ur && "string" == typeof e2)
        for (; t2--; )
          e2 = Lr(e2, Mr, "");
      return e2;
    }, Ho = function(e2, t2) {
      xr(t2) && "cause" in t2 && Vr(e2, "cause", t2.cause);
    }, Ko = Oo, Yo = function(e2, t2) {
      return void 0 === e2 ? arguments.length < 2 ? "" : t2 : Do(e2);
    }, qo = Lo, Jo = rt("toStringTag"), Xo = Mo.Error, zo = [].push, Qo = function(e2, t2) {
      var i3, n2 = arguments.length > 2 ? arguments[2] : void 0, r2 = Uo(Zo, this);
      Vo ? i3 = Vo(new Xo(), r2 ? xo(this) : Zo) : (i3 = r2 ? this : Fo(Zo), Bo(i3, Jo, "Error")), void 0 !== t2 && Bo(i3, "message", Yo(t2)), qo && Bo(i3, "stack", Wo(i3.stack, 1)), Ho(i3, n2);
      var o2 = [];
      return Ko(e2, zo, { that: o2 }), Bo(i3, "errors", o2), i3;
    };
    Vo ? Vo(Qo, Xo) : jo(Qo, Xo, { name: true });
    var Zo = Qo.prototype = Fo(Xo.prototype, { constructor: Go(1, Qo), message: Go(1, ""), name: Go(1, "AggregateError") });
    ko({ global: true }, { AggregateError: Qo });
    var $o = S, es = Me, ts = d(Function.toString);
    $o(es.inspectSource) || (es.inspectSource = function(e2) {
      return ts(e2);
    });
    var is, ns, rs, os = es.inspectSource, ss = S, as2 = os, cs = h2.WeakMap, ds = ss(cs) && /native code/.test(as2(cs)), us = h2, ls = d, hs = q, ps = ui, _s = Ge, Es = Me, ms = pn, fs = Gn, Ss = "Object already initialized", Ts = us.TypeError, gs = us.WeakMap;
    if (ds || Es.state) {
      var Rs = Es.state || (Es.state = new gs()), Is = ls(Rs.get), Cs = ls(Rs.has), vs = ls(Rs.set);
      is = function(e2, t2) {
        if (Cs(Rs, e2))
          throw new Ts(Ss);
        return t2.facade = e2, vs(Rs, e2, t2), t2;
      }, ns = function(e2) {
        return Is(Rs, e2) || {};
      }, rs = function(e2) {
        return Cs(Rs, e2);
      };
    } else {
      var ys = ms("state");
      fs[ys] = true, is = function(e2, t2) {
        if (_s(e2, ys))
          throw new Ts(Ss);
        return t2.facade = e2, ps(e2, ys, t2), t2;
      }, ns = function(e2) {
        return _s(e2, ys) ? e2[ys] : {};
      }, rs = function(e2) {
        return _s(e2, ys);
      };
    }
    var As, Os, Ns, bs = { set: is, get: ns, has: rs, enforce: function(e2) {
      return rs(e2) ? ns(e2) : is(e2, {});
    }, getterFor: function(e2) {
      return function(t2) {
        var i3;
        if (!hs(t2) || (i3 = ns(t2)).type !== e2)
          throw Ts("Incompatible receiver, " + e2 + " required");
        return i3;
      };
    } }, ws = g, Ds = Ge, Ps = Function.prototype, Ls = ws && Object.getOwnPropertyDescriptor, ks = Ds(Ps, "name"), Ms = { EXISTS: ks, PROPER: ks && "something" === function() {
    }.name, CONFIGURABLE: ks && (!ws || ws && Ls(Ps, "name").configurable) }, Us = ui, xs = function(e2, t2, i3, n2) {
      n2 && n2.enumerable ? e2[t2] = i3 : Us(e2, t2, i3);
    }, Vs = i2, js = S, Fs = Pr, Bs = Cn, Gs = xs, Ws = rt("iterator"), Hs = false;
    [].keys && ("next" in (Ns = [].keys()) ? (Os = Bs(Bs(Ns))) !== Object.prototype && (As = Os) : Hs = true);
    var Ks = null == As || Vs(function() {
      var e2 = {};
      return As[Ws].call(e2) !== e2;
    });
    js((As = Ks ? {} : Fs(As))[Ws]) || Gs(As, Ws, function() {
      return this;
    });
    var Ys = { IteratorPrototype: As, BUGGY_SAFARI_ITERATORS: Hs }, qs = Zr, Js = Hr ? {}.toString : function() {
      return "[object " + qs(this) + "]";
    }, Xs = Hr, zs = Ht.f, Qs = ui, Zs = Ge, $s = Js, ea = rt("toStringTag"), ta = function(e2, t2, i3, n2) {
      if (e2) {
        var r2 = i3 ? e2 : e2.prototype;
        Zs(r2, ea) || zs(r2, ea, { configurable: true, value: t2 }), n2 && !Xs && Qs(r2, "toString", $s);
      }
    }, ia = Ys.IteratorPrototype, na = Pr, ra = w2, oa = ta, sa = jr, aa = function() {
      return this;
    }, ca = Ii, da = C, ua = function(e2, t2, i3, n2) {
      var r2 = t2 + " Iterator";
      return e2.prototype = na(ia, { next: ra(+!n2, i3) }), oa(e2, r2, false, true), sa[r2] = aa, e2;
    }, la = Cn, ha = ta, pa = xs, _a = jr, Ea = Ms.PROPER, ma = Ys.BUGGY_SAFARI_ITERATORS, fa = rt("iterator"), Sa = "keys", Ta = "values", ga = "entries", Ra = function() {
      return this;
    }, Ia = function(e2, t2, i3, n2, r2, o2, s2) {
      ua(i3, t2, n2);
      var a2, c2, d2, u2 = function(e3) {
        if (e3 === r2 && E2)
          return E2;
        if (!ma && e3 in p3)
          return p3[e3];
        switch (e3) {
          case Sa:
          case Ta:
          case ga:
            return function() {
              return new i3(this, e3);
            };
        }
        return function() {
          return new i3(this);
        };
      }, l2 = t2 + " Iterator", h3 = false, p3 = e2.prototype, _2 = p3[fa] || p3["@@iterator"] || r2 && p3[r2], E2 = !ma && _2 || u2(r2), m2 = "Array" == t2 && p3.entries || _2;
      if (m2 && (a2 = la(m2.call(new e2()))) !== Object.prototype && a2.next && (ha(a2, l2, true, true), _a[l2] = Ra), Ea && r2 == Ta && _2 && _2.name !== Ta && (h3 = true, E2 = function() {
        return da(_2, this);
      }), r2)
        if (c2 = { values: u2(Ta), keys: o2 ? E2 : u2(Sa), entries: u2(ga) }, s2)
          for (d2 in c2)
            (ma || h3 || !(d2 in p3)) && pa(p3, d2, c2[d2]);
        else
          ca({ target: t2, proto: true, forced: ma || h3 }, c2);
      return s2 && p3[fa] !== E2 && pa(p3, fa, E2, { name: r2 }), _a[t2] = E2, c2;
    }, Ca = K, va = jr, ya = bs;
    Ht.f;
    var Aa = Ia, Oa = "Array Iterator", Na = ya.set, ba = ya.getterFor(Oa);
    Aa(Array, "Array", function(e2, t2) {
      Na(this, { type: Oa, target: Ca(e2), index: 0, kind: t2 });
    }, function() {
      var e2 = ba(this), t2 = e2.target, i3 = e2.kind, n2 = e2.index++;
      return !t2 || n2 >= t2.length ? (e2.target = void 0, { value: void 0, done: true }) : "keys" == i3 ? { value: n2, done: false } : "values" == i3 ? { value: t2[n2], done: false } : { value: [n2, t2[n2]], done: false };
    }, "values"), va.Arguments = va.Array;
    var wa = h2.Promise, Da = xs, Pa = $, La = Ht, ka = g, Ma = rt("species"), Ua = u, xa = h2.TypeError, Va = rt("iterator"), ja = false;
    try {
      var Fa = 0, Ba = { next: function() {
        return { done: !!Fa++ };
      }, return: function() {
        ja = true;
      } };
      Ba[Va] = function() {
        return this;
      }, Array.from(Ba, function() {
        throw 2;
      });
    } catch (e2) {
    }
    var Ga = d, Wa = i2, Ha = S, Ka = Zr, Ya = os, qa = function() {
    }, Ja = [], Xa = $("Reflect", "construct"), za = /^\s*(?:class|function)\b/, Qa = Ga(za.exec), Za = !za.exec(qa), $a = function(e2) {
      if (!Ha(e2))
        return false;
      try {
        return Xa(qa, Ja, e2), true;
      } catch (e3) {
        return false;
      }
    }, ec = function(e2) {
      if (!Ha(e2))
        return false;
      switch (Ka(e2)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return Za || !!Qa(za, Ya(e2));
      } catch (e3) {
        return true;
      }
    };
    ec.sham = true;
    var tc, ic, nc, rc, oc = !Xa || Wa(function() {
      var e2;
      return $a($a.call) || !$a(Object) || !$a(function() {
        e2 = true;
      }) || e2;
    }) ? ec : $a, sc = oc, ac = Te, cc = h2.TypeError, dc = zt, uc = function(e2) {
      if (sc(e2))
        return e2;
      throw cc(ac(e2) + " is not a constructor");
    }, lc = rt("species"), hc = function(e2, t2) {
      var i3, n2 = dc(e2).constructor;
      return void 0 === n2 || null == (i3 = dc(n2)[lc]) ? t2 : uc(i3);
    }, pc = d([].slice), _c = /(?:ipad|iphone|ipod).*applewebkit/i.test(ee), Ec = h2, mc = f, fc = Wt, Sc = S, Tc = Ge, gc = i2, Rc = gr, Ic = pc, Cc = Tt2, vc = _c, yc = ji, Ac = Ec.setImmediate, Oc = Ec.clearImmediate, Nc = Ec.process, bc = Ec.Dispatch, wc = Ec.Function, Dc = Ec.MessageChannel, Pc = Ec.String, Lc = 0, kc = {}, Mc = "onreadystatechange";
    try {
      tc = Ec.location;
    } catch (e2) {
    }
    var Uc = function(e2) {
      if (Tc(kc, e2)) {
        var t2 = kc[e2];
        delete kc[e2], t2();
      }
    }, xc = function(e2) {
      return function() {
        Uc(e2);
      };
    }, Vc = function(e2) {
      Uc(e2.data);
    }, jc = function(e2) {
      Ec.postMessage(Pc(e2), tc.protocol + "//" + tc.host);
    };
    Ac && Oc || (Ac = function(e2) {
      var t2 = Ic(arguments, 1);
      return kc[++Lc] = function() {
        mc(Sc(e2) ? e2 : wc(e2), void 0, t2);
      }, ic(Lc), Lc;
    }, Oc = function(e2) {
      delete kc[e2];
    }, yc ? ic = function(e2) {
      Nc.nextTick(xc(e2));
    } : bc && bc.now ? ic = function(e2) {
      bc.now(xc(e2));
    } : Dc && !vc ? (rc = (nc = new Dc()).port2, nc.port1.onmessage = Vc, ic = fc(rc.postMessage, rc)) : Ec.addEventListener && Sc(Ec.postMessage) && !Ec.importScripts && tc && "file:" !== tc.protocol && !gc(jc) ? (ic = jc, Ec.addEventListener("message", Vc, false)) : ic = Mc in Cc("script") ? function(e2) {
      Rc.appendChild(Cc("script")).onreadystatechange = function() {
        Rc.removeChild(this), Uc(e2);
      };
    } : function(e2) {
      setTimeout(xc(e2), 0);
    });
    var Fc, Bc, Gc, Wc, Hc, Kc, Yc, qc, Jc = { set: Ac, clear: Oc }, Xc = h2, zc = /ipad|iphone|ipod/i.test(ee) && void 0 !== Xc.Pebble, Qc = /web0s(?!.*chrome)/i.test(ee), Zc = h2, $c = Wt, ed = T.f, td = Jc.set, id = _c, nd = zc, rd = Qc, od = ji, sd = Zc.MutationObserver || Zc.WebKitMutationObserver, ad = Zc.document, cd = Zc.process, dd = Zc.Promise, ud = ed(Zc, "queueMicrotask"), ld = ud && ud.value;
    ld || (Fc = function() {
      var e2, t2;
      for (od && (e2 = cd.domain) && e2.exit(); Bc; ) {
        t2 = Bc.fn, Bc = Bc.next;
        try {
          t2();
        } catch (e3) {
          throw Bc ? Wc() : Gc = void 0, e3;
        }
      }
      Gc = void 0, e2 && e2.enter();
    }, id || od || rd || !sd || !ad ? !nd && dd && dd.resolve ? ((Yc = dd.resolve(void 0)).constructor = dd, qc = $c(Yc.then, Yc), Wc = function() {
      qc(Fc);
    }) : od ? Wc = function() {
      cd.nextTick(Fc);
    } : (td = $c(td, Zc), Wc = function() {
      td(Fc);
    }) : (Hc = true, Kc = ad.createTextNode(""), new sd(Fc).observe(Kc, { characterData: true }), Wc = function() {
      Kc.data = Hc = !Hc;
    }));
    var hd = ld || function(e2) {
      var t2 = { fn: e2, next: void 0 };
      Gc && (Gc.next = t2), Bc || (Bc = t2, Wc()), Gc = t2;
    }, pd = {}, _d = Ce, Ed = function(e2) {
      var t2, i3;
      this.promise = new e2(function(e3, n2) {
        if (void 0 !== t2 || void 0 !== i3)
          throw TypeError("Bad Promise constructor");
        t2 = e3, i3 = n2;
      }), this.resolve = _d(t2), this.reject = _d(i3);
    };
    pd.f = function(e2) {
      return new Ed(e2);
    };
    var md = zt, fd = q, Sd = pd, Td = function(e2, t2) {
      if (md(e2), fd(t2) && t2.constructor === e2)
        return t2;
      var i3 = Sd.f(e2);
      return (0, i3.resolve)(t2), i3.promise;
    }, gd = h2, Rd = function(e2) {
      try {
        return { error: false, value: e2() };
      } catch (e3) {
        return { error: true, value: e3 };
      }
    }, Id = function() {
      this.head = null, this.tail = null;
    };
    Id.prototype = { add: function(e2) {
      var t2 = { item: e2, next: null };
      this.head ? this.tail.next = t2 : this.head = t2, this.tail = t2;
    }, get: function() {
      var e2 = this.head;
      if (e2)
        return this.head = e2.next, this.tail === e2 && (this.tail = null), e2.item;
    } };
    var Cd, vd, yd, Ad = "object" == typeof window, Od = Ii, Nd = h2, bd = $, wd = C, Dd = wa, Pd = function(e2, t2, i3) {
      for (var n2 in t2)
        i3 && i3.unsafe && e2[n2] ? e2[n2] = t2[n2] : Da(e2, n2, t2[n2], i3);
      return e2;
    }, Ld = ta, kd = function(e2) {
      var t2 = Pa(e2), i3 = La.f;
      ka && t2 && !t2[Ma] && i3(t2, Ma, { configurable: true, get: function() {
        return this;
      } });
    }, Md = Ce, Ud = S, xd = q, Vd = function(e2, t2) {
      if (Ua(t2, e2))
        return e2;
      throw xa("Incorrect invocation");
    }, jd = os, Fd = Oo, Bd = function(e2, t2) {
      if (!t2 && !ja)
        return false;
      var i3 = false;
      try {
        var n2 = {};
        n2[Va] = function() {
          return { next: function() {
            return { done: i3 = true };
          } };
        }, e2(n2);
      } catch (e3) {
      }
      return i3;
    }, Gd = hc, Wd = Jc.set, Hd = hd, Kd = Td, Yd = function(e2, t2) {
      var i3 = gd.console;
      i3 && i3.error && (1 == arguments.length ? i3.error(e2) : i3.error(e2, t2));
    }, qd = pd, Jd = Rd, Xd = Id, zd = bs, Qd = jt, Zd = Ad, $d = ji, eu = ae, tu = rt("species"), iu = "Promise", nu = zd.getterFor(iu), ru = zd.set, ou = zd.getterFor(iu), su = Dd && Dd.prototype, au = Dd, cu = su, du = Nd.TypeError, uu = Nd.document, lu = Nd.process, hu = qd.f, pu = hu, _u = !!(uu && uu.createEvent && Nd.dispatchEvent), Eu = Ud(Nd.PromiseRejectionEvent), mu = "unhandledrejection", fu = Qd(iu, function() {
      var e2 = jd(au), t2 = e2 !== String(au);
      if (!t2 && 66 === eu)
        return true;
      if (!cu.finally)
        return true;
      if (eu >= 51 && /native code/.test(e2))
        return false;
      var i3 = new au(function(e3) {
        e3(1);
      }), n2 = function(e3) {
        e3(function() {
        }, function() {
        });
      };
      return (i3.constructor = {})[tu] = n2, !(i3.then(function() {
      }) instanceof n2) || !t2 && Zd && !Eu;
    }), Su = fu || !Bd(function(e2) {
      au.all(e2).catch(function() {
      });
    }), Tu = function(e2) {
      var t2;
      return !(!xd(e2) || !Ud(t2 = e2.then)) && t2;
    }, gu = function(e2, t2) {
      var i3, n2, r2, o2 = t2.value, s2 = 1 == t2.state, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, d2 = e2.reject, u2 = e2.domain;
      try {
        a2 ? (s2 || (2 === t2.rejection && yu(t2), t2.rejection = 1), true === a2 ? i3 = o2 : (u2 && u2.enter(), i3 = a2(o2), u2 && (u2.exit(), r2 = true)), i3 === e2.promise ? d2(du("Promise-chain cycle")) : (n2 = Tu(i3)) ? wd(n2, i3, c2, d2) : c2(i3)) : d2(o2);
      } catch (e3) {
        u2 && !r2 && u2.exit(), d2(e3);
      }
    }, Ru = function(e2, t2) {
      e2.notified || (e2.notified = true, Hd(function() {
        for (var i3, n2 = e2.reactions; i3 = n2.get(); )
          gu(i3, e2);
        e2.notified = false, t2 && !e2.rejection && Cu(e2);
      }));
    }, Iu = function(e2, t2, i3) {
      var n2, r2;
      _u ? ((n2 = uu.createEvent("Event")).promise = t2, n2.reason = i3, n2.initEvent(e2, false, true), Nd.dispatchEvent(n2)) : n2 = { promise: t2, reason: i3 }, !Eu && (r2 = Nd["on" + e2]) ? r2(n2) : e2 === mu && Yd("Unhandled promise rejection", i3);
    }, Cu = function(e2) {
      wd(Wd, Nd, function() {
        var t2, i3 = e2.facade, n2 = e2.value;
        if (vu(e2) && (t2 = Jd(function() {
          $d ? lu.emit("unhandledRejection", n2, i3) : Iu(mu, i3, n2);
        }), e2.rejection = $d || vu(e2) ? 2 : 1, t2.error))
          throw t2.value;
      });
    }, vu = function(e2) {
      return 1 !== e2.rejection && !e2.parent;
    }, yu = function(e2) {
      wd(Wd, Nd, function() {
        var t2 = e2.facade;
        $d ? lu.emit("rejectionHandled", t2) : Iu("rejectionhandled", t2, e2.value);
      });
    }, Au = function(e2, t2, i3) {
      return function(n2) {
        e2(t2, n2, i3);
      };
    }, Ou = function(e2, t2, i3) {
      e2.done || (e2.done = true, i3 && (e2 = i3), e2.value = t2, e2.state = 2, Ru(e2, true));
    }, Nu = function(e2, t2, i3) {
      if (!e2.done) {
        e2.done = true, i3 && (e2 = i3);
        try {
          if (e2.facade === t2)
            throw du("Promise can't be resolved itself");
          var n2 = Tu(t2);
          n2 ? Hd(function() {
            var i4 = { done: false };
            try {
              wd(n2, t2, Au(Nu, i4, e2), Au(Ou, i4, e2));
            } catch (t3) {
              Ou(i4, t3, e2);
            }
          }) : (e2.value = t2, e2.state = 1, Ru(e2, false));
        } catch (t3) {
          Ou({ done: false }, t3, e2);
        }
      }
    };
    fu && (cu = (au = function(e2) {
      Vd(this, cu), Md(e2), wd(Cd, this);
      var t2 = nu(this);
      try {
        e2(Au(Nu, t2), Au(Ou, t2));
      } catch (e3) {
        Ou(t2, e3);
      }
    }).prototype, (Cd = function(e2) {
      ru(this, { type: iu, done: false, notified: false, parent: false, reactions: new Xd(), rejection: false, state: 0, value: void 0 });
    }).prototype = Pd(cu, { then: function(e2, t2) {
      var i3 = ou(this), n2 = hu(Gd(this, au));
      return i3.parent = true, n2.ok = !Ud(e2) || e2, n2.fail = Ud(t2) && t2, n2.domain = $d ? lu.domain : void 0, 0 == i3.state ? i3.reactions.add(n2) : Hd(function() {
        gu(n2, i3);
      }), n2.promise;
    }, catch: function(e2) {
      return this.then(void 0, e2);
    } }), vd = function() {
      var e2 = new Cd(), t2 = nu(e2);
      this.promise = e2, this.resolve = Au(Nu, t2), this.reject = Au(Ou, t2);
    }, qd.f = hu = function(e2) {
      return e2 === au || e2 === yd ? new vd(e2) : pu(e2);
    }), Od({ global: true, wrap: true, forced: fu }, { Promise: au }), Ld(au, iu, false, true), kd(iu), yd = bd(iu), Od({ target: iu, stat: true, forced: fu }, { reject: function(e2) {
      var t2 = hu(this);
      return wd(t2.reject, void 0, e2), t2.promise;
    } }), Od({ target: iu, stat: true, forced: true }, { resolve: function(e2) {
      return Kd(this === yd ? au : this, e2);
    } }), Od({ target: iu, stat: true, forced: Su }, { all: function(e2) {
      var t2 = this, i3 = hu(t2), n2 = i3.resolve, r2 = i3.reject, o2 = Jd(function() {
        var i4 = Md(t2.resolve), o3 = [], s2 = 0, a2 = 1;
        Fd(e2, function(e3) {
          var c2 = s2++, d2 = false;
          a2++, wd(i4, t2, e3).then(function(e4) {
            d2 || (d2 = true, o3[c2] = e4, --a2 || n2(o3));
          }, r2);
        }), --a2 || n2(o3);
      });
      return o2.error && r2(o2.value), i3.promise;
    }, race: function(e2) {
      var t2 = this, i3 = hu(t2), n2 = i3.reject, r2 = Jd(function() {
        var r3 = Md(t2.resolve);
        Fd(e2, function(e3) {
          wd(r3, t2, e3).then(i3.resolve, n2);
        });
      });
      return r2.error && n2(r2.value), i3.promise;
    } });
    var bu = C, wu = Ce, Du = pd, Pu = Rd, Lu = Oo;
    Ii({ target: "Promise", stat: true }, { allSettled: function(e2) {
      var t2 = this, i3 = Du.f(t2), n2 = i3.resolve, r2 = i3.reject, o2 = Pu(function() {
        var i4 = wu(t2.resolve), r3 = [], o3 = 0, s2 = 1;
        Lu(e2, function(e3) {
          var a2 = o3++, c2 = false;
          s2++, bu(i4, t2, e3).then(function(e4) {
            c2 || (c2 = true, r3[a2] = { status: "fulfilled", value: e4 }, --s2 || n2(r3));
          }, function(e4) {
            c2 || (c2 = true, r3[a2] = { status: "rejected", reason: e4 }, --s2 || n2(r3));
          });
        }), --s2 || n2(r3);
      });
      return o2.error && r2(o2.value), i3.promise;
    } });
    var ku = Ce, Mu = $, Uu = C, xu = pd, Vu = Rd, ju = Oo, Fu = "No one promise resolved";
    Ii({ target: "Promise", stat: true }, { any: function(e2) {
      var t2 = this, i3 = Mu("AggregateError"), n2 = xu.f(t2), r2 = n2.resolve, o2 = n2.reject, s2 = Vu(function() {
        var n3 = ku(t2.resolve), s3 = [], a2 = 0, c2 = 1, d2 = false;
        ju(e2, function(e3) {
          var u2 = a2++, l2 = false;
          c2++, Uu(n3, t2, e3).then(function(e4) {
            l2 || d2 || (d2 = true, r2(e4));
          }, function(e4) {
            l2 || d2 || (l2 = true, s3[u2] = e4, --c2 || o2(new i3(s3, Fu)));
          });
        }), --c2 || o2(new i3(s3, Fu));
      });
      return s2.error && o2(s2.value), n2.promise;
    } });
    var Bu = wa, Gu = $, Wu = S, Hu = hc, Ku = Td;
    Ii({ target: "Promise", proto: true, real: true, forced: !!Bu && i2(function() {
      Bu.prototype.finally.call({ then: function() {
      } }, function() {
      });
    }) }, { finally: function(e2) {
      var t2 = Hu(this, Gu("Promise")), i3 = Wu(e2);
      return this.then(i3 ? function(i4) {
        return Ku(t2, e2()).then(function() {
          return i4;
        });
      } : e2, i3 ? function(i4) {
        return Ku(t2, e2()).then(function() {
          throw i4;
        });
      } : e2);
    } });
    var Yu = d, qu = yi, Ju = wo, Xu = G2, zu = Yu("".charAt), Qu = Yu("".charCodeAt), Zu = Yu("".slice), $u = function(e2) {
      return function(t2, i3) {
        var n2, r2, o2 = Ju(Xu(t2)), s2 = qu(i3), a2 = o2.length;
        return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (n2 = Qu(o2, s2)) < 55296 || n2 > 56319 || s2 + 1 === a2 || (r2 = Qu(o2, s2 + 1)) < 56320 || r2 > 57343 ? e2 ? zu(o2, s2) : n2 : e2 ? Zu(o2, s2, s2 + 2) : r2 - 56320 + (n2 - 55296 << 10) + 65536;
      };
    }, el = { codeAt: $u(false), charAt: $u(true) }.charAt, tl = wo, il = bs, nl = Ia, rl = "String Iterator", ol = il.set, sl = il.getterFor(rl);
    nl(String, "String", function(e2) {
      ol(this, { type: rl, string: tl(e2), index: 0 });
    }, function() {
      var e2, t2 = sl(this), i3 = t2.string, n2 = t2.index;
      return n2 >= i3.length ? { value: void 0, done: true } : (e2 = el(i3, n2), t2.index += e2.length, { value: e2, done: false });
    });
    var al = J.Promise, cl = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, dl = h2, ul = Zr, ll = ui, hl = jr, pl = rt("toStringTag");
    for (var _l in cl) {
      var El = dl[_l], ml = El && El.prototype;
      ml && ul(ml) !== pl && ll(ml, pl, _l), hl[_l] = hl.Array;
    }
    var fl = al, Sl = fl;
    const Tl = rn;
    function gl(e2, t2) {
      const i3 = e2 && e2.navigator;
      if (!i3.mediaDevices)
        return;
      const n2 = function(e3) {
        if ("object" != typeof e3 || e3.mandatory || e3.optional)
          return e3;
        const t3 = {};
        return Object.keys(e3).forEach((i4) => {
          if ("require" === i4 || "advanced" === i4 || "mediaSource" === i4)
            return;
          const n3 = "object" == typeof e3[i4] ? e3[i4] : { ideal: e3[i4] };
          void 0 !== n3.exact && "number" == typeof n3.exact && (n3.min = n3.max = n3.exact);
          const r3 = function(e4, t4) {
            return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
          };
          if (void 0 !== n3.ideal) {
            t3.optional = t3.optional || [];
            let e4 = {};
            "number" == typeof n3.ideal ? (e4[r3("min", i4)] = n3.ideal, t3.optional.push(e4), e4 = {}, e4[r3("max", i4)] = n3.ideal, t3.optional.push(e4)) : (e4[r3("", i4)] = n3.ideal, t3.optional.push(e4));
          }
          void 0 !== n3.exact && "number" != typeof n3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3("", i4)] = n3.exact) : ["min", "max"].forEach((e4) => {
            void 0 !== n3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[r3(e4, i4)] = n3[e4]);
          });
        }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
      }, r2 = function(e3, r3) {
        if (t2.version >= 61)
          return r3(e3);
        if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
          const t3 = function(e4, t4, i4) {
            t4 in e4 && !(i4 in e4) && (e4[i4] = e4[t4], delete e4[t4]);
          };
          t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = n2(e3.audio);
        }
        if (e3 && "object" == typeof e3.video) {
          let o3 = e3.video.facingMode;
          o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
          const s2 = t2.version < 66;
          if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i3.mediaDevices.getSupportedConstraints || !i3.mediaDevices.getSupportedConstraints().facingMode || s2)) {
            let t3;
            if (delete e3.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t3 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t3 = ["front"]), t3)
              return i3.mediaDevices.enumerateDevices().then((i4) => {
                let s3 = (i4 = i4.filter((e4) => "videoinput" === e4.kind)).find((e4) => t3.some((t4) => e4.label.toLowerCase().includes(t4)));
                return !s3 && i4.length && t3.includes("back") && (s3 = i4[i4.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = n2(e3.video), Tl("chrome: " + JSON.stringify(e3)), r3(e3);
              });
          }
          e3.video = n2(e3.video);
        }
        return Tl("chrome: " + JSON.stringify(e3)), r3(e3);
      }, o2 = function(e3) {
        return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
          return this.name + (this.message && ": ") + this.message;
        } };
      };
      if (i3.getUserMedia = function(e3, t3, n3) {
        r2(e3, (e4) => {
          i3.webkitGetUserMedia(e4, t3, (e5) => {
            n3 && n3(o2(e5));
          });
        });
      }.bind(i3), i3.mediaDevices.getUserMedia) {
        const e3 = i3.mediaDevices.getUserMedia.bind(i3.mediaDevices);
        i3.mediaDevices.getUserMedia = function(t3) {
          return r2(t3, (t4) => e3(t4).then((e4) => {
            if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length)
              throw e4.getTracks().forEach((e5) => {
                e5.stop();
              }), new DOMException("", "NotFoundError");
            return e4;
          }, (e4) => Sl.reject(o2(e4))));
        };
      }
    }
    function Rl(e2) {
      e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
    }
    function Il(e2) {
      if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
        Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
          return this._ontrack;
        }, set(e3) {
          this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
        }, enumerable: true, configurable: true });
        const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          return this._ontrackpoly || (this._ontrackpoly = (t3) => {
            t3.stream.addEventListener("addtrack", (i3) => {
              let n2;
              n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i3.track.id) : { track: i3.track };
              const r2 = new Event("track");
              r2.track = i3.track, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
            }), t3.stream.getTracks().forEach((i3) => {
              let n2;
              n2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i3.id) : { track: i3 };
              const r2 = new Event("track");
              r2.track = i3, r2.receiver = n2, r2.transceiver = { receiver: n2 }, r2.streams = [t3.stream], this.dispatchEvent(r2);
            });
          }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
        };
      } else
        en2(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
    }
    function Cl(e2) {
      if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
        const t2 = function(e3, t3) {
          return { track: t3, get dtmf() {
            return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
          }, _pc: e3 };
        };
        if (!e2.RTCPeerConnection.prototype.getSenders) {
          e2.RTCPeerConnection.prototype.getSenders = function() {
            return this._senders = this._senders || [], this._senders.slice();
          };
          const i4 = e2.RTCPeerConnection.prototype.addTrack;
          e2.RTCPeerConnection.prototype.addTrack = function(e3, n4) {
            let r2 = i4.apply(this, arguments);
            return r2 || (r2 = t2(this, e3), this._senders.push(r2)), r2;
          };
          const n3 = e2.RTCPeerConnection.prototype.removeTrack;
          e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
            n3.apply(this, arguments);
            const t3 = this._senders.indexOf(e3);
            -1 !== t3 && this._senders.splice(t3, 1);
          };
        }
        const i3 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._senders = this._senders || [], i3.apply(this, [e3]), e3.getTracks().forEach((e4) => {
            this._senders.push(t2(this, e4));
          });
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._senders = this._senders || [], n2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
            const t3 = this._senders.find((t4) => t4.track === e4);
            t3 && this._senders.splice(this._senders.indexOf(t3), 1);
          });
        };
      } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
          return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
        } });
      }
    }
    function vl(e2) {
      if (!e2.RTCPeerConnection)
        return;
      const t2 = e2.RTCPeerConnection.prototype.getStats;
      e2.RTCPeerConnection.prototype.getStats = function() {
        const [e3, i3, n2] = arguments;
        if (arguments.length > 0 && "function" == typeof e3)
          return t2.apply(this, arguments);
        if (0 === t2.length && (0 === arguments.length || "function" != typeof e3))
          return t2.apply(this, []);
        const r2 = function(e4) {
          const t3 = {};
          return e4.result().forEach((e5) => {
            const i4 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
            e5.names().forEach((t4) => {
              i4[t4] = e5.stat(t4);
            }), t3[i4.id] = i4;
          }), t3;
        }, o2 = function(e4) {
          return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
        };
        if (arguments.length >= 2) {
          const n3 = function(e4) {
            i3(o2(r2(e4)));
          };
          return t2.apply(this, [n3, e3]);
        }
        return new Sl((e4, i4) => {
          t2.apply(this, [function(t3) {
            e4(o2(r2(t3)));
          }, i4]);
        }).then(i3, n2);
      };
    }
    function yl(e2) {
      if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver))
        return;
      if (!("getStats" in e2.RTCRtpSender.prototype)) {
        const t3 = e2.RTCPeerConnection.prototype.getSenders;
        t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t3.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const i3 = e2.RTCPeerConnection.prototype.addTrack;
        i3 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i3.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          const e3 = this;
          return this._pc.getStats().then((t4) => dn(t4, e3.track, true));
        };
      }
      if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
        const t3 = e2.RTCPeerConnection.prototype.getReceivers;
        t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t3.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), en2(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          const e3 = this;
          return this._pc.getStats().then((t4) => dn(t4, e3.track, false));
        };
      }
      if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype))
        return;
      const t2 = e2.RTCPeerConnection.prototype.getStats;
      e2.RTCPeerConnection.prototype.getStats = function() {
        if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
          const e3 = arguments[0];
          let t3, i3, n2;
          return this.getSenders().forEach((i4) => {
            i4.track === e3 && (t3 ? n2 = true : t3 = i4);
          }), this.getReceivers().forEach((t4) => (t4.track === e3 && (i3 ? n2 = true : i3 = t4), t4.track === e3)), n2 || t3 && i3 ? Sl.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i3 ? i3.getStats() : Sl.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
        }
        return t2.apply(this, arguments);
      };
    }
    function Al(e2) {
      e2.RTCPeerConnection.prototype.getLocalStreams = function() {
        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
      };
      const t2 = e2.RTCPeerConnection.prototype.addTrack;
      e2.RTCPeerConnection.prototype.addTrack = function(e3, i4) {
        if (!i4)
          return t2.apply(this, arguments);
        this._shimmedLocalStreams = this._shimmedLocalStreams || {};
        const n3 = t2.apply(this, arguments);
        return this._shimmedLocalStreams[i4.id] ? -1 === this._shimmedLocalStreams[i4.id].indexOf(n3) && this._shimmedLocalStreams[i4.id].push(n3) : this._shimmedLocalStreams[i4.id] = [i4, n3], n3;
      };
      const i3 = e2.RTCPeerConnection.prototype.addStream;
      e2.RTCPeerConnection.prototype.addStream = function(e3) {
        this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
          if (this.getSenders().find((t4) => t4.track === e4))
            throw new DOMException("Track already exists.", "InvalidAccessError");
        });
        const t3 = this.getSenders();
        i3.apply(this, arguments);
        const n3 = this.getSenders().filter((e4) => -1 === t3.indexOf(e4));
        this._shimmedLocalStreams[e3.id] = [e3].concat(n3);
      };
      const n2 = e2.RTCPeerConnection.prototype.removeStream;
      e2.RTCPeerConnection.prototype.removeStream = function(e3) {
        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], n2.apply(this, arguments);
      };
      const r2 = e2.RTCPeerConnection.prototype.removeTrack;
      e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
        return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
          const i4 = this._shimmedLocalStreams[t3].indexOf(e3);
          -1 !== i4 && this._shimmedLocalStreams[t3].splice(i4, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
        }), r2.apply(this, arguments);
      };
    }
    function Ol(e2, t2) {
      if (!e2.RTCPeerConnection)
        return;
      if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65)
        return Al(e2);
      const i3 = e2.RTCPeerConnection.prototype.getLocalStreams;
      e2.RTCPeerConnection.prototype.getLocalStreams = function() {
        const e3 = i3.apply(this);
        return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
      };
      const n2 = e2.RTCPeerConnection.prototype.addStream;
      e2.RTCPeerConnection.prototype.addStream = function(t3) {
        if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
          if (this.getSenders().find((t4) => t4.track === e3))
            throw new DOMException("Track already exists.", "InvalidAccessError");
        }), !this._reverseStreams[t3.id]) {
          const i4 = new e2.MediaStream(t3.getTracks());
          this._streams[t3.id] = i4, this._reverseStreams[i4.id] = t3, t3 = i4;
        }
        n2.apply(this, [t3]);
      };
      const r2 = e2.RTCPeerConnection.prototype.removeStream;
      function o2(e3, t3) {
        let i4 = t3.sdp;
        return Object.keys(e3._reverseStreams || []).forEach((t4) => {
          const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
          i4 = i4.replace(new RegExp(r3.id, "g"), n3.id);
        }), new RTCSessionDescription({ type: t3.type, sdp: i4 });
      }
      function s2(e3, t3) {
        let i4 = t3.sdp;
        return Object.keys(e3._reverseStreams || []).forEach((t4) => {
          const n3 = e3._reverseStreams[t4], r3 = e3._streams[n3.id];
          i4 = i4.replace(new RegExp(n3.id, "g"), r3.id);
        }), new RTCSessionDescription({ type: t3.type, sdp: i4 });
      }
      e2.RTCPeerConnection.prototype.removeStream = function(e3) {
        this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
      }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i4) {
        if ("closed" === this.signalingState)
          throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
        const n3 = [].slice.call(arguments, 1);
        if (1 !== n3.length || !n3[0].getTracks().find((e3) => e3 === t3))
          throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
        const r3 = this.getSenders().find((e3) => e3.track === t3);
        if (r3)
          throw new DOMException("Track already exists.", "InvalidAccessError");
        this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
        const o3 = this._streams[i4.id];
        if (o3)
          o3.addTrack(t3), Sl.resolve().then(() => {
            this.dispatchEvent(new Event("negotiationneeded"));
          });
        else {
          const n4 = new e2.MediaStream([t3]);
          this._streams[i4.id] = n4, this._reverseStreams[n4.id] = i4, this.addStream(n4);
        }
        return this.getSenders().find((e3) => e3.track === t3);
      }, ["createOffer", "createAnswer"].forEach(function(t3) {
        const i4 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
          const e3 = arguments;
          return arguments.length && "function" == typeof arguments[0] ? i4.apply(this, [(t4) => {
            const i5 = o2(this, t4);
            e3[0].apply(null, [i5]);
          }, (t4) => {
            e3[1] && e3[1].apply(null, t4);
          }, arguments[2]]) : i4.apply(this, arguments).then((e4) => o2(this, e4));
        } };
        e2.RTCPeerConnection.prototype[t3] = n3[t3];
      });
      const a2 = e2.RTCPeerConnection.prototype.setLocalDescription;
      e2.RTCPeerConnection.prototype.setLocalDescription = function() {
        return arguments.length && arguments[0].type ? (arguments[0] = s2(this, arguments[0]), a2.apply(this, arguments)) : a2.apply(this, arguments);
      };
      const c2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
      Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
        const e3 = c2.get.apply(this);
        return "" === e3.type ? e3 : o2(this, e3);
      } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
        if ("closed" === this.signalingState)
          throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
        if (!e3._pc)
          throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
        if (!(e3._pc === this))
          throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
        let t3;
        this._streams = this._streams || {}, Object.keys(this._streams).forEach((i4) => {
          this._streams[i4].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[i4]);
        }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
      };
    }
    function Nl(e2, t2) {
      !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
        const i3 = e2.RTCPeerConnection.prototype[t3], n2 = { [t3]() {
          return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
        } };
        e2.RTCPeerConnection.prototype[t3] = n2[t3];
      });
    }
    function bl(e2, t2) {
      en2(e2, "negotiationneeded", (e3) => {
        const i3 = e3.target;
        if (!(t2.version < 72 || i3.getConfiguration && "plan-b" === i3.getConfiguration().sdpSemantics) || "stable" === i3.signalingState)
          return e3;
      });
    }
    var wl = Object.freeze({ __proto__: null, shimMediaStream: Rl, shimOnTrack: Il, shimGetSendersWithDtmf: Cl, shimGetStats: vl, shimSenderReceiverGetStats: yl, shimAddTrackRemoveTrackWithNative: Al, shimAddTrackRemoveTrack: Ol, shimPeerConnection: Nl, fixNegotiationNeeded: bl, shimGetUserMedia: gl, shimGetDisplayMedia: function(e2, t2) {
      e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i3) {
        return t2(i3).then((t3) => {
          const n2 = i3.video && i3.video.width, r2 = i3.video && i3.video.height, o2 = i3.video && i3.video.frameRate;
          return i3.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, n2 && (i3.video.mandatory.maxWidth = n2), r2 && (i3.video.mandatory.maxHeight = r2), e2.navigator.mediaDevices.getUserMedia(i3);
        });
      } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
    } });
    function Dl(e2, t2) {
      const i3 = e2 && e2.navigator, n2 = e2 && e2.MediaStreamTrack;
      if (i3.getUserMedia = function(e3, t3, n3) {
        on2("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i3.mediaDevices.getUserMedia(e3).then(t3, n3);
      }, !(t2.version > 55 && "autoGainControl" in i3.mediaDevices.getSupportedConstraints())) {
        const e3 = function(e4, t4, i4) {
          t4 in e4 && !(i4 in e4) && (e4[i4] = e4[t4], delete e4[t4]);
        }, t3 = i3.mediaDevices.getUserMedia.bind(i3.mediaDevices);
        if (i3.mediaDevices.getUserMedia = function(i4) {
          return "object" == typeof i4 && "object" == typeof i4.audio && (i4 = JSON.parse(JSON.stringify(i4)), e3(i4.audio, "autoGainControl", "mozAutoGainControl"), e3(i4.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i4);
        }, n2 && n2.prototype.getSettings) {
          const t4 = n2.prototype.getSettings;
          n2.prototype.getSettings = function() {
            const i4 = t4.apply(this, arguments);
            return e3(i4, "mozAutoGainControl", "autoGainControl"), e3(i4, "mozNoiseSuppression", "noiseSuppression"), i4;
          };
        }
        if (n2 && n2.prototype.applyConstraints) {
          const t4 = n2.prototype.applyConstraints;
          n2.prototype.applyConstraints = function(i4) {
            return "audio" === this.kind && "object" == typeof i4 && (i4 = JSON.parse(JSON.stringify(i4)), e3(i4, "autoGainControl", "mozAutoGainControl"), e3(i4, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i4]);
          };
        }
      }
    }
    function Pl(e2) {
      "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
        return { receiver: this.receiver };
      } });
    }
    function Ll(e2, t2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection)
        return;
      !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
        const i4 = e2.RTCPeerConnection.prototype[t3], n3 = { [t3]() {
          return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i4.apply(this, arguments);
        } };
        e2.RTCPeerConnection.prototype[t3] = n3[t3];
      });
      const i3 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n2 = e2.RTCPeerConnection.prototype.getStats;
      e2.RTCPeerConnection.prototype.getStats = function() {
        const [e3, r2, o2] = arguments;
        return n2.apply(this, [e3 || null]).then((e4) => {
          if (t2.version < 53 && !r2)
            try {
              e4.forEach((e5) => {
                e5.type = i3[e5.type] || e5.type;
              });
            } catch (t3) {
              if ("TypeError" !== t3.name)
                throw t3;
              e4.forEach((t4, n3) => {
                e4.set(n3, Object.assign({}, t4, { type: i3[t4.type] || t4.type }));
              });
            }
          return e4;
        }).then(r2, o2);
      };
    }
    function kl(e2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
        return;
      if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype)
        return;
      const t2 = e2.RTCPeerConnection.prototype.getSenders;
      t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
        const e3 = t2.apply(this, []);
        return e3.forEach((e4) => e4._pc = this), e3;
      });
      const i3 = e2.RTCPeerConnection.prototype.addTrack;
      i3 && (e2.RTCPeerConnection.prototype.addTrack = function() {
        const e3 = i3.apply(this, arguments);
        return e3._pc = this, e3;
      }), e2.RTCRtpSender.prototype.getStats = function() {
        return this.track ? this._pc.getStats(this.track) : Sl.resolve(/* @__PURE__ */ new Map());
      };
    }
    function Ml(e2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
        return;
      if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype)
        return;
      const t2 = e2.RTCPeerConnection.prototype.getReceivers;
      t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
        const e3 = t2.apply(this, []);
        return e3.forEach((e4) => e4._pc = this), e3;
      }), en2(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
        return this._pc.getStats(this.track);
      };
    }
    function Ul(e2) {
      e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
        on2("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
          t2.track && e3.getTracks().includes(t2.track) && this.removeTrack(t2);
        });
      });
    }
    function xl(e2) {
      e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
    }
    function Vl(e2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection)
        return;
      const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
      t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
        this.setParametersPromises = [];
        let e3 = arguments[1] && arguments[1].sendEncodings;
        void 0 === e3 && (e3 = []), e3 = [...e3];
        const i3 = e3.length > 0;
        i3 && e3.forEach((e4) => {
          if ("rid" in e4) {
            if (!/^[a-z0-9]{0,16}$/i.test(e4.rid))
              throw new TypeError("Invalid RID value provided.");
          }
          if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1))
            throw new RangeError("scale_resolution_down_by must be >= 1.0");
          if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0))
            throw new RangeError("max_framerate must be >= 0.0");
        });
        const n2 = t2.apply(this, arguments);
        if (i3) {
          const { sender: t3 } = n2, i4 = t3.getParameters();
          (!("encodings" in i4) || 1 === i4.encodings.length && 0 === Object.keys(i4.encodings[0]).length) && (i4.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i4).then(() => {
            delete t3.sendEncodings;
          }).catch(() => {
            delete t3.sendEncodings;
          })));
        }
        return n2;
      });
    }
    function jl(e2) {
      if ("object" != typeof e2 || !e2.RTCRtpSender)
        return;
      const t2 = e2.RTCRtpSender.prototype.getParameters;
      t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
        const e3 = t2.apply(this, arguments);
        return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
      });
    }
    function Fl(e2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection)
        return;
      const t2 = e2.RTCPeerConnection.prototype.createOffer;
      e2.RTCPeerConnection.prototype.createOffer = function() {
        return this.setParametersPromises && this.setParametersPromises.length ? Sl.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
          this.setParametersPromises = [];
        }) : t2.apply(this, arguments);
      };
    }
    function Bl(e2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection)
        return;
      const t2 = e2.RTCPeerConnection.prototype.createAnswer;
      e2.RTCPeerConnection.prototype.createAnswer = function() {
        return this.setParametersPromises && this.setParametersPromises.length ? Sl.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
          this.setParametersPromises = [];
        }) : t2.apply(this, arguments);
      };
    }
    var Gl = Object.freeze({ __proto__: null, shimOnTrack: Pl, shimPeerConnection: Ll, shimSenderGetStats: kl, shimReceiverGetStats: Ml, shimRemoveStream: Ul, shimRTCDataChannel: xl, shimAddTransceiver: Vl, shimGetParameters: jl, shimCreateOffer: Fl, shimCreateAnswer: Bl, shimGetUserMedia: Dl, shimGetDisplayMedia: function(e2, t2) {
      e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i3) {
        if (!i3 || !i3.video) {
          const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
          return e3.name = "NotFoundError", e3.code = 8, Sl.reject(e3);
        }
        return true === i3.video ? i3.video = { mediaSource: t2 } : i3.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i3);
      });
    } });
    function Wl(e2) {
      if ("object" == typeof e2 && e2.RTCPeerConnection) {
        if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._localStreams || (this._localStreams = []), this._localStreams;
        }), !("addStream" in e2.RTCPeerConnection.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.addTrack;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._localStreams || (this._localStreams = []), this._localStreams.includes(e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i3) => t2.call(this, i3, e3)), e3.getVideoTracks().forEach((i3) => t2.call(this, i3, e3));
          }, e2.RTCPeerConnection.prototype.addTrack = function(e3) {
            for (var i3 = arguments.length, n2 = new Array(i3 > 1 ? i3 - 1 : 0), r2 = 1; r2 < i3; r2++)
              n2[r2 - 1] = arguments[r2];
            return n2 && n2.forEach((e4) => {
              this._localStreams ? this._localStreams.includes(e4) || this._localStreams.push(e4) : this._localStreams = [e4];
            }), t2.apply(this, arguments);
          };
        }
        "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._localStreams || (this._localStreams = []);
          const t2 = this._localStreams.indexOf(e3);
          if (-1 === t2)
            return;
          this._localStreams.splice(t2, 1);
          const i3 = e3.getTracks();
          this.getSenders().forEach((e4) => {
            i3.includes(e4.track) && this.removeTrack(e4);
          });
        });
      }
    }
    function Hl(e2) {
      if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
        Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
          return this._onaddstream;
        }, set(e3) {
          this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
            e4.streams.forEach((e5) => {
              if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e5))
                return;
              this._remoteStreams.push(e5);
              const t3 = new Event("addstream");
              t3.stream = e5, this.dispatchEvent(t3);
            });
          });
        } });
        const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          const e3 = this;
          return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
            t3.streams.forEach((t4) => {
              if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0)
                return;
              e3._remoteStreams.push(t4);
              const i3 = new Event("addstream");
              i3.stream = t4, e3.dispatchEvent(i3);
            });
          }), t2.apply(e3, arguments);
        };
      }
    }
    function Kl(e2) {
      if ("object" != typeof e2 || !e2.RTCPeerConnection)
        return;
      const t2 = e2.RTCPeerConnection.prototype, i3 = t2.createOffer, n2 = t2.createAnswer, r2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
      t2.createOffer = function(e3, t3) {
        const n3 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = i3.apply(this, [n3]);
        return t3 ? (r3.then(e3, t3), Sl.resolve()) : r3;
      }, t2.createAnswer = function(e3, t3) {
        const i4 = arguments.length >= 2 ? arguments[2] : arguments[0], r3 = n2.apply(this, [i4]);
        return t3 ? (r3.then(e3, t3), Sl.resolve()) : r3;
      };
      let a2 = function(e3, t3, i4) {
        const n3 = r2.apply(this, [e3]);
        return i4 ? (n3.then(t3, i4), Sl.resolve()) : n3;
      };
      t2.setLocalDescription = a2, a2 = function(e3, t3, i4) {
        const n3 = o2.apply(this, [e3]);
        return i4 ? (n3.then(t3, i4), Sl.resolve()) : n3;
      }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i4) {
        const n3 = s2.apply(this, [e3]);
        return i4 ? (n3.then(t3, i4), Sl.resolve()) : n3;
      }, t2.addIceCandidate = a2;
    }
    function Yl(e2) {
      const t2 = e2 && e2.navigator;
      if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
        const e3 = t2.mediaDevices, i3 = e3.getUserMedia.bind(e3);
        t2.mediaDevices.getUserMedia = (e4) => i3(ql(e4));
      }
      !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = function(e3, i3, n2) {
        t2.mediaDevices.getUserMedia(e3).then(i3, n2);
      }.bind(t2));
    }
    function ql(e2) {
      return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: cn(e2.video) }) : e2;
    }
    function Jl(e2) {
      if (!e2.RTCPeerConnection)
        return;
      const t2 = e2.RTCPeerConnection;
      e2.RTCPeerConnection = function(e3, i3) {
        if (e3 && e3.iceServers) {
          const t3 = [];
          for (let i4 = 0; i4 < e3.iceServers.length; i4++) {
            let n2 = e3.iceServers[i4];
            !n2.hasOwnProperty("urls") && n2.hasOwnProperty("url") ? (on2("RTCIceServer.url", "RTCIceServer.urls"), n2 = JSON.parse(JSON.stringify(n2)), n2.urls = n2.url, delete n2.url, t3.push(n2)) : t3.push(e3.iceServers[i4]);
          }
          e3.iceServers = t3;
        }
        return new t2(e3, i3);
      }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
    }
    function Xl(e2) {
      "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
        return { receiver: this.receiver };
      } });
    }
    function zl(e2) {
      const t2 = e2.RTCPeerConnection.prototype.createOffer;
      e2.RTCPeerConnection.prototype.createOffer = function(e3) {
        if (e3) {
          void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
          const t3 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
          false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
          const i3 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
          false === e3.offerToReceiveVideo && i3 ? "sendrecv" === i3.direction ? i3.setDirection ? i3.setDirection("sendonly") : i3.direction = "sendonly" : "recvonly" === i3.direction && (i3.setDirection ? i3.setDirection("inactive") : i3.direction = "inactive") : true !== e3.offerToReceiveVideo || i3 || this.addTransceiver("video", { direction: "recvonly" });
        }
        return t2.apply(this, arguments);
      };
    }
    function Ql(e2) {
      "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
    }
    var Zl = Object.freeze({ __proto__: null, shimLocalStreamsAPI: Wl, shimRemoteStreamsAPI: Hl, shimCallbacksAPI: Kl, shimGetUserMedia: Yl, shimConstraints: ql, shimRTCIceServerUrls: Jl, shimTrackEventTransceiver: Xl, shimCreateOfferLegacy: zl, shimAudioContext: Ql }), $l = "	\n\v\f\r                　\u2028\u2029\uFEFF", eh = G2, th = wo, ih = d("".replace), nh = "[	\n\v\f\r                　\u2028\u2029\uFEFF]", rh = RegExp("^" + nh + nh + "*"), oh = RegExp(nh + nh + "*$"), sh = function(e2) {
      return function(t2) {
        var i3 = th(eh(t2));
        return 1 & e2 && (i3 = ih(i3, rh, "")), 2 & e2 && (i3 = ih(i3, oh, "")), i3;
      };
    }, ah = { start: sh(1), end: sh(2), trim: sh(3) }, ch = Ms.PROPER, dh = i2, uh = $l, lh = ah.trim;
    Ii({ target: "String", proto: true, forced: function(e2) {
      return dh(function() {
        return !!uh[e2]() || "​᠎" !== "​᠎"[e2]() || ch && uh[e2].name !== e2;
      });
    }("trim") }, { trim: function() {
      return lh(this);
    } });
    var hh = Hi("String").trim, ph = u, _h = hh, Eh = String.prototype, mh = function(e2) {
      var t2 = e2.trim;
      return "string" == typeof e2 || e2 === Eh || ph(Eh, e2) && t2 === Eh.trim ? _h : t2;
    }, fh = { exports: {} };
    !function(e2) {
      const t2 = { generateIdentifier: function() {
        return Math.random().toString(36).substr(2, 10);
      } };
      t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
        return mh(e3).call(e3).split("\n").map((e4) => mh(e4).call(e4));
      }, t2.splitSections = function(e3) {
        return e3.split("\nm=").map((e4, t3) => {
          var i3;
          return mh(i3 = t3 > 0 ? "m=" + e4 : e4).call(i3) + "\r\n";
        });
      }, t2.getDescription = function(e3) {
        const i3 = t2.splitSections(e3);
        return i3 && i3[0];
      }, t2.getMediaSections = function(e3) {
        const i3 = t2.splitSections(e3);
        return i3.shift(), i3;
      }, t2.matchPrefix = function(e3, i3) {
        return t2.splitLines(e3).filter((e4) => 0 === e4.indexOf(i3));
      }, t2.parseCandidate = function(e3) {
        let t3;
        t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
        const i3 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
        for (let e4 = 8; e4 < t3.length; e4 += 2)
          switch (t3[e4]) {
            case "raddr":
              i3.relatedAddress = t3[e4 + 1];
              break;
            case "rport":
              i3.relatedPort = parseInt(t3[e4 + 1], 10);
              break;
            case "tcptype":
              i3.tcpType = t3[e4 + 1];
              break;
            case "ufrag":
              i3.ufrag = t3[e4 + 1], i3.usernameFragment = t3[e4 + 1];
              break;
            default:
              void 0 === i3[t3[e4]] && (i3[t3[e4]] = t3[e4 + 1]);
          }
        return i3;
      }, t2.writeCandidate = function(e3) {
        const t3 = [];
        t3.push(e3.foundation);
        const i3 = e3.component;
        "rtp" === i3 ? t3.push(1) : "rtcp" === i3 ? t3.push(2) : t3.push(i3), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
        const n2 = e3.type;
        return t3.push("typ"), t3.push(n2), "host" !== n2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
      }, t2.parseIceOptions = function(e3) {
        return e3.substr(14).split(" ");
      }, t2.parseRtpMap = function(e3) {
        let t3 = e3.substr(9).split(" ");
        const i3 = { payloadType: parseInt(t3.shift(), 10) };
        return t3 = t3[0].split("/"), i3.name = t3[0], i3.clockRate = parseInt(t3[1], 10), i3.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i3.numChannels = i3.channels, i3;
      }, t2.writeRtpMap = function(e3) {
        let t3 = e3.payloadType;
        void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
        const i3 = e3.channels || e3.numChannels || 1;
        return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i3 ? "/" + i3 : "") + "\r\n";
      }, t2.parseExtmap = function(e3) {
        const t3 = e3.substr(9).split(" ");
        return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1] };
      }, t2.writeExtmap = function(e3) {
        return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + "\r\n";
      }, t2.parseFmtp = function(e3) {
        const t3 = {};
        let i3;
        const n2 = e3.substr(e3.indexOf(" ") + 1).split(";");
        for (let e4 = 0; e4 < n2.length; e4++) {
          var r2, o2;
          i3 = mh(r2 = n2[e4]).call(r2).split("="), t3[mh(o2 = i3[0]).call(o2)] = i3[1];
        }
        return t3;
      }, t2.writeFmtp = function(e3) {
        let t3 = "", i3 = e3.payloadType;
        if (void 0 !== e3.preferredPayloadType && (i3 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
          const n2 = [];
          Object.keys(e3.parameters).forEach((t4) => {
            void 0 !== e3.parameters[t4] ? n2.push(t4 + "=" + e3.parameters[t4]) : n2.push(t4);
          }), t3 += "a=fmtp:" + i3 + " " + n2.join(";") + "\r\n";
        }
        return t3;
      }, t2.parseRtcpFb = function(e3) {
        const t3 = e3.substr(e3.indexOf(" ") + 1).split(" ");
        return { type: t3.shift(), parameter: t3.join(" ") };
      }, t2.writeRtcpFb = function(e3) {
        let t3 = "", i3 = e3.payloadType;
        return void 0 !== e3.preferredPayloadType && (i3 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
          t3 += "a=rtcp-fb:" + i3 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
        }), t3;
      }, t2.parseSsrcMedia = function(e3) {
        const t3 = e3.indexOf(" "), i3 = { ssrc: parseInt(e3.substr(7, t3 - 7), 10) }, n2 = e3.indexOf(":", t3);
        return n2 > -1 ? (i3.attribute = e3.substr(t3 + 1, n2 - t3 - 1), i3.value = e3.substr(n2 + 1)) : i3.attribute = e3.substr(t3 + 1), i3;
      }, t2.parseSsrcGroup = function(e3) {
        const t3 = e3.substr(13).split(" ");
        return { semantics: t3.shift(), ssrcs: t3.map((e4) => parseInt(e4, 10)) };
      }, t2.getMid = function(e3) {
        const i3 = t2.matchPrefix(e3, "a=mid:")[0];
        if (i3)
          return i3.substr(6);
      }, t2.parseFingerprint = function(e3) {
        const t3 = e3.substr(14).split(" ");
        return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
      }, t2.getDtlsParameters = function(e3, i3) {
        return { role: "auto", fingerprints: t2.matchPrefix(e3 + i3, "a=fingerprint:").map(t2.parseFingerprint) };
      }, t2.writeDtlsParameters = function(e3, t3) {
        let i3 = "a=setup:" + t3 + "\r\n";
        return e3.fingerprints.forEach((e4) => {
          i3 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
        }), i3;
      }, t2.parseCryptoLine = function(e3) {
        const t3 = e3.substr(9).split(" ");
        return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
      }, t2.writeCryptoLine = function(e3) {
        return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
      }, t2.parseCryptoKeyParams = function(e3) {
        if (0 !== e3.indexOf("inline:"))
          return null;
        const t3 = e3.substr(7).split("|");
        return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
      }, t2.writeCryptoKeyParams = function(e3) {
        return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
      }, t2.getCryptoParameters = function(e3, i3) {
        return t2.matchPrefix(e3 + i3, "a=crypto:").map(t2.parseCryptoLine);
      }, t2.getIceParameters = function(e3, i3) {
        const n2 = t2.matchPrefix(e3 + i3, "a=ice-ufrag:")[0], r2 = t2.matchPrefix(e3 + i3, "a=ice-pwd:")[0];
        return n2 && r2 ? { usernameFragment: n2.substr(12), password: r2.substr(10) } : null;
      }, t2.writeIceParameters = function(e3) {
        let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
        return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
      }, t2.parseRtpParameters = function(e3) {
        const i3 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, n2 = t2.splitLines(e3)[0].split(" ");
        for (let r2 = 3; r2 < n2.length; r2++) {
          const o2 = n2[r2], s2 = t2.matchPrefix(e3, "a=rtpmap:" + o2 + " ")[0];
          if (s2) {
            const n3 = t2.parseRtpMap(s2), r3 = t2.matchPrefix(e3, "a=fmtp:" + o2 + " ");
            switch (n3.parameters = r3.length ? t2.parseFmtp(r3[0]) : {}, n3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + o2 + " ").map(t2.parseRtcpFb), i3.codecs.push(n3), n3.name.toUpperCase()) {
              case "RED":
              case "ULPFEC":
                i3.fecMechanisms.push(n3.name.toUpperCase());
            }
          }
        }
        return t2.matchPrefix(e3, "a=extmap:").forEach((e4) => {
          i3.headerExtensions.push(t2.parseExtmap(e4));
        }), i3;
      }, t2.writeRtpDescription = function(e3, i3) {
        let n2 = "";
        n2 += "m=" + e3 + " ", n2 += i3.codecs.length > 0 ? "9" : "0", n2 += " UDP/TLS/RTP/SAVPF ", n2 += i3.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", n2 += "c=IN IP4 0.0.0.0\r\n", n2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i3.codecs.forEach((e4) => {
          n2 += t2.writeRtpMap(e4), n2 += t2.writeFmtp(e4), n2 += t2.writeRtcpFb(e4);
        });
        let r2 = 0;
        return i3.codecs.forEach((e4) => {
          e4.maxptime > r2 && (r2 = e4.maxptime);
        }), r2 > 0 && (n2 += "a=maxptime:" + r2 + "\r\n"), i3.headerExtensions && i3.headerExtensions.forEach((e4) => {
          n2 += t2.writeExtmap(e4);
        }), n2;
      }, t2.parseRtpEncodingParameters = function(e3) {
        const i3 = [], n2 = t2.parseRtpParameters(e3), r2 = -1 !== n2.fecMechanisms.indexOf("RED"), o2 = -1 !== n2.fecMechanisms.indexOf("ULPFEC"), s2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a2 = s2.length > 0 && s2[0].ssrc;
        let c2;
        const d2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substr(17).split(" ").map((e5) => parseInt(e5, 10)));
        d2.length > 0 && d2[0].length > 1 && d2[0][0] === a2 && (c2 = d2[0][1]), n2.codecs.forEach((e4) => {
          if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
            let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
            a2 && c2 && (t3.rtx = { ssrc: c2 }), i3.push(t3), r2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: o2 ? "red+ulpfec" : "red" }, i3.push(t3));
          }
        }), 0 === i3.length && a2 && i3.push({ ssrc: a2 });
        let u2 = t2.matchPrefix(e3, "b=");
        return u2.length && (u2 = 0 === u2[0].indexOf("b=TIAS:") ? parseInt(u2[0].substr(7), 10) : 0 === u2[0].indexOf("b=AS:") ? 1e3 * parseInt(u2[0].substr(5), 10) * 0.95 - 16e3 : void 0, i3.forEach((e4) => {
          e4.maxBitrate = u2;
        })), i3;
      }, t2.parseRtcpParameters = function(e3) {
        const i3 = {}, n2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
        n2 && (i3.cname = n2.value, i3.ssrc = n2.ssrc);
        const r2 = t2.matchPrefix(e3, "a=rtcp-rsize");
        i3.reducedSize = r2.length > 0, i3.compound = 0 === r2.length;
        const o2 = t2.matchPrefix(e3, "a=rtcp-mux");
        return i3.mux = o2.length > 0, i3;
      }, t2.writeRtcpParameters = function(e3) {
        let t3 = "";
        return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
      }, t2.parseMsid = function(e3) {
        let i3;
        const n2 = t2.matchPrefix(e3, "a=msid:");
        if (1 === n2.length)
          return i3 = n2[0].substr(7).split(" "), { stream: i3[0], track: i3[1] };
        const r2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
        return r2.length > 0 ? (i3 = r2[0].value.split(" "), { stream: i3[0], track: i3[1] }) : void 0;
      }, t2.parseSctpDescription = function(e3) {
        const i3 = t2.parseMLine(e3), n2 = t2.matchPrefix(e3, "a=max-message-size:");
        let r2;
        n2.length > 0 && (r2 = parseInt(n2[0].substr(19), 10)), isNaN(r2) && (r2 = 65536);
        const o2 = t2.matchPrefix(e3, "a=sctp-port:");
        if (o2.length > 0)
          return { port: parseInt(o2[0].substr(12), 10), protocol: i3.fmt, maxMessageSize: r2 };
        const s2 = t2.matchPrefix(e3, "a=sctpmap:");
        if (s2.length > 0) {
          const e4 = s2[0].substr(10).split(" ");
          return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: r2 };
        }
      }, t2.writeSctpDescription = function(e3, t3) {
        let i3 = [];
        return i3 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i3.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i3.join("");
      }, t2.generateSessionId = function() {
        return Math.random().toString().substr(2, 21);
      }, t2.writeSessionBoilerplate = function(e3, i3, n2) {
        let r2;
        const o2 = void 0 !== i3 ? i3 : 2;
        r2 = e3 || t2.generateSessionId();
        return "v=0\r\no=" + (n2 || "thisisadapterortc") + " " + r2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
      }, t2.getDirection = function(e3, i3) {
        const n2 = t2.splitLines(e3);
        for (let e4 = 0; e4 < n2.length; e4++)
          switch (n2[e4]) {
            case "a=sendrecv":
            case "a=sendonly":
            case "a=recvonly":
            case "a=inactive":
              return n2[e4].substr(2);
          }
        return i3 ? t2.getDirection(i3) : "sendrecv";
      }, t2.getKind = function(e3) {
        return t2.splitLines(e3)[0].split(" ")[0].substr(2);
      }, t2.isRejected = function(e3) {
        return "0" === e3.split(" ", 2)[1];
      }, t2.parseMLine = function(e3) {
        const i3 = t2.splitLines(e3)[0].substr(2).split(" ");
        return { kind: i3[0], port: parseInt(i3[1], 10), protocol: i3[2], fmt: i3.slice(3).join(" ") };
      }, t2.parseOLine = function(e3) {
        const i3 = t2.matchPrefix(e3, "o=")[0].substr(2).split(" ");
        return { username: i3[0], sessionId: i3[1], sessionVersion: parseInt(i3[2], 10), netType: i3[3], addressType: i3[4], address: i3[5] };
      }, t2.isValidSDP = function(e3) {
        if ("string" != typeof e3 || 0 === e3.length)
          return false;
        const i3 = t2.splitLines(e3);
        for (let e4 = 0; e4 < i3.length; e4++)
          if (i3[e4].length < 2 || "=" !== i3[e4].charAt(1))
            return false;
        return true;
      }, e2.exports = t2;
    }(fh);
    var Sh = fh.exports, Th = Object.freeze(e({ __proto__: null, default: Sh }, [fh.exports]));
    function gh(e2) {
      if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)
        return;
      const t2 = e2.RTCIceCandidate;
      e2.RTCIceCandidate = function(e3) {
        if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substr(2)), e3.candidate && e3.candidate.length) {
          const i3 = new t2(e3), n2 = Sh.parseCandidate(e3.candidate), r2 = Object.assign(i3, n2);
          return r2.toJSON = function() {
            return { candidate: r2.candidate, sdpMid: r2.sdpMid, sdpMLineIndex: r2.sdpMLineIndex, usernameFragment: r2.usernameFragment };
          }, r2;
        }
        return new t2(e3);
      }, e2.RTCIceCandidate.prototype = t2.prototype, en2(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
    }
    function Rh(e2) {
      !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || en2(e2, "icecandidate", (e3) => {
        if (e3.candidate) {
          const t2 = Sh.parseCandidate(e3.candidate.candidate);
          "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
        }
        return e3;
      });
    }
    function Ih(e2, t2) {
      if (!e2.RTCPeerConnection)
        return;
      "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
        return void 0 === this._sctp ? null : this._sctp;
      } });
      const i3 = function(e3) {
        if (!e3 || !e3.sdp)
          return false;
        const t3 = Sh.splitSections(e3.sdp);
        return t3.shift(), t3.some((e4) => {
          const t4 = Sh.parseMLine(e4);
          return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
        });
      }, n2 = function(e3) {
        const t3 = e3.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
        if (null === t3 || t3.length < 2)
          return -1;
        const i4 = parseInt(t3[1], 10);
        return i4 != i4 ? -1 : i4;
      }, r2 = function(e3) {
        let i4 = 65536;
        return "firefox" === t2.browser && (i4 = t2.version < 57 ? -1 === e3 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i4;
      }, o2 = function(e3, i4) {
        let n3 = 65536;
        "firefox" === t2.browser && 57 === t2.version && (n3 = 65535);
        const r3 = Sh.matchPrefix(e3.sdp, "a=max-message-size:");
        return r3.length > 0 ? n3 = parseInt(r3[0].substr(19), 10) : "firefox" === t2.browser && -1 !== i4 && (n3 = 2147483637), n3;
      }, s2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
      e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
        if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
          const { sdpSemantics: e3 } = this.getConfiguration();
          "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
            return void 0 === this._sctp ? null : this._sctp;
          }, enumerable: true, configurable: true });
        }
        if (i3(arguments[0])) {
          const e3 = n2(arguments[0]), t3 = r2(e3), i4 = o2(arguments[0], e3);
          let s3;
          s3 = 0 === t3 && 0 === i4 ? Number.POSITIVE_INFINITY : 0 === t3 || 0 === i4 ? Math.max(t3, i4) : Math.min(t3, i4);
          const a2 = {};
          Object.defineProperty(a2, "maxMessageSize", { get: () => s3 }), this._sctp = a2;
        }
        return s2.apply(this, arguments);
      };
    }
    function Ch(e2) {
      if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype))
        return;
      function t2(e3, t3) {
        const i4 = e3.send;
        e3.send = function() {
          const n2 = arguments[0], r2 = n2.length || n2.size || n2.byteLength;
          if ("open" === e3.readyState && t3.sctp && r2 > t3.sctp.maxMessageSize)
            throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
          return i4.apply(e3, arguments);
        };
      }
      const i3 = e2.RTCPeerConnection.prototype.createDataChannel;
      e2.RTCPeerConnection.prototype.createDataChannel = function() {
        const e3 = i3.apply(this, arguments);
        return t2(e3, this), e3;
      }, en2(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
    }
    function vh(e2) {
      if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype)
        return;
      const t2 = e2.RTCPeerConnection.prototype;
      Object.defineProperty(t2, "connectionState", { get() {
        return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
      }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
        return this._onconnectionstatechange || null;
      }, set(e3) {
        this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
      }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
        const i3 = t2[e3];
        t2[e3] = function() {
          return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
            const t3 = e4.target;
            if (t3._lastConnectionState !== t3.connectionState) {
              t3._lastConnectionState = t3.connectionState;
              const i4 = new Event("connectionstatechange", e4);
              t3.dispatchEvent(i4);
            }
            return e4;
          }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i3.apply(this, arguments);
        };
      });
    }
    function yh(e2, t2) {
      if (!e2.RTCPeerConnection)
        return;
      if ("chrome" === t2.browser && t2.version >= 71)
        return;
      if ("safari" === t2.browser && t2.version >= 605)
        return;
      const i3 = e2.RTCPeerConnection.prototype.setRemoteDescription;
      e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
        if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
          const i4 = t3.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== mh(e3).call(e3)).join("\n");
          e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i4 }) : t3.sdp = i4;
        }
        return i3.apply(this, arguments);
      };
    }
    function Ah(e2, t2) {
      if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
        return;
      const i3 = e2.RTCPeerConnection.prototype.addIceCandidate;
      i3 && 0 !== i3.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
        return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Sl.resolve() : i3.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Sl.resolve());
      });
    }
    function Oh(e2, t2) {
      if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
        return;
      const i3 = e2.RTCPeerConnection.prototype.setLocalDescription;
      i3 && 0 !== i3.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
        let e3 = arguments[0] || {};
        if ("object" != typeof e3 || e3.type && e3.sdp)
          return i3.apply(this, arguments);
        if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type)
          switch (this.signalingState) {
            case "stable":
            case "have-local-offer":
            case "have-remote-pranswer":
              e3.type = "offer";
              break;
            default:
              e3.type = "answer";
          }
        if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type)
          return i3.apply(this, [e3]);
        const t3 = "offer" === e3.type ? this.createOffer : this.createAnswer;
        return t3.apply(this).then((e4) => i3.apply(this, [e4]));
      });
    }
    var Nh = Object.freeze({ __proto__: null, shimRTCIceCandidate: gh, shimRTCIceCandidateRelayProtocol: Rh, shimMaxMessageSize: Ih, shimSendThrowTypeError: Ch, shimConnectionState: vh, removeExtmapAllowMixed: yh, shimAddIceCandidateNullOrEmpty: Ah, shimParameterlessSetLocalDescription: Oh });
    let bh, wh;
    !function() {
      let { window: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true };
      const i3 = rn, n2 = sn(e2), r2 = { browserDetails: n2, commonShim: Nh, extractVersion: $i, disableLog: tn, disableWarnings: nn, sdp: Th };
      switch (n2.browser) {
        case "chrome":
          if (!wl || !Nl || !t2.shimChrome)
            return i3("Chrome shim is not included in this adapter release."), r2;
          if (null === n2.version)
            return i3("Chrome shim can not determine version, not shimming."), r2;
          i3("adapter.js shimming chrome."), r2.browserShim = wl, Ah(e2, n2), Oh(e2), gl(e2, n2), Rl(e2), Nl(e2, n2), Il(e2), Ol(e2, n2), Cl(e2), vl(e2), yl(e2), bl(e2, n2), gh(e2), Rh(e2), vh(e2), Ih(e2, n2), Ch(e2), yh(e2, n2);
          break;
        case "firefox":
          if (!Gl || !Ll || !t2.shimFirefox)
            return i3("Firefox shim is not included in this adapter release."), r2;
          i3("adapter.js shimming firefox."), r2.browserShim = Gl, Ah(e2, n2), Oh(e2), Dl(e2, n2), Ll(e2, n2), Pl(e2), Ul(e2), kl(e2), Ml(e2), xl(e2), Vl(e2), jl(e2), Fl(e2), Bl(e2), gh(e2), vh(e2), Ih(e2, n2), Ch(e2);
          break;
        case "safari":
          if (!Zl || !t2.shimSafari)
            return i3("Safari shim is not included in this adapter release."), r2;
          i3("adapter.js shimming safari."), r2.browserShim = Zl, Ah(e2, n2), Oh(e2), Jl(e2), zl(e2), Kl(e2), Wl(e2), Hl(e2), Xl(e2), Yl(e2), Ql(e2), gh(e2), Rh(e2), Ih(e2, n2), Ch(e2), yh(e2, n2);
          break;
        default:
          i3("Unsupported browser!");
      }
    }({ window: "undefined" == typeof window ? void 0 : window }), function(e2) {
      e2.WIN_10 = "Windows 10", e2.WIN_81 = "Windows 8.1", e2.WIN_8 = "Windows 8", e2.WIN_7 = "Windows 7", e2.WIN_VISTA = "Windows Vista", e2.WIN_SERVER_2003 = "Windows Server 2003", e2.WIN_XP = "Windows XP", e2.WIN_2000 = "Windows 2000", e2.ANDROID = "Android", e2.HARMONY_OS = "HarmonyOS", e2.OPEN_BSD = "Open BSD", e2.SUN_OS = "Sun OS", e2.LINUX = "Linux", e2.IOS = "iOS", e2.MAC_OS = "Mac OS", e2.QNX = "QNX", e2.UNIX = "UNIX", e2.BEOS = "BeOS", e2.OS_2 = "OS/2", e2.SEARCH_BOT = "Search Bot";
    }(bh || (bh = {})), function(e2) {
      e2.CHROME = "Chrome", e2.SAFARI = "Safari", e2.EDGE = "Edge", e2.FIREFOX = "Firefox", e2.OPERA = "OPR", e2.QQ = "QQBrowser", e2.WECHAT = "MicroMessenger";
    }(wh || (wh = {}));
    var Dh = { exports: {} };
    !function(e2, i3) {
      !function(t2, n2) {
        var r2 = "function", o2 = "undefined", s2 = "object", a2 = "string", c2 = "major", d2 = "model", u2 = "name", l2 = "type", h3 = "vendor", p3 = "version", _2 = "architecture", E2 = "console", m2 = "mobile", f2 = "tablet", S2 = "smarttv", T2 = "wearable", g2 = "embedded", R2 = "Amazon", I2 = "Apple", C2 = "ASUS", v2 = "BlackBerry", y2 = "Firefox", A2 = "Google", O2 = "Huawei", N2 = "LG", b2 = "Microsoft", w3 = "Motorola", D2 = "Opera", P2 = "Samsung", L3 = "Sharp", k3 = "Sony", M2 = "Xiaomi", U2 = "Zebra", x3 = "Facebook", V2 = "Chromium OS", j3 = "Mac OS", F3 = function(e3) {
          for (var t3 = {}, i4 = 0; i4 < e3.length; i4++)
            t3[e3[i4].toUpperCase()] = e3[i4];
          return t3;
        }, B2 = function(e3, t3) {
          return typeof e3 === a2 && -1 !== G3(t3).indexOf(G3(e3));
        }, G3 = function(e3) {
          return e3.toLowerCase();
        }, W2 = function(e3, t3) {
          if (typeof e3 === a2)
            return e3 = e3.replace(/^\s\s*/, ""), typeof t3 === o2 ? e3 : e3.substring(0, 350);
        }, H2 = function(e3, t3) {
          for (var i4, o3, a3, c3, d3, u3, l3 = 0; l3 < t3.length && !d3; ) {
            var h4 = t3[l3], p4 = t3[l3 + 1];
            for (i4 = o3 = 0; i4 < h4.length && !d3 && h4[i4]; )
              if (d3 = h4[i4++].exec(e3))
                for (a3 = 0; a3 < p4.length; a3++)
                  u3 = d3[++o3], typeof (c3 = p4[a3]) === s2 && c3.length > 0 ? 2 === c3.length ? typeof c3[1] == r2 ? this[c3[0]] = c3[1].call(this, u3) : this[c3[0]] = c3[1] : 3 === c3.length ? typeof c3[1] !== r2 || c3[1].exec && c3[1].test ? this[c3[0]] = u3 ? u3.replace(c3[1], c3[2]) : n2 : this[c3[0]] = u3 ? c3[1].call(this, u3, c3[2]) : n2 : 4 === c3.length && (this[c3[0]] = u3 ? c3[3].call(this, u3.replace(c3[1], c3[2])) : n2) : this[c3] = u3 || n2;
            l3 += 2;
          }
        }, K2 = function(e3, t3) {
          for (var i4 in t3)
            if (typeof t3[i4] === s2 && t3[i4].length > 0) {
              for (var r3 = 0; r3 < t3[i4].length; r3++)
                if (B2(t3[i4][r3], e3))
                  return "?" === i4 ? n2 : i4;
            } else if (B2(t3[i4], e3))
              return "?" === i4 ? n2 : i4;
          return e3;
        }, Y2 = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, q2 = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [p3, [u2, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [p3, [u2, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [u2, p3], [/opios[\/ ]+([\w\.]+)/i], [p3, [u2, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [p3, [u2, D2]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [u2, p3], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [p3, [u2, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [p3, [u2, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [p3, [u2, "WeChat"]], [/konqueror\/([\w\.]+)/i], [p3, [u2, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [p3, [u2, "IE"]], [/yabrowser\/([\w\.]+)/i], [p3, [u2, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[u2, /(.+)/, "$1 Secure Browser"], p3], [/\bfocus\/([\w\.]+)/i], [p3, [u2, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [p3, [u2, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [p3, [u2, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [p3, [u2, "Dolphin"]], [/coast\/([\w\.]+)/i], [p3, [u2, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [p3, [u2, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [p3, [u2, y2]], [/\bqihu|(qi?ho?o?|360)browser/i], [[u2, "360 Browser"]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[u2, /(.+)/, "$1 Browser"], p3], [/(comodo_dragon)\/([\w\.]+)/i], [[u2, /_/g, " "], p3], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [u2, p3], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [u2], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[u2, x3], p3], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [u2, p3], [/\bgsa\/([\w\.]+) .*safari\//i], [p3, [u2, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [p3, [u2, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[u2, "Chrome WebView"], p3], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [p3, [u2, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [u2, p3], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [p3, [u2, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [p3, u2], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [u2, [p3, K2, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [u2, p3], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[u2, "Netscape"], p3], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [p3, [u2, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [u2, p3], [/(cobalt)\/([\w\.]+)/i], [u2, [p3, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[_2, "amd64"]], [/(ia32(?=;))/i], [[_2, G3]], [/((?:i[346]|x)86)[;\)]/i], [[_2, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[_2, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[_2, "armhf"]], [/windows (ce|mobile); ppc;/i], [[_2, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[_2, /ower/, "", G3]], [/(sun4\w)[;\)]/i], [[_2, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[_2, G3]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [d2, [h3, P2], [l2, f2]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [d2, [h3, P2], [l2, m2]], [/\((ip(?:hone|od)[\w ]*);/i], [d2, [h3, I2], [l2, m2]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [d2, [h3, I2], [l2, f2]], [/(macintosh);/i], [d2, [h3, I2]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [d2, [h3, L3], [l2, m2]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [d2, [h3, O2], [l2, f2]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [d2, [h3, O2], [l2, m2]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[d2, /_/g, " "], [h3, M2], [l2, m2]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[d2, /_/g, " "], [h3, M2], [l2, f2]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [d2, [h3, "OPPO"], [l2, m2]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [d2, [h3, "Vivo"], [l2, m2]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [d2, [h3, "Realme"], [l2, m2]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [d2, [h3, w3], [l2, m2]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [d2, [h3, w3], [l2, f2]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [d2, [h3, N2], [l2, f2]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [d2, [h3, N2], [l2, m2]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [d2, [h3, "Lenovo"], [l2, f2]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[d2, /_/g, " "], [h3, "Nokia"], [l2, m2]], [/(pixel c)\b/i], [d2, [h3, A2], [l2, f2]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [d2, [h3, A2], [l2, m2]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [d2, [h3, k3], [l2, m2]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[d2, "Xperia Tablet"], [h3, k3], [l2, f2]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [d2, [h3, "OnePlus"], [l2, m2]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [d2, [h3, R2], [l2, f2]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[d2, /(.+)/g, "Fire Phone $1"], [h3, R2], [l2, m2]], [/(playbook);[-\w\),; ]+(rim)/i], [d2, h3, [l2, f2]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [d2, [h3, v2], [l2, m2]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [d2, [h3, C2], [l2, f2]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [d2, [h3, C2], [l2, m2]], [/(nexus 9)/i], [d2, [h3, "HTC"], [l2, f2]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [h3, [d2, /_/g, " "], [l2, m2]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [d2, [h3, "Acer"], [l2, f2]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [d2, [h3, "Meizu"], [l2, m2]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h3, d2, [l2, m2]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h3, d2, [l2, f2]], [/(surface duo)/i], [d2, [h3, b2], [l2, f2]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [d2, [h3, "Fairphone"], [l2, m2]], [/(u304aa)/i], [d2, [h3, "AT&T"], [l2, m2]], [/\bsie-(\w*)/i], [d2, [h3, "Siemens"], [l2, m2]], [/\b(rct\w+) b/i], [d2, [h3, "RCA"], [l2, f2]], [/\b(venue[\d ]{2,7}) b/i], [d2, [h3, "Dell"], [l2, f2]], [/\b(q(?:mv|ta)\w+) b/i], [d2, [h3, "Verizon"], [l2, f2]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [d2, [h3, "Barnes & Noble"], [l2, f2]], [/\b(tm\d{3}\w+) b/i], [d2, [h3, "NuVision"], [l2, f2]], [/\b(k88) b/i], [d2, [h3, "ZTE"], [l2, f2]], [/\b(nx\d{3}j) b/i], [d2, [h3, "ZTE"], [l2, m2]], [/\b(gen\d{3}) b.+49h/i], [d2, [h3, "Swiss"], [l2, m2]], [/\b(zur\d{3}) b/i], [d2, [h3, "Swiss"], [l2, f2]], [/\b((zeki)?tb.*\b) b/i], [d2, [h3, "Zeki"], [l2, f2]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h3, "Dragon Touch"], d2, [l2, f2]], [/\b(ns-?\w{0,9}) b/i], [d2, [h3, "Insignia"], [l2, f2]], [/\b((nxa|next)-?\w{0,9}) b/i], [d2, [h3, "NextBook"], [l2, f2]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h3, "Voice"], d2, [l2, m2]], [/\b(lvtel\-)?(v1[12]) b/i], [[h3, "LvTel"], d2, [l2, m2]], [/\b(ph-1) /i], [d2, [h3, "Essential"], [l2, m2]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [d2, [h3, "Envizen"], [l2, f2]], [/\b(trio[-\w\. ]+) b/i], [d2, [h3, "MachSpeed"], [l2, f2]], [/\btu_(1491) b/i], [d2, [h3, "Rotor"], [l2, f2]], [/(shield[\w ]+) b/i], [d2, [h3, "Nvidia"], [l2, f2]], [/(sprint) (\w+)/i], [h3, d2, [l2, m2]], [/(kin\.[onetw]{3})/i], [[d2, /\./g, " "], [h3, b2], [l2, m2]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [d2, [h3, U2], [l2, f2]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [d2, [h3, U2], [l2, m2]], [/smart-tv.+(samsung)/i], [h3, [l2, S2]], [/hbbtv.+maple;(\d+)/i], [[d2, /^/, "SmartTV"], [h3, P2], [l2, S2]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h3, N2], [l2, S2]], [/(apple) ?tv/i], [h3, [d2, "Apple TV"], [l2, S2]], [/crkey/i], [[d2, "Chromecast"], [h3, A2], [l2, S2]], [/droid.+aft(\w)( bui|\))/i], [d2, [h3, R2], [l2, S2]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [d2, [h3, L3], [l2, S2]], [/(bravia[\w ]+)( bui|\))/i], [d2, [h3, k3], [l2, S2]], [/(mitv-\w{5}) bui/i], [d2, [h3, M2], [l2, S2]], [/Hbbtv.*(technisat) (.*);/i], [h3, d2, [l2, S2]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[h3, W2], [d2, W2], [l2, S2]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[l2, S2]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h3, d2, [l2, E2]], [/droid.+; (shield) bui/i], [d2, [h3, "Nvidia"], [l2, E2]], [/(playstation [345portablevi]+)/i], [d2, [h3, k3], [l2, E2]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [d2, [h3, b2], [l2, E2]], [/((pebble))app/i], [h3, d2, [l2, T2]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [d2, [h3, I2], [l2, T2]], [/droid.+; (glass) \d/i], [d2, [h3, A2], [l2, T2]], [/droid.+; (wt63?0{2,3})\)/i], [d2, [h3, U2], [l2, T2]], [/(quest( 2| pro)?)/i], [d2, [h3, x3], [l2, T2]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h3, [l2, g2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [d2, [l2, m2]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [d2, [l2, f2]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[l2, f2]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[l2, m2]], [/(android[-\w\. ]{0,9});.+buil/i], [d2, [h3, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [p3, [u2, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [p3, [u2, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [u2, p3], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [p3, u2]], os: [[/microsoft (windows) (vista|xp)/i], [u2, p3], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [u2, [p3, K2, Y2]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[u2, "Windows"], [p3, K2, Y2]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[p3, /_/g, "."], [u2, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[u2, j3], [p3, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [p3, u2], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [u2, p3], [/\(bb(10);/i], [p3, [u2, v2]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [p3, [u2, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [p3, [u2, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [p3, [u2, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [p3, [u2, "watchOS"]], [/crkey\/([\d\.]+)/i], [p3, [u2, "Chromecast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[u2, V2], p3], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [u2, p3], [/(sunos) ?([\w\.\d]*)/i], [[u2, "Solaris"], p3], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [u2, p3]] }, J2 = function(e3, i4) {
          if (typeof e3 === s2 && (i4 = e3, e3 = n2), !(this instanceof J2))
            return new J2(e3, i4).getResult();
          var c3 = typeof t2 !== o2 && t2.navigator ? t2.navigator : n2, d3 = e3 || (c3 && c3.userAgent ? c3.userAgent : ""), u3 = c3 && c3.userAgentData ? c3.userAgentData : n2, l3 = i4 ? function(e4, t3) {
            var i5 = {};
            for (var n3 in e4)
              t3[n3] && t3[n3].length % 2 == 0 ? i5[n3] = t3[n3].concat(e4[n3]) : i5[n3] = e4[n3];
            return i5;
          }(q2, i4) : q2;
          return this.getBrowser = function() {
            var e4 = {};
            return e4.name = n2, e4.version = n2, H2.call(e4, d3, l3.browser), e4.major = function(e5) {
              return typeof e5 === a2 ? e5.replace(/[^\d\.]/g, "").split(".")[0] : n2;
            }(e4.version), c3 && c3.brave && typeof c3.brave.isBrave == r2 && (e4.name = "Brave"), e4;
          }, this.getCPU = function() {
            var e4 = {};
            return e4.architecture = n2, H2.call(e4, d3, l3.cpu), e4;
          }, this.getDevice = function() {
            var e4 = {};
            return e4.vendor = n2, e4.model = n2, e4.type = n2, H2.call(e4, d3, l3.device), !e4.type && u3 && u3.mobile && (e4.type = m2), "Macintosh" == e4.model && c3 && typeof c3.standalone !== o2 && c3.maxTouchPoints && c3.maxTouchPoints > 2 && (e4.model = "iPad", e4.type = f2), e4;
          }, this.getEngine = function() {
            var e4 = {};
            return e4.name = n2, e4.version = n2, H2.call(e4, d3, l3.engine), e4;
          }, this.getOS = function() {
            var e4 = {};
            return e4.name = n2, e4.version = n2, H2.call(e4, d3, l3.os), !e4.name && u3 && "Unknown" != u3.platform && (e4.name = u3.platform.replace(/chrome os/i, V2).replace(/macos/i, j3)), e4;
          }, this.getResult = function() {
            return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
          }, this.getUA = function() {
            return d3;
          }, this.setUA = function(e4) {
            return d3 = typeof e4 === a2 && e4.length > 350 ? W2(e4, 350) : e4, this;
          }, this.setUA(d3), this;
        };
        J2.VERSION = "0.7.34", J2.BROWSER = F3([u2, p3, c2]), J2.CPU = F3([_2]), J2.DEVICE = F3([d2, h3, l2, E2, m2, S2, f2, T2, g2]), J2.ENGINE = J2.OS = F3([u2, p3]), e2.exports && (i3 = e2.exports = J2), i3.UAParser = J2;
        var X2 = typeof t2 !== o2 && (t2.jQuery || t2.Zepto);
        if (X2 && !X2.ua) {
          var z2 = new J2();
          X2.ua = z2.getResult(), X2.ua.get = function() {
            return z2.getUA();
          }, X2.ua.set = function(e3) {
            z2.setUA(e3);
            var t3 = z2.getResult();
            for (var i4 in t3)
              X2.ua[i4] = t3[i4];
          };
        }
      }("object" == typeof window ? window : t);
    }(Dh, Dh.exports);
    const Ph = new Dh.exports();
    let Lh, kh, Mh = Ph.getResult(), Uh = null;
    function xh(e2) {
      if (!Uh) {
        e2 && Ph.setUA(e2), Mh = Ph.getResult();
        const t2 = function(e3) {
          if ("Blink" === e3.engine.name && "WeChat" !== e3.browser.name)
            return wh.CHROME;
          switch (e3.browser.name) {
            case "Chrome Headless":
            case "Chrome":
            case "Chromium":
              return wh.CHROME;
            case "Safari":
            case "Mobile Safari":
              return wh.SAFARI;
            case "Edge":
              return wh.EDGE;
            case "Firefox":
              return wh.FIREFOX;
            case "QQBrowser":
              return wh.QQ;
            case "Opera":
              return wh.OPERA;
            case "WeChat":
              return wh.WECHAT;
            default:
              return e3.browser.name || "";
          }
        }(Mh), i3 = function(e3) {
          let t3;
          t3 = "Blink" === e3.engine.name ? e3.engine.version || "" : e3.browser.version || "";
          return t3.split(".")[0];
        }(Mh), n2 = function(e3) {
          switch (e3.os.name) {
            case "Windows":
              return e3.os.version ? e3.os.name + " " + e3.os.version : e3.os.name;
            default:
              return e3.os.name || "";
          }
        }(Mh), r2 = Mh.os.version;
        if (!(t2 && i3 && n2 && r2))
          return { name: t2, version: i3, os: n2, osVersion: r2 };
        Uh = { name: t2, version: i3, os: n2, osVersion: r2 };
      }
      return Uh;
    }
    function Vh() {
      return xh().os;
    }
    function jh() {
      const e2 = xh();
      return "".concat(e2.os, " ").concat(e2.osVersion);
    }
    function Fh() {
      const e2 = xh();
      return !!("WebKit" === Mh.engine.name && e2.os === bh.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e2.name !== wh.SAFARI || Yh() && e2.name !== wh.SAFARI);
    }
    function Bh() {
      const e2 = xh();
      if (Fh()) {
        if (e2.os === bh.MAC_OS)
          return true;
        if (e2.os === bh.IOS) {
          const e3 = Mh.os.version && Mh.os.version.split(".");
          if (e3 && 14 === Number(e3[0]) && e3[1] && Number(e3[1]) >= 3)
            return true;
          if (e3 && Number(e3[0]) > 14)
            return true;
        }
      }
      return false;
    }
    function Gh() {
      return "WebKit" === Mh.engine.name;
    }
    function Wh() {
      return xh().name === wh.CHROME;
    }
    function Hh() {
      return xh().name === wh.SAFARI;
    }
    function Kh() {
      return xh().name === wh.FIREFOX;
    }
    function Yh() {
      return xh().os === bh.IOS;
    }
    function qh(e2) {
      const t2 = xh();
      return !(t2.name !== wh.CHROME || !t2.osVersion) && Number(t2.version) >= e2;
    }
    function Jh(e2) {
      const t2 = xh();
      return !(t2.name !== wh.EDGE || !t2.osVersion) && Number(t2.version) >= e2;
    }
    function Xh(e2) {
      const t2 = xh();
      return !(t2.name !== wh.OPERA || !t2.osVersion) && Number(t2.version) >= e2;
    }
    function zh() {
      const e2 = xh();
      return !(e2.name !== wh.CHROME || !e2.osVersion) && Number(e2.version) <= 90;
    }
    function Qh() {
      const e2 = xh();
      if (e2.os !== bh.IOS || !e2.osVersion)
        return false;
      const t2 = e2.osVersion.split(".");
      return Number(t2[0]) < 14 || 14 === Number(t2[0]) && Number(t2[1]) <= 6;
    }
    function Zh() {
      const e2 = xh();
      if (e2.os !== bh.IOS || !e2.osVersion)
        return false;
      const t2 = e2.osVersion.split(".");
      return 15 === Number(t2[0]);
    }
    function $h() {
      const e2 = xh();
      if (e2.os !== bh.IOS || !e2.osVersion)
        return false;
      const t2 = e2.osVersion.split(".");
      return 16 === Number(t2[0]);
    }
    function ep() {
      const e2 = xh();
      if (e2.os !== bh.IOS || !e2.osVersion)
        return false;
      const t2 = e2.osVersion.split(".");
      return 15 === Number(t2[0]) && Number(t2[1]) >= 1;
    }
    function tp() {
      return Hh() && navigator.maxTouchPoints > 0;
    }
    function ip() {
      return xh().name === wh.WECHAT;
    }
    function np() {
      return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
    }
    function rp() {
      const e2 = xh();
      if (e2.name === wh.EDGE || e2.name === wh.SAFARI)
        return false;
      return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
    }
    function op() {
      return Vh() === bh.ANDROID;
    }
    function sp() {
      const e2 = xh();
      return op() && (e2.name === wh.CHROME || e2.name === wh.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
    }
    !function(e2) {
      e2.L1T1 = "L1T1", e2.L1T2 = "L1T2", e2.L1T3 = "L1T3", e2.L2T1_KEY = "L2T1_KEY", e2.L2T2_KEY = "L2T2_KEY", e2.L2T3_KEY = "L2T3_KEY", e2.L3T1_KEY = "L3T1_KEY", e2.L3T2_KEY = "L3T2_KEY", e2.L3T3_KEY = "L3T3_KEY";
    }(Lh || (Lh = {})), function(e2) {
      e2.CERTIFICATE = "certificate", e2.CODEC = "codec", e2.CANDIDATE_PAIR = "candidate-pair", e2.LOCAL_CANDIDATE = "local-candidate", e2.REMOTE_CANDIDATE = "remote-candidate", e2.INBOUND = "inbound-rtp", e2.TRACK = "track", e2.OUTBOUND = "outbound-rtp", e2.PC = "peer-connection", e2.REMOTE_INBOUND = "remote-inbound-rtp", e2.REMOTE_OUTBOUND = "remote-outbound-rtp", e2.TRANSPORT = "transport", e2.CSRC = "csrc", e2.DATA_CHANNEL = "data-channel", e2.STREAM = "stream", e2.SENDER = "sender", e2.RECEIVER = "receiver";
    }(kh || (kh = {}));
    var ap = { exports: {} }, cp = Ii, dp = g, up = Ht.f;
    cp({ target: "Object", stat: true, forced: Object.defineProperty !== up, sham: !dp }, { defineProperty: up });
    var lp = J.Object, hp = ap.exports = function(e2, t2, i3) {
      return lp.defineProperty(e2, t2, i3);
    };
    lp.defineProperty.sham && (hp.sham = true);
    var pp = ap.exports;
    function _p(e2, t2, i3) {
      return t2 in e2 ? pp(e2, t2, { value: i3, enumerable: true, configurable: true, writable: true }) : e2[t2] = i3, e2;
    }
    var Ep, mp = { exports: {} }, fp = function(e2, t2) {
      return function() {
        for (var i3 = new Array(arguments.length), n2 = 0; n2 < i3.length; n2++)
          i3[n2] = arguments[n2];
        return e2.apply(t2, i3);
      };
    }, Sp = fp, Tp = Object.prototype.toString, gp = (Ep = /* @__PURE__ */ Object.create(null), function(e2) {
      var t2 = Tp.call(e2);
      return Ep[t2] || (Ep[t2] = t2.slice(8, -1).toLowerCase());
    });
    function Rp(e2) {
      return e2 = e2.toLowerCase(), function(t2) {
        return gp(t2) === e2;
      };
    }
    function Ip(e2) {
      return Array.isArray(e2);
    }
    function Cp(e2) {
      return void 0 === e2;
    }
    var vp = Rp("ArrayBuffer");
    function yp(e2) {
      return null !== e2 && "object" == typeof e2;
    }
    function Ap(e2) {
      if ("object" !== gp(e2))
        return false;
      var t2 = Object.getPrototypeOf(e2);
      return null === t2 || t2 === Object.prototype;
    }
    var Op = Rp("Date"), Np = Rp("File"), bp = Rp("Blob"), wp = Rp("FileList");
    function Dp(e2) {
      return "[object Function]" === Tp.call(e2);
    }
    var Pp = Rp("URLSearchParams");
    function Lp(e2, t2) {
      if (null != e2)
        if ("object" != typeof e2 && (e2 = [e2]), Ip(e2))
          for (var i3 = 0, n2 = e2.length; i3 < n2; i3++)
            t2.call(null, e2[i3], i3, e2);
        else
          for (var r2 in e2)
            Object.prototype.hasOwnProperty.call(e2, r2) && t2.call(null, e2[r2], r2, e2);
    }
    var kp, Mp = (kp = "undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function(e2) {
      return kp && e2 instanceof kp;
    }), Up = { isArray: Ip, isArrayBuffer: vp, isBuffer: function(e2) {
      return null !== e2 && !Cp(e2) && null !== e2.constructor && !Cp(e2.constructor) && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
    }, isFormData: function(e2) {
      var t2 = "[object FormData]";
      return e2 && ("function" == typeof FormData && e2 instanceof FormData || Tp.call(e2) === t2 || Dp(e2.toString) && e2.toString() === t2);
    }, isArrayBufferView: function(e2) {
      return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e2) : e2 && e2.buffer && vp(e2.buffer);
    }, isString: function(e2) {
      return "string" == typeof e2;
    }, isNumber: function(e2) {
      return "number" == typeof e2;
    }, isObject: yp, isPlainObject: Ap, isUndefined: Cp, isDate: Op, isFile: Np, isBlob: bp, isFunction: Dp, isStream: function(e2) {
      return yp(e2) && Dp(e2.pipe);
    }, isURLSearchParams: Pp, isStandardBrowserEnv: function() {
      return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document);
    }, forEach: Lp, merge: function e2() {
      var t2 = {};
      function i3(i4, n3) {
        Ap(t2[n3]) && Ap(i4) ? t2[n3] = e2(t2[n3], i4) : Ap(i4) ? t2[n3] = e2({}, i4) : Ip(i4) ? t2[n3] = i4.slice() : t2[n3] = i4;
      }
      for (var n2 = 0, r2 = arguments.length; n2 < r2; n2++)
        Lp(arguments[n2], i3);
      return t2;
    }, extend: function(e2, t2, i3) {
      return Lp(t2, function(t3, n2) {
        e2[n2] = i3 && "function" == typeof t3 ? Sp(t3, i3) : t3;
      }), e2;
    }, trim: function(e2) {
      return e2.trim ? e2.trim() : e2.replace(/^\s+|\s+$/g, "");
    }, stripBOM: function(e2) {
      return 65279 === e2.charCodeAt(0) && (e2 = e2.slice(1)), e2;
    }, inherits: function(e2, t2, i3, n2) {
      e2.prototype = Object.create(t2.prototype, n2), e2.prototype.constructor = e2, i3 && Object.assign(e2.prototype, i3);
    }, toFlatObject: function(e2, t2, i3) {
      var n2, r2, o2, s2 = {};
      t2 = t2 || {};
      do {
        for (r2 = (n2 = Object.getOwnPropertyNames(e2)).length; r2-- > 0; )
          s2[o2 = n2[r2]] || (t2[o2] = e2[o2], s2[o2] = true);
        e2 = Object.getPrototypeOf(e2);
      } while (e2 && (!i3 || i3(e2, t2)) && e2 !== Object.prototype);
      return t2;
    }, kindOf: gp, kindOfTest: Rp, endsWith: function(e2, t2, i3) {
      e2 = String(e2), (void 0 === i3 || i3 > e2.length) && (i3 = e2.length), i3 -= t2.length;
      var n2 = e2.indexOf(t2, i3);
      return -1 !== n2 && n2 === i3;
    }, toArray: function(e2) {
      if (!e2)
        return null;
      var t2 = e2.length;
      if (Cp(t2))
        return null;
      for (var i3 = new Array(t2); t2-- > 0; )
        i3[t2] = e2[t2];
      return i3;
    }, isTypedArray: Mp, isFileList: wp }, xp = Up;
    function Vp(e2) {
      return encodeURIComponent(e2).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    var jp = function(e2, t2, i3) {
      if (!t2)
        return e2;
      var n2;
      if (i3)
        n2 = i3(t2);
      else if (xp.isURLSearchParams(t2))
        n2 = t2.toString();
      else {
        var r2 = [];
        xp.forEach(t2, function(e3, t3) {
          null != e3 && (xp.isArray(e3) ? t3 += "[]" : e3 = [e3], xp.forEach(e3, function(e4) {
            xp.isDate(e4) ? e4 = e4.toISOString() : xp.isObject(e4) && (e4 = JSON.stringify(e4)), r2.push(Vp(t3) + "=" + Vp(e4));
          }));
        }), n2 = r2.join("&");
      }
      if (n2) {
        var o2 = e2.indexOf("#");
        -1 !== o2 && (e2 = e2.slice(0, o2)), e2 += (-1 === e2.indexOf("?") ? "?" : "&") + n2;
      }
      return e2;
    }, Fp = Up;
    function Bp() {
      this.handlers = [];
    }
    Bp.prototype.use = function(e2, t2, i3) {
      return this.handlers.push({ fulfilled: e2, rejected: t2, synchronous: !!i3 && i3.synchronous, runWhen: i3 ? i3.runWhen : null }), this.handlers.length - 1;
    }, Bp.prototype.eject = function(e2) {
      this.handlers[e2] && (this.handlers[e2] = null);
    }, Bp.prototype.forEach = function(e2) {
      Fp.forEach(this.handlers, function(t2) {
        null !== t2 && e2(t2);
      });
    };
    var Gp = Bp, Wp = Up, Hp = Up;
    function Kp(e2, t2, i3, n2, r2) {
      Error.call(this), this.message = e2, this.name = "AxiosError", t2 && (this.code = t2), i3 && (this.config = i3), n2 && (this.request = n2), r2 && (this.response = r2);
    }
    Hp.inherits(Kp, Error, { toJSON: function() {
      return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: this.config, code: this.code, status: this.response && this.response.status ? this.response.status : null };
    } });
    var Yp = Kp.prototype, qp = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function(e2) {
      qp[e2] = { value: e2 };
    }), Object.defineProperties(Kp, qp), Object.defineProperty(Yp, "isAxiosError", { value: true }), Kp.from = function(e2, t2, i3, n2, r2, o2) {
      var s2 = Object.create(Yp);
      return Hp.toFlatObject(e2, s2, function(e3) {
        return e3 !== Error.prototype;
      }), Kp.call(s2, e2.message, t2, i3, n2, r2), s2.name = e2.name, o2 && Object.assign(s2, o2), s2;
    };
    var Jp = Kp, Xp = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, zp = Up;
    var Qp = function(e2, t2) {
      t2 = t2 || new FormData();
      var i3 = [];
      function n2(e3) {
        return null === e3 ? "" : zp.isDate(e3) ? e3.toISOString() : zp.isArrayBuffer(e3) || zp.isTypedArray(e3) ? "function" == typeof Blob ? new Blob([e3]) : Buffer.from(e3) : e3;
      }
      return function e3(r2, o2) {
        if (zp.isPlainObject(r2) || zp.isArray(r2)) {
          if (-1 !== i3.indexOf(r2))
            throw Error("Circular reference detected in " + o2);
          i3.push(r2), zp.forEach(r2, function(i4, r3) {
            if (!zp.isUndefined(i4)) {
              var s2, a2 = o2 ? o2 + "." + r3 : r3;
              if (i4 && !o2 && "object" == typeof i4) {
                if (zp.endsWith(r3, "{}"))
                  i4 = JSON.stringify(i4);
                else if (zp.endsWith(r3, "[]") && (s2 = zp.toArray(i4)))
                  return void s2.forEach(function(e4) {
                    !zp.isUndefined(e4) && t2.append(a2, n2(e4));
                  });
              }
              e3(i4, a2);
            }
          }), i3.pop();
        } else
          t2.append(o2, n2(r2));
      }(e2), t2;
    }, Zp = Jp, $p = Up, e_ = $p.isStandardBrowserEnv() ? { write: function(e2, t2, i3, n2, r2, o2) {
      var s2 = [];
      s2.push(e2 + "=" + encodeURIComponent(t2)), $p.isNumber(i3) && s2.push("expires=" + new Date(i3).toGMTString()), $p.isString(n2) && s2.push("path=" + n2), $p.isString(r2) && s2.push("domain=" + r2), true === o2 && s2.push("secure"), document.cookie = s2.join("; ");
    }, read: function(e2) {
      var t2 = document.cookie.match(new RegExp("(^|;\\s*)(" + e2 + ")=([^;]*)"));
      return t2 ? decodeURIComponent(t2[3]) : null;
    }, remove: function(e2) {
      this.write(e2, "", Date.now() - 864e5);
    } } : { write: function() {
    }, read: function() {
      return null;
    }, remove: function() {
    } }, t_ = function(e2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e2);
    }, i_ = function(e2, t2) {
      return t2 ? e2.replace(/\/+$/, "") + "/" + t2.replace(/^\/+/, "") : e2;
    }, n_ = function(e2, t2) {
      return e2 && !t_(t2) ? i_(e2, t2) : t2;
    }, r_ = Up, o_ = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"], s_ = Up, a_ = s_.isStandardBrowserEnv() ? function() {
      var e2, t2 = /(msie|trident)/i.test(navigator.userAgent), i3 = document.createElement("a");
      function n2(e3) {
        var n3 = e3;
        return t2 && (i3.setAttribute("href", n3), n3 = i3.href), i3.setAttribute("href", n3), { href: i3.href, protocol: i3.protocol ? i3.protocol.replace(/:$/, "") : "", host: i3.host, search: i3.search ? i3.search.replace(/^\?/, "") : "", hash: i3.hash ? i3.hash.replace(/^#/, "") : "", hostname: i3.hostname, port: i3.port, pathname: "/" === i3.pathname.charAt(0) ? i3.pathname : "/" + i3.pathname };
      }
      return e2 = n2(window.location.href), function(t3) {
        var i4 = s_.isString(t3) ? n2(t3) : t3;
        return i4.protocol === e2.protocol && i4.host === e2.host;
      };
    }() : function() {
      return true;
    }, c_ = Jp;
    function d_(e2) {
      c_.call(this, null == e2 ? "canceled" : e2, c_.ERR_CANCELED), this.name = "CanceledError";
    }
    Up.inherits(d_, c_, { __CANCEL__: true });
    var u_ = d_, l_ = Up, h_ = function(e2, t2, i3) {
      var n2 = i3.config.validateStatus;
      i3.status && n2 && !n2(i3.status) ? t2(new Zp("Request failed with status code " + i3.status, [Zp.ERR_BAD_REQUEST, Zp.ERR_BAD_RESPONSE][Math.floor(i3.status / 100) - 4], i3.config, i3.request, i3)) : e2(i3);
    }, p_ = e_, __ = jp, E_ = n_, m_ = function(e2) {
      var t2, i3, n2, r2 = {};
      return e2 ? (r_.forEach(e2.split("\n"), function(e3) {
        if (n2 = e3.indexOf(":"), t2 = r_.trim(e3.substr(0, n2)).toLowerCase(), i3 = r_.trim(e3.substr(n2 + 1)), t2) {
          if (r2[t2] && o_.indexOf(t2) >= 0)
            return;
          r2[t2] = "set-cookie" === t2 ? (r2[t2] ? r2[t2] : []).concat([i3]) : r2[t2] ? r2[t2] + ", " + i3 : i3;
        }
      }), r2) : r2;
    }, f_ = a_, S_ = Xp, T_ = Jp, g_ = u_, R_ = function(e2) {
      var t2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e2);
      return t2 && t2[1] || "";
    }, I_ = function(e2) {
      return new Promise(function(t2, i3) {
        var n2, r2 = e2.data, o2 = e2.headers, s2 = e2.responseType;
        function a2() {
          e2.cancelToken && e2.cancelToken.unsubscribe(n2), e2.signal && e2.signal.removeEventListener("abort", n2);
        }
        l_.isFormData(r2) && l_.isStandardBrowserEnv() && delete o2["Content-Type"];
        var c2 = new XMLHttpRequest();
        if (e2.auth) {
          var d2 = e2.auth.username || "", u2 = e2.auth.password ? unescape(encodeURIComponent(e2.auth.password)) : "";
          o2.Authorization = "Basic " + btoa(d2 + ":" + u2);
        }
        var l2 = E_(e2.baseURL, e2.url);
        function h3() {
          if (c2) {
            var n3 = "getAllResponseHeaders" in c2 ? m_(c2.getAllResponseHeaders()) : null, r3 = { data: s2 && "text" !== s2 && "json" !== s2 ? c2.response : c2.responseText, status: c2.status, statusText: c2.statusText, headers: n3, config: e2, request: c2 };
            h_(function(e3) {
              t2(e3), a2();
            }, function(e3) {
              i3(e3), a2();
            }, r3), c2 = null;
          }
        }
        if (c2.open(e2.method.toUpperCase(), __(l2, e2.params, e2.paramsSerializer), true), c2.timeout = e2.timeout, "onloadend" in c2 ? c2.onloadend = h3 : c2.onreadystatechange = function() {
          c2 && 4 === c2.readyState && (0 !== c2.status || c2.responseURL && 0 === c2.responseURL.indexOf("file:")) && setTimeout(h3);
        }, c2.onabort = function() {
          c2 && (i3(new T_("Request aborted", T_.ECONNABORTED, e2, c2)), c2 = null);
        }, c2.onerror = function() {
          i3(new T_("Network Error", T_.ERR_NETWORK, e2, c2, c2)), c2 = null;
        }, c2.ontimeout = function() {
          var t3 = e2.timeout ? "timeout of " + e2.timeout + "ms exceeded" : "timeout exceeded", n3 = e2.transitional || S_;
          e2.timeoutErrorMessage && (t3 = e2.timeoutErrorMessage), i3(new T_(t3, n3.clarifyTimeoutError ? T_.ETIMEDOUT : T_.ECONNABORTED, e2, c2)), c2 = null;
        }, l_.isStandardBrowserEnv()) {
          var p3 = (e2.withCredentials || f_(l2)) && e2.xsrfCookieName ? p_.read(e2.xsrfCookieName) : void 0;
          p3 && (o2[e2.xsrfHeaderName] = p3);
        }
        "setRequestHeader" in c2 && l_.forEach(o2, function(e3, t3) {
          void 0 === r2 && "content-type" === t3.toLowerCase() ? delete o2[t3] : c2.setRequestHeader(t3, e3);
        }), l_.isUndefined(e2.withCredentials) || (c2.withCredentials = !!e2.withCredentials), s2 && "json" !== s2 && (c2.responseType = e2.responseType), "function" == typeof e2.onDownloadProgress && c2.addEventListener("progress", e2.onDownloadProgress), "function" == typeof e2.onUploadProgress && c2.upload && c2.upload.addEventListener("progress", e2.onUploadProgress), (e2.cancelToken || e2.signal) && (n2 = function(e3) {
          c2 && (i3(!e3 || e3 && e3.type ? new g_() : e3), c2.abort(), c2 = null);
        }, e2.cancelToken && e2.cancelToken.subscribe(n2), e2.signal && (e2.signal.aborted ? n2() : e2.signal.addEventListener("abort", n2))), r2 || (r2 = null);
        var _2 = R_(l2);
        _2 && -1 === ["http", "https", "file"].indexOf(_2) ? i3(new T_("Unsupported protocol " + _2 + ":", T_.ERR_BAD_REQUEST, e2)) : c2.send(r2);
      });
    }, C_ = Up, v_ = function(e2, t2) {
      Wp.forEach(e2, function(i3, n2) {
        n2 !== t2 && n2.toUpperCase() === t2.toUpperCase() && (e2[t2] = i3, delete e2[n2]);
      });
    }, y_ = Jp, A_ = Qp, O_ = { "Content-Type": "application/x-www-form-urlencoded" };
    function N_(e2, t2) {
      !C_.isUndefined(e2) && C_.isUndefined(e2["Content-Type"]) && (e2["Content-Type"] = t2);
    }
    var b_, w_ = { transitional: Xp, adapter: (("undefined" != typeof XMLHttpRequest || "undefined" != typeof process && "[object process]" === Object.prototype.toString.call(process)) && (b_ = I_), b_), transformRequest: [function(e2, t2) {
      if (v_(t2, "Accept"), v_(t2, "Content-Type"), C_.isFormData(e2) || C_.isArrayBuffer(e2) || C_.isBuffer(e2) || C_.isStream(e2) || C_.isFile(e2) || C_.isBlob(e2))
        return e2;
      if (C_.isArrayBufferView(e2))
        return e2.buffer;
      if (C_.isURLSearchParams(e2))
        return N_(t2, "application/x-www-form-urlencoded;charset=utf-8"), e2.toString();
      var i3, n2 = C_.isObject(e2), r2 = t2 && t2["Content-Type"];
      if ((i3 = C_.isFileList(e2)) || n2 && "multipart/form-data" === r2) {
        var o2 = this.env && this.env.FormData;
        return A_(i3 ? { "files[]": e2 } : e2, o2 && new o2());
      }
      return n2 || "application/json" === r2 ? (N_(t2, "application/json"), function(e3, t3, i4) {
        if (C_.isString(e3))
          try {
            return (t3 || JSON.parse)(e3), C_.trim(e3);
          } catch (e4) {
            if ("SyntaxError" !== e4.name)
              throw e4;
          }
        return (i4 || JSON.stringify)(e3);
      }(e2)) : e2;
    }], transformResponse: [function(e2) {
      var t2 = this.transitional || w_.transitional, i3 = t2 && t2.silentJSONParsing, n2 = t2 && t2.forcedJSONParsing, r2 = !i3 && "json" === this.responseType;
      if (r2 || n2 && C_.isString(e2) && e2.length)
        try {
          return JSON.parse(e2);
        } catch (e3) {
          if (r2) {
            if ("SyntaxError" === e3.name)
              throw y_.from(e3, y_.ERR_BAD_RESPONSE, this, null, this.response);
            throw e3;
          }
        }
      return e2;
    }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: null }, validateStatus: function(e2) {
      return e2 >= 200 && e2 < 300;
    }, headers: { common: { Accept: "application/json, text/plain, */*" } } };
    C_.forEach(["delete", "get", "head"], function(e2) {
      w_.headers[e2] = {};
    }), C_.forEach(["post", "put", "patch"], function(e2) {
      w_.headers[e2] = C_.merge(O_);
    });
    var D_ = w_, P_ = Up, L_ = D_, k_ = function(e2) {
      return !(!e2 || !e2.__CANCEL__);
    }, M_ = Up, U_ = function(e2, t2, i3) {
      var n2 = this || L_;
      return P_.forEach(i3, function(i4) {
        e2 = i4.call(n2, e2, t2);
      }), e2;
    }, x_ = k_, V_ = D_, j_ = u_;
    function F_(e2) {
      if (e2.cancelToken && e2.cancelToken.throwIfRequested(), e2.signal && e2.signal.aborted)
        throw new j_();
    }
    var B_ = Up, G_ = function(e2, t2) {
      t2 = t2 || {};
      var i3 = {};
      function n2(e3, t3) {
        return B_.isPlainObject(e3) && B_.isPlainObject(t3) ? B_.merge(e3, t3) : B_.isPlainObject(t3) ? B_.merge({}, t3) : B_.isArray(t3) ? t3.slice() : t3;
      }
      function r2(i4) {
        return B_.isUndefined(t2[i4]) ? B_.isUndefined(e2[i4]) ? void 0 : n2(void 0, e2[i4]) : n2(e2[i4], t2[i4]);
      }
      function o2(e3) {
        if (!B_.isUndefined(t2[e3]))
          return n2(void 0, t2[e3]);
      }
      function s2(i4) {
        return B_.isUndefined(t2[i4]) ? B_.isUndefined(e2[i4]) ? void 0 : n2(void 0, e2[i4]) : n2(void 0, t2[i4]);
      }
      function a2(i4) {
        return i4 in t2 ? n2(e2[i4], t2[i4]) : i4 in e2 ? n2(void 0, e2[i4]) : void 0;
      }
      var c2 = { url: o2, method: o2, data: o2, baseURL: s2, transformRequest: s2, transformResponse: s2, paramsSerializer: s2, timeout: s2, timeoutMessage: s2, withCredentials: s2, adapter: s2, responseType: s2, xsrfCookieName: s2, xsrfHeaderName: s2, onUploadProgress: s2, onDownloadProgress: s2, decompress: s2, maxContentLength: s2, maxBodyLength: s2, beforeRedirect: s2, transport: s2, httpAgent: s2, httpsAgent: s2, cancelToken: s2, socketPath: s2, responseEncoding: s2, validateStatus: a2 };
      return B_.forEach(Object.keys(e2).concat(Object.keys(t2)), function(e3) {
        var t3 = c2[e3] || r2, n3 = t3(e3);
        B_.isUndefined(n3) && t3 !== a2 || (i3[e3] = n3);
      }), i3;
    }, W_ = "0.27.2", H_ = W_, K_ = Jp, Y_ = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(e2, t2) {
      Y_[e2] = function(i3) {
        return typeof i3 === e2 || "a" + (t2 < 1 ? "n " : " ") + e2;
      };
    });
    var q_ = {};
    Y_.transitional = function(e2, t2, i3) {
      function n2(e3, t3) {
        return "[Axios v" + H_ + "] Transitional option '" + e3 + "'" + t3 + (i3 ? ". " + i3 : "");
      }
      return function(i4, r2, o2) {
        if (false === e2)
          throw new K_(n2(r2, " has been removed" + (t2 ? " in " + t2 : "")), K_.ERR_DEPRECATED);
        return t2 && !q_[r2] && (q_[r2] = true, console.warn(n2(r2, " has been deprecated since v" + t2 + " and will be removed in the near future"))), !e2 || e2(i4, r2, o2);
      };
    };
    var J_ = Up, X_ = jp, z_ = Gp, Q_ = function(e2) {
      return F_(e2), e2.headers = e2.headers || {}, e2.data = U_.call(e2, e2.data, e2.headers, e2.transformRequest), e2.headers = M_.merge(e2.headers.common || {}, e2.headers[e2.method] || {}, e2.headers), M_.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function(t2) {
        delete e2.headers[t2];
      }), (e2.adapter || V_.adapter)(e2).then(function(t2) {
        return F_(e2), t2.data = U_.call(e2, t2.data, t2.headers, e2.transformResponse), t2;
      }, function(t2) {
        return x_(t2) || (F_(e2), t2 && t2.response && (t2.response.data = U_.call(e2, t2.response.data, t2.response.headers, e2.transformResponse))), Promise.reject(t2);
      });
    }, Z_ = G_, $_ = n_, eE = { assertOptions: function(e2, t2, i3) {
      if ("object" != typeof e2)
        throw new K_("options must be an object", K_.ERR_BAD_OPTION_VALUE);
      for (var n2 = Object.keys(e2), r2 = n2.length; r2-- > 0; ) {
        var o2 = n2[r2], s2 = t2[o2];
        if (s2) {
          var a2 = e2[o2], c2 = void 0 === a2 || s2(a2, o2, e2);
          if (true !== c2)
            throw new K_("option " + o2 + " must be " + c2, K_.ERR_BAD_OPTION_VALUE);
        } else if (true !== i3)
          throw new K_("Unknown option " + o2, K_.ERR_BAD_OPTION);
      }
    }, validators: Y_ }, tE = eE.validators;
    function iE(e2) {
      this.defaults = e2, this.interceptors = { request: new z_(), response: new z_() };
    }
    iE.prototype.request = function(e2, t2) {
      "string" == typeof e2 ? (t2 = t2 || {}).url = e2 : t2 = e2 || {}, (t2 = Z_(this.defaults, t2)).method ? t2.method = t2.method.toLowerCase() : this.defaults.method ? t2.method = this.defaults.method.toLowerCase() : t2.method = "get";
      var i3 = t2.transitional;
      void 0 !== i3 && eE.assertOptions(i3, { silentJSONParsing: tE.transitional(tE.boolean), forcedJSONParsing: tE.transitional(tE.boolean), clarifyTimeoutError: tE.transitional(tE.boolean) }, false);
      var n2 = [], r2 = true;
      this.interceptors.request.forEach(function(e3) {
        "function" == typeof e3.runWhen && false === e3.runWhen(t2) || (r2 = r2 && e3.synchronous, n2.unshift(e3.fulfilled, e3.rejected));
      });
      var o2, s2 = [];
      if (this.interceptors.response.forEach(function(e3) {
        s2.push(e3.fulfilled, e3.rejected);
      }), !r2) {
        var a2 = [Q_, void 0];
        for (Array.prototype.unshift.apply(a2, n2), a2 = a2.concat(s2), o2 = Promise.resolve(t2); a2.length; )
          o2 = o2.then(a2.shift(), a2.shift());
        return o2;
      }
      for (var c2 = t2; n2.length; ) {
        var d2 = n2.shift(), u2 = n2.shift();
        try {
          c2 = d2(c2);
        } catch (e3) {
          u2(e3);
          break;
        }
      }
      try {
        o2 = Q_(c2);
      } catch (e3) {
        return Promise.reject(e3);
      }
      for (; s2.length; )
        o2 = o2.then(s2.shift(), s2.shift());
      return o2;
    }, iE.prototype.getUri = function(e2) {
      e2 = Z_(this.defaults, e2);
      var t2 = $_(e2.baseURL, e2.url);
      return X_(t2, e2.params, e2.paramsSerializer);
    }, J_.forEach(["delete", "get", "head", "options"], function(e2) {
      iE.prototype[e2] = function(t2, i3) {
        return this.request(Z_(i3 || {}, { method: e2, url: t2, data: (i3 || {}).data }));
      };
    }), J_.forEach(["post", "put", "patch"], function(e2) {
      function t2(t3) {
        return function(i3, n2, r2) {
          return this.request(Z_(r2 || {}, { method: e2, headers: t3 ? { "Content-Type": "multipart/form-data" } : {}, url: i3, data: n2 }));
        };
      }
      iE.prototype[e2] = t2(), iE.prototype[e2 + "Form"] = t2(true);
    });
    var nE = iE, rE = u_;
    function oE(e2) {
      if ("function" != typeof e2)
        throw new TypeError("executor must be a function.");
      var t2;
      this.promise = new Promise(function(e3) {
        t2 = e3;
      });
      var i3 = this;
      this.promise.then(function(e3) {
        if (i3._listeners) {
          var t3, n2 = i3._listeners.length;
          for (t3 = 0; t3 < n2; t3++)
            i3._listeners[t3](e3);
          i3._listeners = null;
        }
      }), this.promise.then = function(e3) {
        var t3, n2 = new Promise(function(e4) {
          i3.subscribe(e4), t3 = e4;
        }).then(e3);
        return n2.cancel = function() {
          i3.unsubscribe(t3);
        }, n2;
      }, e2(function(e3) {
        i3.reason || (i3.reason = new rE(e3), t2(i3.reason));
      });
    }
    oE.prototype.throwIfRequested = function() {
      if (this.reason)
        throw this.reason;
    }, oE.prototype.subscribe = function(e2) {
      this.reason ? e2(this.reason) : this._listeners ? this._listeners.push(e2) : this._listeners = [e2];
    }, oE.prototype.unsubscribe = function(e2) {
      if (this._listeners) {
        var t2 = this._listeners.indexOf(e2);
        -1 !== t2 && this._listeners.splice(t2, 1);
      }
    }, oE.source = function() {
      var e2;
      return { token: new oE(function(t2) {
        e2 = t2;
      }), cancel: e2 };
    };
    var sE = oE, aE = Up, cE = Up, dE = fp, uE = nE, lE = G_;
    var hE = function e2(t2) {
      var i3 = new uE(t2), n2 = dE(uE.prototype.request, i3);
      return cE.extend(n2, uE.prototype, i3), cE.extend(n2, i3), n2.create = function(i4) {
        return e2(lE(t2, i4));
      }, n2;
    }(D_);
    hE.Axios = uE, hE.CanceledError = u_, hE.CancelToken = sE, hE.isCancel = k_, hE.VERSION = W_, hE.toFormData = Qp, hE.AxiosError = Jp, hE.Cancel = hE.CanceledError, hE.all = function(e2) {
      return Promise.all(e2);
    }, hE.spread = function(e2) {
      return function(t2) {
        return e2.apply(null, t2);
      };
    }, hE.isAxiosError = function(e2) {
      return aE.isObject(e2) && true === e2.isAxiosError;
    }, mp.exports = hE, mp.exports.default = hE;
    var pE = mp.exports;
    class _E {
      constructor(e2) {
        _p(this, "logger", void 0), _p(this, "prefixLists", []), this.logger = e2;
      }
      debug() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        this.logger.debug(...this.prefixLists, ...t2);
      }
      info() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        this.logger.info(...this.prefixLists, ...t2);
      }
      warning() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        this.logger.warning(...this.prefixLists, ...t2);
      }
      error() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        this.logger.error(...this.prefixLists, ...t2);
      }
      prefix(e2) {
        return this.prefixLists.push(e2), this;
      }
      popPrefix() {
        return this.prefixLists.pop(), this;
      }
    }
    class EE {
      constructor() {
        _p(this, "_events", {}), _p(this, "addListener", this.on);
      }
      getListeners(e2) {
        return this._events[e2] ? this._events[e2].map((e3) => e3.listener) : [];
      }
      on(e2, t2) {
        this._events[e2] || (this._events[e2] = []);
        const i3 = this._events[e2];
        -1 === this._indexOfListener(i3, t2) && i3.push({ listener: t2, once: false });
      }
      once(e2, t2) {
        this._events[e2] || (this._events[e2] = []);
        const i3 = this._events[e2];
        -1 === this._indexOfListener(i3, t2) && i3.push({ listener: t2, once: true });
      }
      off(e2, t2) {
        if (!this._events[e2])
          return;
        const i3 = this._events[e2], n2 = this._indexOfListener(i3, t2);
        -1 !== n2 && i3.splice(n2, 1), 0 === this._events[e2].length && delete this._events[e2];
      }
      removeAllListeners(e2) {
        e2 ? delete this._events[e2] : this._events = {};
      }
      emit(e2) {
        this._events[e2] || (this._events[e2] = []);
        const t2 = this._events[e2].map((e3) => e3);
        for (var i3 = arguments.length, n2 = new Array(i3 > 1 ? i3 - 1 : 0), r2 = 1; r2 < i3; r2++)
          n2[r2 - 1] = arguments[r2];
        for (let i4 = 0; i4 < t2.length; i4 += 1) {
          const r3 = t2[i4];
          r3.once && this.off(e2, r3.listener), r3.listener.apply(this, n2 || []);
        }
      }
      safeEmit(e2) {
        for (var t2 = arguments.length, i3 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
          i3[n2 - 1] = arguments[n2];
        [...this._events[e2] || []].forEach((t3) => {
          t3.once && this.off(e2, t3.listener);
          try {
            t3.listener.apply(this, i3);
          } catch (t4) {
            OE.error("safeEmit event:".concat(e2, " error ").concat(null == t4 ? void 0 : t4.toString()));
          }
        });
      }
      _indexOfListener(e2, t2) {
        let i3 = e2.length;
        for (; i3--; )
          if (e2[i3].listener === t2)
            return i3;
        return -1;
      }
    }
    const mE = new class extends EE {
      reportLogUploadError(e2) {
        this.emit("REPORT_LOG_UPLOAD", e2);
      }
    }();
    let fE;
    !function(e2) {
      e2.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e2.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e2.TIMEOUT = "TIMEOUT", e2.INVALID_PARAMS = "INVALID_PARAMS", e2.NOT_READABLE = "NOT_READABLE", e2.NOT_SUPPORTED = "NOT_SUPPORTED", e2.INVALID_OPERATION = "INVALID_OPERATION", e2.OPERATION_ABORTED = "OPERATION_ABORTED", e2.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e2.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e2.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e2.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e2.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e2.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e2.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e2.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e2.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e2.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e2.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e2.PERMISSION_DENIED = "PERMISSION_DENIED", e2.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e2.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e2.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e2.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e2.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e2.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e2.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e2.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e2.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e2.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e2.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e2.UID_CONFLICT = "UID_CONFLICT", e2.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e2.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e2.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e2.INVALID_TRACK = "INVALID_TRACK", e2.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e2.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e2.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e2.ICE_FAILED = "ICE_FAILED", e2.PC_CLOSED = "PC_CLOSED", e2.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e2.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e2.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e2.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e2.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e2.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e2.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e2.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e2.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e2.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e2.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e2.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e2.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e2.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e2.WS_ABORT = "WS_ABORT", e2.WS_DISCONNECT = "WS_DISCONNECT", e2.WS_ERR = "WS_ERR", e2.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e2.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e2.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e2.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e2.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e2.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e2.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e2.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e2.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e2.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e2.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e2.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e2.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e2.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e2.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e2.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e2.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e2.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e2.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e2.INVALID_PLUGIN = "INVALID_PLUGIN", e2.DISCONNECT_P2P = "DISCONNECT_P2P", e2.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e2.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e2.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e2.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e2.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", e2.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", e2.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED";
    }(fE || (fE = {}));
    class SE extends Error {
      constructor(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", i3 = arguments.length > 2 ? arguments[2] : void 0;
        super(t2), _p(this, "code", void 0), _p(this, "message", void 0), _p(this, "data", void 0), _p(this, "name", "AgoraRTCException"), this.code = e2, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t2), this.data = i3;
      }
      toString() {
        return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack);
      }
      print() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
        return "error" === e2 && OE.error(this.toString()), "warning" === e2 && OE.warning(this.toString()), this;
      }
      throw() {
        throw this.print(), this;
      }
    }
    const TE = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
    function gE(e2, t2) {
      const i3 = Math.floor(t2.timeout * Math.pow(t2.timeoutFactor, e2));
      return Math.min(t2.maxRetryTimeout, i3);
    }
    function RE(e2, t2, i3, n2) {
      const r2 = Object.assign({}, TE, n2);
      let o2 = r2.timeout;
      const s2 = async () => {
        await function(e3) {
          return new Sl((t3) => {
            window.setTimeout(t3, e3);
          });
        }(o2), o2 *= r2.timeoutFactor, o2 = Math.min(r2.maxRetryTimeout, o2);
      };
      let a2 = false;
      const c2 = new Sl(async (n3, o3) => {
        t2 = t2 || (() => false), i3 = i3 || (() => true);
        for (let c3 = 0; c3 < r2.maxRetryCount; c3 += 1) {
          if (a2)
            return o3(new SE(fE.OPERATION_ABORTED));
          try {
            const i4 = await e2();
            if (!t2(i4, c3))
              return n3(i4);
            if (c3 + 1 === r2.maxRetryCount)
              return n3(i4);
            await s2();
          } catch (e3) {
            if (!i3(e3, c3))
              return o3(e3);
            if (c3 + 1 === r2.maxRetryCount)
              return o3(e3);
            await s2();
          }
        }
      });
      return c2.cancel = () => a2 = true, c2;
    }
    function IE() {
      const e2 = /* @__PURE__ */ new Date();
      return e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
    }
    function CE() {
      const e2 = /* @__PURE__ */ new Date(), t2 = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
      return t2 ? (null == t2 ? void 0 : t2[0]) + ":" + e2.getUTCMilliseconds() : e2.toTimeString().split(" ")[0] + ":" + e2.getMilliseconds();
    }
    const vE = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 }, yE = Date.now(), AE = (e2) => {
      for (const t2 in vE)
        if (Object.prototype.hasOwnProperty.call(vE, t2) && vE[t2] === e2)
          return t2;
      return "DEFAULT";
    };
    const OE = new class {
      constructor() {
        _p(this, "proxyServerURL", void 0), _p(this, "logLevel", vE.DEBUG), _p(this, "uploadState", "collecting"), _p(this, "uploadLogWaitingList", []), _p(this, "uploadLogUploadingList", []), _p(this, "uploadErrorCount", 0), _p(this, "currentLogID", 0), _p(this, "url", void 0), _p(this, "extLog", (e2, t2) => {
          this.appendLogToWaitingList(e2, ...t2);
        });
      }
      debug() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        const n2 = [vE.DEBUG].concat(t2);
        this.log.apply(this, n2);
      }
      info() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        const n2 = [vE.INFO].concat(t2);
        this.log.apply(this, n2);
      }
      warning() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        const n2 = [vE.WARNING].concat(t2);
        this.log.apply(this, n2);
      }
      error() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        const n2 = [vE.ERROR].concat(t2);
        this.log.apply(this, n2);
      }
      upload() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        const n2 = [vE.DEBUG].concat(t2);
        this.uploadLog.apply(this, n2);
      }
      setLogLevel(e2) {
        e2 = Math.min(Math.max(0, e2), 4), this.logLevel = e2;
      }
      enableLogUpload() {
        BE("UPLOAD_LOG", true);
      }
      disableLogUpload() {
        BE("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
      }
      setProxyServer(e2) {
        this.proxyServerURL = e2;
      }
      prefix(e2) {
        return new _E(this).prefix(e2);
      }
      log() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        if (Date.now() - yE < 100)
          return void setTimeout(() => {
            this.log(...t2);
          }, Date.now() - yE);
        const n2 = Math.max(0, Math.min(4, t2[0]));
        if (t2[0] = IE() + " Agora-SDK [".concat(AE(n2), "]:"), this.appendLogToWaitingList(n2, ...t2), n2 < this.logLevel)
          return;
        const r2 = IE() + " %cAgora-SDK [".concat(AE(n2), "]:");
        let o2 = [];
        if (!GE("USE_NEW_LOG"))
          switch (n2) {
            case vE.DEBUG:
              o2 = [r2, "color: #64B5F6;"].concat(t2.slice(1)), console.log.apply(console, o2);
              break;
            case vE.INFO:
              o2 = [r2, "color: #1E88E5; font-weight: bold;"].concat(t2.slice(1)), console.log.apply(console, o2);
              break;
            case vE.WARNING:
              o2 = [r2, "color: #FB8C00; font-weight: bold;"].concat(t2.slice(1)), console.warn.apply(console, o2);
              break;
            case vE.ERROR:
              o2 = [r2, "color: #B00020; font-weight: bold;"].concat(t2.slice(1)), console.error.apply(console, o2);
          }
      }
      uploadLog() {
        for (var e2 = arguments.length, t2 = new Array(e2), i3 = 0; i3 < e2; i3++)
          t2[i3] = arguments[i3];
        if (Date.now() - yE < 100)
          return void setTimeout(() => {
            this.uploadLog(...t2);
          }, Date.now() - yE);
        const n2 = Math.max(0, Math.min(4, t2[0]));
        t2[0] = IE() + " Agora-SDK [".concat(AE(n2), "]:"), this.appendLogToWaitingList(n2, ...t2);
      }
      appendLogToWaitingList(e2) {
        if (!GE("UPLOAD_LOG"))
          return;
        for (var t2 = arguments.length, i3 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++)
          i3[n2 - 1] = arguments[n2];
        Array.isArray(i3[0]) ? i3[0][0] = CE() + " Agora-SDK [".concat(AE(e2), "]:") : i3[0] = CE() + " Agora-SDK [".concat(AE(e2), "]:");
        let r2 = "";
        i3.forEach((e3) => {
          "object" == typeof e3 && (e3 = JSON.stringify(e3)), r2 += "".concat(e3, " ");
        }), this.uploadLogWaitingList.push({ payload_str: r2, log_level: e2, log_item_id: this.currentLogID++ }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
      }
      startUpload() {
        this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();
      }
      async uploadLogs() {
        const e2 = this.uploadLogUploadingList, t2 = { sdk_version: bE, process_id: GE("PROCESS_ID"), payload: JSON.stringify(e2) };
        return RE(async () => {
          const e3 = await pE.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(GE("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(GE("LOG_UPLOAD_SERVER"), "/upload/v1")), t2, { responseType: "text" });
          if ("OK" !== e3.data) {
            const t3 = new Error("unexpected upload log response");
            throw t3.response = e3, t3;
          }
        }, () => (this.uploadLogUploadingList = [], false), (e3) => (e3.response ? mE.reportLogUploadError({ status: e3.response.status, data: e3.response.data, headers: e3.response.headers, message: e3.message }) : e3.request ? mE.reportLogUploadError({ status: e3.request.status, message: e3.message }) : mE.reportLogUploadError({ status: -1, message: e3.message }), true), { timeout: GE("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: GE("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
      }
      uploadLogInterval() {
        0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, GE("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
          this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), GE("UPLOAD_LOG_INTERVAL"));
        }).catch((e2) => {
          this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), GE("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), GE("UPLOAD_LOG_RETRY_INTERVAL_V1"));
        }));
      }
    }(), NE = "v4.18.3-0-g04adbcef-dirty(9/20/2023, 10:34:38 AM)", bE = function(e2) {
      if (e2.match(/[0-9]+\.[0-9]+\.[0-9]+$/))
        return e2;
      const t2 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
      if (t2 && t2[1] && t2[2]) {
        const e3 = t2[1], i4 = t2[2];
        return "".concat(e3, ".").concat(i4);
      }
      const i3 = e2.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
      if (i3 && i3[1] && i3[2]) {
        const e3 = i3[1], t3 = i3[2];
        return "".concat(e3, ".").concat(100 * (Number(t3) + 1));
      }
      return "4.0.0.999";
    }("4.18.3"), wE = function() {
      try {
        return true === JSON.parse("true");
      } catch (e2) {
        return true;
      }
    }(), DE = ["CHINA", "GLOBAL"], PE = function() {
      const e2 = "us".concat("erna", "me"), t2 = "pa".concat("sswo", "rd"), i3 = ["t", "s", "t"];
      i3.splice(1, 0, "e");
      const n2 = i3.join(""), r2 = [];
      for (let e3 = 0; e3 < 6; e3++)
        r2.push("1");
      const o2 = r2.join(""), s2 = {};
      return s2[e2] = n2, s2[t2] = o2, Object.assign(s2, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
    }();
    window.DEFAULT_TURN_CONFIG = PE;
    const LE = { "90p": YE(160, 90), "90p_1": YE(160, 90), "120p": YE(160, 120, 15, 30, 65), "120p_1": YE(160, 120, 15, 30, 65), "120p_3": YE(120, 120, 15, 30, 50), "120p_4": YE(212, 120), "180p": YE(320, 180, 15, 30, 140), "180p_1": YE(320, 180, 15, 30, 140), "180p_3": YE(180, 180, 15, 30, 100), "180p_4": YE(240, 180, 15, 30, 120), "240p": YE(320, 240, 15, 40, 200), "240p_1": YE(320, 240, 15, 40, 200), "240p_3": YE(240, 240, 15, 40, 140), "240p_4": YE(424, 240, 15, 40, 220), "360p": YE(640, 360, 15, 80, 400), "360p_1": YE(640, 360, 15, 80, 400), "360p_3": YE(360, 360, 15, 80, 260), "360p_4": YE(640, 360, 30, 80, 600), "360p_6": YE(360, 360, 30, 80, 400), "360p_7": YE(480, 360, 15, 80, 320), "360p_8": YE(480, 360, 30, 80, 490), "360p_9": YE(640, 360, 15, 80, 800), "360p_10": YE(640, 360, 24, 80, 800), "360p_11": YE(640, 360, 24, 80, 1e3), "480p": YE(640, 480, 15, 100, 500), "480p_1": YE(640, 480, 15, 100, 500), "480p_2": YE(640, 480, 30, 100, 1e3), "480p_3": YE(480, 480, 15, 100, 400), "480p_4": YE(640, 480, 30, 100, 750), "480p_6": YE(480, 480, 30, 100, 600), "480p_8": YE(848, 480, 15, 100, 610), "480p_9": YE(848, 480, 30, 100, 930), "480p_10": YE(640, 480, 10, 100, 400), "720p": YE(1280, 720, 15, 120, 1130), "720p_1": YE(1280, 720, 15, 120, 1130), "720p_2": YE(1280, 720, 30, 120, 2e3), "720p_3": YE(1280, 720, 30, 120, 1710), "720p_5": YE(960, 720, 15, 120, 910), "720p_6": YE(960, 720, 30, 120, 1380), "1080p": YE(1920, 1080, 15, 120, 2080), "1080p_1": YE(1920, 1080, 15, 120, 2080), "1080p_2": YE(1920, 1080, 30, 120, 3e3), "1080p_3": YE(1920, 1080, 30, 120, 3150), "1080p_5": YE(1920, 1080, 60, 120, 4780), "1440p": YE(2560, 1440, 30, 120, 4850), "1440p_1": YE(2560, 1440, 30, 120, 4850), "1440p_2": YE(2560, 1440, 60, 120, 7350), "4k": YE(3840, 2160, 30, 120, 8910), "4k_1": YE(3840, 2160, 30, 120, 8910), "4k_3": YE(3840, 2160, 60, 120, 13500) }, kE = { "480p": qE(640, 480, 5), "480p_1": qE(640, 480, 5), "480p_2": qE(640, 480, 30), "480p_3": qE(640, 480, 15), "720p": qE(1280, 720, 5), "720p_1": qE(1280, 720, 5), "720p_2": qE(1280, 720, 30), "720p_3": qE(1280, 720, 15), "1080p": qE(1920, 1080, 5), "1080p_1": qE(1920, 1080, 5), "1080p_2": qE(1920, 1080, 30), "1080p_3": qE(1920, 1080, 15) }, ME = { "1SL1TL": JE(1, 1), "3SL3TL": JE(3, 3), "2SL3TL": JE(2, 3) };
    function UE(e2) {
      return e2 || (e2 = "480p_1"), "string" == typeof e2 ? Object.assign({}, LE[e2]) : e2;
    }
    function xE(e2) {
      return "string" == typeof e2 ? Object.assign({}, kE[e2]) : e2;
    }
    function VE(e2) {
      return "string" == typeof e2 ? Object.assign({}, ME[e2]) : e2;
    }
    const jE = { speech_low_quality: KE(16e3, false), speech_standard: KE(32e3, false, 18), music_standard: KE(48e3, false), standard_stereo: KE(48e3, true, 56), high_quality: KE(48e3, false, 128), high_quality_stereo: KE(48e3, true, 192) };
    function FE(e2) {
      return "string" == typeof e2 ? Object.assign({}, jE[e2]) : e2;
    }
    function BE(e2, t2, i3) {
      Object.keys(WE).includes(e2) && (!i3 && Object.keys(HE).includes(e2) || (WE[e2] = t2));
    }
    function GE(e2) {
      return WE[e2];
    }
    const WE = { PROCESS_ID: "", ENCRYPT_AES: true, AREAS: DE, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], SUBSCRIBE_TWCC: false, PUBLISH_TWCC: false, PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, USE_PUB_RTX: false, USE_SUB_RTX: false, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: true, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: {}, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, ENABLE_USER_LICENSE_CHECK: true, SIGNAL_CHANNEL: 0, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, SVC: [], ENABLE_ENCODED_TRANSFORM: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true } }, HE = {};
    function KE(e2, t2, i3) {
      return { sampleRate: e2, stereo: t2, bitrate: i3 };
    }
    function YE(e2, t2, i3, n2, r2) {
      return { width: e2, height: t2, frameRate: i3, bitrateMin: n2, bitrateMax: r2 };
    }
    function qE(e2, t2, i3, n2, r2) {
      return { width: { max: e2 }, height: { max: t2 }, frameRate: i3, bitrateMin: n2, bitrateMax: r2 };
    }
    function JE(e2, t2) {
      return { numSpatialLayers: e2, numTemporalLayers: t2 };
    }
    wE || (WE.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], WE.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], WE.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], WE.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], WE.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], WE.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], WE.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", WE.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", WE.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", WE.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", WE.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
    const XE = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]], zE = [], QE = [];
    function ZE(e2, t2) {
      return !!t2 && zE.some((i3) => i3.uid === e2 && i3.channelName === t2);
    }
    var $E = Et2, em = Ht, tm = w2, im = function(e2, t2, i3) {
      var n2 = $E(t2);
      n2 in e2 ? em.f(e2, n2, tm(0, i3)) : e2[n2] = i3;
    }, nm = Un, rm = bi, om = im, sm = h2.Array, am = Math.max, cm = function(e2, t2, i3) {
      for (var n2 = rm(e2), r2 = nm(t2, n2), o2 = nm(void 0 === i3 ? n2 : i3, n2), s2 = sm(am(o2 - r2, 0)), a2 = 0; r2 < o2; r2++, a2++)
        om(s2, a2, e2[r2]);
      return s2.length = a2, s2;
    }, dm = cm, um = Math.floor, lm = function(e2, t2) {
      var i3 = e2.length, n2 = um(i3 / 2);
      return i3 < 8 ? hm(e2, t2) : pm(e2, lm(dm(e2, 0, n2), t2), lm(dm(e2, n2), t2), t2);
    }, hm = function(e2, t2) {
      for (var i3, n2, r2 = e2.length, o2 = 1; o2 < r2; ) {
        for (n2 = o2, i3 = e2[o2]; n2 && t2(e2[n2 - 1], i3) > 0; )
          e2[n2] = e2[--n2];
        n2 !== o2++ && (e2[n2] = i3);
      }
      return e2;
    }, pm = function(e2, t2, i3, n2) {
      for (var r2 = t2.length, o2 = i3.length, s2 = 0, a2 = 0; s2 < r2 || a2 < o2; )
        e2[s2 + a2] = s2 < r2 && a2 < o2 ? n2(t2[s2], i3[a2]) <= 0 ? t2[s2++] : i3[a2++] : s2 < r2 ? t2[s2++] : i3[a2++];
      return e2;
    }, _m = lm, Em = ee.match(/firefox\/(\d+)/i), mm = !!Em && +Em[1], fm = /MSIE|Trident/.test(ee), Sm = ee.match(/AppleWebKit\/(\d+)\./), Tm = !!Sm && +Sm[1], gm = Ii, Rm = d, Im = Ce, Cm = je, vm = bi, ym = wo, Am = i2, Om = _m, Nm = Vi, bm = mm, wm = fm, Dm = ae, Pm = Tm, Lm = [], km = Rm(Lm.sort), Mm = Rm(Lm.push), Um = Am(function() {
      Lm.sort(void 0);
    }), xm = Am(function() {
      Lm.sort(null);
    }), Vm = Nm("sort"), jm = !Am(function() {
      if (Dm)
        return Dm < 70;
      if (!(bm && bm > 3)) {
        if (wm)
          return true;
        if (Pm)
          return Pm < 603;
        var e2, t2, i3, n2, r2 = "";
        for (e2 = 65; e2 < 76; e2++) {
          switch (t2 = String.fromCharCode(e2), e2) {
            case 66:
            case 69:
            case 70:
            case 72:
              i3 = 3;
              break;
            case 68:
            case 71:
              i3 = 4;
              break;
            default:
              i3 = 2;
          }
          for (n2 = 0; n2 < 47; n2++)
            Lm.push({ k: t2 + n2, v: i3 });
        }
        for (Lm.sort(function(e3, t3) {
          return t3.v - e3.v;
        }), n2 = 0; n2 < Lm.length; n2++)
          t2 = Lm[n2].k.charAt(0), r2.charAt(r2.length - 1) !== t2 && (r2 += t2);
        return "DGBEFHACIJK" !== r2;
      }
    });
    gm({ target: "Array", proto: true, forced: Um || !xm || !Vm || !jm }, { sort: function(e2) {
      void 0 !== e2 && Im(e2);
      var t2 = Cm(this);
      if (jm)
        return void 0 === e2 ? km(t2) : km(t2, e2);
      var i3, n2, r2 = [], o2 = vm(t2);
      for (n2 = 0; n2 < o2; n2++)
        n2 in t2 && Mm(r2, t2[n2]);
      for (Om(r2, function(e3) {
        return function(t3, i4) {
          return void 0 === i4 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i4) || 0 : ym(t3) > ym(i4) ? 1 : -1;
        };
      }(e2)), i3 = r2.length, n2 = 0; n2 < i3; )
        t2[n2] = r2[n2++];
      for (; n2 < o2; )
        delete t2[n2++];
      return t2;
    } });
    var Fm = Hi("Array").sort, Bm = u, Gm = Fm, Wm = Array.prototype, Hm = function(e2) {
      var t2 = e2.sort;
      return e2 === Wm || Bm(Wm, e2) && t2 === Wm.sort ? Gm : t2;
    };
    function Km(e2, t2) {
      if ("boolean" != typeof e2)
        throw new SE(fE.INVALID_PARAMS, "Invalid ".concat(t2, ": The value is of the boolean type."));
    }
    function Ym(e2, t2, i3) {
      if (i3.includes(e2))
        return;
      throw new SE(fE.INVALID_PARAMS, "".concat(t2, " can only be set as ").concat(JSON.stringify(i3)));
    }
    function qm(e2, t2) {
      let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
      if (e2 < i3 || e2 > n2 || r2 && !tf(e2)) {
        throw new SE(fE.INVALID_PARAMS, "invalid ".concat(t2, ": the value range is [").concat(i3, ", ").concat(n2, "]. integer only"));
      }
    }
    function Jm(e2, t2) {
      if ("number" != typeof e2) {
        if (!(e2.min || e2.max || e2.ideal || e2.exact)) {
          throw new SE(fE.INVALID_PARAMS, "".concat(t2, " is not a valid ConstrainLong"));
        }
        void 0 !== e2.min && qm(e2.min, "".concat(t2, ".min"), 0, 1 / 0), void 0 !== e2.max && qm(e2.max, "".concat(t2, ".max"), 1, 1 / 0), void 0 !== e2.exact && qm(e2.exact, "".concat(t2, ".exact"), 1, 1 / 0), void 0 !== e2.ideal && qm(e2.ideal, "".concat(t2, ".ideal"), 1, 1 / 0);
      } else
        qm(e2, t2, 1, 1 / 0);
    }
    function Xm(e2, t2) {
      let i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255, r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
      if (null == e2)
        throw new SE(fE.INVALID_PARAMS, "".concat(t2 || "param", " cannot be empty"));
      if (!ef(e2, i3, n2, r2))
        throw new SE(fE.INVALID_PARAMS, "Invalid ".concat(t2 || "string param", ": Length of the string: [").concat(i3, ",").concat(n2, "].").concat(r2 ? " ASCII characters only." : ""));
    }
    function zm(e2, t2) {
      if (!Array.isArray(e2))
        throw new SE(fE.INVALID_PARAMS, "".concat(t2, " should be an array"));
    }
    function Qm(e2) {
      if ("string" != typeof e2 || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e2))
        throw OE.error("Invalid Channel Name ".concat(e2)), new SE(fE.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
    }
    function Zm(e2) {
      if (!(t2 = e2, "number" == typeof t2 && Math.floor(t2) === t2 && 0 <= t2 && t2 <= 4294967295 || ef(e2, 1, 255)))
        throw OE.error("Invalid UID ".concat(e2, " ").concat(typeof e2)), new SE(fE.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
      var t2;
      "string" == typeof e2 && OE.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
    }
    function $m(e2) {
      return null == e2;
    }
    function ef(e2) {
      let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255, n2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
      return "string" == typeof e2 && e2.length <= i3 && e2.length >= t2 && (!n2 || nf(e2));
    }
    function tf(e2) {
      return "number" == typeof e2 && e2 % 1 == 0;
    }
    function nf(e2) {
      if ("string" != typeof e2)
        return false;
      for (let t2 = 0; t2 < e2.length; t2 += 1) {
        const i3 = e2.charCodeAt(t2);
        if (i3 < 0 || i3 > 255)
          return false;
      }
      return true;
    }
    let rf, of, sf;
    !function(e2) {
      e2.FREE = "free", e2.UPLOADING = "uploading";
    }(rf || (rf = {})), function(e2) {
      e2[e2.MISC = 0] = "MISC", e2[e2.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e2[e2.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e2[e2.WEB_EVENT = 3] = "WEB_EVENT", e2[e2.INTERNAL_API = 4] = "INTERNAL_API", e2[e2.WEB_API = 5] = "WEB_API", e2[e2.PUBLIC_API = 6] = "PUBLIC_API";
    }(of || (of = {})), function(e2) {
      e2.NONE = "none", e2.INIT = "init", e2.CANPLAY = "canplay", e2.PLAYING = "playing", e2.PAUSED = "paused", e2.SUSPEND = "suspend", e2.STALLED = "stalled", e2.WAITING = "waiting", e2.ERROR = "error", e2.DESTROYED = "destroyed", e2.ABORT = "abort", e2.ENDED = "ended", e2.EMPTIED = "emptied", e2.LOADEDDATA = "loadeddata";
    }(sf || (sf = {}));
    const af = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
    function cf(e2) {
      return Xm(e2.reportId, "params.reportId", 0, 100, false), Xm(e2.category, "params.category", 0, 100, false), Xm(e2.event, "params.event", 0, 100, false), Xm(e2.label, "params.label", 0, 100, false), qm(e2.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
    }
    const df = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
    let uf, lf, hf, pf, _f, Ef, mf, ff, Sf, Tf, gf, Rf, If, Cf, vf, yf, Af, Of, Nf, bf, wf, Df, Pf, Lf;
    function kf(e2) {
      return qm(e2.timeout, "config.timeout", 0, 1e5), qm(e2.timeoutFactor, "config.timeoutFactor", 0, 100, false), qm(e2.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), qm(e2.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
    }
    function Mf(e2) {
      return Ym(e2.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), Ym(e2.mode, "config.mode", ["rtc", "live"]), void 0 !== e2.audioCodec && Ym(e2.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e2.proxyServer && Xm(e2.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e2.turnServer && xf(e2.turnServer), void 0 !== e2.httpRetryConfig && kf(e2.httpRetryConfig), void 0 !== e2.websocketRetryConfig && kf(e2.websocketRetryConfig), true;
    }
    function Uf(e2) {
      if (!Array.isArray(e2) || e2.length < 1)
        return false;
      try {
        e2.forEach((e3) => {
          if (!e3.urls)
            throw Error();
        });
      } catch (e3) {
        return false;
      }
      return true;
    }
    function xf(e2) {
      return Xm(e2.turnServerURL, "turnServerURL"), Xm(e2.username, "username"), Xm(e2.password, "password"), e2.udpport && qm(e2.udpport, "udpport", 1, 99999, true), e2.forceturn && Km(e2.forceturn, "forceturn"), e2.security && Km(e2.security, "security"), e2.tcpport && qm(e2.tcpport, "tcpport", 1, 99999, true), true;
    }
    function Vf(e2) {
      return void 0 !== e2.level && Ym(e2.level, "level", [1, 2, 3]), true;
    }
    !function(e2) {
      e2.PUBLISH = "publish", e2.SUBSCRIBE = "subscribe", e2.WS_COMPRESSOR_INIT = "ws_compressor_init", e2.SESSION_INIT = "session_init", e2.JOIN_CHOOSE_SERVER = "join_choose_server", e2.REQ_USER_ACCOUNT = "req_user_account", e2.JOIN_GATEWAY = "join_gateway", e2.REJOIN_GATEWAY = "rejoin_gateway", e2.STREAM_SWITCH = "stream_switch", e2.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e2.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e2.FIRST_VIDEO_RECEIVED = "first_video_received", e2.FIRST_AUDIO_RECEIVED = "first_audio_received", e2.FIRST_VIDEO_DECODE = "first_video_decode", e2.FIRST_AUDIO_DECODE = "first_audio_decode", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_UPDATE_STREAM = "on_update_stream", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.USER_ANALYTICS = "req_user_analytics", e2.PC_STATS = "pc_stats";
    }(uf || (uf = {})), function(e2) {
      e2.SESSION = "io.agora.pb.Wrtc.Session", e2.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e2.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e2.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e2.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e2.PUBLISH = "io.agora.pb.Wrtc.Publish", e2.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e2.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e2.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e2.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e2.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e2.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e2.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e2.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e2.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e2.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e2.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e2.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e2.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e2.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e2.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e2.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e2.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e2.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e2.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e2.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e2.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e2.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e2.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e2.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", e2.PC_STATS = "io.agora.pb.Wrtc.PCStats";
    }(lf || (lf = {})), function(e2) {
      e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
    }(hf || (hf = {})), function(e2) {
      e2[e2.SESSION = 26] = "SESSION", e2[e2.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e2[e2.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e2[e2.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e2[e2.PUBLISH = 30] = "PUBLISH", e2[e2.SUBSCRIBE = 29] = "SUBSCRIBE", e2[e2.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e2[e2.STREAM_SWITCH = 32] = "STREAM_SWITCH", e2[e2.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e2[e2.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e2[e2.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e2[e2.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e2[e2.API_INVOKE = 41] = "API_INVOKE", e2[e2.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e2[e2.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e2[e2.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e2[e2.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e2[e2.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e2[e2.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e2[e2.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e2[e2.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e2[e2.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e2[e2.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e2[e2.WORKER_EVENT = 156] = "WORKER_EVENT", e2[e2.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e2[e2.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e2[e2.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e2[e2.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e2[e2.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED";
    }(pf || (pf = {})), function(e2) {
      e2.CREATE_CLIENT = "createClient", e2.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e2.SET_AREA = "setArea", e2.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e2.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e2.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e2.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e2.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e2.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e2.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e2.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e2.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e2.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e2.START_PROXY_SERVER = "Client.startProxyServer", e2.STOP_PROXY_SERVER = "Client.stopProxyServer", e2.SET_PROXY_SERVER = "Client.setProxyServer", e2.SET_TURN_SERVER = "Client.setTurnServer", e2.SET_CLIENT_ROLE = "Client.setClientRole", e2.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e2.ENABLE_DUAL_STREAM = "Client.enableDualStream", e2.DISABLE_DUAL_STREAM = "Client.disableDualStream", e2.JOIN = "Client.join", e2.LEAVE = "Client.leave", e2.PUBLISH = "Client.publish", e2.UNPUBLISH = "Client.unpublish", e2.SUBSCRIBE = "Client.subscribe", e2.MASS_SUBSCRIBE = "Client.massSubscribe", e2.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e2.UNSUBSCRIBE = "Client.unsubscribe", e2.RENEW_TOKEN = "Client.renewToken", e2.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e2.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e2.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e2.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e2.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e2.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e2.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e2.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e2.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e2.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e2.START_LIVE_STREAMING = "Client.startLiveStreaming", e2.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e2.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e2.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e2.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e2.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e2.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e2.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e2.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e2.SET_CONFIG_DISTRIBUTE = "_configDistribute", e2.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e2.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e2.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e2.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e2.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e2.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e2.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e2.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e2.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e2.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e2.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e2.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e2.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e2.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e2.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e2.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e2.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e2.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e2.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e2.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e2.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e2.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e2.STREAM_TYPE_CHANGE = "streamTypeChange", e2.CONNECTION_STATE_CHANGE = "connectionStateChange", e2.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", e2.IMAGE_MODERATION_UPLOAD = "imageModerationUpload";
    }(_f || (_f = {})), function(e2) {
      e2.TRACER = "tracer";
    }(Ef || (Ef = {})), function(e2) {
      e2.IDLE = "IDLE", e2.INITING = "INITING", e2.INITEND = "INITEND";
    }(mf || (mf = {})), function(e2) {
      e2.STATE_CHANGE = "state_change", e2.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e2.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e2.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged";
    }(ff || (ff = {})), function(e2) {
      e2[e2.ACCESS_POINT = 101] = "ACCESS_POINT", e2[e2.UNILBS = 201] = "UNILBS", e2[e2.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR";
    }(Sf || (Sf = {})), function(e2) {
      e2[e2.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e2[e2.IIIEGAL_UID = 2] = "IIIEGAL_UID", e2[e2.INTERNAL_ERROR = 3] = "INTERNAL_ERROR";
    }(Tf || (Tf = {})), function(e2) {
      e2[e2.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e2[e2.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e2[e2.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e2[e2.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e2[e2.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e2[e2.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e2[e2.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e2[e2.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e2[e2.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e2[e2.USER_OVERLOAD = 16] = "USER_OVERLOAD", e2[e2.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e2[e2.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND";
    }(gf || (gf = {})), function(e2) {
      e2[e2.NO_FLAG_SET = 100] = "NO_FLAG_SET", e2[e2.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e2[e2.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e2[e2.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e2[e2.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e2[e2.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e2[e2.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e2[e2.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e2[e2.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e2[e2.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e2[e2.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e2[e2.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e2[e2.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e2[e2.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e2[e2.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e2[e2.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e2[e2.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e2[e2.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV";
    }(Rf || (Rf = {})), function(e2) {
      e2[e2.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e2[e2.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e2[e2.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e2[e2.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e2[e2.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e2[e2.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e2[e2.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e2[e2.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e2[e2.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e2[e2.K_UID_BANNED = 14] = "K_UID_BANNED", e2[e2.K_IP_BANNED = 15] = "K_IP_BANNED", e2[e2.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e2[e2.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e2[e2.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e2[e2.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e2[e2.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e2[e2.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e2[e2.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e2[e2.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e2[e2.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e2[e2.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e2[e2.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e2[e2.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e2[e2.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e2[e2.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e2[e2.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e2[e2.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e2[e2.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e2[e2.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e2[e2.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e2[e2.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e2[e2.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e2[e2.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e2[e2.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e2[e2.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e2[e2.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e2[e2.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e2[e2.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e2[e2.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e2[e2.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e2[e2.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e2[e2.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e2[e2.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e2[e2.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e2[e2.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e2[e2.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e2[e2.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e2[e2.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e2[e2.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e2[e2.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e2[e2.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e2[e2.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e2[e2.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e2[e2.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e2[e2.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e2[e2.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e2[e2.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e2[e2.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e2[e2.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e2[e2.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e2[e2.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e2[e2.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e2[e2.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY";
    }(If || (If = {})), function(e2) {
      e2[e2.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e2[e2.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY";
    }(Cf || (Cf = {})), function(e2) {
      e2.LEAVE = "LEAVE", e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.UID_BANNED = "UID_BANNED", e2.IP_BANNED = "IP_BANNED", e2.CHANNEL_BANNED = "CHANNEL_BANNED", e2.FALLBACK = "FALLBACK", e2.LICENSE_MISSING = "LICENSE_MISSING", e2.LICENSE_EXPIRED = "LICENSE_EXPIRED", e2.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e2.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e2.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e2.LICENSE_ILLEGAL = "LICENSE_ILLEGAL";
    }(vf || (vf = {})), function(e2) {
      e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.MEDIA_RECONNECT_START = "media-reconnect-start", e2.MEDIA_RECONNECT_END = "media-reconnect-end", e2.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e2.USER_JOINED = "user-joined", e2.USER_LEAVED = "user-left", e2.USER_PUBLISHED = "user-published", e2.USER_UNPUBLISHED = "user-unpublished", e2.USER_INFO_UPDATED = "user-info-updated", e2.CLIENT_BANNED = "client-banned", e2.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e2.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e2.VOLUME_INDICATOR = "volume-indicator", e2.CRYPT_ERROR = "crypt-error", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGED = "stream-type-changed", e2.STREAM_FALLBACK = "stream-fallback", e2.RECEIVE_METADATA = "receive-metadata", e2.STREAM_MESSAGE = "stream-message", e2.LIVE_STREAMING_ERROR = "live-streaming-error", e2.LIVE_STREAMING_WARNING = "live-streaming-warning", e2.INJECT_STREAM_STATUS = "stream-inject-status", e2.EXCEPTION = "exception", e2.ERROR = "error", e2.P2P_LOST = "p2p_lost", e2.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e2.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e2.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e2.PUBLISHED_USER_LIST = "published-user-list", e2.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e2.CONTENT_INSPECT_ERROR = "content-inspect-error", e2.CONTENT_INSPECT_RESULT = "content-inspect-result", e2.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change";
    }(yf || (yf = {})), function(e2) {
      e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
    }(Af || (Af = {})), function(e2) {
      e2.CONNECTING = "connecting", e2.CONNECTED = "connected", e2.RECONNECTING = "reconnecting", e2.CLOSED = "closed";
    }(Of || (Of = {})), function(e2) {
      e2.WS_CONNECTED = "ws_connected", e2.WS_RECONNECTING = "ws_reconnecting", e2.WS_CLOSED = "ws_closed", e2.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e2.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e2.ON_BINARY_DATA = "on_binary_data", e2.REQUEST_RECOVER = "request_recover", e2.REQUEST_JOIN_INFO = "request_join_info", e2.REQUEST_REJOIN_INFO = "req_rejoin_info", e2.IS_P2P_DISCONNECTED = "is_p2p_dis", e2.DISCONNECT_P2P = "dis_p2p", e2.ABORT_P2P_EXECUTION = "abort_p2p_execution", e2.NEED_RENEW_SESSION = "need-sid", e2.REPORT_JOIN_GATEWAY = "report_join_gateway", e2.REQUEST_TIMEOUT = "request_timeout", e2.REQUEST_SUCCESS = "request_success", e2.JOIN_RESPONSE = "join_response", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_CONNECTING = "datachannel_connecting", e2.DATACHANNEL_FAILBACK = "datachannel_failback";
    }(Nf || (Nf = {})), function(e2) {
      e2.PING = "ping", e2.PING_BACK = "ping_back", e2.JOIN = "join_v3", e2.REJOIN = "rejoin_v3", e2.LEAVE = "leave", e2.SET_CLIENT_ROLE = "set_client_role", e2.PUBLISH = "publish", e2.UNPUBLISH = "unpublish", e2.SUBSCRIBE = "subscribe", e2.SUBSCRIBE_STREAMS = "subscribe_streams", e2.UNSUBSCRIBE = "unsubscribe", e2.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e2.SUBSCRIBE_CHANGE = "subscribe_change", e2.TRAFFIC_STATS = "traffic_stats", e2.RENEW_TOKEN = "renew_token", e2.SWITCH_VIDEO_STREAM = "switch_video_stream", e2.DEFAULT_VIDEO_STREAM = "default_video_stream", e2.SET_FALLBACK_OPTION = "set_fallback_option", e2.GATEWAY_INFO = "gateway_info", e2.CONTROL = "control", e2.SEND_METADATA = "send_metadata", e2.DATA_STREAM = "data_stream", e2.PICK_SVC_LAYER = "pick_svc_layer", e2.RESTART_ICE = "restart_ice", e2.CONNECT_PC = "connect_pc", e2.SET_VIDEO_PROFILE = "set_video_profile", e2.SET_PARAMETER = "set_parameter";
    }(bf || (bf = {})), function(e2) {
      e2.PUBLISH_STATS = "publish_stats", e2.PUBLISH_RELATED_STATS = "publish_related_stats", e2.SUBSCRIBE_STATS = "subscribe_stats", e2.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e2.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e2.DENOISER_STATS = "denoiser_stats", e2.TRANSPORT_STATS = "transport_stats", e2.EXTENSION_USAGE_STATS = "extension_usage_stats";
    }(wf || (wf = {})), function(e2) {
      e2.ON_USER_ONLINE = "on_user_online", e2.ON_USER_OFFLINE = "on_user_offline", e2.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e2.ON_PUBLISH_STREAM = "on_publish_stream", e2.ON_UPLINK_STATS = "on_uplink_stats", e2.ON_P2P_LOST = "on_p2p_lost", e2.ON_REMOVE_STREAM = "on_remove_stream", e2.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e2.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e2.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e2.ON_USER_BANNED = "on_user_banned", e2.ON_USER_LICENSE_BANNED = "on_user_license_banned", e2.ON_NOTIFICATION = "on_notification", e2.ON_CRYPT_ERROR = "on_crypt_error", e2.MUTE_AUDIO = "mute_audio", e2.MUTE_VIDEO = "mute_video", e2.UNMUTE_AUDIO = "unmute_audio", e2.UNMUTE_VIDEO = "unmute_video", e2.ON_P2P_OK = "on_p2p_ok", e2.RECEIVE_METADATA = "receive_metadata", e2.ON_DATA_STREAM = "on_data_stream", e2.ENABLE_LOCAL_VIDEO = "enable_local_video", e2.DISABLE_LOCAL_VIDEO = "disable_local_video", e2.ENABLE_LOCAL_AUDIO = "enable_local_audio", e2.DISABLE_LOCAL_AUDIO = "disable_local_audio", e2.ON_PUBLISHED_USER_LIST = "on_published_user_list";
    }(Df || (Df = {})), function(e2) {
      e2.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e2.NEED_ANSWER = "NEED_ANSWER", e2.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e2.P2P_LOST = "P2P_LOST", e2.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e2.NEED_UNPUB = "NEED_UNPUB", e2.NEED_UNSUB = "NEED_UNSUB", e2.NEED_UPLOAD = "NEED_UPLOAD", e2.NEED_CONTROL = "NEED_CONTROL", e2.START_RECONNECT = "START_RECONNECT", e2.END_RECONNECT = "END_RECONNECT", e2.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT";
    }(Pf || (Pf = {})), function(e2) {
      e2.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e2.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e2.ON_AUDIO_BUFFER = "on_audio_buffer", e2.UPDATE_SOURCE = "update_source";
    }(Lf || (Lf = {}));
    const jf = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, currentPacketLossRate: 0 }, Ff = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 }, Bf = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 }, Gf = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 }, Wf = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
    let Hf, Kf, Yf;
    !function(e2) {
      e2.CONNECTED = "websocket:connected", e2.RECONNECTING = "websocket:reconnecting", e2.WILL_RECONNECT = "websocket:will_reconnect", e2.CLOSED = "websocket:closed", e2.FAILED = "websocket:failed", e2.ON_MESSAGE = "websocket:on_message", e2.REQUEST_NEW_URLS = "websocket:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire";
    }(Hf || (Hf = {})), function(e2) {
      e2.TRANSCODE = "mix_streaming", e2.RAW = "raw_streaming", e2.INJECT = "inject_streaming";
    }(Kf || (Kf = {})), function(e2) {
      e2[e2.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e2[e2.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e2[e2.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e2[e2.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e2[e2.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e2[e2.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e2[e2.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e2[e2.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e2[e2.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN";
    }(Yf || (Yf = {}));
    const qf = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 }, Jf = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
    function Xf(e2, t2) {
      Xm(e2.url, "".concat(t2, ".url"), 1, 1e3, false), $m(e2.x) || qm(e2.x, "".concat(t2, ".x"), 0, 1e4), $m(e2.y) || qm(e2.y, "".concat(t2, ".y"), 0, 1e4), $m(e2.width) || qm(e2.width, "".concat(t2, ".width"), 0, 1e4), $m(e2.height) || qm(e2.height, "".concat(t2, ".height"), 0, 1e4), $m(e2.zOrder) || qm(e2.zOrder, "".concat(t2, ".zOrder"), 0, 255), $m(e2.alpha) || qm(e2.alpha, "".concat(t2, ".alpha"), 0, 1, false);
    }
    const zf = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" }, Qf = { audioBitrate: 48, audioChannels: 2, audioVolume: 100, audioSampleRate: 48e3, height: 0, width: 0, videoBitrate: 400, videoFramerate: 15, videoGop: 30 };
    let Zf, $f, eS, tS, iS, nS, rS, oS, sS, aS, cS, dS, uS, lS, hS, pS, _S, ES, mS, fS, SS;
    function TS(e2) {
      if (!e2.channelName)
        throw new SE(fE.INVALID_PARAMS, "invalid channelName in info");
      if ("number" != typeof e2.uid)
        throw new SE(fE.INVALID_PARAMS, "invalid uid in info, uid must be a number");
      return e2.token && Xm(e2.token, "info.token", 1, 2047), Zm(e2.uid), Qm(e2.channelName), true;
    }
    function gS(e2) {
      return Ym(e2, "mediaSource", ["screen", "window", "application"]), true;
    }
    !function(e2) {
      e2.WARNING = "@live_uap-warning", e2.ERROR = "@line_uap-error", e2.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e2.INJECT_STREAM_STATUS = "@live_uap-inject-status", e2.WORKER_STATUS = "@live_uap-worker-status", e2.REQUEST_NEW_ADDRESS = "@live_uap-request-address";
    }(Zf || (Zf = {})), function(e2) {
      e2.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager";
    }($f || ($f = {})), function(e2) {
      e2[e2.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e2[e2.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e2[e2.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e2[e2.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e2[e2.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e2[e2.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e2[e2.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e2[e2.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e2[e2.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e2[e2.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e2[e2.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e2[e2.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e2[e2.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e2[e2.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e2[e2.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e2[e2.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e2[e2.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";
    }(eS || (eS = {})), function(e2) {
      e2.CONNECT_FAILED = "connect failed", e2.CONNECT_TIMEOUT = "connect timeout", e2.WS_DISCONNECTED = "websocket disconnected", e2.REQUEST_TIMEOUT = "request timeout", e2.REQUEST_FAILED = "request failed", e2.WAIT_STATUS_TIMEOUT = "wait status timeout", e2.WAIT_STATUS_ERROR = "wait status error", e2.BAD_STATE = "bad state", e2.WS_ABORT = "ws abort", e2.AP_REQUEST_TIMEOUT = "AP request timeout", e2.AP_JSON_PARSE_ERROR = "AP json parse error", e2.AP_REQUEST_ERROR = "AP request error", e2.AP_REQUEST_ABORT = "AP request abort";
    }(tS || (tS = {})), function(e2) {
      e2[e2.SetSdkProfile = 0] = "SetSdkProfile", e2[e2.SetSourceChannel = 1] = "SetSourceChannel", e2[e2.SetSourceUserId = 2] = "SetSourceUserId", e2[e2.SetDestChannel = 3] = "SetDestChannel", e2[e2.StartPacketTransfer = 4] = "StartPacketTransfer", e2[e2.StopPacketTransfer = 5] = "StopPacketTransfer", e2[e2.UpdateDestChannel = 6] = "UpdateDestChannel", e2[e2.Reconnect = 7] = "Reconnect", e2[e2.SetVideoProfile = 8] = "SetVideoProfile";
    }(iS || (iS = {})), function(e2) {
      e2.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e2.NETWORK_CONNECTED = "NETWORK_CONNECTED", e2.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e2.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e2.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e2.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e2.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e2.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e2.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e2.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";
    }(nS || (nS = {})), function(e2) {
      e2.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e2.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e2.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e2.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE";
    }(rS || (rS = {})), function(e2) {
      e2.RELAY_OK = "RELAY_OK", e2.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e2.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e2.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED";
    }(oS || (oS = {})), function(e2) {
      e2.High = "high", e2.Low = "low", e2.Audio = "audio", e2.Screen = "screen", e2.ScreenLow = "screen_low";
    }(sS || (sS = {})), function(e2) {
      e2.DISCONNECT = "disconnect", e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.NETWORK_QUALITY = "network-quality", e2.STREAM_TYPE_CHANGE = "stream-type-change", e2.IS_P2P_DISCONNECTED = "is-p2p-dis", e2.DISCONNECT_P2P = "dis-p2p", e2.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e2.NEED_RENEW_SESSION = "need-sid", e2.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e2.JOIN_RESPONSE = "join-response", e2.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e2.RESET_CONNECTION_EVENTS = "reset-connection-events", e2.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e2.DATACHANNEL_FAILBACK = "datachannel_failback", e2.RESET_SIGNAL = "reset-signal";
    }(aS || (aS = {})), function(e2) {
      e2[e2.Nothing = 0] = "Nothing", e2[e2.Audio = 1] = "Audio", e2[e2.LwoVideo = 2] = "LwoVideo", e2[e2.Video = 4] = "Video", e2[e2.Data = 8] = "Data";
    }(cS || (cS = {})), function(e2) {
      e2[e2.websocket = 0] = "websocket", e2[e2.datachannel = 1] = "datachannel";
    }(dS || (dS = {})), function(e2) {
      e2.NEED_RENEGOTIATE = "@need_renegotiate", e2.NEED_REPLACE_TRACK = "@need_replace_track", e2.NEED_CLOSE = "@need_close", e2.NEED_ENABLE_TRACK = "@need_enable_track", e2.NEED_DISABLE_TRACK = "@need_disable_track", e2.NEED_SESSION_ID = "@need_sid", e2.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e2.GET_STATS = "@get_stats", e2.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e2.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e2.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e2.NEED_MUTE_TRACK = "@need_mute_track", e2.NEED_UNMUTE_TRACK = "@need_unmute_track";
    }(uS || (uS = {})), function(e2) {
      e2.SCREEN_TRACK = "screen_track", e2.CUSTOM_TRACK = "custome_track", e2.LOW_STREAM = "low_stream";
    }(lS || (lS = {})), function(e2) {
      e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
    }(hS || (hS = {})), function(e2) {
      e2[e2.HIGH_STREAM = 0] = "HIGH_STREAM", e2[e2.LOW_STREAM = 1] = "LOW_STREAM";
    }(pS || (pS = {})), function(e2) {
      e2[e2.DISABLE = 0] = "DISABLE", e2[e2.LOW_STREAM = 1] = "LOW_STREAM", e2[e2.AUDIO_ONLY = 2] = "AUDIO_ONLY";
    }(_S || (_S = {})), function(e2) {
      e2.TRANSCEIVER_UPDATED = "transceiver-updated";
    }(ES || (ES = {})), function(e2) {
      e2.SOURCE_STATE_CHANGE = "source-state-change", e2.TRACK_ENDED = "track-ended", e2.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e2.CLOSED = "closed";
    }(mS || (mS = {})), function(e2) {
      e2.FIRST_FRAME_DECODED = "first-frame-decoded", e2.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status";
    }(fS || (fS = {})), function(e2) {
      e2.CHINA = "CHINA", e2.ASIA = "ASIA", e2.NORTH_AMERICA = "NORTH_AMERICA", e2.EUROPE = "EUROPE", e2.JAPAN = "JAPAN", e2.INDIA = "INDIA", e2.KOREA = "KOREA", e2.HKMC = "HKMC", e2.US = "US", e2.OCEANIA = "OCEANIA", e2.SOUTH_AMERICA = "SOUTH_AMERICA", e2.AFRICA = "AFRICA", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "EXTENSIONS";
    }(SS || (SS = {}));
    const RS = [SS.AFRICA, SS.ASIA, SS.CHINA, SS.EUROPE, SS.GLOBAL, SS.INDIA, SS.JAPAN, SS.NORTH_AMERICA, SS.OCEANIA, SS.OVERSEA, SS.SOUTH_AMERICA];
    let IS;
    !function(e2) {
      e2.CHINA = "CN", e2.ASIA = "AS", e2.NORTH_AMERICA = "NA", e2.EUROPE = "EU", e2.JAPAN = "JP", e2.INDIA = "IN", e2.KOREA = "KR", e2.HKMC = "HK", e2.US = "US", e2.OCEANIA = "OC", e2.SOUTH_AMERICA = "SA", e2.AFRICA = "AF", e2.OVERSEA = "OVERSEA", e2.GLOBAL = "GLOBAL", e2.EXTENSIONS = "GLOBAL";
    }(IS || (IS = {}));
    const CS = { CHINA: {}, ASIA: { CODE: IS.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: IS.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: IS.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: IS.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "	uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: IS.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: IS.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: IS.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: IS.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: IS.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: IS.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: IS.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: IS.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: IS.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
    let vS, yS, AS, OS, NS, bS, wS, DS, PS, LS, kS, MS, US, xS, VS, jS, FS, BS, GS, WS2, HS, KS;
    wE && (CS.CHINA = { CODE: IS.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] }), function(e2) {
      e2.UPDATE_BITRATE_LIMIT = "update_bitrate_limit";
    }(vS || (vS = {}));
    class YS extends EE {
      constructor(e2, t2) {
        super(), _p(this, "onICEConnectionStateChange", void 0), _p(this, "onConnectionStateChange", void 0), _p(this, "onDTLSTransportStateChange", void 0), _p(this, "onDTLSTransportError", void 0), _p(this, "onICETransportStateChange", void 0), _p(this, "onFirstAudioReceived", void 0), _p(this, "onFirstVideoReceived", void 0), _p(this, "onFirstAudioDecoded", void 0), _p(this, "onFirstVideoDecoded", void 0), _p(this, "onFirstVideoDecodedTimeout", void 0), _p(this, "onSelectedLocalCandidateChanged", void 0), _p(this, "onSelectedRemoteCandidateChanged", void 0), _p(this, "establishPromise", void 0);
      }
    }
    !function(e2) {
      e2.SEND = "sendonly", e2.RECV = "recvonly", e2.SENDRECV = "sendrecv", e2.INACTIVE = "inactive";
    }(yS || (yS = {})), function(e2) {
      e2.VIDEO = "video", e2.AUDIO = "audio";
    }(AS || (AS = {})), function(e2) {
      e2[e2.UDP = 0] = "UDP", e2[e2.TCP = 1] = "TCP", e2[e2.RELAY = 2] = "RELAY";
    }(OS || (OS = {})), function(e2) {
      e2[e2.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", e2[e2.TCP_RESTART = 1] = "TCP_RESTART", e2[e2.RELAY_RESTART = 2] = "RELAY_RESTART", e2[e2.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", e2[e2.OLD_RESTART = 11] = "OLD_RESTART", e2[e2.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED";
    }(NS || (NS = {})), function(e2) {
      e2.LocalVideoTrack = "videoTrack", e2.LocalAudioTrack = "audioTrack", e2.LocalVideoLowTrack = "videoLowTrack";
    }(bS || (bS = {})), function(e2) {
      e2.New = "new", e2.Connected = "connected", e2.Reconnecting = "reconnecting", e2.Disconnected = "disconnected";
    }(wS || (wS = {})), function(e2) {
      e2.StateChange = "stateChange", e2.IceConnectionStateChange = "iceConnectionStateChange", e2.RequestMuteLocal = "requestMuteLocal", e2.RequestUnmuteLocal = "requestUnmuteLocal", e2.RequestRePublish = "requestRePublish", e2.RequestReSubscribe = "requestReSubscribe", e2.RequestUploadStats = "requestUploadStats", e2.MediaReconnectStart = "MediaReconnectStart", e2.MediaReconnectEnd = "MediaReconnectEnd", e2.NeedSignalRTT = "NeedSignalRTT", e2.RequestRestartICE = "RequestRestartIce", e2.PeerConnectionStateChange = "PeerConnectionStateChange", e2.RequestReconnect = "RequestReconnect", e2.RequestReconnectPC = "RequestReconnectPC", e2.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e2.P2PLost = "P2PLost", e2.UpdateVideoEncoder = "UpdateVideoEncoder", e2.ConnectionTypeChange = "ConnectionTypeChange", e2.RequestLowStreamParameter = "RequestLowStreamParameter", e2.QueryClientConnectionState = "QueryClientConnectionState";
    }(DS || (DS = {})), function(e2) {
      e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
    }(PS || (PS = {})), function(e2) {
      e2.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e2.ONLINE = "ONLINE", e2.OFFLINE = "OFFLINE";
    }(LS || (LS = {})), function(e2) {
      e2.ON_TRACK = "on_track", e2.ON_NODE = "on_node";
    }(kS || (kS = {})), function(e2) {
      e2.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e2.REQUEST_CONSTRAINTS = "request_constraints";
    }(MS || (MS = {})), function(e2) {
      e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
    }(US || (US = {})), function(e2) {
      e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
    }(xS || (xS = {})), function(e2) {
      e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
    }(VS || (VS = {})), function(e2) {
      e2.NETWORK_ERROR = "NETWORK_ERROR", e2.SERVER_ERROR = "SERVER_ERROR", e2.MULTI_IP = "MULTI_IP", e2.TIMEOUT = "TIMEOUT", e2.OFFLINE = "OFFLINE", e2.LEAVE = "LEAVE", e2.P2P_FAILED = "P2P_FAILED", e2.FALLBACK = "FALLBACK";
    }(jS || (jS = {})), function(e2) {
      e2.CONNECTED = "transmitter:connected", e2.RECONNECTING = "transmitter:reconnecting", e2.WILL_RECONNECT = "transmitter:will_reconnect", e2.CLOSED = "transmitter:closed", e2.FAILED = "transmitter:failed", e2.ON_MESSAGE = "transmitter:on_message", e2.REQUEST_NEW_URLS = "transmitter:request_new_urls", e2.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e2.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e2.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e2.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e2.FAILBACK = "transmitter:failback";
    }(FS || (FS = {})), function(e2) {
      e2.CAMERA_CHANGED = "camera-changed", e2.MICROPHONE_CHANGED = "microphone-changed", e2.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", e2.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", e2.AUTOPLAY_FAILED = "autoplay-failed", e2.SECURITY_POLICY_VIOLATION = "security-policy-violation";
    }(BS || (BS = {})), function(e2) {
      e2[e2.APP_TYPE_INVALID_VALUE = -1] = "APP_TYPE_INVALID_VALUE", e2[e2.APP_TYPE_NATIVE = 0] = "APP_TYPE_NATIVE", e2[e2.APP_TYPE_NATIVE_COCOS = 1] = "APP_TYPE_NATIVE_COCOS", e2[e2.APP_TYPE_NATIVE_UNITY = 2] = "APP_TYPE_NATIVE_UNITY", e2[e2.APP_TYPE_NATIVE_ELECTRON = 3] = "APP_TYPE_NATIVE_ELECTRON", e2[e2.APP_TYPE_NATIVE_FLUTTER = 4] = "APP_TYPE_NATIVE_FLUTTER", e2[e2.APP_TYPE_NATIVE_UNREAL = 5] = "APP_TYPE_NATIVE_UNREAL", e2[e2.APP_TYPE_NATIVE_XAMARIN = 6] = "APP_TYPE_NATIVE_XAMARIN", e2[e2.APP_TYPE_NATIVE_API_CLOUD = 7] = "APP_TYPE_NATIVE_API_CLOUD", e2[e2.APP_TYPE_NATIVE_REACT_NATIVE = 8] = "APP_TYPE_NATIVE_REACT_NATIVE", e2[e2.APP_TYPE_NATIVE_PYTHON = 9] = "APP_TYPE_NATIVE_PYTHON", e2[e2.APP_TYPE_NATIVE_COCOS_CREATOR = 10] = "APP_TYPE_NATIVE_COCOS_CREATOR", e2[e2.APP_TYPE_NATIVE_RUST = 11] = "APP_TYPE_NATIVE_RUST", e2[e2.APP_TYPE_NATIVE_C_SHARP = 12] = "APP_TYPE_NATIVE_C_SHARP", e2[e2.APP_TYPE_NATIVE_CEF = 13] = "APP_TYPE_NATIVE_CEF", e2[e2.APP_TYPE_NATIVE_UNI_APP = 14] = "APP_TYPE_NATIVE_UNI_APP", e2[e2.APP_TYPE_WEBRTC = 1e3] = "APP_TYPE_WEBRTC", e2[e2.APP_TYPE_WEBRTC_REACT = 1001] = "APP_TYPE_WEBRTC_REACT", e2[e2.APP_TYPE_WEBRTC_VUE = 1002] = "APP_TYPE_WEBRTC_VUE", e2[e2.APP_TYPE_WEBRTC_ANGULAR = 1003] = "APP_TYPE_WEBRTC_ANGULAR";
    }(GS || (GS = {})), function(e2) {
      e2.CONNECTING = "CONNECTING", e2.RECONNECTING = "RECONNECTING", e2.CONNECTED = "CONNECTED", e2.CLOSED = "CLOSED";
    }(WS2 || (WS2 = {})), function(e2) {
      e2.CONNECTION_STATE_CHANGE = "connection-state-change", e2.STATE_CHANGE = "state-change", e2.INSPECT_RESULT = "inspect-result", e2.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e2.REQUEST_NEW_WORKER_URL = "request-new-worker-url";
    }(HS || (HS = {})), function(e2) {
      e2[e2.CONNECT_AP = 0] = "CONNECT_AP", e2[e2.AP_CONNECTED = 1] = "AP_CONNECTED", e2[e2.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e2[e2.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e2[e2.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e2[e2.CONNECT_WORKER = 5] = "CONNECT_WORKER", e2[e2.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e2[e2.CLOSED = 7] = "CLOSED";
    }(KS || (KS = {}));
    const qS = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false };
    function JS() {
      return qS;
    }
    let XS;
    !function(e2) {
      e2[e2.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e2[e2.CLOUD_PROXY = 18] = "CLOUD_PROXY", e2[e2.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e2[e2.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK";
    }(XS || (XS = {}));
    var zS = k2, QS = Array.isArray || function(e2) {
      return "Array" == zS(e2);
    }, ZS = h2, $S = QS, eT = oc, tT = q, iT = rt("species"), nT = ZS.Array, rT = function(e2) {
      var t2;
      return $S(e2) && (t2 = e2.constructor, (eT(t2) && (t2 === nT || $S(t2.prototype)) || tT(t2) && null === (t2 = t2[iT])) && (t2 = void 0)), void 0 === t2 ? nT : t2;
    }, oT = function(e2, t2) {
      return new (rT(e2))(0 === t2 ? 0 : t2);
    }, sT = Wt, aT = F2, cT = je, dT = bi, uT = oT, lT = d([].push), hT = function(e2) {
      var t2 = 1 == e2, i3 = 2 == e2, n2 = 3 == e2, r2 = 4 == e2, o2 = 6 == e2, s2 = 7 == e2, a2 = 5 == e2 || o2;
      return function(c2, d2, u2, l2) {
        for (var h3, p3, _2 = cT(c2), E2 = aT(_2), m2 = sT(d2, u2), f2 = dT(E2), S2 = 0, T2 = l2 || uT, g2 = t2 ? T2(c2, f2) : i3 || s2 ? T2(c2, 0) : void 0; f2 > S2; S2++)
          if ((a2 || S2 in E2) && (p3 = m2(h3 = E2[S2], S2, _2), e2))
            if (t2)
              g2[S2] = p3;
            else if (p3)
              switch (e2) {
                case 3:
                  return true;
                case 5:
                  return h3;
                case 6:
                  return S2;
                case 2:
                  lT(g2, h3);
              }
            else
              switch (e2) {
                case 4:
                  return false;
                case 7:
                  lT(g2, h3);
              }
        return o2 ? -1 : n2 || r2 ? r2 : g2;
      };
    }, pT = { forEach: hT(0), map: hT(1), filter: hT(2), some: hT(3), every: hT(4), find: hT(5), findIndex: hT(6), filterReject: hT(7) }, _T = pT.forEach, ET = Vi("forEach") ? [].forEach : function(e2) {
      return _T(this, e2, arguments.length > 1 ? arguments[1] : void 0);
    };
    Ii({ target: "Array", proto: true, forced: [].forEach != ET }, { forEach: ET });
    var mT = Hi("Array").forEach, fT = Zr, ST = Ge, TT = u, gT = mT, RT = Array.prototype, IT = { DOMTokenList: true, NodeList: true }, CT = function(e2) {
      var t2 = e2.forEach;
      return e2 === RT || TT(RT, e2) && t2 === RT.forEach || ST(IT, fT(e2)) ? gT : t2;
    }, vT = je, yT = hr;
    Ii({ target: "Object", stat: true, forced: i2(function() {
      yT(1);
    }) }, { keys: function(e2) {
      return yT(vT(e2));
    } });
    var AT = J.Object.keys, OT = Xi, NT = Ii, bT = QS, wT = d([].reverse), DT = [1, 2];
    NT({ target: "Array", proto: true, forced: String(DT) === String(DT.reverse()) }, { reverse: function() {
      return bT(this) && (this.length = this.length), wT(this);
    } });
    var PT = Hi("Array").reverse, LT = u, kT = PT, MT = Array.prototype, UT = function(e2) {
      var t2 = e2.reverse;
      return e2 === MT || LT(MT, e2) && t2 === MT.reverse ? kT : t2;
    }, xT = i2, VT = ae, jT = rt("species"), FT = function(e2) {
      return VT >= 51 || !xT(function() {
        var t2 = [];
        return (t2.constructor = {})[jT] = function() {
          return { foo: 1 };
        }, 1 !== t2[e2](Boolean).foo;
      });
    }, BT = Ii, GT = h2, WT2 = QS, HT = oc, KT = q, YT = Un, qT = bi, JT = K, XT = im, zT = rt, QT = pc, ZT = FT("slice"), $T = zT("species"), eg = GT.Array, tg = Math.max;
    BT({ target: "Array", proto: true, forced: !ZT }, { slice: function(e2, t2) {
      var i3, n2, r2, o2 = JT(this), s2 = qT(o2), a2 = YT(e2, s2), c2 = YT(void 0 === t2 ? s2 : t2, s2);
      if (WT2(o2) && (i3 = o2.constructor, (HT(i3) && (i3 === eg || WT2(i3.prototype)) || KT(i3) && null === (i3 = i3[$T])) && (i3 = void 0), i3 === eg || void 0 === i3))
        return QT(o2, a2, c2);
      for (n2 = new (void 0 === i3 ? eg : i3)(tg(c2 - a2, 0)), r2 = 0; a2 < c2; a2++, r2++)
        a2 in o2 && XT(n2, r2, o2[a2]);
      return n2.length = r2, n2;
    } });
    var ig = Hi("Array").slice, ng = u, rg = ig, og = Array.prototype, sg = function(e2) {
      var t2 = e2.slice;
      return e2 === og || ng(og, e2) && t2 === og.slice ? rg : t2;
    };
    function ag(e2, t2, i3, n2, r2) {
      var o2, s2, a2, c2 = {};
      return CT(o2 = AT(n2)).call(o2, function(e3) {
        c2[e3] = n2[e3];
      }), c2.enumerable = !!c2.enumerable, c2.configurable = !!c2.configurable, ("value" in c2 || c2.initializer) && (c2.writable = true), c2 = OT(s2 = UT(a2 = sg(i3).call(i3)).call(a2)).call(s2, function(i4, n3) {
        return n3(e2, t2, i4) || i4;
      }, c2), r2 && void 0 !== c2.initializer && (c2.value = c2.initializer ? c2.initializer.call(r2) : void 0, c2.initializer = void 0), void 0 === c2.initializer && (pp(e2, t2, c2), c2 = null), c2;
    }
    var cg = Hi("Array").keys, dg = Zr, ug = Ge, lg = u, hg = cg, pg = Array.prototype, _g = { DOMTokenList: true, NodeList: true }, Eg = function(e2) {
      var t2 = e2.keys;
      return e2 === pg || lg(pg, e2) && t2 === pg.keys || ug(_g, dg(e2)) ? hg : t2;
    };
    function mg(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function fg(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? mg(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : mg(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let Sg = 0, Tg = 0;
    function gg(e2, t2, i3, n2) {
      return new Sl((r2, o2) => {
        t2.timeout = t2.timeout || GE("HTTP_CONNECT_TIMEOUT"), t2.responseType = t2.responseType || "json", t2.data && !i3 ? (t2.data = JSON.stringify(t2.data), Sg += XI(t2.data)) : i3 && (t2.data.size ? Sg += t2.data.size : t2.data instanceof FormData ? Sg += function(e3) {
          let t3 = 0;
          /DingTalk/i.test(navigator.userAgent) && e3.realFormData && (e3 = e3.realFormData);
          return e3.forEach((e4) => {
            t3 += "string" == typeof e4 ? XI(e4) : e4.size;
          }), t3 + 138;
        }(t2.data) : Sg += XI(JSON.stringify(t2.data))), t2.headers = t2.headers || {}, t2.headers["Content-Type"] = t2.headers["Content-Type"] || "application/json", t2.method = "POST", t2.url = e2, pE.request(t2).then((e3) => {
          "string" == typeof e3.data ? Tg += XI(e3.data) : e3.data instanceof ArrayBuffer || e3.data instanceof Uint8Array ? Tg += e3.data.byteLength : Tg += XI(JSON.stringify(e3.data)), n2 && r2({ data: e3.data, headers: e3.headers }), r2(e3.data);
        }).catch((e3) => {
          pE.isCancel(e3) ? o2(new SE(fE.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e3.code ? o2(new SE(fE.NETWORK_TIMEOUT, e3.message)) : e3.response ? o2(new SE(fE.NETWORK_RESPONSE_ERROR, e3.response.status)) : o2(new SE(fE.NETWORK_ERROR, e3.message));
        });
      });
    }
    async function Rg(e2, t2) {
      const i3 = new Blob([t2.data], { type: "buffer" });
      return await gg(e2, fg(fg({}, t2), {}, { data: i3, headers: { "Content-Type": "application/octet-stream" } }), true);
    }
    const Ig = new class extends EE {
      set networkState(e2) {
        OE.info("[".concat(this._moduleName, "]") + "network state changed, " + this._networkState + " -> " + e2), this.emit(LS.NETWORK_STATE_CHANGE, e2, this._networkState), e2 === PS.ONLINE ? this.emit(LS.ONLINE) : e2 === PS.OFFLINE && (this.onlineWaiter = new Sl((e3) => {
          this.once(LS.ONLINE, () => {
            this.onlineWaiter = void 0, e3(PS.ONLINE);
          });
        }), this.emit(LS.OFFLINE)), this._networkState = e2;
      }
      get networkState() {
        return this._networkState;
      }
      constructor() {
        super(), _p(this, "_moduleName", "network-indicator"), _p(this, "_networkState", PS.ONLINE), _p(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
          this.networkState = PS.ONLINE;
        }), window.addEventListener("offline", () => {
          this.networkState = PS.OFFLINE;
        });
      }
    }();
    let Cg = false;
    const vg = new class extends EE {
      constructor() {
        super(...arguments), _p(this, "onAutoplayFailed", void 0), _p(this, "onAudioAutoplayFailed", void 0);
      }
    }();
    function yg() {
      if (xh(), !Cg) {
        const e2 = (t2) => {
          t2.preventDefault(), Cg = false, sp() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
        };
        Cg = true, sp() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), OE.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), vg.onAutoplayFailed ? vg.onAutoplayFailed() : vg.onAudioAutoplayFailed ? OE.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : OE.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), vg.emit("autoplay-failed");
      }
    }
    function Ag(e2) {
      return new TextEncoder().encode(e2);
    }
    const Og = function(e2, t2) {
      const i3 = new Uint8Array(e2.byteLength + t2.byteLength);
      return i3.set(new Uint8Array(e2), 0), i3.set(new Uint8Array(t2), e2.byteLength), i3;
    };
    const Ng = async (e2) => function(e3, t2) {
      let i3 = "";
      return new Uint8Array(e3).forEach((e4) => {
        i3 += e4.toString(t2).padStart(2, "0");
      }), i3;
    }(await crypto.subtle.digest("SHA-256", Ag(e2)), 16);
    function bg(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function wg(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? bg(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : bg(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    function Dg() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return function(t2, i3, n2) {
        const r2 = n2.value;
        if ("function" == typeof r2) {
          const o2 = e2.className || t2.__className__ || ("AgoraRTCClient" === t2.constructor.name ? "Client" : t2.constructor.name);
          n2.value = function() {
            for (var t3 = arguments.length, n3 = new Array(t3), s2 = 0; s2 < t3; s2++)
              n3[s2] = arguments[s2];
            let a2 = n3;
            if (e2.argsMap)
              try {
                a2 = e2.argsMap(this, ...n3);
              } catch (e3) {
                OE.warning(e3), a2 = [];
              }
            try {
              JSON.stringify(a2);
            } catch (e3) {
              OE.warning("arguments for method ".concat(o2, ".").concat(String(i3), " not serializable for apiInvoke.")), a2 = [];
            }
            const c2 = (e2.report || Pg).reportApiInvoke(this._sessionId || null, { name: "".concat(o2, ".").concat(String(i3)), options: a2, tag: Ef.TRACER, reportResult: e2.reportResult }, e2.throttleTime);
            try {
              const t4 = r2.apply(this, n3);
              return t4 instanceof Sl ? t4.then((t5) => (c2.onSuccess(e2.reportResult && t5), t5)).catch((e3) => {
                throw c2.onError(e3), e3;
              }) : (c2.onSuccess(e2.reportResult && t4), t4);
            } catch (e3) {
              throw c2.onError(e3), e3;
            }
          };
        }
        return n2;
      };
    }
    const Pg = new class {
      constructor() {
        _p(this, "baseInfoMap", /* @__PURE__ */ new Map()), _p(this, "proxyServer", void 0), _p(this, "clientList", zE), _p(this, "eventUploadTimer", void 0), _p(this, "setSessionIdTimer", void 0), _p(this, "url", void 0), _p(this, "backupUrl", void 0), _p(this, "_appId", void 0), _p(this, "keyEventUploadPendingItems", []), _p(this, "normalEventUploadPendingItems", []), _p(this, "apiInvokeUploadPendingItems", []), _p(this, "apiInvokeCount", 0), _p(this, "ltsList", []), _p(this, "lastSendNormalEventTime", Date.now()), _p(this, "customReportCounterTimer", void 0), _p(this, "customReportCount", 0), _p(this, "extApiInvoke", async (e2) => {
          for (const t2 of e2) {
            const e3 = wg(wg({}, t2), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: Ef.TRACER });
            this.sendApiInvoke(e3);
          }
        }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), GE("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), GE("EVENT_REPORT_SEND_INTERVAL"));
      }
      adjustSessionStartTime(e2) {
        if (!this.baseInfoMap.has(e2) && !this.baseInfoMap.get(e2))
          return void OE.error("adjust session ".concat(e2, " start time, sid is not exist or info is undefined"));
        const t2 = this.baseInfoMap.get(e2), i3 = Date.now(), n2 = t2.startTime;
        t2.startTime = i3, OE.debug("rewrite session ".concat(e2, " startTime: ").concat(i3, " , ").concat(i3 - n2, "ms")), this.baseInfoMap.set(e2, t2);
      }
      setAppId(e2) {
        this._appId = e2;
      }
      reportApiInvoke(e2, t2, i3) {
        t2.timeout = t2.timeout || 6e4, t2.reportResult = void 0 === t2.reportResult || t2.reportResult;
        const n2 = Date.now();
        this.apiInvokeCount += 1;
        const r2 = this.apiInvokeCount, o2 = () => ({ tag: t2.tag, invokeId: r2, sid: e2, name: t2.name, apiInvokeTime: n2, options: t2.options, states: t2.states || null }), s2 = !!GE("SHOW_REPORT_INVOKER_LOG");
        s2 && OE.info("".concat(t2.name, " start"), t2.options);
        let a2 = false;
        zI(t2.timeout).then(() => {
          a2 || (this.sendApiInvoke(wg(wg({}, o2()), {}, { error: fE.API_INVOKE_TIMEOUT, success: false })), OE.debug("".concat(t2.name, " timeout")));
        });
        const c2 = new SE(fE.UNEXPECTED_ERROR, "".concat(t2.name, ": this api invoke is end"));
        return { onSuccess: (e3) => {
          const n3 = () => {
            if (a2)
              throw c2;
            return a2 = true, this.sendApiInvoke(wg(wg({}, o2()), {}, { success: true }, t2.reportResult && { result: e3 })), s2 && OE.info("".concat(t2.name, " onSuccess")), e3;
          };
          return i3 ? mC(n3, t2.name + "Success", i3, () => a2 = true) : n3();
        }, onError: (e3) => {
          const n3 = () => {
            if (a2)
              throw e3;
            a2 = true, this.sendApiInvoke(wg(wg({}, o2()), {}, { success: false, error: e3 })), s2 && OE.info("".concat(t2.name, " onFailure"), e3.toString());
          };
          return i3 ? mC(n3, t2.name + "Error", i3, () => a2 = true) : n3();
        } };
      }
      sessionInit(e2, t2) {
        if (this.baseInfoMap.has(e2))
          return;
        const i3 = Date.now(), n2 = this.createBaseInfo(e2, i3);
        n2.cname = t2.cname;
        const r2 = Object.assign({}, { willUploadConsoleLog: GE("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: wE ? "global" : "oversea", areas: GE("AREAS") && GE("AREAS").join(",") }, t2.extend), o2 = Date.now(), s2 = wg(wg({}, n2), {}, { eventType: uf.SESSION_INIT, appid: t2.appid, browser: navigator.userAgent, build: NE, lts: o2, elapse: o2 - i3, extend: JSON.stringify(r2), mode: t2.mode, process: GE("PROCESS_ID"), appType: GE("APP_TYPE"), success: true, version: bE });
        this.send({ type: lf.SESSION, data: s2 }, true);
      }
      joinChooseServer(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.JOIN_CHOOSE_SERVER, lts: r2, eventElapse: r2 - t2.lts, chooseServerAddr: t2.csAddr, errorCode: t2.ec, elapse: r2 - i3.startTime, success: t2.succ, chooseServerAddrList: JSON.stringify(t2.serverList), uid: t2.uid ? parseInt(t2.uid) : null, cid: t2.cid ? parseInt(t2.cid) : null, chooseServerIp: t2.csIp || "", opid: t2.opid, unilbsServerIds: t2.unilbsServerIds, extend: t2.extend || void 0, isHttp3: t2.isHttp3 });
        this.send({ type: lf.JOIN_CHOOSE_SERVER, data: o2 }, true);
      }
      reqUserAccount(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.REQ_USER_ACCOUNT, lts: r2, success: t2.success, serverAddress: t2.serverAddr, stringUid: t2.stringUid, uid: t2.uid, errorCode: t2.errorCode, elapse: r2 - i3.startTime, eventElapse: r2 - t2.lts, extend: JSON.stringify(t2.extend) });
        this.send({ type: lf.REQ_USER_ACCOUNT, data: o2 }, true);
      }
      joinGateway(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info;
        t2.vid && (n2.vid = t2.vid), n2.uid = t2.uid, n2.cid = t2.cid;
        const r2 = Date.now(), { firstSuccess: o2, avoidJoinStartTime: s2, isProxy: a2, addr: c2 } = t2, d2 = r2 - (o2 && s2 ? s2 : i3.startTime), u2 = wg(wg({}, n2), {}, { eventType: uf.JOIN_GATEWAY, lts: r2, gatewayAddr: t2.addr, success: t2.succ, errorCode: t2.ec, elapse: d2, eventElapse: r2 - t2.lts, firstSuccess: o2, signalChannel: t2.signalChannel }), l2 = u2.success ? 1 : 0;
        if (t2.succ && (i3.lastJoinSuccessTime = r2), o2)
          this.send({ type: lf.JOIN_GATEWAY, data: u2 }, true);
        else {
          let e3;
          if (c2)
            if (a2) {
              const t4 = c2.match(/h=(\d{1,3}-){3}\d{1,3}/g), i4 = c2.match(/p=[0-9]{1,6}/g);
              e3 = { isSuccess: l2, gatewayIp: t4 && t4.length ? t4[0].split("=")[1].replace(/-/g, ".") : "", port: i4 && i4.length ? i4[0].split("=")[1] : "", isProxy: a2 ? 1 : 0 };
            } else {
              const t4 = c2.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), i4 = c2.match(/:[0-9]{1,6}/g);
              e3 = { isSuccess: l2, gatewayIp: t4 && t4.length ? t4[0].split("//")[1].replace(/-/g, ".") : "", port: i4 && i4.length ? i4[0].split(":")[1] : "", isProxy: a2 ? 1 : 0 };
            }
          else
            e3 = { isSuccess: l2, gatewayIp: "", port: "", isProxy: a2 ? 1 : 0 };
          delete u2.success, delete u2.eventType, delete u2.firstSuccess, u2.vid = Number(u2.vid);
          const t3 = Object.assign({}, u2, e3, { eventType: uf.REJOIN_GATEWAY });
          this.send({ type: lf.RE_JOIN_GATEWAY, data: t3 }, true);
        }
      }
      joinChannelTimeout(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = Date.now(), r2 = wg(wg({}, i3.info), {}, { lts: n2, timeout: t2, elapse: n2 - i3.startTime });
        this.send({ type: lf.JOIN_CHANNEL_TIMEOUT, data: r2 }, true);
      }
      publish(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.PUBLISH, lts: r2, eventElapse: t2.eventElapse, elapse: r2 - i3.startTime, success: t2.succ, errorCode: t2.ec, videoName: t2.videoName, audioName: t2.audioName, screenName: t2.screenName, screenshare: t2.screenshare, audio: t2.audio, video: t2.video, p2pid: t2.p2pid, publishRequestid: t2.publishRequestid });
        this.send({ type: lf.PUBLISH, data: o2 }, true);
      }
      subscribe(e2, t2, i3) {
        const n2 = this.baseInfoMap.get(e2);
        if (!n2)
          return;
        const r2 = n2.info, o2 = Date.now(), s2 = wg(wg({}, r2), {}, { eventType: uf.SUBSCRIBE, lts: o2, eventElapse: t2.eventElapse, elapse: o2 - n2.startTime, success: t2.succ, errorCode: t2.ec, video: t2.video, audio: t2.audio, subscribeRequestid: t2.subscribeRequestid, p2pid: t2.p2pid }, i3 && { extend: JSON.stringify({ isMassSubscribe: true }) });
        "string" == typeof t2.peerid ? s2.peerSuid = t2.peerid : s2.peer = t2.peerid, this.send({ type: lf.SUBSCRIBE, data: s2 }, true);
      }
      wsCompressorInit(e2) {
        var t2;
        const i3 = [...Eg(t2 = this.baseInfoMap).call(t2)], n2 = i3.length ? i3[0] : "UnableToGetSid", r2 = this.baseInfoMap.get(n2);
        if (!r2)
          return;
        const o2 = r2.info, s2 = Date.now(), a2 = wg(wg({}, o2), {}, { eventType: uf.WS_COMPRESSOR_INIT, lts: s2, eventElapse: e2.eventElapse, elapse: s2 - r2.startTime, status: e2.status ? 1 : 2 });
        this.send({ type: lf.WS_COMPRESSOR_INIT, data: a2 }, true);
      }
      firstRemoteVideoDecode(e2, t2, i3, n2) {
        const r2 = this.baseInfoMap.get(e2);
        if (!r2)
          return;
        const o2 = r2.info, s2 = Date.now(), a2 = wg(wg(wg({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2, firstDecodeFrame: Math.max(s2 - r2.startTime, 0), apEnd: Math.max(n2.apEnd - r2.startTime, 0), apStart: Math.max(n2.apStart - r2.startTime, 0), joinGwEnd: Math.max(n2.joinGwEnd - r2.startTime, 0), joinGwStart: Math.max(n2.joinGwStart - r2.startTime, 0), pcEnd: Math.max(n2.pcEnd - r2.startTime, 0), pcStart: Math.max(n2.pcStart - r2.startTime, 0), subscriberEnd: Math.max(n2.subscriberEnd - r2.startTime, 0), subscriberStart: Math.max(n2.subscriberStart - r2.startTime, 0), videoAddNotify: Math.max(n2.videoAddNotify - r2.startTime, 0) });
        this.send({ type: i3, data: a2 }, true);
      }
      firstRemoteFrame(e2, t2, i3, n2) {
        const r2 = this.baseInfoMap.get(e2);
        if (!r2)
          return;
        const o2 = r2.info, s2 = Date.now(), a2 = wg(wg(wg({}, o2), n2), {}, { elapse: s2 - r2.startTime, eventType: t2, lts: s2 });
        this.send({ type: i3, data: a2 }, true);
      }
      pcStats(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { vid: void 0 === n2.vid ? 0 : Number(n2.vid), elapse: r2 - i3.startTime, eventType: uf.PC_STATS, lts: r2 });
        this.send({ type: lf.PC_STATS, data: o2 }, true);
      }
      onGatewayStream(e2, t2, i3, n2) {
        const r2 = this.baseInfoMap.get(e2);
        if (!r2)
          return;
        const o2 = r2.info, s2 = Date.now(), a2 = wg(wg(wg({}, o2), n2), {}, { eventType: t2, lts: s2 });
        this.send({ type: i3, data: a2 }, true);
      }
      streamSwitch(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.STREAM_SWITCH, lts: r2, isDual: t2.isdual, elapse: r2 - i3.startTime, success: t2.succ });
        this.send({ type: lf.STREAM_SWITCH, data: o2 }, true);
      }
      requestProxyAppCenter(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.REQUEST_PROXY_APPCENTER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i3.startTime, APAddr: t2.APAddr, workerManagerList: t2.workerManagerList, response: t2.response, errorCode: t2.ec, success: t2.succ });
        this.send({ type: lf.REQUEST_PROXY_APPCENTER, data: o2 }, true);
      }
      requestProxyWorkerManager(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { eventType: uf.REQUEST_PROXY_WORKER_MANAGER, lts: r2, eventElapse: r2 - t2.lts, elapse: r2 - i3.startTime, workerManagerAddr: t2.workerManagerAddr, response: t2.response, errorCode: t2.ec, success: t2.succ });
        this.send({ type: lf.REQUEST_PROXY_WORKER_MANAGER, data: o2 }, true);
      }
      setProxyServer(e2) {
        this.proxyServer = e2, e2 ? OE.debug("reportProxyServerurl: ".concat(e2)) : OE.debug("disable reportProxyServerurl: ".concat(e2));
      }
      peerPublishStatus(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg({}, n2), {}, { subscribeElapse: t2.subscribeElapse, peer: t2.peer, peerPublishDuration: Math.max(t2.audioPublishDuration, t2.videoPublishDuration), audiotag: t2.audioPublishDuration > 0 ? 1 : -1, videotag: t2.videoPublishDuration > 0 ? 1 : -1, lts: r2, elapse: r2 - i3.startTime, joinChannelSuccessElapse: r2 - (i3.lastJoinSuccessTime || r2), peerPublishDurationVideo: t2.videoPublishDuration, peerPublishDurationAudio: t2.audioPublishDuration });
        this.send({ type: lf.PEER_PUBLISH_STATUS, data: o2 }, true);
      }
      workerEvent(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now();
        (function(e3, t3, i4) {
          const n3 = e3[t3];
          if (!n3 || "string" != typeof n3)
            return [e3];
          e3[t3] = "";
          const r3 = XI(JSON.stringify(e3));
          let o2 = 0;
          const s2 = [];
          let a2 = 0;
          for (let c2 = 0; c2 < n3.length; c2++)
            a2 += n3.charCodeAt(c2) <= 127 ? 1 : 3, a2 <= i4 - r3 || (s2[s2.length] = JI(JI({}, e3), {}, { [t3]: n3.substring(o2, c2) }), o2 = c2, a2 = n3.charCodeAt(c2) <= 127 ? 1 : 3);
          o2 !== n3.length - 1 && (s2[s2.length] = JI(JI({}, e3), {}, { [t3]: n3.substring(o2) }));
          return s2;
        })(wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2, productType: "WebRTC" }), "payload", 1300).forEach((e3) => this.send({ type: lf.WORKER_EVENT, data: e3 }, true));
      }
      apworkerEvent(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2 });
        this.send({ type: lf.AP_WORKER_EVENT, data: o2 }, true);
      }
      joinWebProxyAP(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2, extend: t2.extend || void 0 });
        this.send({ type: lf.JOIN_WEB_PROXY_AP, data: o2 }, true);
      }
      WebSocketQuit(e2, t2) {
        const i3 = this.baseInfoMap.get(e2);
        if (!i3)
          return;
        const n2 = i3.info, r2 = Date.now(), o2 = wg(wg(wg({}, n2), t2), {}, { elapse: r2 - i3.startTime, lts: r2 });
        this.send({ type: lf.WEBSOCKET_QUIT, data: o2 }, true);
      }
      async sendCustomReportMessage(e2, t2) {
        if (this.customReportCount += t2.length, this.customReportCount > GE("CUSTOM_REPORT_LIMIT"))
          throw new SE(fE.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
        this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
          this.customReportCount = 0;
        }, 5e3));
        const i3 = Date.now(), n2 = t2.map((t3) => ({ type: lf.USER_ANALYTICS, data: wg(wg({ sid: e2 }, t3), {}, { lts: i3 }) }));
        try {
          GE("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(n2) : await this.postDataToStatsCollector(n2);
        } catch (e3) {
          throw OE.error("send custom report message failed", e3.toString()), new SE(fE.CUSTOM_REPORT_SEND_FAILED, e3.message);
        }
      }
      autoplayFailed(e2, t2, i3, n2) {
        if (!e2)
          return;
        const r2 = this.baseInfoMap.get(e2);
        if (!r2)
          return;
        const o2 = r2.info, s2 = Date.now(), a2 = wg(wg({}, o2), {}, { vid: void 0 === o2.vid ? 0 : Number(o2.vid), lts: s2, elapse: s2 - r2.startTime, cbRegistered: vg.onAutoplayFailed || vg.onAudioAutoplayFailed ? 1 : -1, errorMsg: i3, mediaType: t2, trackId: n2, extend: void 0 });
        this.send({ type: lf.AUTOPLAY_FAILED, data: a2 }, true);
      }
      sendApiInvoke(e2) {
        const t2 = GE("NOT_REPORT_EVENT");
        if (e2.tag && t2.includes && t2.includes(e2.tag))
          return false;
        if (null === e2.sid)
          return this.apiInvokeUploadPendingItems.push(e2), false;
        const i3 = this.baseInfoMap.get(e2.sid);
        if (!i3)
          return this.apiInvokeUploadPendingItems.push(e2), false;
        const { cname: n2, uid: r2, cid: o2 } = i3.info;
        e2.lts = e2.lts || Date.now();
        let s2 = void 0;
        if (e2.error)
          if (e2.error instanceof SE) {
            const { code: t3, message: i4 } = e2.error;
            s2 = t3 || (i4 || e2.error.toString());
          } else
            s2 = e2.error.toString();
        const a2 = { invokeId: e2.invokeId, sid: e2.sid, cname: n2, cid: o2, uid: r2, lts: e2.lts, success: e2.success, elapse: e2.lts - i3.startTime, execElapse: e2.lts - e2.apiInvokeTime, apiName: e2.name, options: e2.options ? JSON.stringify(e2.options) : void 0, execStates: e2.states ? JSON.stringify(e2.states) : void 0, execResult: e2.result ? JSON.stringify(e2.result) : void 0, errorCode: e2.error ? s2 : void 0, errorMsg: e2.error ? JSON.stringify(e2.error) : void 0 };
        return this.send({ type: lf.API_INVOKE, data: a2 }, false), true;
      }
      appendSessionId() {
        this.clientList.forEach((e2) => {
          if (e2._sessionId) {
            const t2 = this.apiInvokeUploadPendingItems.length;
            for (let i3 = 0; i3 < t2; i3++) {
              const t3 = this.apiInvokeUploadPendingItems.shift();
              t3 && (t3.sid = e2._sessionId, this.sendApiInvoke(Object.assign({}, t3)));
            }
          }
        });
      }
      send(e2, t2) {
        if (t2)
          return this.keyEventUploadPendingItems.push(e2), void this.sendItems(this.keyEventUploadPendingItems, true);
        this.normalEventUploadPendingItems.push(e2), this.normalEventUploadPendingItems.length > GE("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
      }
      doSend() {
        this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
      }
      sendItems(e2, t2) {
        const i3 = [], n2 = [];
        for (; e2.length; ) {
          const t3 = e2.shift();
          i3.length < 20 ? i3.push(t3) : n2.push(t3);
        }
        e2.push(...n2);
        for (const e3 of [...i3]) {
          var r2;
          if (-1 !== this.ltsList.indexOf(e3.data.lts))
            e3.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e3.data.lts);
          else
            this.ltsList.push(e3.data.lts), Hm(r2 = this.ltsList).call(r2, (e4, t3) => e4 - t3);
        }
        t2 || (this.lastSendNormalEventTime = Date.now());
        return GE("ENABLE_EVENT_REPORT") ? (i3.length && (GE("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i3) : this.postDataToStatsCollector(i3)).catch(((e3) => (i4) => {
          GE("EVENT_REPORT_RETRY") && (t2 ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e3) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e3), this.normalEventUploadPendingItems.length > GE("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - GE("NORMAL_EVENT_QUEUE_CAPACITY")), OE.warning("report: drop normal events"))));
        })(i3)), e2) : e2;
      }
      async postDataToStatsCollector2(e2) {
        Ig.networkState === PS.OFFLINE && await Sl.race([Ig.onlineWaiter, zI(2 * TE.maxRetryTimeout)]);
        const t2 = (e3) => {
          let t3 = new Uint8Array();
          return e3.forEach((e4) => {
            const i4 = Ag(JSON.stringify(e4.data)), n3 = new ArrayBuffer(5), r2 = ((e5) => {
              let t4 = 0;
              return Object.entries(lf).forEach((i5) => {
                let [n4, r3] = i5;
                r3 === e5.type && (t4 = pf[n4]);
              }), t4;
            })(e4), o2 = new DataView(n3);
            o2.setUint16(0, i4.byteLength, true), o2.setUint8(2, 255 & r2), o2.setUint8(3, r2 >>> 8 & 255), o2.setUint8(4, r2 >>> 16 & 255), t3 = Og(t3, new Uint8Array(n3)), t3 = Og(t3, i4);
          }), t3;
        }, i3 = "event";
        let n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i3) : "https://".concat(GE("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i3);
        for (let r2 = 0; r2 < 2; r2 += 1) {
          1 === r2 && (n2 = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i3) : "https://".concat(GE("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i3));
          try {
            await gg(n2, { timeout: 1e4, data: t2(e2), headers: wg(wg({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
          } catch (e3) {
            if (1 === r2)
              throw e3;
            continue;
          }
          return;
        }
      }
      async postDataToStatsCollector(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const i3 = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e2.map((e3) => JSON.stringify(e3)), vid: ((e3) => {
          const t3 = e3 && e3.data.sid && this.baseInfoMap.get(e3.data.sid);
          return t3 && t3.info.vid && +t3.info.vid || 0;
        })(e2[0]) };
        Ig.networkState === PS.OFFLINE && await Sl.race([Ig.onlineWaiter, zI(2 * TE.maxRetryTimeout)]);
        const n2 = t2 ? "/events/proto-raws" : "/events/messages";
        let r2 = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("EVENT_REPORT_DOMAIN"), "&p=").concat(GE("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(GE("EVENT_REPORT_DOMAIN"), ":").concat(GE("STATS_COLLECTOR_PORT")).concat(n2));
        for (let e3 = 0; e3 < 2; e3 += 1) {
          1 === e3 && (r2 = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(GE("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(GE("STATS_COLLECTOR_PORT"), "&d=").concat(n2) : "https://".concat(GE("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(GE("STATS_COLLECTOR_PORT")).concat(n2)));
          try {
            t2 ? await Rg(r2, { timeout: 1e4, data: i3 }) : await gg(r2, { timeout: 1e4, data: i3 });
          } catch (t3) {
            if (1 === e3)
              throw t3;
            continue;
          }
          return;
        }
      }
      createBaseInfo(e2, t2) {
        const i3 = Object.assign({}, df);
        return i3.sid = e2, this.baseInfoMap.set(e2, { info: i3, startTime: t2 }), i3;
      }
      reportResourceTiming(e2, t2) {
        const i3 = performance.getEntriesByName(e2), n2 = i3[i3.length - 1];
        n2 && this.reportApiInvoke(t2, { name: "Client.resourceTiming", options: n2, tag: Ef.TRACER }).onSuccess();
      }
    }();
    mE.on("REPORT_LOG_UPLOAD", (e2) => {
      e2.networkState = Ig.networkState, Pg.reportApiInvoke(null, { name: "logUploadError", options: e2, tag: Ef.TRACER });
    });
    class Lg extends EE {
      constructor(e2, t2) {
        super(), _p(this, "trackMediaType", void 0), _p(this, "_ID", void 0), _p(this, "_rtpTransceiver", void 0), _p(this, "_lowRtpTransceiver", void 0), _p(this, "_hints", []), _p(this, "_isClosed", false), _p(this, "_originMediaStreamTrack", void 0), _p(this, "_mediaStreamTrack", void 0), _p(this, "_external", {}), this._ID = t2 || ZI(8, "track-"), this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, function(e3) {
          QE.includes(e3) || QE.push(e3);
        }(this);
      }
      toString() {
        return this._ID;
      }
      getTrackId() {
        return this._ID;
      }
      getMediaStreamTrack(e2) {
        if (!e2) {
          const e3 = Pg.reportApiInvoke(null, { name: _f.GET_MEDIA_STREAM_TRACK, options: [], tag: Ef.TRACER });
          this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e3.onSuccess(this._mediaStreamTrack.label) : e3.onSuccess("");
        }
        return this._mediaStreamTrack;
      }
      getRTCRtpTransceiver(e2) {
        return e2 === hS.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
      }
      getMediaStreamTrackSettings() {
        return this.getMediaStreamTrack(true).getSettings();
      }
      close() {
        this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e2) {
          const t2 = QE.indexOf(e2);
          -1 !== t2 && QE.splice(t2, 1);
        }(this), this.emit(mS.CLOSED);
      }
      _updateRtpTransceiver(e2, t2) {
        if (t2 === hS.LOW_STREAM) {
          if (this._lowRtpTransceiver === e2)
            return;
          this._lowRtpTransceiver = e2;
        } else {
          if (this._rtpTransceiver === e2)
            return;
          this._rtpTransceiver = e2;
        }
        this.emit(ES.TRANSCEIVER_UPDATED, e2, t2);
      }
    }
    let kg, Mg = 1;
    class Ug {
      constructor(e2) {
        _p(this, "lockingPromise", Sl.resolve()), _p(this, "locks", 0), _p(this, "name", ""), _p(this, "lockId", void 0), this.lockId = Mg++, e2 && (this.name = e2), OE.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
      }
      get isLocked() {
        return this.locks > 0;
      }
      lock(e2) {
        let t2;
        this.locks += 1, OE.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : ""));
        const i3 = new Sl((i4) => {
          t2 = () => {
            this.locks -= 1, OE.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e2 ? e2 : "")), i4();
          };
        }), n2 = this.lockingPromise.then(() => t2);
        return this.lockingPromise = this.lockingPromise.then(() => i3), n2;
      }
    }
    function xg(e2, t2) {
      return function(i3, n2, r2) {
        const o2 = r2.value;
        if ("function" != typeof o2)
          throw new Error("Cannot use mutex on object property.");
        return r2.value = async function() {
          const i4 = this[t2];
          if (!i4)
            throw new Error("mutex property key ".concat(t2, " doesn't exist on ").concat(e2));
          const r3 = await i4.lock("From ".concat(e2, ".").concat(n2));
          try {
            for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++)
              a2[c2] = arguments[c2];
            return await o2.apply(this, a2);
          } finally {
            r3();
          }
        }, r2;
      };
    }
    class Vg extends Lg {
      get isExternalTrack() {
        return this._isExternalTrack;
      }
      get muted() {
        return this._muted;
      }
      get enabled() {
        return this._enabled;
      }
      get processorContext() {
        return this._processorContext;
      }
      set processorContext(e2) {
        this._processorContext = e2;
      }
      constructor(e2, t2) {
        super(e2, t2), _p(this, "_enabled", true), _p(this, "_muted", false), _p(this, "_isExternalTrack", false), _p(this, "_isClosed", false), _p(this, "_enabledMutex", void 0), _p(this, "processor", void 0), _p(this, "_processorContext", void 0), _p(this, "_handleTrackEnded", () => {
          this.onTrackEnded();
        }), this._enabledMutex = new Ug("".concat(this.getTrackId())), e2.addEventListener("ended", this._handleTrackEnded);
      }
      getTrackLabel() {
        var e2, t2;
        return null !== (e2 = null === (t2 = this._originMediaStreamTrack) || void 0 === t2 ? void 0 : t2.label) && void 0 !== e2 ? e2 : "";
      }
      close() {
        this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, OE.debug("[".concat(this.getTrackId(), "] close")), this.emit(uS.NEED_CLOSE), super.close());
      }
      async _updateOriginMediaStreamTrack(e2, t2) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        this._isExternalTrack = i3, e2 !== this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop(), e2.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }));
      }
      _getDefaultPlayerConfig() {
        return {};
      }
      onTrackEnded() {
        OE.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(mS.TRACK_ENDED);
      }
      stateCheck(e2, t2) {
        if (OE.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e2, ": ").concat(t2, "]")), Km(t2, e2), this._enabled && this._muted && "enabled" === e2 && false === t2)
          throw new SE(fE.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print();
        if (!this._enabled && !this._muted && "muted" === e2 && true === t2)
          throw new SE(fE.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print();
      }
      getProcessorStats() {
        return this.processorContext.gatherStats();
      }
      getProcessorUsage() {
        return this.processorContext.gatherUsage();
      }
    }
    function jg(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    !function(e2) {
      e2.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", e2.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", e2.IOS_INTERRUPTION_START = "ios-interruption-start", e2.IOS_INTERRUPTION_END = "ios-interruption-end", e2.STATE_CHANGE = "state-change";
    }(kg || (kg = {}));
    const Fg = window.AudioContext || window.webkitAudioContext;
    let Bg = null;
    const Gg = new class extends EE {
      constructor() {
        super(...arguments), _p(this, "prevState", void 0), _p(this, "curState", void 0), _p(this, "currentTime", void 0), _p(this, "currentTimeStuckAt", void 0), _p(this, "interruptDetectorTrack", void 0), _p(this, "onLocalAudioTrackMute", () => {
          OE.info("ios15-interruption-start"), this.emit(kg.IOS_15_16_INTERRUPTION_START);
        }), _p(this, "onLocalAudioTrackUnmute", async () => {
          OE.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? OE.info("ios15-interruption-end-canceled") : (Bg && await Bg.suspend(), this.emit(kg.IOS_15_16_INTERRUPTION_END));
        });
      }
      get duringInterruption() {
        return "running" === this.prevState && "interrupted" === this.curState;
      }
      bindInterruptDetectorTrack(e2) {
        OE.debug("webaudio bindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e2, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
      }
      unbindInterruptDetectorTrack(e2) {
        OE.debug("webaudio unbindInterruptDetectorTrack ".concat(e2.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e2 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
      }
    }();
    function Wg() {
      if (!Fg)
        return void OE.error("your browser is not support web audio");
      OE.info("create audio context");
      const e2 = function(e3) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var i3 = null != arguments[t2] ? arguments[t2] : {};
          t2 % 2 ? jg(Object(i3), true).forEach(function(t3) {
            _p(e3, t3, i3[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i3)) : jg(Object(i3)).forEach(function(t3) {
            Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(i3, t3));
          });
        }
        return e3;
      }({}, GE("WEBAUDIO_INIT_OPTIONS"));
      OE.debug("audio context init option:", JSON.stringify(e2)), Bg = new Fg(e2), Gg.curState = Bg.state, Bg.onstatechange = () => {
        Gg.prevState = Gg.curState, Gg.curState = Bg ? Bg.state : void 0;
        const { prevState: e3, curState: t2 } = Gg, i3 = "running" === t2, n2 = "interrupted" === t2, r2 = "running" === e3, o2 = "suspended" === e3, s2 = "interrupted" === e3, a2 = xh().osVersion;
        (Yh() || tp()) && r2 && n2 && (OE.info("ios".concat(a2, "-interruption-start")), Gg.emit(kg.IOS_INTERRUPTION_START)), (Yh() || tp()) && (o2 || s2) && i3 && (OE.info("ios".concat(a2, "-interruption-end")), Gg.emit(kg.IOS_INTERRUPTION_END)), e3 !== t2 && (OE.debug("AudioContext State Change", "".concat(e3, "=>").concat(t2)), Gg.emit(kg.STATE_CHANGE));
      }, setInterval(() => {
        var e3;
        const t2 = null === (e3 = Bg) || void 0 === e3 ? void 0 : e3.currentTime;
        if (Gg.currentTime !== t2)
          Gg.currentTimeStuckAt && (OE.debug("AudioContext current time resume at ".concat(t2)), Gg.currentTimeStuckAt = void 0), Gg.currentTime = t2;
        else {
          if (t2 !== Gg.currentTimeStuckAt) {
            Pg.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: t2 }, tag: Ef.TRACER }).onSuccess(), OE.warning("AudioContext current time stuck at ".concat(t2));
          }
          Gg.currentTimeStuckAt = t2;
        }
      }, 5e3), async function(e3) {
        const t2 = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
        let i3, n2 = false, r2 = false, o2 = false;
        function s2(t3) {
          "running" === e3.state ? a2(false) : Yh() || tp() ? "suspended" === e3.state && (a2(true), t3 && e3.resume().then(d2, d2)) : "closed" !== e3.state && (a2(true), t3 && e3.resume().then(d2, d2));
        }
        function a2(e4) {
          if (n2 !== e4) {
            n2 = e4;
            for (let i4 = 0, n3 = t2; i4 < n3.length; i4 += 1) {
              const t3 = n3[i4];
              e4 ? window.addEventListener(t3, u2, { capture: true, passive: true }) : window.removeEventListener(t3, u2, { capture: true, passive: true });
            }
          }
        }
        function c2() {
          s2(true);
        }
        function d2() {
          s2(false);
        }
        function u2() {
          s2(true);
        }
        function l2(e4) {
          if (!o2)
            if (i3.paused)
              if (e4) {
                h3(false), o2 = true;
                let e5 = void 0;
                try {
                  e5 = i3.play(), e5 ? e5.then(p3, p3) : (i3.addEventListener("playing", p3), i3.addEventListener("abort", p3), i3.addEventListener("error", p3));
                } catch (e6) {
                  p3();
                }
              } else
                h3(true);
            else
              h3(false);
        }
        function h3(e4) {
          if (r2 !== e4) {
            r2 = e4;
            for (let i4 = 0, n3 = t2; i4 < n3.length; i4++) {
              const t3 = n3[i4];
              e4 ? window.addEventListener(t3, _2, { capture: true, passive: true }) : window.removeEventListener(t3, _2, { capture: true, passive: true });
            }
          }
        }
        function p3() {
          i3.removeEventListener("playing", p3), i3.removeEventListener("abort", p3), i3.removeEventListener("error", p3), o2 = false, l2(false);
        }
        function _2() {
          l2(true);
        }
        if (Yh()) {
          const t3 = e3.createMediaStreamDestination(), n3 = document.createElement("div");
          n3.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i3 = n3.children.item(0), i3.controls = false, i3.disableRemotePlayback = true, i3.preload = "auto", i3.srcObject = t3.stream, l2(true);
        }
        Gg.on(kg.STATE_CHANGE, c2), s2(false);
      }(Bg);
    }
    function Hg() {
      if (!Bg) {
        if (Wg(), !Bg)
          throw new SE(fE.NOT_SUPPORTED, "can not create audio context");
        return Bg;
      }
      return Bg;
    }
    function Kg() {
      return !!Bg;
    }
    function Yg(e2) {
      if (function() {
        if (null !== qg)
          return qg;
        const e3 = Hg(), t3 = e3.createBufferSource(), i4 = e3.createGain(), n2 = e3.createGain();
        t3.connect(i4), t3.connect(n2), t3.disconnect(i4);
        let r2 = false;
        try {
          t3.disconnect(i4);
        } catch (e4) {
          r2 = true;
        }
        return t3.disconnect(), qg = r2, r2;
      }())
        return;
      const t2 = e2.connect, i3 = e2.disconnect;
      e2.connect = (i4, n2, r2) => (e2._inputNodes || (e2._inputNodes = []), e2._inputNodes.includes(i4) || (i4 instanceof AudioNode ? (e2._inputNodes.push(i4), t2.call(e2, i4, n2, r2)) : t2.call(e2, i4, n2)), e2), e2.disconnect = (n2, r2, o2) => {
        i3.call(e2), n2 ? aC(e2._inputNodes, n2) : e2._inputNodes = [];
        for (const i4 of e2._inputNodes)
          t2.call(e2, i4);
      };
    }
    let qg = null;
    function Jg(e2, t2) {
      let i3 = false;
      const n2 = 1 / t2;
      if (GE("DISABLE_WEBAUDIO")) {
        const t3 = window.setInterval(() => {
          i3 ? window.clearInterval(t3) : e2(performance.now() / 1e3);
        }, 1e3 * n2);
      } else {
        const t3 = Hg();
        let r2 = t3.createGain();
        r2.gain.value = 0, r2.connect(t3.destination);
        const o2 = () => {
          if (i3)
            return void (r2 = null);
          const s2 = t3.createOscillator();
          s2.onended = o2, s2.connect(r2), s2.start(0), s2.stop(t3.currentTime + n2), e2(t3.currentTime);
        };
        o2();
      }
      return () => {
        i3 = true;
      };
    }
    class Xg {
      constructor() {
        _p(this, "context", void 0), _p(this, "analyserNode", void 0), _p(this, "sourceNode", void 0), this.context = Hg(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
      }
      updateSource(e2) {
        if (e2 !== this.sourceNode) {
          if (this.sourceNode)
            try {
              this.sourceNode.disconnect(this.analyserNode);
            } catch (e3) {
            }
          this.sourceNode = e2, null == e2 || e2.connect(this.analyserNode);
        }
      }
      getVolumeLevel() {
        if (!this.sourceNode)
          return 0;
        if (!this.context || Yh() || tp() || "running" !== this.context.state && this.context.resume(), !this.analyserNode)
          return 0;
        const e2 = new Float32Array(this.analyserNode.fftSize);
        if (this.analyserNode.getFloatTimeDomainData)
          this.analyserNode.getFloatTimeDomainData(e2);
        else {
          const t3 = new Uint8Array(this.analyserNode.fftSize);
          this.analyserNode.getByteTimeDomainData(t3);
          for (let i3 = 0; i3 < e2.length; ++i3)
            e2[i3] = t3[i3] / 128 - 1;
        }
        const t2 = zi(e2).call(e2, (e3, t3) => e3 + t3 * t3, 0) / e2.length;
        return Math.max(10 * Math.log10(t2) + 100, 0) / 100;
      }
      getAnalyserNode() {
        return this.analyserNode;
      }
      rebuildAnalyser() {
        try {
          var e2, t2;
          null === (e2 = this.sourceNode) || void 0 === e2 || e2.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, null === (t2 = this.sourceNode) || void 0 === t2 || t2.connect(this.analyserNode);
        } catch (e3) {
          OE.warning("rebuild analyser node failed.");
        }
      }
      destroy() {
        this.updateSource(void 0);
      }
    }
    class zg extends EE {
      get processSourceNode() {
        return this.sourceNode;
      }
      set processedNode(e2) {
        var t2;
        if (!this.isDestroyed && this._processedNode !== e2) {
          try {
            var i3;
            null === (i3 = this.sourceNode) || void 0 === i3 || i3.disconnect(this.outputNode);
          } catch (e3) {
          }
          null === (t2 = this._processedNode) || void 0 === t2 || t2.disconnect(), this._processedNode = e2, this.connect();
        }
      }
      get processedNode() {
        return this._processedNode;
      }
      constructor() {
        super(), _p(this, "outputNode", void 0), _p(this, "outputTrack", void 0), _p(this, "isPlayed", false), _p(this, "sourceNode", void 0), _p(this, "context", void 0), _p(this, "audioBufferNode", void 0), _p(this, "destNode", void 0), _p(this, "audioOutputLevel", 0), _p(this, "volumeLevelAnalyser", void 0), _p(this, "_processedNode", void 0), _p(this, "playNode", void 0), _p(this, "isDestroyed", false), _p(this, "onNoAudioInput", void 0), _p(this, "isNoAudioInput", false), _p(this, "_noAudioInputCount", 0), this.context = Hg(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), Yg(this.outputNode), this.volumeLevelAnalyser = new Xg();
      }
      startGetAudioBuffer(e2) {
        this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e2), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e3) => {
          this.emit(Lf.ON_AUDIO_BUFFER, function(e4) {
            for (let t2 = 0; t2 < e4.outputBuffer.numberOfChannels; t2 += 1) {
              const i3 = e4.outputBuffer.getChannelData(t2);
              for (let e5 = 0; e5 < i3.length; e5 += 1)
                i3[e5] = 0;
            }
            return e4.inputBuffer;
          }(e3));
        });
      }
      stopGetAudioBuffer() {
        this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
      }
      createOutputTrack() {
        if (!JS().webAudioMediaStreamDest)
          throw new SE(fE.NOT_SUPPORTED, "your browser is not support audio processor");
        return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
      }
      play(e2) {
        "running" !== this.context.state && dC(() => {
          Gg.emit("autoplay-failed");
        }), this.isPlayed = true, this.playNode = e2 || this.context.destination, this.outputNode.connect(this.playNode);
      }
      stop() {
        if (this.isPlayed)
          try {
            this.outputNode.disconnect(this.playNode);
          } catch (e2) {
          }
        this.isPlayed = false;
      }
      getAccurateVolumeLevel() {
        return this.volumeLevelAnalyser.getVolumeLevel();
      }
      async checkHasAudioInput() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        if (e2 > 5)
          return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
        Yh() || tp() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
        const t2 = this.volumeLevelAnalyser.getAnalyserNode();
        let i3;
        t2.getFloatTimeDomainData ? (i3 = new Float32Array(t2.fftSize), t2.getFloatTimeDomainData(i3)) : (i3 = new Uint8Array(t2.fftSize), t2.getByteTimeDomainData(i3));
        let n2 = false;
        for (let e3 = 0; e3 < i3.length; e3++)
          0 !== i3[e3] && (n2 = true);
        return n2 ? (this.isNoAudioInput = false, true) : (await zI(200), await this.checkHasAudioInput(e2 ? e2 + 1 : 1) && n2);
      }
      getAudioVolume() {
        return this.outputNode.gain.value;
      }
      setVolume(e2) {
        this.outputNode.gain.setValueAtTime(e2, this.context.currentTime);
      }
      destroy() {
        this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
      }
      disconnect() {
        var e2, t2;
        null === (e2 = this.processedNode) || void 0 === e2 || e2.disconnect(), null === (t2 = this.sourceNode) || void 0 === t2 || t2.disconnect(), this.outputNode && this.outputNode.disconnect();
      }
      connect() {
        var e2;
        this.processedNode ? null === (e2 = this.processedNode) || void 0 === e2 || e2.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);
        this.volumeLevelAnalyser.updateSource(this.outputNode);
      }
    }
    class Qg extends zg {
      get isFreeze() {
        return false;
      }
      constructor(e2, t2, i3) {
        var n2;
        if (super(), _p(this, "sourceNode", void 0), _p(this, "track", void 0), _p(this, "clonedTrack", void 0), _p(this, "audioElement", void 0), _p(this, "isCurrentTrackCloned", false), _p(this, "isRemoteTrack", false), _p(this, "originVolumeLevelAnalyser", void 0), _p(this, "rebuildWebAudio", async () => {
          if (OE.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed)
            return document.body.removeEventListener("click", this.rebuildWebAudio, true), void OE.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
          this.context.resume().then(() => OE.info("resume success")), OE.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
          const e3 = this.track;
          this.track = this.track.clone(), this.isCurrentTrackCloned ? e3.stop() : this.isCurrentTrackCloned = true;
          const t3 = new MediaStream([this.track]);
          this.sourceNode = this.context.createMediaStreamSource(t3), Yg(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
          const i4 = this.outputNode.gain.value;
          this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i4, this.context.currentTime), Yg(this.outputNode), this.emit(Lf.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t3, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
        }), "audio" !== e2.kind)
          throw new SE(fE.UNEXPECTED_ERROR);
        this.track = e2;
        const r2 = new MediaStream([this.track]);
        if (this.isRemoteTrack = !!t2, this.sourceNode = this.context.createMediaStreamSource(r2), Yg(this.sourceNode), i3) {
          const e3 = i3.clone();
          e3.enabled = true, this.clonedTrack = e3, OE.debug("create an unmuted track ".concat(e3.id, " from the original track ").concat(i3.id, " to get the volume"));
          const t3 = this.context.createMediaStreamSource(new MediaStream([e3]));
          Yg(t3), this.originVolumeLevelAnalyser = new Xg(), this.originVolumeLevelAnalyser.updateSource(t3);
        }
        this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = r2;
        const o2 = xh();
        t2 && o2.os === bh.IOS && Number(null === (n2 = o2.osVersion) || void 0 === n2 ? void 0 : n2.split(".")[0]) < 15 && (Gg.on(kg.STATE_CHANGE, () => {
          "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, true) : "running" === this.context.state && this.rebuildWebAudio();
        }), this.checkHasAudioInput().then((e3) => {
          e3 || document.body.addEventListener("click", this.rebuildWebAudio, true);
        }));
      }
      updateTrack(e2) {
        this.sourceNode.disconnect(), this.track = e2, this.isCurrentTrackCloned = false;
        const t2 = new MediaStream([e2]);
        this.sourceNode = this.context.createMediaStreamSource(t2), Yg(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(Lf.UPDATE_SOURCE), this.audioElement.srcObject = t2;
      }
      destroy() {
        var e2;
        this.audioElement.srcObject = null, this.audioElement.remove(), Gg.off("state-change", this.rebuildWebAudio), null === (e2 = this.originVolumeLevelAnalyser) || void 0 === e2 || e2.destroy(), this.clonedTrack = void 0, super.destroy();
      }
      createMediaStreamSourceNode(e2) {
        return this.context.createMediaStreamSource(new MediaStream([e2]));
      }
      updateOriginTrack(e2) {
        const t2 = e2.clone();
        t2.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t2), OE.debug("create an unmuted track ".concat(t2.id, " from the original track ").concat(e2.id, " to get the volume"));
        const i3 = this.context.createMediaStreamSource(new MediaStream([t2]));
        Yg(i3), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i3);
      }
      getOriginVolumeLevel() {
        return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
      }
    }
    async function Zg(e2, t2) {
      const i3 = (e3, t3) => e3 ? "number" != typeof e3 ? e3.max || e3.exact || e3.ideal || e3.min || t3 : e3 : t3, n2 = { audio: false, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: e2, maxHeight: i3(t2.height, 1080), maxWidth: i3(t2.width, 1920) } } };
      return t2.frameRate && "number" != typeof t2.frameRate ? (n2.video.mandatory.maxFrameRate = t2.frameRate.max, n2.video.mandatory.minFrameRate = t2.frameRate.min) : "number" == typeof t2.frameRate && (n2.video.mandatory.maxFrameRate = t2.frameRate), await navigator.mediaDevices.getUserMedia(n2);
    }
    async function $g(e2) {
      const t2 = await eR(e2.mediaSource), i3 = await function(e3) {
        return new Sl((t3, i4) => {
          const n2 = document.createElement("div");
          n2.innerText = "share screen", n2.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
          const r2 = document.createElement("div");
          r2.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
          const o2 = document.createElement("div");
          o2.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o2.setAttribute("style", "height: 12%;");
          const s2 = document.createElement("div");
          s2.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
          const a2 = document.createElement("div");
          a2.setAttribute("style", "text-align: right; padding: 16px 0;");
          const c2 = document.createElement("button");
          c2.innerHTML = "cancel", c2.setAttribute("style", "width: 85px;"), c2.onclick = () => {
            document.body.removeChild(d2);
            const e4 = new Error("NotAllowedError");
            e4.name = "NotAllowedError", i4(e4);
          }, a2.appendChild(c2), r2.appendChild(o2), r2.appendChild(s2), r2.appendChild(a2);
          const d2 = document.createElement("div");
          d2.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), d2.appendChild(n2), d2.appendChild(r2), document.body.appendChild(d2), e3.map((e4) => {
            if (e4.id) {
              const i5 = document.createElement("div");
              i5.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
              let n3 = e4.thumbnail;
              const { width: r3 } = n3.getSize();
              r3 > 1920 && (n3 = n3.resize({ width: 1920 })), i5.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n3.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + (e4.name.replace(/[\u00A0-\u9999<>\&]/g, function(e5) {
                return "&#" + e5.charCodeAt(0) + ";";
              }) + "</span>"), i5.onclick = () => {
                document.body.removeChild(d2), t3(e4.id);
              }, s2.appendChild(i5);
            }
          });
        });
      }(t2);
      return await Zg(i3, e2);
    }
    async function eR(e2) {
      let t2 = ["window", "screen"];
      "application" !== e2 && "window" !== e2 || (t2 = ["window"]), "screen" === e2 && (t2 = ["screen"]);
      const i3 = iR();
      if (!i3)
        throw new SE(fE.ELECTRON_IS_NULL);
      let n2 = null;
      try {
        var r2;
        n2 = (null === (r2 = i3.desktopCapturer) || void 0 === r2 ? void 0 : r2.getSources({ types: t2 })) || i3.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: t2 });
      } catch (e3) {
        n2 = null;
      }
      n2 && n2.then || (n2 = new Sl((e3, n3) => {
        i3.desktopCapturer.getSources({ types: t2 }, (t3, i4) => {
          t3 ? n3(t3) : e3(i4);
        });
      }));
      try {
        return await n2;
      } catch (e3) {
        throw new SE(fE.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e3.toString());
      }
    }
    let tR = null;
    function iR() {
      if (tR)
        return tR;
      try {
        return tR = window.require("electron"), tR;
      } catch (e2) {
        return null;
      }
    }
    function nR(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    const rR = new Ug("safari");
    let oR = false, sR = false;
    async function aR(e2, t2) {
      let i3 = 0, n2 = null;
      for (; i3 < 2; )
        try {
          n2 = await cR(e2, t2, i3 > 0);
          break;
        } catch (e3) {
          if (e3 instanceof SE)
            throw OE.error("[".concat(t2, "] ").concat(e3.toString())), e3;
          const n3 = dR(e3.name || e3.code || e3, e3.message);
          if (n3.code === fE.MEDIA_OPTION_INVALID) {
            OE.debug("[".concat(t2, "] detect media option invalid, retry")), i3 += 1, await zI(500);
            continue;
          }
          throw OE.error("[".concat(t2, "] ").concat(n3.toString())), n3;
        }
      if (!n2)
        throw new SE(fE.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
      return n2;
    }
    async function cR(e2, t2, i3) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
        throw new SE(fE.NOT_SUPPORTED, "can not find getUserMedia");
      i3 && (e2.video && (delete e2.video.width, delete e2.video.height), e2.screen && (delete e2.screen.width, delete e2.screen.height));
      const n2 = JS(), r2 = new MediaStream();
      if (e2.audioSource && r2.addTrack(e2.audioSource), e2.videoSource && r2.addTrack(e2.videoSource), !e2.audio && !e2.video && !e2.screen)
        return OE.debug("Using Video Source/ Audio Source"), r2;
      if (e2.screen)
        if (iR())
          if (e2.screen.sourceId) {
            uR(r2, await Zg(e2.screen.sourceId, e2.screen));
          } else {
            uR(r2, await $g(e2.screen));
          }
        else if (Wh() && e2.screen.extensionId && e2.screen.mandatory) {
          if (!n2.getStreamFromExtension)
            throw new SE(fE.NOT_SUPPORTED, "This browser does not support screen sharing");
          OE.debug("[".concat(t2, '] Screen access on chrome stable, looking for extension"'));
          const i4 = await (s2 = e2.screen.extensionId, a2 = t2, new Sl((e3, t3) => {
            try {
              chrome.runtime.sendMessage(s2, { getStream: true }, (i5) => {
                if (!i5 || !i5.streamId)
                  return OE.error("[".concat(a2, "] No response from Chrome Plugin. Plugin not installed properly"), i5), void t3(new SE(fE.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                e3(i5.streamId);
              });
            } catch (e4) {
              OE.error("[".concat(a2, "] AgoraRTC screensharing plugin is not accessible(").concat(s2, ")"), e4.toString()), t3(new SE(fE.CHROME_PLUGIN_NOT_INSTALL));
            }
          }));
          e2.screen.mandatory.chromeMediaSourceId = i4;
          uR(r2, await navigator.mediaDevices.getUserMedia({ video: { mandatory: e2.screen.mandatory } }));
        } else if (n2.getDisplayMedia) {
          var o2;
          e2.screen.mediaSource && gS(e2.screen.mediaSource);
          const i4 = { width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate, displaySurface: null !== (o2 = e2.screen.displaySurface) && void 0 !== o2 ? o2 : "screen" === e2.screen.mediaSource ? "monitor" : e2.screen.mediaSource }, { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3 } = e2.screen, c3 = { selfBrowserSurface: n3, surfaceSwitching: s3, systemAudio: a3 };
          !n3 && delete c3.selfBrowserSurface, !s3 && delete c3.surfaceSwitching, !a3 && delete c3.systemAudio, OE.debug("[".concat(t2, "] getDisplayMedia:"), JSON.stringify({ video: i4, audio: !!e2.screenAudio, controls: c3 }));
          uR(r2, await navigator.mediaDevices.getDisplayMedia(function(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var i5 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? nR(Object(i5), true).forEach(function(t4) {
                _p(e3, t4, i5[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i5)) : nR(Object(i5)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i5, t4));
              });
            }
            return e3;
          }({ video: i4, audio: !!e2.screenAudio }, c3)));
        } else {
          if (!Kh())
            throw OE.error("[".concat(t2, "] This browser does not support screenSharing")), new SE(fE.NOT_SUPPORTED, "This browser does not support screen sharing");
          {
            e2.screen.mediaSource && gS(e2.screen.mediaSource);
            const i4 = { video: { mediaSource: e2.screen.mediaSource, width: e2.screen.width, height: e2.screen.height, frameRate: e2.screen.frameRate } };
            OE.debug("[".concat(t2, "] getUserMedia: ").concat(JSON.stringify(i4)));
            uR(r2, await navigator.mediaDevices.getUserMedia(i4));
          }
        }
      var s2, a2;
      if (!e2.video && !e2.audio)
        return r2;
      let c2 = { video: e2.video, audio: e2.audio }, d2 = GE("MEDIA_DEVICE_CONSTRAINTS");
      if (d2)
        try {
          "string" == typeof d2 && (d2 = JSON.parse(d2)), c2 = function e3(t3, i4) {
            if (!SC(t3) || !SC(i4))
              return i4;
            if (Array.isArray(t3) && !Array.isArray(i4) || !Array.isArray(t3) && Array.isArray(i4))
              return i4;
            if (Array.isArray(i4) && Array.isArray(t3)) {
              const n3 = [...t3];
              for (let r3 = 0; r3 < i4.length; r3++)
                n3[r3] = e3(t3[r3], i4[r3]);
              return n3;
            }
            {
              const n3 = JI({}, t3);
              for (const r3 in i4)
                Object.prototype.hasOwnProperty.call(i4, r3) && (Object.prototype.hasOwnProperty.call(t3, r3) ? n3[r3] = e3(t3[r3], i4[r3]) : n3[r3] = i4[r3]);
              return n3;
            }
          }(c2, d2);
        } catch (e3) {
        }
      OE.debug("[".concat(t2, "] GetUserMedia"), JSON.stringify(c2)), xh();
      let u2, l2 = null;
      (Hh() || Yh() || Fh()) && (l2 = await rR.lock());
      try {
        u2 = await navigator.mediaDevices.getUserMedia(c2);
      } catch (e3) {
        throw l2 && l2(), e3;
      }
      return c2.audio && (oR = true), c2.video && (sR = true), uR(r2, u2), l2 && l2(), r2;
    }
    function dR(e2, t2) {
      switch (e2) {
        case "Starting video failed":
        case "OverconstrainedError":
        case "TrackStartError":
          return new SE(fE.MEDIA_OPTION_INVALID, "".concat(e2, ": ").concat(t2));
        case "NotFoundError":
        case "DevicesNotFoundError":
          return new SE(fE.DEVICE_NOT_FOUND, "".concat(e2, ": ").concat(t2));
        case "NotSupportedError":
          return new SE(fE.NOT_SUPPORTED, "".concat(e2, ": ").concat(t2));
        case "NotReadableError":
          return new SE(fE.NOT_READABLE, "".concat(e2, ": ").concat(t2));
        case "InvalidStateError":
        case "NotAllowedError":
        case "PERMISSION_DENIED":
        case "PermissionDeniedError":
          return new SE(fE.PERMISSION_DENIED, "".concat(e2, ": ").concat(t2));
        case "ConstraintNotSatisfiedError":
          return new SE(fE.CONSTRAINT_NOT_SATISFIED, "".concat(e2, ": ").concat(t2));
        default:
          return OE.error("getUserMedia unexpected error", e2), new SE(fE.UNEXPECTED_ERROR, "".concat(e2, ": ").concat(t2));
      }
    }
    function uR(e2, t2) {
      const i3 = e2.getVideoTracks()[0], n2 = e2.getAudioTracks()[0], r2 = t2.getVideoTracks()[0], o2 = t2.getAudioTracks()[0];
      o2 && (n2 && e2.removeTrack(n2), e2.addTrack(o2)), r2 && (i3 && e2.removeTrack(i3), e2.addTrack(r2));
    }
    const lR = new class extends EE {
      get state() {
        return this._state;
      }
      set state(e2) {
        e2 !== this._state && (this.emit(ff.STATE_CHANGE, e2), this._state = e2);
      }
      constructor() {
        super(), _p(this, "_state", mf.IDLE), _p(this, "isAccessMicrophonePermission", false), _p(this, "isAccessCameraPermission", false), _p(this, "lastAccessMicrophonePermission", false), _p(this, "lastAccessCameraPermission", false), _p(this, "checkdeviceMatched", false), _p(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
          navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
            (GE("ENUMERATE_DEVICES_INTERVAL") || (op() || Vh() === bh.HARMONY_OS) && rp()) && this.updateDevicesInfo();
          }, GE("ENUMERATE_DEVICES_INTERVAL_TIME"));
        }).catch((e2) => OE.error(e2.toString()));
      }
      async enumerateDevices(e2, t2) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
          return new SE(fE.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
        }
        const n2 = await navigator.mediaDevices.enumerateDevices(), r2 = this.checkMediaDeviceInfoIsOk(n2);
        let o2 = !this.isAccessMicrophonePermission && e2, s2 = !this.isAccessCameraPermission && t2;
        r2.audio && (o2 = false), r2.video && (s2 = false);
        let a2 = null, c2 = null, d2 = null;
        if (!i3 && (o2 || s2)) {
          if (rR.isLocked) {
            OE.debug("[device manager] wait GUM lock");
            (await rR.lock())(), OE.debug("[device manager] GUM unlock");
          }
          if (oR && (o2 = false, this.isAccessMicrophonePermission = true), sR && (s2 = false, this.isAccessCameraPermission = true), OE.debug("[device manager] check media device permissions", e2, t2, o2, s2), o2 && s2) {
            try {
              d2 = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
            } catch (e3) {
              const t3 = dR(e3.name || e3.code || e3, e3.message);
              if (t3.code === fE.PERMISSION_DENIED)
                throw t3;
              OE.warning("getUserMedia failed in getDevices", t3);
            }
            this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
          } else if (o2) {
            try {
              a2 = await navigator.mediaDevices.getUserMedia({ audio: e2 });
            } catch (e3) {
              const t3 = dR(e3.name || e3.code || e3, e3.message);
              if (t3.code === fE.PERMISSION_DENIED)
                throw t3;
              OE.warning("getUserMedia failed in getDevices", t3);
            }
            this.isAccessMicrophonePermission = true;
          } else if (s2) {
            try {
              c2 = await navigator.mediaDevices.getUserMedia({ video: t2 });
            } catch (e3) {
              const t3 = dR(e3.name || e3.code || e3, e3.message);
              if (t3.code === fE.PERMISSION_DENIED)
                throw t3;
              OE.warning("getUserMedia failed in getDevices", t3);
            }
            this.isAccessCameraPermission = true;
          }
          OE.debug("[device manager] mic permission", e2, "cam permission", t2);
        }
        try {
          const e3 = await navigator.mediaDevices.enumerateDevices();
          return a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null, e3;
        } catch (e3) {
          a2 && a2.getTracks().forEach((e4) => e4.stop()), c2 && c2.getTracks().forEach((e4) => e4.stop()), d2 && d2.getTracks().forEach((e4) => e4.stop()), a2 = null, c2 = null, d2 = null;
          return new SE(fE.ENUMERATE_DEVICES_FAILED, e3.toString()).throw();
        }
      }
      async getRecordingDevices() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audioinput" === e3.kind);
      }
      async getCamerasDevices() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return (await this.enumerateDevices(false, true, e2)).filter((e3) => "videoinput" === e3.kind);
      }
      async getSpeakers() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return (await this.enumerateDevices(true, false, e2)).filter((e3) => "audiooutput" === e3.kind);
      }
      searchDeviceIdByName(e2) {
        let t2 = null;
        return this.deviceInfoMap.forEach((i3) => {
          i3.device.label === e2 && (t2 = i3.device.deviceId);
        }), t2;
      }
      async getDeviceById(e2) {
        const t2 = (await this.enumerateDevices(true, true, true)).find((t3) => t3.deviceId === e2);
        if (!t2)
          throw new SE(fE.DEVICE_NOT_FOUND, "deviceId: ".concat(e2));
        return t2;
      }
      async init() {
        this.state = mf.INITING;
        try {
          await this.updateDevicesInfo(), this.state = mf.INITEND;
        } catch (e2) {
          if (OE.warning("Device Detection functionality cannot start properly.", e2.toString()), this.state = mf.IDLE, !function() {
            if ("boolean" == typeof isSecureContext)
              return isSecureContext;
            return "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname;
          }()) {
            new SE(fE.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw();
          }
          throw e2;
        }
      }
      async updateDevicesInfo() {
        const e2 = await this.enumerateDevices(true, true, true), t2 = Date.now(), i3 = [];
        if (e2[0] && e2[0].label && false === this.checkdeviceMatched) {
          this.checkdeviceMatched = true;
          const t3 = e2.find((e3) => "audioinput" === e3.kind && "default" === e3.deviceId), i4 = e2.find((e3) => "audiooutput" === e3.kind && "default" === e3.deviceId);
          t3 && i4 ? i4.groupId === t3.groupId ? OE.debug("[device-check] default input ".concat(t3.label, " and output ").concat(i4.label, " is the same group")) : OE.warning("[device-check] default input ".concat(t3.label, " and output ").concat(i4.label, " is not the same group")) : OE.debug("[device-check] default input or output not found");
        }
        const n2 = this.checkMediaDeviceInfoIsOk(e2);
        if (e2.forEach((e3) => {
          if (!e3.deviceId)
            return;
          const n3 = this.deviceInfoMap.get("".concat(e3.kind, "_").concat(e3.deviceId));
          if ("ACTIVE" !== (n3 ? n3.state : "INACTIVE")) {
            const n4 = { initAt: t2, updateAt: t2, device: e3, state: "ACTIVE" };
            this.deviceInfoMap.set("".concat(e3.kind, "_").concat(e3.deviceId), n4), i3.push(n4);
          }
          n3 && (n3.updateAt = t2);
        }), this.deviceInfoMap.forEach((e3, n3) => {
          "ACTIVE" === e3.state && e3.updateAt !== t2 && (e3.state = "INACTIVE", i3.push(e3));
        }), this.state !== mf.INITEND)
          return n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
        i3.forEach((e3) => {
          switch (e3.device.kind) {
            case "audioinput":
              this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(ff.RECORDING_DEVICE_CHANGED, e3);
              break;
            case "videoinput":
              this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(ff.CAMERA_DEVICE_CHANGED, e3);
              break;
            case "audiooutput":
              this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(ff.PLAYOUT_DEVICE_CHANGED, e3);
          }
        }), n2.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), n2.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
      }
      checkMediaDeviceInfoIsOk(e2) {
        const t2 = e2.filter((e3) => "audioinput" === e3.kind), i3 = e2.filter((e3) => "videoinput" === e3.kind), n2 = { audio: false, video: false };
        for (const e3 of t2)
          if (e3.label && e3.deviceId) {
            n2.audio = true;
            break;
          }
        for (const e3 of i3)
          if (e3.label && e3.deviceId) {
            n2.video = true;
            break;
          }
        return n2;
      }
    }();
    const hR = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"], pR = new class {
      constructor() {
        _p(this, "onAutoplayFailed", void 0), _p(this, "elementMap", /* @__PURE__ */ new Map()), _p(this, "elementStateMap", /* @__PURE__ */ new Map()), _p(this, "elementsNeedToResume", []), _p(this, "sinkIdMap", /* @__PURE__ */ new Map()), _p(this, "autoResumeAfterInterruption", () => {
          Array.from(this.elementMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            const n2 = this.elementStateMap.get(t2), r2 = i3.srcObject.getAudioTracks()[0];
            Zh() ? r2 && "live" === r2.readyState && "running" === Gg.curState && (OE.debug("auto resume after interruption for iOS 15"), i3.pause(), i3.play()) : n2 && "paused" === n2 && r2 && "live" === r2.readyState && "running" === Gg.curState && (OE.debug("auto resume after interruption for iOS"), i3.play());
          });
        }), _p(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
          Array.from(this.elementMap.entries()).forEach((e2) => {
            let [t2, i3] = e2;
            const n2 = i3.srcObject.getAudioTracks()[0];
            n2 && "live" === n2.readyState && (OE.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), i3.pause(), i3.play());
          });
        }), this.autoResumeAudioElement(), Gg.on(kg.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Gg.on(kg.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), Gg.on(kg.STATE_CHANGE, () => {
          Yh() && "suspended" === Gg.prevState && "running" === Gg.curState && this.autoResumeAfterInterruption();
        });
      }
      async setSinkID(e2, t2) {
        const i3 = this.elementMap.get(e2);
        if (this.sinkIdMap.set(e2, t2), i3)
          try {
            await i3.setSinkId(t2);
          } catch (e3) {
            throw new SE(fE.PERMISSION_DENIED, "can not set sink id: " + e3.toString());
          }
      }
      play(e2, t2, i3, n2) {
        if (this.elementMap.has(t2))
          return;
        const r2 = document.createElement("audio");
        r2.autoplay = true, r2.srcObject = new MediaStream([e2]), this.bindAudioElementEvents(t2, r2), this.elementMap.set(t2, r2), this.elementStateMap.set(t2, sf.INIT), this.setVolume(t2, i3);
        const o2 = this.sinkIdMap.get(t2);
        if (o2)
          try {
            r2.setSinkId(o2).catch((e3) => {
              OE.warning("[".concat(t2, "] set sink id failed"), e3.toString());
            });
          } catch (e3) {
            OE.warning("[".concat(t2, "] set sink id failed"), e3.toString());
          }
        const s2 = r2.play();
        s2 && s2.then && s2.catch((e3) => {
          n2 && Pg.autoplayFailed(n2, "audio", e3.message, t2), OE.warning("audio element play warning", e3.toString()), this.elementMap.has(t2) && "NotAllowedError" === e3.name && (OE.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r2), dC(() => {
            this.onAutoplayFailed && this.onAutoplayFailed(), yg();
          }));
        });
      }
      updateTrack(e2, t2) {
        const i3 = this.elementMap.get(e2);
        i3 && (i3.srcObject = new MediaStream([t2]));
      }
      isPlaying(e2) {
        return this.elementMap.has(e2) && "playing" === this.elementStateMap.get(e2);
      }
      setVolume(e2, t2) {
        const i3 = this.elementMap.get(e2);
        i3 && (t2 = Math.max(0, Math.min(100, t2)), i3.volume = t2 / 100);
      }
      stop(e2) {
        const t2 = this.elementMap.get(e2);
        if (this.sinkIdMap.delete(e2), !t2)
          return;
        const i3 = this.elementsNeedToResume.indexOf(t2);
        this.elementsNeedToResume.splice(i3, 1), t2.srcObject = null, t2.remove(), this.elementMap.delete(e2), this.elementStateMap.delete(e2);
      }
      bindAudioElementEvents(e2, t2) {
        hR.forEach((i3) => {
          t2.addEventListener(i3, (i4) => {
            const n2 = this.elementStateMap.get(e2), r2 = "pause" === i4.type ? "paused" : i4.type;
            if (OE.debug("[".concat(e2, "] audio-element-status change ").concat(n2, " => ").concat(r2)), "error" === i4.type) {
              const i5 = null == t2 ? void 0 : t2.error;
              i5 && OE.error("[".concat(e2, "] media error, code: ").concat(i5.code, ", message: ").concat(i5.message));
            }
            this.elementStateMap.set(e2, r2);
          });
        });
      }
      getPlayerState(e2) {
        return this.elementStateMap.get(e2) || "uninit";
      }
      autoResumeAudioElement() {
        const e2 = () => {
          this.elementsNeedToResume.forEach((e3) => {
            e3.play().then((e4) => {
              OE.debug("Auto resume audio element success");
            }).catch((e4) => {
              OE.warning("Auto resume audio element failed!", e4);
            });
          }), this.elementsNeedToResume = [];
        };
        new Sl((e3) => {
          document.body ? e3() : window.addEventListener("load", () => e3());
        }).then(() => {
          sp() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true));
        });
      }
    }();
    function _R() {
      return function(e2, t2, i3) {
        const n2 = i3.value;
        return "function" == typeof n2 && (i3.value = function() {
          this._isClosed && new SE(fE.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning");
          for (var e3 = arguments.length, t3 = new Array(e3), i4 = 0; i4 < e3; i4++)
            t3[i4] = arguments[i4];
          const r2 = n2.apply(this, t3);
          return r2 instanceof Sl ? new Sl((e4, t4) => {
            r2.then(e4).catch(t4);
          }) : r2;
        }), i3;
      };
    }
    var ER = Hi("Array").values, mR = Zr, fR = Ge, SR = u, TR = ER, gR = Array.prototype, RR = { DOMTokenList: true, NodeList: true }, IR = function(e2) {
      var t2 = e2.values;
      return e2 === gR || SR(gR, e2) && t2 === gR.values || fR(RR, mR(e2)) ? TR : t2;
    };
    function CR(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function vR(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? CR(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : CR(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class yR extends EE {
      constructor(e2) {
        super(), _p(this, "name", "VideoProcessorDestination"), _p(this, "ID", "0"), _p(this, "_source", void 0), _p(this, "videoContext", void 0), _p(this, "inputTrack", void 0), this.videoContext = e2;
      }
      get kind() {
        return "video";
      }
      get enabled() {
        return true;
      }
      pipe() {
        throw new SE(fE.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
      }
      unpipe() {
        throw new SE(fE.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
      }
      enable() {
      }
      disable() {
      }
      updateInput(e2) {
        if (e2.context !== this.videoContext)
          throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
        e2.track && e2.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e2.track, this.emit(kS.ON_TRACK, e2.track));
      }
      reset() {
        this.inputTrack = void 0, this.videoContext.chained = false, this.emit(kS.ON_TRACK, void 0);
      }
    }
    class AR extends EE {
      set chained(e2) {
        this._chained = e2;
      }
      get chained() {
        return this._chained;
      }
      constructor(e2, t2) {
        super(), _p(this, "constraintsMap", /* @__PURE__ */ new Map()), _p(this, "statsRegistry", []), _p(this, "usageRegistry", []), _p(this, "trackId", void 0), _p(this, "direction", void 0), _p(this, "_chained", false), this.trackId = e2, this.direction = t2;
      }
      async getConstraints() {
        return await nC(this, MS.REQUEST_CONSTRAINTS);
      }
      async requestApplyConstraints(e2, t2) {
        var i3;
        return OE.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(i3 = this.constraintsMap).call(i3)));
      }
      async requestRevertConstraints(e2) {
        var t2;
        if (this.constraintsMap.has(e2))
          return OE.info("processor ".concat(e2.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(t2 = this.constraintsMap).call(t2)));
      }
      registerStats(e2, t2, i3) {
        this.statsRegistry.find((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i3 });
      }
      unregisterStats(e2, t2) {
        const i3 = this.statsRegistry.findIndex((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2);
        -1 !== i3 && this.statsRegistry.splice(i3, 1);
      }
      gatherStats() {
        const e2 = [];
        for (const { processorID: t2, processorName: i3, type: n2, cb: r2 } of this.statsRegistry)
          try {
            const o2 = r2();
            e2.push({ processorID: t2, processorName: i3, type: n2, stats: o2 });
          } catch (e3) {
            OE.error(new SE(fE.UNEXPECTED_ERROR, e3.message));
          }
        return e2;
      }
      registerUsage(e2, t2) {
        this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
      }
      unregisterUsage(e2) {
        const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
        -1 !== t2 && this.usageRegistry.splice(t2, 1);
      }
      async gatherUsage() {
        const e2 = [];
        if (!this.chained)
          return [];
        for (const { cb: t2 } of this.usageRegistry)
          try {
            let i3 = t2();
            i3 instanceof Sl && (i3 = await i3), e2.push(vR(vR({}, i3), {}, { direction: this.direction }));
          } catch (e3) {
            OE.error("gather extension usage error", e3);
          }
        return e2;
      }
      getDirection() {
        return this.direction;
      }
    }
    class OR extends EE {
      constructor(e2) {
        super(), _p(this, "name", "AudioProcessorDestination"), _p(this, "ID", "0"), _p(this, "inputTrack", void 0), _p(this, "inputNode", void 0), _p(this, "audioProcessorContext", void 0), _p(this, "_source", void 0), this.audioProcessorContext = e2;
      }
      get kind() {
        return "audio";
      }
      get enabled() {
        return true;
      }
      pipe() {
        throw new SE(fE.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
      }
      unpipe() {
        throw new SE(fE.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
      }
      enable() {
      }
      disable() {
      }
      reset() {
        this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(kS.ON_TRACK, void 0), this.emit(kS.ON_NODE, void 0);
      }
      updateInput(e2) {
        if (e2.context !== this.audioProcessorContext)
          throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
        e2.track && this.inputTrack !== e2.track && (this.audioProcessorContext.chained = true, this.inputTrack = e2.track, this.emit(kS.ON_TRACK, this.inputTrack)), e2.node && this.inputNode !== e2.node && (this.audioProcessorContext.chained = true, this.inputNode = e2.node, this.emit(kS.ON_NODE, this.inputNode));
      }
    }
    class NR extends EE {
      set chained(e2) {
        this._chained = e2;
      }
      get chained() {
        return this._chained;
      }
      constructor(e2, t2, i3) {
        super(), _p(this, "constraintsMap", /* @__PURE__ */ new Map()), _p(this, "statsRegistry", []), _p(this, "audioContext", void 0), _p(this, "trackId", void 0), _p(this, "direction", void 0), _p(this, "usageRegistry", []), _p(this, "_chained", false), this.audioContext = e2, this.trackId = t2, this.direction = i3;
      }
      async getConstraints() {
        return nC(this, MS.REQUEST_CONSTRAINTS);
      }
      getAudioContext() {
        return this.audioContext;
      }
      async requestApplyConstraints(e2, t2) {
        var i3;
        return OE.info("processor ".concat(t2.name, " requestApplyConstraints for ").concat(this.trackId)), e2 && this.constraintsMap.set(t2, e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(i3 = this.constraintsMap).call(i3)));
      }
      async requestRevertConstraints(e2) {
        var t2;
        if (this.constraintsMap.has(e2))
          return this.constraintsMap.delete(e2), rC(this, MS.REQUEST_UPDATE_CONSTRAINTS, Array.from(IR(t2 = this.constraintsMap).call(t2)));
      }
      registerStats(e2, t2, i3) {
        this.statsRegistry.find((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2) || this.statsRegistry.push({ processorName: e2.name, processorID: e2.ID, type: t2, cb: i3 });
      }
      unregisterStats(e2, t2) {
        const i3 = this.statsRegistry.findIndex((i4) => i4.processorID === e2.ID && i4.processorName === e2.name && i4.type === t2);
        -1 !== i3 && this.statsRegistry.splice(i3, 1);
      }
      gatherStats() {
        const e2 = [];
        for (const { processorID: t2, processorName: i3, type: n2, cb: r2 } of this.statsRegistry)
          try {
            const o2 = r2();
            e2.push({ processorID: t2, processorName: i3, type: n2, stats: o2 });
          } catch (e3) {
            OE.error(new SE(fE.UNEXPECTED_ERROR, e3.message));
          }
        return e2;
      }
      registerUsage(e2, t2) {
        this.usageRegistry.find((t3) => t3.processorID === e2.ID && t3.processorName === e2.name) || this.usageRegistry.push({ processorID: e2.ID, processorName: e2.name, cb: t2 });
      }
      unregisterUsage(e2) {
        const t2 = this.usageRegistry.findIndex((t3) => t3.processorID === e2.ID && t3.processorName === e2.name);
        -1 !== t2 && this.usageRegistry.splice(t2, 1);
      }
      async gatherUsage() {
        const e2 = [];
        if (!this.chained)
          return [];
        for (const { cb: t2 } of this.usageRegistry)
          try {
            let i3 = t2();
            i3 instanceof Sl && (i3 = await i3), e2.push(vR(vR({}, i3), {}, { direction: this.direction }));
          } catch (e3) {
            OE.error("gather extension usage error", e3);
          }
        return e2;
      }
      getDirection() {
        return this.direction;
      }
    }
    class bR extends EE {
      get isPlayed() {
        return true;
      }
      get isFreeze() {
        return false;
      }
      constructor() {
        super(), _p(this, "context", void 0), _p(this, "processSourceNode", void 0), _p(this, "outputTrack", void 0), _p(this, "processedNode", void 0), _p(this, "clonedTrack", void 0), _p(this, "outputNode", void 0), this.outputNode = new wR();
      }
      setVolume() {
      }
      createOutputTrack() {
        throw new SE(fE.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
      }
      getOriginVolumeLevel() {
        return 0;
      }
      getAccurateVolumeLevel() {
        return 0;
      }
      stopGetAudioBuffer() {
      }
      startGetAudioBuffer() {
      }
      play() {
      }
      stop() {
      }
      destroy() {
      }
      updateTrack() {
      }
      updateOriginTrack() {
      }
      createMediaStreamSourceNode() {
      }
    }
    class wR {
      disconnect() {
      }
      connect() {
      }
    }
    let DR, PR = null;
    class LR {
      constructor() {
        _p(this, "state", "open"), _p(this, "trigger", void 0), _p(this, "tasks", []), OE.debug("[macro-task-queue] is created."), this.trigger = setTimeout(() => {
          this.state = "closed", OE.debug("[macro-task-queue] will be closed, all remaining tasks will execute. [".concat(this.tasks.map((e2) => e2.key), "]")), this.trigger = void 0, this.tasks.forEach((e2) => {
            let { func: t2 } = e2;
            return t2();
          }), this.tasks.length = 0, OE.debug("[macro-task-queue] is closed.");
        });
      }
      enqueue(e2, t2) {
        "closed" !== this.state && (this.tasks.push({ key: e2, func: t2 }), OE.debug("[macro-task-queue] is queued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e2 ? e2 : "")));
      }
      runTask(e2) {
        if ("closed" === this.state)
          return;
        const t2 = this.tasks.findIndex((t3) => t3.key === e2);
        if (-1 !== t2) {
          const i3 = this.tasks.splice(t2, 1);
          OE.debug("[macro-task-queue] is unqueued, current queue ".concat(this.tasks.length, ". ").concat("string" == typeof e2 ? e2 : "")), i3[0].func();
        }
      }
      release() {
        this.trigger && (this.state = "closed", clearTimeout(this.trigger), this.trigger = void 0, this.tasks.length = 0, OE.debug("[macro-task-queue] is closed."));
      }
    }
    function kR(e2) {
      return function(t2, i3, n2) {
        var r2;
        const o2 = null !== (r2 = n2.value) && void 0 !== r2 ? r2 : n2.get, s2 = function() {
          PR && "open" === PR.state && PR.runTask(e2);
          for (var t3 = arguments.length, i4 = new Array(t3), n3 = 0; n3 < t3; n3++)
            i4[n3] = arguments[n3];
          return null == o2 ? void 0 : o2.apply(this, ...i4);
        };
        return n2.value ? n2.value = s2 : n2.get = s2, n2;
      };
    }
    var MR, UR, xR, VR, jR, FR, BR, GR, WR, HR, KR, YR, qR, JR, XR, zR, QR, ZR, $R, eI, tI, iI, nI, rI, oI, sI, aI, cI, dI, uI, lI, hI, pI, _I, EI, mI, fI, SI, TI, gI, RI, II;
    function CI(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function vI(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? CI(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : CI(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    !function(e2) {
      e2.UPDATE_TRACK_SOURCE = "update-track-source";
    }(DR || (DR = {}));
    let yI = (MR = kR("INIT_WEBAUDIO"), UR = kR("INIT_WEBAUDIO"), xR = kR("INIT_WEBAUDIO"), VR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), jR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), FR = _R(), BR = xg("LocalAudioTrack", "_enabledMutex"), GR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), WR = _R(), HR = xg("LocalAudioTrack", "_enabledMutex"), KR = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), YR = _R(), qR = _R(), JR = _R(), XR = Dg({ argsMap: (e2) => [e2.getTrackId()] }), zR = _R(), QR = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ZR = _R(), $R = Dg({ argsMap: (e2) => [e2.getTrackId()] }), eI = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), tI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((iI = class extends Vg {
      get _source() {
        return this._trackSource;
      }
      set _source(e2) {
        this._trackSource = e2;
      }
      get processorContext() {
        return this._processorContext;
      }
      set processorContext(e2) {
        this._processorContext = e2;
      }
      get processorDestination() {
        return this._processorDestination;
      }
      set processorDestination(e2) {
        this._processorDestination = e2;
      }
      get isPlaying() {
        return this._useAudioElement ? pR.isPlaying(this.getTrackId()) : this._source.isPlayed;
      }
      get __className__() {
        return "LocalAudioTrack";
      }
      constructor(e2, t2, i3, n2, r2) {
        super(e2, i3), _p(this, "trackMediaType", "audio"), _p(this, "_encoderConfig", void 0), _p(this, "_trackSource", void 0), _p(this, "_enabled", true), _p(this, "_volume", 100), _p(this, "_useAudioElement", false), _p(this, "_bypassWebAudio", false), _p(this, "processor", void 0), _p(this, "_processorContext", void 0), _p(this, "_processorDestination", void 0), _p(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t2, this._getOriginVolumeLevel = !!n2;
        const o2 = () => {
          this.processorContext = new NR(this._source.context, this.getTrackId(), "local"), this.processorDestination = new OR(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(Lf.UPDATE_SOURCE, () => {
            this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
          });
        }, s2 = r2 && Hh() && !Kg();
        if (GE("DISABLE_WEBAUDIO") ? (this._source = new bR(), this._useAudioElement = true, this._bypassWebAudio = true) : s2 ? this._source = new bR() : (this._source = new Qg(e2, false, this._getOriginVolumeLevel ? e2 : void 0), GE("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true)), o2(), !GE("DISABLE_WEBAUDIO") && s2) {
          (PR || (PR = new LR()), PR).enqueue("INIT_WEBAUDIO", () => {
            this._source = new Qg(e2, false, this._getOriginVolumeLevel ? e2 : void 0), GE("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = true), o2(), this.emit(DR.UPDATE_TRACK_SOURCE);
          });
        }
      }
      setVolume(e2) {
        qm(e2, "volume", 0, 1e3), this._volume = e2, this._source.setVolume(e2 / 100), this._useAudioElement && pR.setVolume(this.getTrackId(), e2);
        try {
          if (this._bypassWebAudio)
            return void OE.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
          const e3 = this._source.createOutputTrack();
          this._mediaStreamTrack !== e3 && (this._mediaStreamTrack = e3, rC(this, uS.NEED_REPLACE_TRACK, this).then(() => {
            OE.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
          }).catch((e4) => {
            OE.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e4);
          }));
        } catch (e3) {
        }
      }
      getVolumeLevel() {
        return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
      }
      async setPlaybackDevice(e2) {
        if (!this._useAudioElement)
          throw new SE(fE.NOT_SUPPORTED, "your browser does not support setting the audio output device");
        await pR.setSinkID(this.getTrackId(), e2);
      }
      async setEnabled(e2, t2, i3) {
        return this._setEnabled(e2, t2, i3);
      }
      async _setEnabled(e2, t2, i3) {
        if (!i3) {
          if (e2 === this._enabled)
            return;
          this.stateCheck("enabled", e2);
        }
        if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
          this._originMediaStreamTrack.enabled = true;
          try {
            i3 || (this._enabled = true), await rC(this, uS.NEED_ENABLE_TRACK, this), OE.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e2, " success"));
          } catch (e3) {
            throw i3 || (this._enabled = false), OE.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e3.toString()), e3;
          }
        } else {
          this._originMediaStreamTrack.enabled = false, i3 || (this._enabled = false);
          try {
            await rC(this, uS.NEED_DISABLE_TRACK, this);
          } catch (e3) {
            throw i3 || (this._enabled = true), OE.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
          }
        }
      }
      async setMuted(e2) {
        e2 !== this._muted && (this.stateCheck("muted", e2), this._muted = e2, this._originMediaStreamTrack.enabled = !e2, OE.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e2)), e2 ? await rC(this, uS.NEED_MUTE_TRACK, this) : await rC(this, uS.NEED_UNMUTE_TRACK, this));
      }
      getStats() {
        hC(() => {
          OE.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
        }, "localAudioTrackGetStatsWarning");
        const e2 = oC(this, uS.GET_STATS);
        return e2 || vI({}, jf);
      }
      setAudioFrameCallback(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
        if (!e2)
          return this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
        this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), this._source.on(Lf.ON_AUDIO_BUFFER, (t3) => e2(t3));
      }
      play() {
        OE.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (OE.debug("[".concat(this.getTrackId(), "] start audio playback in element")), pR.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
      }
      stop() {
        OE.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? pR.stop(this.getTrackId()) : this._source.stop();
      }
      close() {
        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy();
      }
      _updatePlayerSource() {
        let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        OE.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && pR.updateTrack(this.getTrackId(), this._mediaStreamTrack);
      }
      async _updateOriginMediaStreamTrack(e2, t2) {
        this._originMediaStreamTrack !== e2 && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e2.addEventListener("ended", this._handleTrackEnded), t2 && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e2, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this.processor.updateInput({ track: e2, context: this.processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e2));
      }
      renewMediaStreamTrack(e2) {
        return Sl.resolve(void 0);
      }
      pipe(e2) {
        if (this._bypassWebAudio)
          throw new SE(fE.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
        if (this.processor === e2)
          return e2;
        if (e2._source)
          throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
        return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
      }
      unpipe() {
        var e2;
        if (!this.processor)
          return;
        const t2 = this.processor;
        null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
      }
      bindProcessorDestinationEvents() {
        this.processorDestination.on(kS.ON_TRACK, async (e2) => {
          e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2), await rC(this, uS.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this));
        }), this.processorDestination.on(kS.ON_NODE, (e2) => {
          this._source.processedNode = e2;
        });
      }
      unbindProcessorDestinationEvents() {
        this.processorDestination.removeAllListeners(kS.ON_TRACK), this.processorDestination.removeAllListeners(kS.ON_NODE);
      }
      unbindProcessorContextEvents() {
        this.processorContext.removeAllListeners(MS.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(MS.REQUEST_CONSTRAINTS);
      }
    }).prototype, "_source", [MR], Object.getOwnPropertyDescriptor(iI.prototype, "_source"), iI.prototype), ag(iI.prototype, "processorContext", [UR], Object.getOwnPropertyDescriptor(iI.prototype, "processorContext"), iI.prototype), ag(iI.prototype, "processorDestination", [xR], Object.getOwnPropertyDescriptor(iI.prototype, "processorDestination"), iI.prototype), ag(iI.prototype, "setVolume", [VR], Object.getOwnPropertyDescriptor(iI.prototype, "setVolume"), iI.prototype), ag(iI.prototype, "setPlaybackDevice", [jR, FR], Object.getOwnPropertyDescriptor(iI.prototype, "setPlaybackDevice"), iI.prototype), ag(iI.prototype, "setEnabled", [BR, GR, WR], Object.getOwnPropertyDescriptor(iI.prototype, "setEnabled"), iI.prototype), ag(iI.prototype, "setMuted", [HR, KR, YR], Object.getOwnPropertyDescriptor(iI.prototype, "setMuted"), iI.prototype), ag(iI.prototype, "getStats", [qR], Object.getOwnPropertyDescriptor(iI.prototype, "getStats"), iI.prototype), ag(iI.prototype, "setAudioFrameCallback", [JR], Object.getOwnPropertyDescriptor(iI.prototype, "setAudioFrameCallback"), iI.prototype), ag(iI.prototype, "play", [XR, zR], Object.getOwnPropertyDescriptor(iI.prototype, "play"), iI.prototype), ag(iI.prototype, "stop", [QR, ZR], Object.getOwnPropertyDescriptor(iI.prototype, "stop"), iI.prototype), ag(iI.prototype, "close", [$R], Object.getOwnPropertyDescriptor(iI.prototype, "close"), iI.prototype), ag(iI.prototype, "pipe", [eI], Object.getOwnPropertyDescriptor(iI.prototype, "pipe"), iI.prototype), ag(iI.prototype, "unpipe", [tI], Object.getOwnPropertyDescriptor(iI.prototype, "unpipe"), iI.prototype), iI), AI = (nI = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), rI = _R(), oI = xg("MicrophoneAudioTrack", "_enabledMutex"), sI = Dg({ argsMap: (e2, t2, i3) => [e2.getTrackId(), t2, i3] }), aI = _R(), cI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((dI = class extends yI {
      get __className__() {
        return "MicrophoneAudioTrack";
      }
      constructor(e2, t2, i3, n2) {
        super(e2, t2.encoderConfig ? FE(t2.encoderConfig) : {}, n2, GE("GET_VOLUME_OF_MUTED_AUDIO_TRACK"), true), _p(this, "_config", void 0), _p(this, "_deviceName", "default"), _p(this, "_constraints", void 0), _p(this, "_originalConstraints", void 0), _p(this, "_enabled", true), this._config = t2, this._constraints = i3, this._originalConstraints = i3, this._deviceName = e2.label, "boolean" == typeof t2.bypassWebAudio && (this._bypassWebAudio = t2.bypassWebAudio), (Zh() || $h()) && Gg.bindInterruptDetectorTrack(this), this.on(DR.UPDATE_TRACK_SOURCE, () => {
          this.bindProcessorContextEvents();
        }), Kg() && this.bindProcessorContextEvents();
      }
      async setDevice(e2) {
        if (OE.info("[".concat(this.getTrackId(), "] start set device to ").concat(e2)), this._enabled)
          try {
            const t2 = await lR.getDeviceById(e2), i3 = {};
            i3.audio = vI({}, this._constraints), i3.audio.deviceId = { exact: e2 }, this._originMediaStreamTrack.stop();
            let n2 = null;
            try {
              n2 = await aR(i3, this.getTrackId());
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await aR({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), e3;
            }
            await this._updateOriginMediaStreamTrack(n2.getAudioTracks()[0], false), this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
        else
          try {
            const t2 = await lR.getDeviceById(e2);
            this._deviceName = t2.label, this._config.microphoneId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
        OE.info("[".concat(this.getTrackId(), "] set device to ").concat(e2, " success"));
      }
      async setEnabled(e2, t2, i3) {
        if (t2)
          return OE.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e2);
        if (!i3) {
          if (e2 === this._enabled)
            return;
          this.stateCheck("enabled", e2);
        }
        if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), !e2) {
          var n2;
          this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n2 = this._source.clonedTrack) || void 0 === n2 || n2.stop(), i3 || (this._enabled = false);
          try {
            await rC(this, uS.NEED_DISABLE_TRACK, this);
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e3.toString()), e3;
          }
          return;
        }
        const r2 = vI({}, this._constraints), o2 = lR.searchDeviceIdByName(this._deviceName);
        o2 && !r2.deviceId && (r2.deviceId = o2);
        try {
          i3 || (this._enabled = true);
          const e3 = await aR({ audio: this._constraints }, this.getTrackId());
          await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], false), await rC(this, uS.NEED_ENABLE_TRACK, this);
        } catch (e3) {
          throw i3 || (this._enabled = false), OE.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e3.toString()), e3;
        }
        OE.info("[".concat(this.getTrackId(), "] setEnabled success"));
      }
      close() {
        super.close(), (Zh() || $h()) && Gg.unbindInterruptDetectorTrack(this);
      }
      onTrackEnded() {
        if ((Yh() || tp()) && this._enabled && !this._isClosed && Gg.duringInterruption) {
          const e2 = async () => {
            Gg.off(kg.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (OE.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
          };
          Gg.on(kg.IOS_INTERRUPTION_END, e2);
        } else
          OE.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(mS.TRACK_ENDED);
      }
      async renewMediaStreamTrack(e2) {
        const t2 = e2 || this._constraints, i3 = lR.searchDeviceIdByName(this._deviceName);
        if (i3 && !t2.deviceId && (t2.deviceId = i3), this._constraints = t2, this._enabled) {
          this._originMediaStreamTrack.stop();
          const e3 = await aR({ audio: this._constraints }, this.getTrackId());
          await this._updateOriginMediaStreamTrack(e3.getAudioTracks()[0], true);
        }
      }
      bindProcessorContextEvents() {
        this.processorContext.on(MS.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i3) => {
          try {
            const i4 = Object.assign({}, this._originalConstraints, ...e2);
            await this.renewMediaStreamTrack(i4), t2();
          } catch (e3) {
            i3(e3);
          }
        }), this.processorContext.on(MS.REQUEST_CONSTRAINTS, async (e2) => {
          e2(this._originMediaStreamTrack.getSettings());
        });
      }
    }).prototype, "setDevice", [nI, rI], Object.getOwnPropertyDescriptor(dI.prototype, "setDevice"), dI.prototype), ag(dI.prototype, "setEnabled", [oI, sI, aI], Object.getOwnPropertyDescriptor(dI.prototype, "setEnabled"), dI.prototype), ag(dI.prototype, "close", [cI], Object.getOwnPropertyDescriptor(dI.prototype, "close"), dI.prototype), dI), OI = (uI = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2, e2.duration] }), lI = _R(), hI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), pI = _R(), _I = Dg({ argsMap: (e2) => [e2.getTrackId()] }), EI = _R(), mI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), fI = _R(), SI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), TI = _R(), gI = Dg({ argsMap: (e2) => [e2.getTrackId()] }), RI = _R(), ag((II = class extends yI {
      get __className__() {
        return "BufferSourceAudioTrack";
      }
      constructor(e2, t2, i3, n2) {
        super(t2.createOutputTrack(), i3, n2), _p(this, "source", void 0), _p(this, "_bufferSource", void 0), this.source = e2, this._bufferSource = t2, this._bufferSource.on(Lf.AUDIO_SOURCE_STATE_CHANGE, (e3) => {
          this.safeEmit(mS.SOURCE_STATE_CHANGE, e3);
        });
        try {
          this._mediaStreamTrack = this._source.createOutputTrack();
        } catch (e3) {
        }
      }
      get currentState() {
        return this._bufferSource.currentState;
      }
      get duration() {
        return this._bufferSource.duration;
      }
      get playbackSpeed() {
        return this._bufferSource.playbackSpeed;
      }
      getCurrentTime() {
        return this._bufferSource.currentTime;
      }
      startProcessAudioBuffer(e2) {
        e2 && this._bufferSource.updateOptions(e2), this._bufferSource.startProcessAudioBuffer();
      }
      pauseProcessAudioBuffer() {
        this._bufferSource.pauseProcessAudioBuffer();
      }
      seekAudioBuffer(e2) {
        this._bufferSource.seekAudioBuffer(e2);
      }
      resumeProcessAudioBuffer() {
        this._bufferSource.resumeProcessAudioBuffer();
      }
      stopProcessAudioBuffer() {
        this._bufferSource.stopProcessAudioBuffer();
      }
      setAudioBufferPlaybackSpeed(e2) {
        qm(e2, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(e2);
      }
    }).prototype, "startProcessAudioBuffer", [uI, lI], Object.getOwnPropertyDescriptor(II.prototype, "startProcessAudioBuffer"), II.prototype), ag(II.prototype, "pauseProcessAudioBuffer", [hI, pI], Object.getOwnPropertyDescriptor(II.prototype, "pauseProcessAudioBuffer"), II.prototype), ag(II.prototype, "seekAudioBuffer", [_I, EI], Object.getOwnPropertyDescriptor(II.prototype, "seekAudioBuffer"), II.prototype), ag(II.prototype, "resumeProcessAudioBuffer", [mI, fI], Object.getOwnPropertyDescriptor(II.prototype, "resumeProcessAudioBuffer"), II.prototype), ag(II.prototype, "stopProcessAudioBuffer", [SI, TI], Object.getOwnPropertyDescriptor(II.prototype, "stopProcessAudioBuffer"), II.prototype), ag(II.prototype, "setAudioBufferPlaybackSpeed", [gI, RI], Object.getOwnPropertyDescriptor(II.prototype, "setAudioBufferPlaybackSpeed"), II.prototype), II);
    class NI extends yI {
      get __className__() {
        return "MixingAudioTrack";
      }
      get isActive() {
        for (const e2 of this.trackList)
          if (e2._enabled && !e2._isClosed && !e2.muted)
            return true;
        return false;
      }
      constructor() {
        const e2 = Hg().createMediaStreamDestination();
        super(e2.stream.getAudioTracks()[0], void 0, ZI(8, "track-mix-")), _p(this, "trackList", void 0), _p(this, "destNode", void 0);
        try {
          this._mediaStreamTrack = this._source.createOutputTrack();
        } catch (e3) {
        }
        this.destNode = e2, this.trackList = [];
      }
      hasAudioTrack(e2) {
        return -1 !== this.trackList.indexOf(e2);
      }
      addAudioTrack(e2) {
        -1 === this.trackList.indexOf(e2) ? (OE.debug("add ".concat(e2.getTrackId(), " to mixing track")), e2._source.outputNode.connect(this.destNode), this.trackList.push(e2), this.updateEncoderConfig()) : OE.debug("track ".concat(e2.getTrackId(), " is already added"));
      }
      removeAudioTrack(e2) {
        if (-1 !== this.trackList.indexOf(e2)) {
          OE.debug("remove ".concat(e2.getTrackId(), " from mixing track"));
          try {
            e2._source.outputNode.disconnect(this.destNode);
          } catch (e3) {
          }
          aC(this.trackList, e2), this.updateEncoderConfig();
        }
      }
      updateEncoderConfig() {
        const e2 = {};
        this.trackList.forEach((t2) => {
          t2._encoderConfig && ((t2._encoderConfig.bitrate || 0) > (e2.bitrate || 0) && (e2.bitrate = t2._encoderConfig.bitrate), (t2._encoderConfig.sampleRate || 0) > (e2.sampleRate || 0) && (e2.sampleRate = t2._encoderConfig.sampleRate), (t2._encoderConfig.sampleSize || 0) > (e2.sampleSize || 0) && (e2.sampleSize = t2._encoderConfig.sampleSize), t2._encoderConfig.stereo && (e2.stereo = true));
        }), this._encoderConfig = e2;
      }
      _updateRtpTransceiver(e2) {
        this._rtpTransceiver !== e2 && (this._rtpTransceiver = e2, this.trackList.forEach((t2) => {
          t2 instanceof NI ? t2.emit(ES.TRANSCEIVER_UPDATED, e2) : t2._updateRtpTransceiver(e2);
        }));
      }
    }
    class bI extends EE {
      constructor() {
        super(...arguments), _p(this, "resultStorage", /* @__PURE__ */ new Map());
      }
      setLocalAudioStats(e2, t2, i3) {
        this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e2, this.checkAudioInputLevel(i3, t2)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e2, this.checkSendAudioBitrate(i3, t2));
      }
      setLocalVideoStats(e2, t2, i3) {
        this.record("SEND_VIDEO_BITRATE_TOO_LOW", e2, this.checkSendVideoBitrate(i3, t2)), this.record("FRAMERATE_INPUT_TOO_LOW", e2, this.checkFramerateInput(i3, t2)), this.record("FRAMERATE_SENT_TOO_LOW", e2, this.checkFramerateSent(i3));
      }
      setRemoteAudioStats(e2, t2) {
        const i3 = e2.getUserId();
        this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i3, this.checkAudioOutputLevel(t2));
      }
      setRemoteVideoStats(e2, t2) {
        const i3 = e2.getUserId();
        this.record("RECV_VIDEO_DECODE_FAILED", i3, this.checkVideoDecode(t2));
      }
      record(e2, t2, i3) {
        if (GE("STATS_UPDATE_INTERVAL") > 500)
          return;
        this.resultStorage.has(e2) || this.resultStorage.set(e2, { result: [], isPrevNormal: true });
        const n2 = this.resultStorage.get(e2);
        if (n2 && (n2.result.push(i3), n2.result.length >= 5)) {
          const i4 = n2.result.includes(true);
          n2.isPrevNormal && !i4 && this.emit("exception", wI[e2], e2, t2), !n2.isPrevNormal && i4 && this.emit("exception", wI[e2] + 2e3, e2 + "_RECOVER", t2), n2.isPrevNormal = i4, n2.result = [];
        }
      }
      checkAudioOutputLevel(e2) {
        return !(e2.receiveBitrate > 0 && 0 === e2.receiveLevel);
      }
      checkAudioInputLevel(e2, t2) {
        return t2 instanceof NI && !t2.isActive || (!!t2.muted || 0 !== e2.sendVolumeLevel);
      }
      checkFramerateInput(e2, t2) {
        let i3 = null;
        t2._encoderConfig && t2._encoderConfig.frameRate && (i3 = FI(t2._encoderConfig.frameRate));
        const n2 = e2.captureFrameRate;
        return !i3 || !n2 || !(i3 > 10 && n2 < 5 || i3 < 10 && i3 >= 5 && n2 <= 1);
      }
      checkFramerateSent(e2) {
        return !(e2.captureFrameRate && e2.sendFrameRate && e2.captureFrameRate > 5 && e2.sendFrameRate <= 1);
      }
      checkSendVideoBitrate(e2, t2) {
        return !!t2.muted || 0 !== e2.sendBitrate;
      }
      checkSendAudioBitrate(e2, t2) {
        return t2 instanceof NI && !t2.isActive || (!!t2.muted || 0 !== e2.sendBitrate);
      }
      checkVideoDecode(e2) {
        return 0 === e2.receiveBitrate || 0 !== e2.decodeFrameRate;
      }
    }
    const wI = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
    const DI = new class {
      markSubscribeStart(e2, t2) {
        performance.mark("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
      }
      markPublishStart(e2, t2) {
        performance.mark("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
      }
      measureFromSubscribeStart(e2, t2) {
        const i3 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/subscribe-").concat(t2));
        if (i3.length > 0) {
          const e3 = i3[i3.length - 1];
          return Math.round(performance.now() - e3.startTime);
        }
        return 0;
      }
      measureFromPublishStart(e2, t2) {
        const i3 = performance.getEntriesByName("agora-web-sdk/".concat(e2, "/publish-").concat(t2));
        if (i3.length > 0) {
          const e3 = i3[i3.length - 1];
          return Math.round(performance.now() - e3.startTime);
        }
        return 0;
      }
    }();
    function PI(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function LI(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? PI(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : PI(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class kI {
      constructor(e2) {
        _p(this, "store", void 0), _p(this, "onStatsException", void 0), _p(this, "onUploadPublishDuration", void 0), _p(this, "onStatsChanged", void 0), _p(this, "localStats", /* @__PURE__ */ new Map()), _p(this, "remoteStats", /* @__PURE__ */ new Map()), _p(this, "updateStatsInterval", void 0), _p(this, "trafficStats", void 0), _p(this, "trafficStatsPeerList", []), _p(this, "uplinkStats", void 0), _p(this, "exceptionMonitor", void 0), _p(this, "p2pChannel", void 0), _p(this, "scalabilityMode", Lh.L1T1), _p(this, "updateStats", () => {
          this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
        }), this.store = e2, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new bI(), this.exceptionMonitor.on("exception", (e3, t2, i3) => {
          this.onStatsException && this.onStatsException(e3, t2, i3);
        });
      }
      reset() {
        this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
      }
      getLocalAudioTrackStats() {
        return this.localStats.get(bS.LocalAudioTrack) || LI({}, jf);
      }
      getLocalVideoTrackStats() {
        return this.localStats.get(bS.LocalVideoTrack) || LI({}, Ff);
      }
      getRemoteAudioTrackStats(e2) {
        const t2 = (e3, t3) => {
          if (!this.trafficStats)
            return t3;
          const i4 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
          return i4 && (t3.publishDuration = i4.B_ppad + (Date.now() - this.trafficStats.timestamp)), t3;
        }, i3 = {};
        if (e2) {
          var n2;
          const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.audioStats;
          r2 && (i3[e2] = t2(e2, r2));
        } else
          Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [n3, { audioStats: r2 }] = e3;
            r2 && (i3[n3] = t2(n3, r2));
          });
        return i3;
      }
      getRemoteNetworkQualityStats(e2) {
        const t2 = {};
        if (e2) {
          var i3;
          const n2 = null === (i3 = this.remoteStats.get(e2)) || void 0 === i3 ? void 0 : i3.networkStats;
          n2 && (t2[e2] = n2);
        } else
          Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [i4, { networkStats: n2 }] = e3;
            n2 && (t2[i4] = n2);
          });
        return t2;
      }
      getRemoteVideoTrackStats(e2) {
        const t2 = (e3, t3) => {
          if (!this.trafficStats)
            return t3;
          const i4 = this.trafficStats.peer_delay.find((t4) => t4.peer_uid === e3);
          return i4 && (t3.publishDuration = i4.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t3;
        }, i3 = {};
        if (e2) {
          var n2;
          const r2 = null === (n2 = this.remoteStats.get(e2)) || void 0 === n2 ? void 0 : n2.videoStats;
          r2 && (i3[e2] = t2(e2, r2));
        } else
          Array.from(this.remoteStats.entries()).forEach((e3) => {
            let [n3, { videoStats: r2 }] = e3;
            r2 && (i3[n3] = t2(n3, r2));
          });
        return i3;
      }
      getRTCStats() {
        let e2 = 0, t2 = 0, i3 = 0, n2 = 0;
        const r2 = this.localStats.get(bS.LocalAudioTrack);
        r2 && (e2 += r2.sendBytes, t2 += r2.sendBitrate);
        const o2 = this.localStats.get(bS.LocalVideoTrack);
        o2 && (e2 += o2.sendBytes, t2 += o2.sendBitrate);
        const s2 = this.localStats.get(bS.LocalVideoLowTrack);
        s2 && (e2 += s2.sendBytes, t2 += s2.sendBitrate), this.remoteStats.forEach((e3) => {
          let { audioStats: t3, videoStats: r3 } = e3;
          t3 && (i3 += t3.receiveBytes, n2 += t3.receiveBitrate), r3 && (i3 += r3.receiveBytes, n2 += r3.receiveBitrate);
        });
        let a2 = 1;
        return this.trafficStats && (a2 += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: a2, SendBitrate: t2, SendBytes: e2, RecvBytes: i3, RecvBitrate: n2, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
      }
      addLocalStats(e2) {
        this.localStats.set(e2, void 0);
      }
      removeLocalStats(e2) {
        e2 ? this.localStats.delete(e2) : this.localStats.clear();
      }
      addRemoteStats(e2) {
        this.remoteStats.set(e2, {});
      }
      removeRemoteStats(e2) {
        e2 ? this.remoteStats.delete(e2) : this.remoteStats.clear();
      }
      addP2PChannel(e2) {
        this.p2pChannel = e2;
      }
      updateTrafficStats(e2) {
        e2.peer_delay = e2.peer_delay.filter((e3) => void 0 !== e3.B_ppad || void 0 !== e3.B_ppvd);
        e2.peer_delay.filter((e3) => -1 === this.trafficStatsPeerList.indexOf(e3.peer_uid)).forEach((e3) => {
          var t2;
          const i3 = null === (t2 = this.p2pChannel) || void 0 === t2 ? void 0 : t2.getRemoteMedia(e3.peer_uid), n2 = null != i3 && i3.videoSSRC ? DI.measureFromSubscribeStart(this.store.clientId, i3.videoSSRC) : 0, r2 = null != i3 && i3.audioSSRC ? DI.measureFromSubscribeStart(this.store.clientId, i3.audioSSRC) : 0;
          void 0 !== e3.B_ppad && void 0 !== e3.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e3.peer_uid, e3.B_ppad, e3.B_ppvd, n2 > r2 ? n2 : r2), this.trafficStatsPeerList.push(e3.peer_uid));
        }), this.trafficStats = e2;
      }
      updateUplinkStats(e2) {
        this.uplinkStats && this.uplinkStats.B_fir !== e2.B_fir && OE.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e2.B_fir)), this.uplinkStats = e2;
      }
      static isRemoteVideoFreeze(e2, t2, i3) {
        if (!e2)
          return false;
        const n2 = !!i3 && t2.framesDecodeFreezeTime > i3.framesDecodeFreezeTime, r2 = !i3 || t2.framesDecodeCount > i3.framesDecodeCount;
        return n2 || !r2;
      }
      static isRemoteAudioFreeze(e2) {
        return !!e2 && e2._isFreeze();
      }
      isLocalVideoFreeze(e2) {
        return !(!e2.inputFrame || !e2.sentFrame) && (e2.inputFrame.frameRate > 5 && e2.sentFrame.frameRate < 3);
      }
      updateLocalStats(e2) {
        Array.from(this.localStats.entries()).forEach((t2) => {
          let [i3, n2] = t2;
          switch (i3) {
            case bS.LocalVideoTrack:
            case bS.LocalVideoLowTrack: {
              const t3 = n2, o2 = LI({}, Ff), s2 = e2.getStats(), a2 = e2.getLocalMedia(i3);
              if (s2) {
                const i4 = s2.videoSend.find((e3) => e3.ssrc === (null == a2 ? void 0 : a2.ssrcs[0].ssrcId));
                if (i4) {
                  const n3 = e2.getLocalVideoSize(), r3 = e2.getEncoderConfig(bS.LocalVideoTrack);
                  "H264" !== i4.codec && "H265" !== i4.codec && "VP8" !== i4.codec && "VP9" !== i4.codec && "AV1X" !== i4.codec && "AV1" !== i4.codec || (o2.codecType = i4.codec), o2.sendBytes = i4.bytes, o2.sendBitrate = t3 ? 8 * Math.max(0, o2.sendBytes - t3.sendBytes) : 0, i4.inputFrame ? (o2.captureFrameRate = i4.inputFrame.frameRate, o2.captureResolutionHeight = i4.inputFrame.height, o2.captureResolutionWidth = i4.inputFrame.width) : n3 && (o2.captureResolutionWidth = n3.width, o2.captureResolutionHeight = n3.height), i4.sentFrame ? (o2.sendFrameRate = i4.sentFrame.frameRate, o2.sendResolutionHeight = i4.sentFrame.height, o2.sendResolutionWidth = i4.sentFrame.width) : n3 && (o2.sendResolutionWidth = n3.width, o2.sendResolutionHeight = n3.height), i4.avgEncodeMs && (o2.encodeDelay = i4.avgEncodeMs), r3 && r3.bitrateMax && (o2.targetSendBitrate = 1e3 * r3.bitrateMax), o2.sendPackets = i4.packets, o2.sendPacketsLost = i4.packetsLost, o2.totalDuration = t3 ? t3.totalDuration + 1 : 1, o2.totalFreezeTime = t3 ? t3.totalFreezeTime : 0, this.isLocalVideoFreeze(i4) && (o2.totalFreezeTime += 1), i4.scalabilityMode && this.scalabilityMode !== i4.scalabilityMode && (OE.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(i4.scalabilityMode)), this.scalabilityMode = i4.scalabilityMode);
                }
                this.trafficStats && (o2.sendPacketsLost = this.trafficStats.B_pvlr4 / 100);
              }
              var r2;
              if (this.localStats.set(i3, o2), (null == t3 ? void 0 : t3.sendResolutionWidth) !== o2.sendResolutionWidth || (null == t3 ? void 0 : t3.sendResolutionHeight) !== o2.sendResolutionHeight)
                null === (r2 = this.onStatsChanged) || void 0 === r2 || r2.call(this, "resolution", { width: o2.sendResolutionWidth, height: o2.sendResolutionHeight });
              o2 && a2 && this.exceptionMonitor.setLocalVideoStats(this.store.uid, a2.track, o2);
              break;
            }
            case bS.LocalAudioTrack: {
              const t3 = n2, r3 = LI({}, jf), o2 = e2.getStats(), s2 = e2.getLocalMedia(i3);
              if (o2) {
                const i4 = o2.audioSend.find((e3) => e3.ssrc === (null == s2 ? void 0 : s2.ssrcs[0].ssrcId));
                if (i4) {
                  if ("opus" !== i4.codec && "aac" !== i4.codec && "PCMU" !== i4.codec && "PCMA" !== i4.codec && "G722" !== i4.codec || (r3.codecType = i4.codec), i4.inputLevel)
                    r3.sendVolumeLevel = Math.round(32767 * i4.inputLevel);
                  else {
                    const t4 = e2.getLocalAudioVolume();
                    t4 && (r3.sendVolumeLevel = Math.round(32767 * t4));
                  }
                  r3.sendBytes = i4.bytes, r3.sendPackets = i4.packets, r3.sendPacketsLost = i4.packetsLost, r3.sendBitrate = t3 ? 8 * Math.max(0, r3.sendBytes - t3.sendBytes) : 0;
                }
              }
              this.trafficStats && (r3.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(bS.LocalAudioTrack, r3), r3 && s2 && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s2.track, r3);
              break;
            }
          }
        });
      }
      updateRemoteStats(e2) {
        Array.from(this.remoteStats.entries()).forEach((t2) => {
          let [i3, { videoStats: n2, audioStats: r2, videoPcStats: o2 }] = t2;
          const s2 = r2, a2 = n2, c2 = o2, d2 = LI({}, Bf), u2 = LI({}, Wf), l2 = LI({}, Gf), { audioTrack: h3, videoTrack: p3, audioSSRC: _2, videoSSRC: E2 } = e2.getRemoteMedia(i3), m2 = e2.getStats(), f2 = null == m2 ? void 0 : m2.audioRecv.find((e3) => e3.ssrc === _2), S2 = null == m2 ? void 0 : m2.videoRecv.find((e3) => e3.ssrc === E2), T2 = this.trafficStats && this.trafficStats.peer_delay.find((e3) => e3.peer_uid === i3);
          if (f2 && ("opus" !== f2.codec && "aac" !== f2.codec && "PCMU" !== f2.codec && "PCMA" !== f2.codec && "G722" !== f2.codec || (d2.codecType = f2.codec), f2.outputLevel ? d2.receiveLevel = Math.round(32767 * f2.outputLevel) : h3 && (d2.receiveLevel = Math.round(32767 * h3.getVolumeLevel())), d2.receiveBytes = f2.bytes, d2.receivePackets = f2.packets, d2.receivePacketsLost = f2.packetsLost, d2.packetLossRate = d2.receivePacketsLost / (d2.receivePackets + d2.receivePacketsLost), d2.receiveBitrate = s2 ? 8 * Math.max(0, d2.receiveBytes - s2.receiveBytes) : 0, d2.totalDuration = s2 ? s2.totalDuration + 1 : 1, d2.totalFreezeTime = s2 ? s2.totalFreezeTime : 0, d2.freezeRate = d2.totalFreezeTime / d2.totalDuration, d2.receiveDelay = f2.jitterBufferMs, d2.totalDuration > 10 && kI.isRemoteAudioFreeze(h3) && (d2.totalFreezeTime += 1)), S2) {
            "H264" !== S2.codec && "H265" !== S2.codec && "VP8" !== S2.codec && "VP9" !== S2.codec && "AV1X" !== S2.codec && "AV1" !== S2.codec || (u2.codecType = S2.codec), u2.receiveBytes = S2.bytes, u2.receiveBitrate = a2 ? 8 * Math.max(0, u2.receiveBytes - a2.receiveBytes) : 0, u2.decodeFrameRate = S2.decodeFrameRate < 0 ? 0 : S2.decodeFrameRate, u2.renderFrameRate = S2.decodeFrameRate < 0 ? 0 : S2.decodeFrameRate, S2.outputFrame && (u2.renderFrameRate = S2.outputFrame.frameRate), S2.receivedFrame ? (u2.receiveFrameRate = S2.receivedFrame.frameRate, u2.receiveResolutionHeight = S2.receivedFrame.height, u2.receiveResolutionWidth = S2.receivedFrame.width) : p3 && (u2.receiveResolutionHeight = p3._videoHeight || 0, u2.receiveResolutionWidth = p3._videoWidth || 0), void 0 !== S2.framesRateFirefox && (u2.receiveFrameRate = Math.round(S2.framesRateFirefox)), u2.receivePackets = S2.packets, u2.receivePacketsLost = S2.packetsLost, u2.packetLossRate = u2.receivePacketsLost / (u2.receivePackets + u2.receivePacketsLost), u2.totalDuration = a2 ? a2.totalDuration + 1 : 1, u2.totalFreezeTime = a2 ? a2.totalFreezeTime : 0, u2.receiveDelay = S2.jitterBufferMs || 0;
            const t3 = !!E2 && e2.getRemoteVideoIsReady(E2);
            p3 && t3 && kI.isRemoteVideoFreeze(p3, S2, c2) && (u2.totalFreezeTime += 1), u2.freezeRate = u2.totalFreezeTime / u2.totalDuration;
          }
          T2 && (d2.end2EndDelay = T2.B_ad, u2.end2EndDelay = T2.B_vd, d2.transportDelay = T2.B_ed, u2.transportDelay = T2.B_ed, d2.currentPacketLossRate = T2.B_ealr4 / 100, u2.currentPacketLossRate = T2.B_evlr4 / 100, l2.uplinkNetworkQuality = T2.B_punq ? T2.B_punq : 0, l2.downlinkNetworkQuality = T2.B_pdnq ? T2.B_pdnq : 0), this.remoteStats.set(i3, { audioStats: d2, videoStats: u2, videoPcStats: S2, networkStats: l2 }), h3 && this.exceptionMonitor.setRemoteAudioStats(h3, d2), p3 && this.exceptionMonitor.setRemoteVideoStats(p3, u2);
        });
      }
    }
    const MI = new class extends EE {
      get visibility() {
        return document.visibilityState;
      }
      get lastHiddenTime() {
        return this._lastHiddenTime;
      }
      get lastVisibleTime() {
        return this._lastVisibleTime;
      }
      constructor() {
        super(), _p(this, "_lastHiddenTime", 0), _p(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
          "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), OE.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
        });
      }
    }();
    function UI(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function xI(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? UI(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : UI(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    function VI(e2) {
      return e2.match(/^[\.\:\d]+$/) ? "".concat(e2.replace(/[^\d]/g, "-"), ".").concat(GE("TURN_DOMAIN")) : (OE.info("Cannot recognized as IP address ".concat(e2, ". Used As Host instead")), e2);
    }
    function jI(e2, t2) {
      var i3, n2;
      const r2 = GE("GATEWAY_DOMAINS");
      let o2 = r2[1] && -1 !== t2.indexOf(r2[1]) ? 1 : 0;
      e2.addresses = e2.addresses || [];
      const s2 = e2.addresses.map((e3) => e3.domain_prefix ? { address: "".concat(e3.domain_prefix, ".").concat(r2[o2++ % r2.length], ":").concat(e3.port) } : e3.ip.match(/^[\.\:\d]+$/) ? { ip: e3.ip, port: e3.port, address: "".concat(e3.ip.replace(/[^\d]/g, "-"), ".").concat(r2[o2++ % r2.length], ":").concat(e3.port) } : (OE.info("Cannot recognized as IP address ".concat(e3.ip, ". Used As Host instead")), { ip: e3.ip, port: e3.port, address: "".concat(e3.ip, ":").concat(e3.port) }));
      if (null !== (i3 = e2.detail) && void 0 !== i3 && i3[18] && "string" == typeof (null === (n2 = e2.detail) || void 0 === n2 ? void 0 : n2[18])) {
        const t3 = e2.detail[18], i4 = null == t3 ? void 0 : t3.split(";");
        for (let e3 = 0; e3 < i4.length; e3++) {
          var a2;
          const t4 = mh(a2 = i4[e3]).call(a2);
          s2[e3] && t4 && (s2[e3].ip6 = t4);
        }
      }
      return { gatewayAddrs: s2, uid: e2.uid, cid: e2.cid, cert: e2.cert, vid: e2.detail && e2.detail[8], uni_lbs_ip: e2.detail && e2.detail[1], res: e2, csIp: e2.detail && e2.detail[502] };
    }
    function FI(e2) {
      return "number" == typeof e2 ? e2 : e2.exact || e2.ideal || e2.max || e2.min || 0;
    }
    function BI(e2) {
      const t2 = e2._encoderConfig;
      if (!t2)
        return {};
      const i3 = { resolution: t2.width && t2.height ? "".concat(FI(t2.width), "x").concat(FI(t2.height)) : void 0, maxVideoBW: t2.bitrateMax, minVideoBW: t2.bitrateMin };
      return "number" == typeof t2.frameRate ? (i3.maxFrameRate = t2.frameRate, i3.minFrameRate = t2.frameRate) : t2.frameRate && (i3.maxFrameRate = t2.frameRate.max || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.min, i3.minFrameRate = t2.frameRate.min || t2.frameRate.ideal || t2.frameRate.exact || t2.frameRate.max), i3;
    }
    function GI(e2) {
      return e2 >= 0 && e2 < 0.17 ? 1 : e2 >= 0.17 && e2 < 0.36 ? 2 : e2 >= 0.36 && e2 < 0.59 ? 3 : e2 >= 0.59 && e2 <= 1 ? 4 : e2 > 1 ? 5 : 0;
    }
    function WI(e2, t2) {
      let i3, n2, r2 = void 0;
      switch (t2) {
        case XS.CHOOSE_SERVER:
          i3 = 4096, n2 = "choose server";
          break;
        case XS.CLOUD_PROXY:
          i3 = 1048576, n2 = "proxy";
          break;
        case XS.CLOUD_PROXY_5:
          i3 = 4194304, n2 = "proxy5";
          break;
        case XS.CLOUD_PROXY_FALLBACK:
          i3 = 4194310, n2 = "proxy fallback";
          break;
        default:
          throw new SE(fE.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: e2.detail && e2.detail[502], retry: false });
      }
      if (e2.response_body.forEach((t3) => {
        t3.buffer && t3.buffer.flag === i3 && (r2 = { code: t3.buffer.code, addresses: (t3.buffer.edges_services || []).map((e3) => xI(xI({}, e3), {}, { ticket: t3.buffer.cert })), server_ts: e2.enter_ts, uid: t3.buffer.uid, cid: t3.buffer.cid, cname: t3.buffer.cname, detail: xI(xI({}, t3.buffer.detail), e2.detail), flag: t3.buffer.flag, opid: e2.opid, cert: t3.buffer.cert });
      }), !r2)
        throw new SE(fE.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(n2, " from multi unilbs response"), { csIp: e2.detail && e2.detail[502] });
      return r2;
    }
    async function HI(e2, t2) {
      return await Sl.all(e2.addresses.map(async (e3) => ({ address: VI(e3.ip), tcpport: e3.port, udpport: e3.port, username: t2 && GE("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t2.toString() : PE.username, password: t2 && GE("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await Ng(t2.toString()) : PE.password })));
    }
    function KI(e2, t2) {
      const i3 = t2._videoWidth || t2.getMediaStreamTrack(true).getSettings().width;
      return i3 || OE.warning("cannot get original video track's width, default scale down 4 times for low stream"), i3 ? i3 / FI(e2.width) : 4;
    }
    function YI(e2) {
      let { candidateType: t2, relayProtocol: i3, type: n2, address: r2, port: o2, protocol: s2 } = e2;
      return "local-candidate" === n2 ? { candidateType: t2, relayProtocol: i3, protocol: s2 } : { candidateType: t2, relayProtocol: i3, address: r2, port: o2, protocol: s2 };
    }
    function qI(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function JI(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? qI(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : qI(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    function XI(e2) {
      return window.TextEncoder ? new TextEncoder().encode(e2).length : e2.length;
    }
    function zI(e2) {
      return new Sl((t2) => {
        window.setTimeout(t2, e2);
      });
    }
    function QI(e2) {
      const t2 = new SE(fE.TIMEOUT, "timeout");
      return new Sl((i3, n2) => {
        window.setTimeout(() => n2(t2), e2);
      });
    }
    function ZI() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7, t2 = arguments.length > 1 ? arguments[1] : void 0;
      const i3 = Math.random().toString(16).substr(2, e2).toLowerCase();
      return i3.length === e2 ? "".concat(t2).concat(i3) : "".concat(t2).concat(i3) + ZI(e2 - i3.length, "");
    }
    function $I() {
      return ZI(32, "").toUpperCase();
    }
    const eC = () => {
    };
    function tC(e2) {
      return new Sl((t2, i3) => {
        let n2 = false;
        const r2 = document.createElement("video");
        r2.setAttribute("autoplay", ""), r2.setAttribute("muted", ""), r2.muted = true, r2.autoplay = true, r2.setAttribute("playsinline", ""), r2.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r2);
        const o2 = Yh() ? "canplay" : "playing";
        r2.addEventListener(o2, () => {
          const e3 = r2.videoWidth, i4 = r2.videoHeight;
          !e3 && Kh() || (n2 = true, r2.srcObject = null, r2.remove(), t2([e3, i4]));
        }), r2.srcObject = new MediaStream([e2]), r2.play().catch(eC), setTimeout(() => {
          n2 || (r2.srcObject = null, r2.remove(), t2([r2.videoWidth, r2.videoHeight]));
        }, 4e3);
      });
    }
    function iC(e2) {
      return Sl.all(e2.map((e3) => e3.then((e4) => {
        throw e4;
      }, (e4) => e4))).then((e3) => {
        throw e3;
      }, (e3) => e3);
    }
    function nC(e2, t2) {
      for (var i3 = arguments.length, n2 = new Array(i3 > 2 ? i3 - 2 : 0), r2 = 2; r2 < i3; r2++)
        n2[r2 - 2] = arguments[r2];
      return 0 === e2.getListeners(t2).length ? Sl.reject(new SE(fE.UNEXPECTED_ERROR, "can not emit promise")) : new Sl((i4, r3) => {
        e2.emit(t2, ...n2, i4, r3);
      });
    }
    function rC(e2, t2) {
      if (0 === e2.getListeners(t2).length)
        return Sl.resolve();
      for (var i3 = arguments.length, n2 = new Array(i3 > 2 ? i3 - 2 : 0), r2 = 2; r2 < i3; r2++)
        n2[r2 - 2] = arguments[r2];
      return nC(e2, t2, ...n2);
    }
    function oC(e2, t2) {
      if (0 === e2.getListeners(t2).length)
        return null;
      for (var i3 = arguments.length, n2 = new Array(i3 > 2 ? i3 - 2 : 0), r2 = 2; r2 < i3; r2++)
        n2[r2 - 2] = arguments[r2];
      return sC(e2, t2, ...n2);
    }
    function sC(e2, t2) {
      let i3 = null, n2 = null;
      for (var r2 = arguments.length, o2 = new Array(r2 > 2 ? r2 - 2 : 0), s2 = 2; s2 < r2; s2++)
        o2[s2 - 2] = arguments[s2];
      if (e2.emit(t2, ...o2, (e3) => {
        i3 = e3;
      }, (e3) => {
        n2 = e3;
      }), null !== n2)
        throw n2;
      if (null === i3)
        throw new SE(fE.UNEXPECTED_ERROR, "handler is not sync");
      return i3;
    }
    function aC(e2, t2) {
      const i3 = e2.indexOf(t2);
      -1 !== i3 && e2.splice(i3, 1);
    }
    function cC(e2) {
      const t2 = [];
      return e2.forEach((e3) => {
        -1 === t2.indexOf(e3) && t2.push(e3);
      }), t2;
    }
    function dC(e2) {
      Sl.resolve().then(e2);
    }
    function uC(e2) {
      return JSON.parse(JSON.stringify(e2));
    }
    const lC = {};
    function hC(e2, t2) {
      lC[t2] || (lC[t2] = true, e2());
    }
    function pC(e2) {
      const t2 = window.atob(e2), i3 = new Uint8Array(new ArrayBuffer(t2.length));
      for (let e3 = 0; e3 < t2.length; e3 += 1)
        i3[e3] = t2.charCodeAt(e3);
      return i3;
    }
    function _C(e2) {
      let t2 = "";
      for (let i3 = 0; i3 < e2.length; i3 += 1)
        t2 += String.fromCharCode(e2[i3]);
      return window.btoa(t2);
    }
    const EC = new class {
      constructor() {
        _p(this, "fnMap", /* @__PURE__ */ new Map());
      }
      throttleByKey(e2, t2, i3, n2) {
        for (var r2 = arguments.length, o2 = new Array(r2 > 4 ? r2 - 4 : 0), s2 = 4; s2 < r2; s2++)
          o2[s2 - 4] = arguments[s2];
        if (this.fnMap.has(t2)) {
          const r3 = this.fnMap.get(t2);
          if (r3.threshold !== i3) {
            r3.fn(...r3.args), clearTimeout(r3.timer);
            const s3 = window.setTimeout(() => {
              const e3 = this.fnMap.get(t2);
              e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
            }, i3);
            this.fnMap.set(t2, { fn: e2, threshold: i3, timer: s3, args: o2, skipFn: n2 });
          } else
            r3.skipFn && r3.skipFn(...r3.args), this.fnMap.set(t2, JI(JI({}, r3), {}, { fn: e2, args: o2, skipFn: n2 }));
        } else {
          const r3 = window.setTimeout(() => {
            const e3 = this.fnMap.get(t2);
            e3 && e3.fn(...e3.args), this.fnMap.delete(t2);
          }, i3);
          this.fnMap.set(t2, { fn: e2, threshold: i3, timer: r3, args: o2, skipFn: n2 });
        }
      }
    }(), mC = EC.throttleByKey.bind(EC), fC = async (e2) => {
      let { fragementLength: t2, referenceList: i3, asyncMapHandler: n2, allFailedhandler: r2, promisesCollector: o2 } = e2, s2 = 0;
      const a2 = t2;
      let c2, d2 = 0;
      const u2 = async () => {
        const e3 = (() => {
          const e4 = s2 * a2, t3 = e4 + a2;
          return i3.slice(e4, t3).map(n2);
        })();
        o2 && o2.push(...e3);
        try {
          c2 = await iC(e3);
        } catch (e4) {
          if (d2 += a2, s2++, !(d2 >= i3.length))
            return void await u2();
          r2(e4);
        }
        e3.forEach((e4) => e4.cancel());
      };
      return await u2(), c2;
    };
    function SC(e2) {
      return "object" == typeof e2 && null !== e2 && !(e2 instanceof RegExp);
    }
    const TC = { [Sf.ACCESS_POINT]: { [Rf.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [Rf.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [Rf.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [Rf.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [Rf.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [Rf.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voice service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [Rf.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [Sf.UNILBS]: { [gf.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [gf.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [gf.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [gf.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [gf.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [gf.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [gf.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [gf.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [gf.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [gf.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [gf.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [gf.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [Sf.STRING_UID_ALLOCATOR]: { [Tf.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [Tf.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [Tf.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
    function gC(e2) {
      const t2 = TC[Math.floor(e2 / 1e4)];
      if (!t2)
        return { desc: "unkonw error", retry: false };
      const i3 = t2[e2 % 1e4];
      if (!i3) {
        if (Math.floor(e2 / 1e4) === Sf.ACCESS_POINT) {
          const t3 = e2 % 1e4;
          if ("1" === t3.toString()[0])
            return { desc: e2.toString(), retry: false };
          if ("2" === t3.toString()[0])
            return { desc: e2.toString(), retry: true };
        }
        return { desc: "unkonw error", retry: false };
      }
      return i3;
    }
    const RC = { [If.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [If.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [If.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [If.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [If.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [If.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [If.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [If.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [If.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [If.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [If.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [If.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [If.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [If.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [If.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [If.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [If.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [If.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [If.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [If.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [If.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [If.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [If.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [If.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [If.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [If.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [If.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [If.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [If.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [If.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [If.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [If.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [If.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [If.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [If.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [If.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [If.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [If.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [If.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [If.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [If.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [If.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [If.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [If.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [If.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [If.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [If.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [If.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [If.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [If.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [If.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [If.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [If.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [If.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [If.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [If.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [If.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [If.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [If.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [If.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [If.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [If.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [If.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [If.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
    function IC(e2) {
      const t2 = RC[e2];
      return t2 || { desc: "UNKNOW_ERROR_".concat(e2), action: "failed" };
    }
    function CC(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    class vC extends EE {
      get url() {
        return this.websocket ? this.websocket.url : null;
      }
      get reconnectMode() {
        return this._reconnectMode;
      }
      set reconnectMode(e2) {
        ["tryNext", "recover"].includes(e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
      }
      get state() {
        return this._state;
      }
      set state(e2) {
        e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(Hf.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(Hf.CONNECTED) : "closed" === this._state ? this.emit(Hf.CLOSED) : "failed" === this._state && this.emit(Hf.FAILED));
      }
      resetReconnectCount(e2) {
        OE.debug("websocket reset reconnect count, reason: " + e2), this.reconnectCount = 0;
      }
      constructor(e2, t2) {
        let i3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], r2 = arguments.length > 4 ? arguments[4] : void 0;
        super(), _p(this, "connectionID", 0), _p(this, "currentURLIndex", 0), _p(this, "urls", void 0), _p(this, "_reconnectMode", "tryNext"), _p(this, "reconnectReason", void 0), _p(this, "_initMutex", new Ug("websocket")), _p(this, "name", void 0), _p(this, "_state", "closed"), _p(this, "reconnectInterrupter", void 0), _p(this, "websocket", void 0), _p(this, "retryConfig", void 0), _p(this, "reconnectCount", 0), _p(this, "forceCloseTimeout", 5e3), _p(this, "onlineReconnectListener", void 0), _p(this, "useCompress", void 0), _p(this, "tryDoubleDomain", false), _p(this, "wsInflateLength", 0), _p(this, "wsDeflateLength", 0), _p(this, "closeEstablishingWs", () => {
        }), _p(this, "store", void 0), _p(this, "joinChannelServiceRecordIndex", void 0), this.store = r2, this.name = e2, this.retryConfig = function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var i4 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? CC(Object(i4), true).forEach(function(t4) {
              _p(e3, t4, i4[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i4)) : CC(Object(i4)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i4, t4));
            });
          }
          return e3;
        }({}, t2), this.useCompress = i3, this.tryDoubleDomain = n2;
        const { timeout: o2, timeoutFactor: s2 } = t2, a2 = Math.max(300, Math.floor(3 * o2 / 5)), c2 = Math.max(1.2, Math.floor(8 * s2) / 10);
        PS.ONLINE && (this.retryConfig.timeout = a2, this.retryConfig.timeoutFactor = c2), Ig.on(LS.NETWORK_STATE_CHANGE, (e3, t3) => {
          e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === PS.ONLINE ? (this.retryConfig.timeout = a2, this.retryConfig.timeoutFactor = c2) : (this.retryConfig.timeout = o2, this.retryConfig.timeoutFactor = s2));
        });
      }
      getConnection() {
        return this.websocket || void 0;
      }
      init(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        this.forceCloseTimeout = t2;
        const i3 = (t3, i4) => {
          this.urls = e2;
          const n2 = this.urls[this.currentURLIndex];
          this.state = "connecting", this.createWebSocketConnection(n2).then(t3).catch(i4), this.once(Hf.CLOSED, () => i4(new SE(fE.WS_DISCONNECT))), this.once(Hf.CONNECTED, () => t3());
        };
        return this._initMutex.lock().then((e3) => new Sl((e4, t3) => {
          i3(e4, t3);
        }).then(() => {
          e3();
        }).catch(() => {
          e3();
        }));
      }
      close(e2, t2) {
        if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
          this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
          const e3 = this.websocket;
          t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this.websocket = void 0;
        }
        this.state = e2 ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
      }
      reconnect(e2, t2) {
        if (!this.websocket)
          return void OE.warning("[".concat(this.name, "] can not reconnect, no websocket"));
        var i3;
        (void 0 !== e2 && (this.reconnectMode = e2), OE.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinChannelServiceRecordIndex) && (null === (i3 = this.store) || void 0 === i3 || i3.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this.joinChannelServiceRecordIndex));
        const n2 = this.websocket.onclose;
        this.websocket.onclose = null, this.websocket.close(), n2 && n2.bind(this.websocket)({ code: 9999, reason: t2 });
      }
      sendMessage(e2) {
        let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN)
          throw new SE(fE.WS_ABORT, "websocket is not ready");
        try {
          t2 || (e2 = JSON.stringify(e2)), this.websocket.send(e2);
        } catch (e3) {
          throw new SE(fE.WS_ERR, "send websocket message error" + e3.toString());
        }
      }
      setWsInflateData(e2) {
        this.wsDeflateLength = this.wsDeflateLength + e2.originLength, this.wsInflateLength = this.wsInflateLength + e2.compressedLength;
      }
      getWsInflateData() {
        const e2 = this.wsInflateLength, t2 = this.wsDeflateLength;
        return this.clearWsInflateData(), { wsInflateLength: e2, wsDeflateLength: t2 };
      }
      clearWsInflateData() {
        this.wsInflateLength = 0, this.wsDeflateLength = 0;
      }
      async createWebSocketConnection(e2, t2) {
        return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new Sl((i3, n2) => {
          var r2;
          const o2 = (e3) => {
            var t3;
            null === (t3 = this.store) || void 0 === t3 || t3.signalChannelOpen(), OE.debug("[".concat(this.name, "] websocket opened:"), e3), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i3();
          }, s2 = async (e3) => {
            if (OE.debug("[".concat(this.name, "] websocket close ").concat(this.websocket && this.websocket.url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount < this.retryConfig.maxRetryCount) {
              "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
              const t3 = oC(this, Hf.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(t3);
              if ("closed" === this.state)
                return void OE.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
              if (!r3)
                return n2(new SE(fE.WS_DISCONNECT, "websocket reconnect failed: ".concat(e3.code))), void this.close(true);
              i3();
            } else
              n2(new SE(fE.WS_DISCONNECT, "websocket close: ".concat(e3.code))), this.close();
          }, a2 = (e3) => {
            this.emit(Hf.ON_MESSAGE, e3);
          };
          this.websocket && (this.websocket.onclose = null, this.websocket.close()), GE("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e2 = GE("GATEWAY_WSS_ADDRESS")), OE.debug("[".concat(this.name, "] start connect, url: ").concat(e2));
          const c2 = null === (r2 = this.store) || void 0 === r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
          this.chooseBestWebsocketConnection(e2, !!t2, c2).then((e3) => {
            var t3;
            this.websocket = e3, o2 && o2(e3.url), e3.onclose = s2, e3.onmessage = a2, null === (t3 = this.store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c2), this.joinChannelServiceRecordIndex = c2;
          }).catch((e3) => {
            var t3;
            if (null === (t3 = this.store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof SE && e3.code === fE.WS_ABORT ? "aborted" : "error", errors: [e3] }, c2), "closed" !== this.state) {
              if (e3 instanceof SE && e3.code === fE.WS_ERR) {
                const t4 = new SE(fE.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
                return OE.error("[".concat(this.name, "]").concat(t4)), void n2(t4);
              }
              s2 && s2(e3);
            } else
              n2(new SE(fE.WS_DISCONNECT, "websocket is closed: ".concat(e3.toString())));
          });
        });
      }
      async reconnectWithAction(e2) {
        let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (this.reconnectCount >= this.retryConfig.maxRetryCount)
          return false;
        if (!this.urls)
          return false;
        if ("closed" === this.state)
          return false;
        this.onlineReconnectListener || Ig.networkState !== PS.OFFLINE || (this.onlineReconnectListener = Ig.onlineWaiter && Ig.onlineWaiter.then(() => {
          this.onlineReconnectListener = void 0;
        }));
        let i3 = true;
        if (this.reconnectInterrupter = () => {
          i3 = false;
        }, t2) {
          const t3 = gE(this.reconnectCount, this.retryConfig);
          OE.debug("[".concat(this.name, "] wait ").concat(t3, "ms to reconnect websocket, mode: ").concat(e2)), await Sl.race([zI(t3), this.onlineReconnectListener || new Sl(() => {
          })]);
        }
        if ("closed" === this.state || !i3)
          return false;
        this.reconnectCount += 1;
        const n2 = async (e3, t3) => {
          this.emit(Hf.RECONNECT_CREATE_CONNECTION, t3), await this.createWebSocketConnection(e3);
        };
        try {
          if ("retry" === e2) {
            const t3 = this.urls[this.currentURLIndex];
            this.emit(Hf.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
          } else if ("tryNext" === e2) {
            if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length)
              return await this.reconnectWithAction("recover", false);
            OE.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex));
            const t3 = this.urls[this.currentURLIndex];
            this.emit(Hf.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
          } else if ("recover" === e2) {
            OE.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(Hf.RECONNECT_WAITTING_FINISH, e2), this.urls = await nC(this, Hf.REQUEST_NEW_URLS), this.currentURLIndex = 0;
            const t3 = this.urls[this.currentURLIndex];
            await n2(t3, e2);
          }
          return true;
        } catch (i4) {
          var r2;
          return OE.error("[".concat(this.name, "] reconnect failed"), i4.toString()), null != i4 && null !== (r2 = i4.data) && void 0 !== r2 && r2.desc && Array.isArray(i4.data.desc) && i4.data.desc.length && i4.data.desc.includes("dynamic key expired") ? (this.emit(Hf.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
        }
      }
      async chooseBestWebsocketConnection(e2, t2, i3) {
        return new Sl((n2, r2) => {
          let o2 = false;
          const s2 = [];
          this.closeEstablishingWs = () => {
            OE.debug("[choose-best-ws] close establishing websockets"), s2.forEach((e3) => {
              e3.onclose = null, e3.onopen = null, e3.onmessage = null, e3.close();
            }), r2(new SE(fE.WS_ABORT, "choose best websocket aborted"));
          };
          const a2 = GE("GATEWAY_DOMAINS");
          let c2;
          const d2 = e2.indexOf("?h="), u2 = a2.find((t3) => -1 !== d2 ? e2.includes(t3, d2) : e2.includes(t3));
          OE.debug("[choose-best-ws] currentDomain: ", u2, ", domains: ", a2);
          let l2 = !this.tryDoubleDomain || t2 || !u2;
          if (!l2 && u2) {
            var h3;
            const t3 = Date.now();
            try {
              a2.forEach((t4) => {
                const i4 = -1 === d2 ? e2.replace(u2, t4) : e2.substr(0, d2) + e2.substr(d2).replace(u2, t4), n3 = new WebSocket(i4);
                n3.binaryType = "arraybuffer", s2.push(n3), OE.debug("[choose-best-ws] ws is connecting:", n3.url);
              });
            } catch (e3) {
              for (OE.debug("[choose-best-ws] ws create failed, fallback to single url"), s2.forEach((e4) => e4.close()); s2.length; )
                s2.pop();
              l2 = true;
            }
            null === (h3 = this.store) || void 0 === h3 || h3.recordJoinChannelService({ urls: s2.map((e3) => e3.url), service: "gateway" }, i3), s2.forEach((e3) => {
              e3.onopen = () => {
                if (o2)
                  return;
                const i4 = Date.now() - t3;
                OE.debug("[choose-best-ws] ws open cost ".concat(i4, "ms")), s2.filter((t4) => t4 !== e3).forEach((e4) => {
                  OE.debug("[choose-best-ws]close backup websocket: ".concat(e4.url)), e4.close();
                }), o2 = true, n2(e3);
              }, e3.onclose = (e4) => {
                if (c2 = e4, o2)
                  return;
                s2.find((e5) => !(e5.readyState === WebSocket.CLOSED || e5.readyState === WebSocket.CLOSING)) || (OE.debug("[choose-best-ws] all websocket is closed"), o2 = true, r2(c2));
              }, e3.onmessage = (t4) => {
                OE.debug("[choose-best-ws]".concat(e3.url, " onmessage: ").concat(t4.data));
              };
            }), zI(this.forceCloseTimeout).then(() => {
              s2.forEach((e3) => {
                e3.readyState !== WebSocket.OPEN && e3.close();
              });
            });
          }
          if (l2) {
            var p3;
            let t3;
            OE.debug("[choose-best-ws] use single url: ", e2), null === (p3 = this.store) || void 0 === p3 || p3.recordJoinChannelService({ urls: [e2], service: "gateway" }, i3);
            try {
              t3 = new WebSocket(e2), s2.push(t3), t3.binaryType = "arraybuffer";
            } catch (e3) {
              const t4 = new SE(fE.WS_ERR, "init websocket failed! Error: ".concat(e3.toString()));
              return OE.error("[".concat(this.name, "]").concat(t4)), void r2(t4);
            }
            t3.onopen = () => {
              n2(t3);
            }, t3.onclose = (e3) => {
              r2(e3);
            }, t3.onmessage = (e3) => {
              OE.debug("[choose-best-ws]".concat(t3.url, " onmessage: ").concat(e3.data));
            }, zI(this.forceCloseTimeout).then(() => {
              t3 && t3.readyState !== WebSocket.OPEN && t3.close();
            });
          }
        }).then((e3) => (this.closeEstablishingWs = void 0, e3)).catch((e3) => {
          throw this.closeEstablishingWs = void 0, e3;
        });
      }
    }
    class yC {
      constructor(e2) {
        _p(this, "input", []), _p(this, "size", void 0), this.size = e2;
      }
      add(e2) {
        this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
      }
      mean() {
        var e2;
        return 0 === this.input.length ? 0 : zi(e2 = this.input).call(e2, (e3, t2) => e3 + t2) / this.input.length;
      }
    }
    class AC extends EE {
      get connectionState() {
        return this._connectionState;
      }
      set connectionState(e2) {
        e2 !== this._connectionState && (this._connectionState = e2, e2 === Of.CONNECTED ? this.emit(Nf.WS_CONNECTED) : e2 === Of.RECONNECTING ? this.emit(Nf.WS_RECONNECTING, this._websocketReconnectReason) : e2 === Of.CLOSED && this.emit(Nf.WS_CLOSED, this._disconnectedReason));
      }
      get currentURLIndex() {
        return this.websocket.currentURLIndex;
      }
      get url() {
        return this.websocket ? this.websocket.url : null;
      }
      get rtt() {
        return this.rttRolling.mean();
      }
      constructor(e2, t2) {
        super(), _p(this, "_disconnectedReason", void 0), _p(this, "_websocketReconnectReason", void 0), _p(this, "_connectionState", Of.CLOSED), _p(this, "reconnectToken", void 0), _p(this, "websocket", void 0), _p(this, "openConnectionTime", void 0), _p(this, "clientId", void 0), _p(this, "lastMsgTime", Date.now()), _p(this, "uploadCache", []), _p(this, "uploadCacheInterval", void 0), _p(this, "rttRolling", new yC(5)), _p(this, "pingpongTimer", void 0), _p(this, "wsInflateDataTimer", void 0), _p(this, "pingpongTimeoutCount", 0), _p(this, "joinResponse", void 0), _p(this, "multiIpOption", void 0), _p(this, "initError", void 0), _p(this, "spec", void 0), _p(this, "store", void 0), _p(this, "onWebsocketMessage", (e3) => {
          if (e3.data instanceof ArrayBuffer)
            return void this.emit(Nf.ON_BINARY_DATA, e3.data);
          const t3 = JSON.parse(e3.data);
          if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
            const e4 = "res-@".concat(t3._id);
            this.emit(e4, t3._result, t3._message);
          } else if (Object.prototype.hasOwnProperty.call(t3, "_type")) {
            if (this.emit(t3._type, t3._message), t3._type === Df.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Df.ON_USER_BANNED)
              switch (t3._message.error_code) {
                case 14:
                  this.close(vf.UID_BANNED);
                  break;
                case 15:
                  this.close(vf.IP_BANNED);
                  break;
                case 16:
                  this.close(vf.CHANNEL_BANNED);
              }
            if (t3._type === Df.ON_USER_LICENSE_BANNED)
              switch (t3._message.error_code) {
                case If.ERR_LICENSE_MISSING:
                  this.close(vf.LICENSE_MISSING);
                  break;
                case If.ERR_LICENSE_EXPIRED:
                  this.close(vf.LICENSE_EXPIRED);
                  break;
                case If.ERR_LICENSE_MINUTES_EXCEEDED:
                  this.close(vf.LICENSE_MINUTES_EXCEEDED);
                  break;
                case If.ERR_LICENSE_PERIOD_INVALID:
                  this.close(vf.LICENSE_PERIOD_INVALID);
                  break;
                case If.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                  this.close(vf.LICENSE_MULTIPLE_SDK_SERVICE);
                  break;
                case If.ERR_LICENSE_ILLEGAL:
                  this.close(vf.LICENSE_ILLEGAL);
                  break;
                default:
                  this.close();
              }
          }
        }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new vC("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
          this.connectionState === Of.CONNECTED && this.reconnect("retry", Af.OFFLINE);
        });
      }
      async request(e2, t2, i3, n2) {
        const r2 = ZI(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Sl((t3, i4) => {
          if (this.connectionState === Of.CONNECTED)
            return t3();
          const n3 = () => {
            this.off(Nf.WS_CLOSED, r3), t3();
          }, r3 = () => {
            this.off(Nf.WS_CONNECTED, n3), i4(new SE(fE.WS_ABORT));
          };
          this.once(Nf.WS_CONNECTED, n3), this.once(Nf.WS_CLOSED, r3), e2 !== bf.PUBLISH && e2 !== bf.SUBSCRIBE && e2 !== bf.UNSUBSCRIBE && e2 !== bf.UNPUBLISH && e2 !== bf.CONTROL && e2 !== bf.RESTART_ICE || this.once(Nf.DISCONNECT_P2P, () => {
            i4(new SE(fE.DISCONNECT_P2P));
          }), e2 !== bf.PUBLISH && e2 !== bf.RESTART_ICE || this.once(Nf.ABORT_P2P_EXECUTION, () => {
            i4(new SE(fE.DISCONNECT_P2P));
          });
        });
        if (this.connectionState !== Of.CONNECTING && this.connectionState !== Of.RECONNECTING || e2 === bf.JOIN || e2 === bf.REJOIN || await a2(), this.websocket.sendMessage(o2, true), n2)
          return;
        const c2 = new Sl((i4, n3) => {
          let o3 = false;
          const a3 = (n4, r3) => {
            o3 = true, i4({ isSuccess: "success" === n4, message: r3 || {} }), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.emit(Nf.REQUEST_SUCCESS, e2, t2);
          };
          this.once("res-@".concat(r2), a3);
          const c3 = () => {
            n3(new SE(fE.WS_ABORT, "type: ".concat(e2))), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
          };
          this.once(Nf.WS_CLOSED, c3), this.once(Nf.WS_RECONNECTING, c3), zI(GE("SIGNAL_REQUEST_TIMEOUT")).then(() => {
            this.websocket.connectionID !== s2 || o3 || (OE.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e2)), this.emit(Nf.REQUEST_TIMEOUT, e2, t2));
          });
        });
        let d2 = null;
        try {
          d2 = await c2;
        } catch (n3) {
          if (this.connectionState === Of.CLOSED || e2 === bf.LEAVE)
            throw new SE(fE.WS_ABORT);
          return !this.spec.forceWaitGatewayResponse || i3 ? n3.throw() : e2 === bf.JOIN || e2 === bf.REJOIN ? null : (await a2(), await this.request(e2, t2));
        }
        if (d2.isSuccess)
          return d2.message;
        const u2 = Number(d2.message.error_code || d2.message.code), l2 = IC(u2), h3 = new SE(fE.UNEXPECTED_RESPONSE, "".concat(l2.desc, ": ").concat(d2.message.error_str), { code: u2, data: d2.message });
        return "success" === l2.action ? d2.message : (OE.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(u2, ", message: ").concat(l2.desc, ", action: ").concat(l2.action)), u2 === If.ERR_TOO_MANY_BROADCASTERS ? e2 === bf.JOIN || e2 === bf.REJOIN ? (this.initError = h3, this.close(), h3.throw()) : h3.throw() : "failed" === l2.action ? h3.throw() : "quit" === l2.action ? (this.initError = h3, this.close(), h3.throw()) : (u2 === If.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, OE.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Af.MULTI_IP)) : this.reconnect(l2.action, Af.SERVER_ERROR), e2 === bf.JOIN || e2 === bf.REJOIN ? null : await this.request(e2, t2)));
      }
      waitMessage(e2, t2) {
        return new Sl((i3) => {
          const n2 = (r2) => {
            (!t2 || t2(r2)) && (this.off(e2, n2), i3(r2));
          };
          this.on(e2, n2);
        });
      }
      upload(e2, t2) {
        const i3 = { _type: e2, _message: t2 };
        try {
          this.websocket.sendMessage(i3);
        } catch (e3) {
          const t3 = GE("MAX_UPLOAD_CACHE") || 50;
          this.uploadCache.push(i3), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
            if (this.connectionState !== Of.CONNECTED)
              return;
            const e4 = this.uploadCache.splice(0, 1)[0];
            0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
          }, GE("UPLOAD_CACHE_INTERVAL") || 2e3));
        }
      }
      send(e2, t2) {
        const i3 = { _type: e2, _message: t2 };
        this.websocket.sendMessage(i3);
      }
      init(e2, t2) {
        return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Sl((i3, n2) => {
          this.once(Nf.WS_CONNECTED, () => i3(this.joinResponse)), this.once(Nf.WS_CLOSED, () => n2(this.initError || new SE(fE.WS_ABORT))), this.connectionState = Of.CONNECTING, this.websocket.init(e2).catch(n2), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
            this.handleWsInflateData();
          }, 2e4), setTimeout(() => {
            t2 && void 0 === this.openConnectionTime && (OE.debug("[".concat(this.clientId, "] init websocket timeout while join with fallback to proxy")), n2(new SE(fE.INIT_WEBSOCKET_TIMEOUT)));
          }, GE("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION"));
        });
      }
      close(e2) {
        this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || vf.LEAVE, this.connectionState = Of.CLOSED, OE.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e2 === vf.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new vC("gateway-".concat(this.clientId), this.spec.retryConfig, true, true, this.store), this.handleWebsocketEvents());
      }
      async join() {
        if (!this.joinResponse) {
          this.emit(Nf.ABORT_P2P_EXECUTION);
          const e2 = await nC(this, Nf.REQUEST_JOIN_INFO), t2 = await this.request(bf.JOIN, e2);
          if (!t2)
            return this.emit(Nf.REPORT_JOIN_GATEWAY, fE.TIMEOUT, this.url || ""), false;
          this.joinResponse = t2, this.emit(Nf.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
        }
        return this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
      }
      async rejoin() {
        if (!this.reconnectToken)
          throw new SE(fE.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
        const e2 = sC(this, Nf.REQUEST_REJOIN_INFO);
        e2.token = this.reconnectToken;
        const t2 = await this.request(bf.REJOIN, e2);
        return !!t2 && (this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
          this.emit(Df.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(Df.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(Df.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(Df.MUTE_AUDIO, { uid: e3.uid }) : this.emit(Df.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(Df.MUTE_VIDEO, { uid: e3.uid }) : this.emit(Df.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(Df.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(Df.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(Df.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
        }), true);
      }
      reconnect(e2, t2) {
        this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
      }
      handleNotification(e2) {
        OE.debug("[".concat(this.clientId, "] receive notification: "), e2);
        const t2 = IC(e2.code);
        if ("success" !== t2.action) {
          if ("failed" !== t2.action)
            return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(vf.UID_BANNED), void this.close()) : void this.reconnect(t2.action, Af.SERVER_ERROR);
          OE.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
        }
      }
      handlePingPong() {
        if (!this.websocket || "connected" !== this.websocket.state)
          return;
        this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
        const e2 = GE("PING_PONG_TIME_OUT"), t2 = Date.now();
        this.pingpongTimeoutCount >= e2 && (OE.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > GE("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Af.TIMEOUT) : this.request(bf.PING, void 0, true).then(() => {
          this.pingpongTimeoutCount = 0;
          const e3 = Date.now() - t2;
          this.rttRolling.add(e3), GE("REPORT_STATS") && this.send(bf.PING_BACK, { pingpongElapse: e3 });
        }).catch((e3) => {
        });
      }
      handleWsInflateData() {
        const { wsInflateLength: e2, wsDeflateLength: t2 } = this.websocket.getWsInflateData();
        0 !== e2 && 0 !== t2 && this.upload(wf.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
      }
      handleWebsocketEvents() {
        this.websocket.on(Hf.RECONNECT_WAITTING_FINISH, (e2) => {
          this.emit(Nf.WS_RECONNECT_WAITTING_FINISH, e2);
        }), this.websocket.on(Hf.RECONNECT_CREATE_CONNECTION, (e2) => {
          this.emit(Nf.WS_RECONNECT_CREATE_CONNECTION, e2);
        }), this.websocket.on(Hf.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Hf.CLOSED, () => {
          this.connectionState = Of.CLOSED;
        }), this.websocket.on(Hf.FAILED, () => {
          this._disconnectedReason = vf.NETWORK_ERROR, this.connectionState = Of.CLOSED;
        }), this.websocket.on(Hf.RECONNECTING, (e2) => {
          this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === Of.CONNECTED ? this.connectionState = Of.RECONNECTING : this.connectionState = Of.CONNECTING;
        }), this.websocket.on(Hf.WILL_RECONNECT, (e2, t2) => {
          if (sC(this, Nf.IS_P2P_DISCONNECTED) && "retry" === e2)
            return OE.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P), t2("tryNext");
          "retry" !== e2 && (OE.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P)), t2(e2);
        }), this.websocket.on(Hf.CONNECTED, () => {
          this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
            OE.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", Af.SERVER_ERROR);
          }) : this.join().catch((e2) => {
            if (this.emit(Nf.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof SE && e2.code === fE.UNEXPECTED_RESPONSE && e2.data.code === If.ERR_NO_AUTHORIZED)
              return OE.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Af.SERVER_ERROR);
            OE.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Af.SERVER_ERROR) : (this.initError = e2, this.close());
          });
        }), this.websocket.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
          nC(this, Nf.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
        }), this.websocket.on(Hf.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
          this.emit(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
        });
      }
    }
    function OC(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    class NC extends EE {
      get url() {
        return this._url ? this._url : null;
      }
      get reconnectMode() {
        return this._reconnectMode;
      }
      set reconnectMode(e2) {
        ["tryNext", "recover"].includes(e2) && this.resetReconnectCount(e2), this._reconnectMode = e2;
      }
      get state() {
        return this._state;
      }
      set state(e2) {
        e2 !== this._state && (this._state = e2, "reconnecting" === this._state ? this.emit(FS.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(FS.CONNECTED) : "closed" === this._state ? this.emit(FS.CLOSED) : "failed" === this._state && this.emit(FS.FAILED));
      }
      constructor(e2, t2, i3, n2) {
        super(), _p(this, "connectionID", 0), _p(this, "currentURLIndex", 0), _p(this, "reconnectReason", void 0), _p(this, "_reconnectMode", "tryNext"), _p(this, "_initMutex", void 0), _p(this, "_name", void 0), _p(this, "_state", "closed"), _p(this, "_reconnectInterrupter", void 0), _p(this, "_url", void 0), _p(this, "_retryConfig", void 0), _p(this, "_reconnectCount", 0), _p(this, "_forceCloseTimeout", 5e3), _p(this, "_onlineReconnectListener", void 0), _p(this, "_closeEstablishingTransmitter", () => {
        }), _p(this, "_store", void 0), _p(this, "_joinChannelServiceRecordIndex", void 0), _p(this, "_transmitter", void 0), _p(this, "_useCompress", void 0), _p(this, "_inflateLength", 0), _p(this, "_deflateLength", 0), this._store = n2, this._name = e2, this._retryConfig = function(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var i4 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? OC(Object(i4), true).forEach(function(t4) {
              _p(e3, t4, i4[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(i4)) : OC(Object(i4)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(i4, t4));
            });
          }
          return e3;
        }({}, t2), this._useCompress = i3;
      }
      resetReconnectCount(e2) {
        OE.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e2)), this._reconnectCount = 0;
      }
      close(e2, t2) {
        if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
          this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
          const e3 = this._transmitter;
          t2 ? setTimeout(() => e3.close(), 500) : e3.close(), this._transmitter = void 0;
        }
        this.state = e2 ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();
      }
      reconnect(e2, t2) {
        if (!this._transmitter)
          return void OE.warning("[".concat(this._name, "] can not reconnect, no websocket"));
        var i3;
        (void 0 !== e2 && (this.reconnectMode = e2), OE.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex) && (null === (i3 = this._store) || void 0 === i3 || i3.recordJoinChannelService({ status: "error", errors: [new Error(t2)] }, this._joinChannelServiceRecordIndex));
        const n2 = this._transmitter.onclose;
        this._transmitter.onclose = null, this._transmitter.close(), n2 && n2.bind(this._transmitter)({ code: 9999, reason: t2 });
      }
      getInflateData() {
        const e2 = this._inflateLength, t2 = this._deflateLength;
        return this.clearInflateData(), { inflateLength: e2, deflateLength: t2 };
      }
      setInflateData(e2) {
        this._deflateLength = this._deflateLength + e2.originLength, this._inflateLength = this._inflateLength + e2.compressedLength;
      }
      clearInflateData() {
        this._inflateLength = 0, this._deflateLength = 0;
      }
    }
    function bC(e2, t2, i3) {
      if ("getBigUint64" in DataView.prototype)
        return e2.getBigUint64(t2, i3);
      const n2 = e2.getUint32(t2, i3), r2 = e2.getUint32(t2 + 4, i3), o2 = Number(!!i3), s2 = Number(!i3);
      return BigInt(n2 * s2 + r2 * o2) << BigInt(32) | BigInt(n2 * o2 + r2 * s2);
    }
    function wC(e2, t2, i3, n2) {
      if ("setBigUint64" in DataView.prototype)
        return e2.setBigUint64(t2, i3, n2);
      const r2 = Number(i3 >> BigInt(32)), o2 = Number(i3 & BigInt(4294967295));
      n2 ? (e2.setUint32(t2 + 4, r2, n2), e2.setUint32(t2, o2, n2)) : (e2.setUint32(t2, r2, n2), e2.setUint32(t2 + 4, o2, n2));
    }
    let DC;
    !function(e2) {
      e2[e2.Default = 0] = "Default", e2[e2.Ack = 1] = "Ack";
    }(DC || (DC = {}));
    class PC {
      constructor(e2, t2, i3) {
        _p(this, "version", 1), _p(this, "initialRTO", void 0), _p(this, "maxBatchAckCount", void 0), _p(this, "maxRTO", void 0), _p(this, "initialRTT", void 0), _p(this, "ID", void 0), _p(this, "rtt", void 0), _p(this, "packetNumber", 1), _p(this, "rtoRatioMap", /* @__PURE__ */ new Map()), _p(this, "timeoutMap", /* @__PURE__ */ new Map()), _p(this, "unorderedPacketQueue", []), _p(this, "batchAckPacketQueue", []), _p(this, "lastOrderedPacketNumber", 0), _p(this, "batchAckTimer", void 0), _p(this, "sendImpl", void 0), _p(this, "receiveImpl", void 0), this.sendImpl = e2, this.receiveImpl = t2, this.ID = ZI(7, "transmitter-"), this.initialRTO = void 0 !== (null == i3 ? void 0 : i3.initialRTO) ? i3.initialRTO : GE("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == i3 ? void 0 : i3.initialRTT) ? i3.initialRTT : GE("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == i3 ? void 0 : i3.initialRTT) ? i3.initialRTT : GE("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == i3 ? void 0 : i3.maxBatchAckCount) ? i3.maxBatchAckCount : GE("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == i3 ? void 0 : i3.maxRTO) ? i3.maxRTO : GE("TRANSMITTER_MAX_RTO");
      }
      packetize(e2, t2) {
        return { type: DC.Default, version: this.version, packetNumber: t2, payload: e2 };
      }
      serialize(e2) {
        switch (e2.type) {
          case DC.Default: {
            let t2;
            if ("string" == typeof e2.payload) {
              t2 = new TextEncoder().encode(e2.payload);
            } else
              t2 = e2.payload;
            const i3 = new ArrayBuffer(t2.length + 15), n2 = new DataView(i3);
            n2.setUint16(0, e2.version), n2.setUint8(2, e2.type), n2.setUint32(3, e2.packetNumber), wC(n2, 7, BigInt(e2.sendTs));
            return new Uint8Array(n2.buffer).set(t2, 15), i3;
          }
          case DC.Ack: {
            const t2 = new ArrayBuffer(16), i3 = new DataView(t2);
            return i3.setUint16(0, e2.version), i3.setUint8(2, e2.type), i3.setUint32(3, e2.maxAckPacketNumber), i3.setUint8(7, e2.shift), wC(i3, 8, BigInt(e2.ackSendTs)), t2;
          }
        }
      }
      deserialize(e2) {
        const t2 = new DataView(e2), i3 = t2.getUint16(0), n2 = t2.getUint8(2);
        switch (n2) {
          case DC.Default: {
            const r2 = t2.getUint32(3), o2 = bC(t2, 7), s2 = e2.slice(15), a2 = new TextDecoder().decode(s2);
            return { version: i3, type: n2, packetNumber: r2, sendTs: Number(o2), payload: a2 };
          }
          case DC.Ack: {
            const e3 = t2.getUint32(3), r2 = t2.getUint8(7), o2 = bC(t2, 8);
            return { version: i3, type: n2, maxAckPacketNumber: e3, shift: r2, ackSendTs: Number(o2) };
          }
          default:
            throw OE.error("[".concat(this.ID, "] Unrecognized packet type ").concat(n2)), new Error("Unrecognized packet type ".concat(n2));
        }
      }
      sendMessage(e2) {
        const t2 = this.packetize(e2, this.packetNumber);
        this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
        const i3 = this.calculateRTO(t2), n2 = window.setTimeout(() => {
          this.resendMessage(t2);
        }, i3);
        this.timeoutMap.set(t2.packetNumber, n2), this.sendPacket(t2);
      }
      onData(e2) {
        const t2 = this.deserialize(e2);
        t2.type === DC.Default ? this.ack(t2) : t2.type === DC.Ack && (this.updateRTT(t2, Math.round(performance.now())), this.clearRTO(t2));
      }
      close() {
        this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach((e2) => {
          let [t2, i3] = e2;
          window.clearTimeout(i3);
        }), this.timeoutMap = /* @__PURE__ */ new Map(), this.rtoRatioMap = /* @__PURE__ */ new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);
      }
      resendMessage(e2) {
        const t2 = this.calculateRTO(e2), i3 = window.setTimeout(() => {
          this.resendMessage(e2);
        }, t2);
        this.timeoutMap.set(e2.packetNumber, i3), this.sendPacket(e2);
      }
      calculateRTO(e2) {
        const t2 = this.rtoRatioMap.get(e2.packetNumber);
        if (void 0 === t2)
          return this.rtoRatioMap.set(e2.packetNumber, 1), this.initialRTO;
        {
          const i3 = 9 * this.rtt / 8 * t2;
          return this.rtoRatioMap.set(e2.packetNumber, t2 + 1), i3 > this.maxRTO ? this.maxRTO : i3;
        }
      }
      updateRTT(e2, t2) {
        const i3 = e2.ackSendTs;
        this.rtt = this.rtt * (7 / 8) + (t2 - i3 - this.rtt) / 8;
      }
      ack(e2) {
        if (e2.packetNumber === this.lastOrderedPacketNumber + 1)
          for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e2) : (this.batchAckPacketQueue.push(e2), this.batchAckTimer = window.setTimeout(() => {
            this.batchAck();
          }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e2.payload); ; ) {
            const e3 = this.unorderedPacketQueue[0];
            if (!e3) {
              this.unorderedPacketQueue.shift();
              break;
            }
            this.batchAckTimer && this.batchAck(), this.receiveImpl(e3.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;
          }
        else if (e2.packetNumber <= this.lastOrderedPacketNumber) {
          const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: DC.Ack, version: this.version };
          this.sendPacket(t2);
        } else if (e2.packetNumber > this.lastOrderedPacketNumber) {
          this.unorderedPacketQueue[e2.packetNumber - this.lastOrderedPacketNumber - 2] = e2;
          const t2 = { ackSendTs: e2.sendTs, maxAckPacketNumber: e2.packetNumber, shift: 0, type: DC.Ack, version: this.version };
          this.sendPacket(t2);
        }
      }
      batchAck() {
        window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
        const e2 = { ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs, maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber, shift: this.batchAckPacketQueue.length - 1, type: DC.Ack, version: this.version };
        this.sendPacket(e2), this.batchAckPacketQueue = [];
      }
      sendPacket(e2) {
        e2.type === DC.Default && (e2.sendTs = Math.round(performance.now()));
        const t2 = this.serialize(e2);
        this.sendImpl(t2);
      }
      clearRTO(e2) {
        for (let t2 = e2.maxAckPacketNumber - e2.shift; t2 <= e2.maxAckPacketNumber; t2++) {
          const e3 = this.timeoutMap.get(t2);
          void 0 !== e3 && window.clearTimeout(e3), this.timeoutMap.delete(t2), this.rtoRatioMap.delete(t2);
        }
      }
    }
    class LC extends NC {
      constructor(e2, t2) {
        super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), _p(this, "_initMutex", void 0), _p(this, "_reconnectInterrupter", void 0), _p(this, "_url", void 0), _p(this, "_transmitter", void 0), _p(this, "_addresses", void 0), _p(this, "_reliableTransmission", void 0), this._initMutex = new Ug("datachannel");
        const { timeout: i3, timeoutFactor: n2 } = t2, r2 = Math.max(300, Math.floor(3 * i3 / 5)), o2 = Math.max(1.2, Math.floor(8 * n2) / 10);
        PS.ONLINE && (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = o2), Ig.on(LS.NETWORK_STATE_CHANGE, (e3, t3) => {
          e3 !== t3 && (this.resetReconnectCount("network state change: ".concat(t3, " -> ").concat(e3)), e3 === PS.ONLINE ? (this._retryConfig.timeout = r2, this._retryConfig.timeoutFactor = o2) : (this._retryConfig.timeout = i3, this._retryConfig.timeoutFactor = n2));
        });
      }
      getConnection() {
        if (this._reliableTransmission)
          return this._reliableTransmission;
      }
      async init(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
        this._forceCloseTimeout = t2;
        const i3 = (t3, i4) => {
          this._addresses = e2, this.currentURLIndex = this._addresses.findIndex((e3) => e3.fingerprint || GE("FINGERPRINT"));
          const n2 = this._addresses[this.currentURLIndex];
          this.state = "connecting", this.createTransmitterConnection(n2).then(t3).catch(i4), this.once(FS.CLOSED, () => i4(new SE(fE.WS_DISCONNECT))), this.once(FS.CONNECTED, () => t3());
        };
        return this._initMutex.lock().then((e3) => new Sl((e4, t3) => {
          i3(e4, t3);
        }).then(() => {
          e3();
        }).catch(() => {
          e3();
        }));
      }
      sendMessage(e2) {
        let t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (!this._transmitter || !this._reliableTransmission)
          throw new SE(fE.WS_ABORT, "datachannel is not ready");
        try {
          t2 || (e2 = JSON.stringify(e2)), this._reliableTransmission.sendMessage(e2);
        } catch (e3) {
          throw new SE(fE.WS_ERR, "send datachannel signal message error" + e3.toString());
        }
      }
      unbindDcCloseEventListener() {
        this._transmitter && (this._transmitter.onclose = null);
      }
      sendMessageWithJSON(e2) {
        const t2 = JSON.stringify(e2);
        return { compressed: t2, compressedLength: t2.length, origin: e2 };
      }
      sendMessageWithUint8Array(e2) {
        return { compressed: e2, compressedLength: e2.byteLength, origin: e2 };
      }
      createTransmitterConnection(e2) {
        return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e2.ip, ":").concat(e2.port), new Sl((t2, i3) => {
          var n2;
          const r2 = () => {
            OE.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t2();
          }, o2 = async (e3) => {
            var n3;
            if (null === (n3 = this._closeEstablishingTransmitter) || void 0 === n3 || n3.call(this), OE.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e3.code, ", reason: ").concat(e3.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {
              "connected" === this.state && (this.reconnectReason = e3.reason, this.state = "reconnecting");
              const n4 = oC(this, FS.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode, r3 = await this.reconnectWithAction(n4);
              if ("closed" === this.state)
                return void OE.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect"));
              if (!r3)
                return i3(new SE(fE.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e3.code))), void this.close(true);
              t2();
            } else
              i3(new SE(fE.WS_DISCONNECT, "datachannel close: ".concat(e3.code))), this.close();
          }, s2 = (e3) => {
            var t3;
            null === (t3 = this._reliableTransmission) || void 0 === t3 || t3.onData(e3.data);
          };
          this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), OE.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e2)));
          const a2 = null === (n2 = this._store) || void 0 === n2 ? void 0 : n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" }), c2 = Date.now();
          nC(this, FS.TO_CONNECT_DATACHANNEL, e2).then((e3) => {
            var t3, i4;
            if (!e3)
              throw new Error("transmissonInfo not exist yet");
            const { transmitter: n3, close: d2 } = e3;
            this._transmitter = n3, null === (t3 = this._store) || void 0 === t3 || t3.signalChannelOpen();
            const u2 = Date.now() - c2;
            OE.debug("[choose dc] dc open cost ".concat(u2, "ms"));
            this._reliableTransmission = new PC((e4) => {
              var t4;
              this._transmitter && "open" === this._transmitter.readyState && (null === (t4 = this._transmitter) || void 0 === t4 || t4.send(e4));
            }, (e4) => {
              "string" == typeof e4 && this.emit(FS.ON_MESSAGE, e4);
            }), this._closeEstablishingTransmitter = () => {
              var e4;
              null === (e4 = this._reliableTransmission) || void 0 === e4 || e4.close(), this._reliableTransmission = void 0, d2();
            }, r2 && r2(), n3.onclose = o2, n3.onmessage = s2, null === (i4 = this._store) || void 0 === i4 || i4.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a2), this._joinChannelServiceRecordIndex = a2;
          }).catch((e3) => {
            var t3;
            if (null === (t3 = this._store) || void 0 === t3 || t3.recordJoinChannelService({ endTs: Date.now(), status: e3 instanceof SE && e3.code === fE.WS_ABORT ? "aborted" : "error", errors: [e3] }, a2), "closed" !== this.state) {
              if (e3 instanceof SE && e3.code === fE.WS_ERR) {
                const t4 = new SE(fE.WS_ERR, "init datachannel failed! Error: ".concat(e3.toString()));
                return OE.error("[".concat(this._name, "]").concat(t4)), void i3(t4);
              }
              o2 && o2(e3);
            } else
              i3(new SE(fE.WS_DISCONNECT, "datachannel is closed: ".concat(e3.toString())));
          });
        });
      }
      async reconnectWithAction(e2) {
        let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (this._reconnectCount >= this._retryConfig.maxRetryCount)
          return false;
        if (!this._addresses)
          return false;
        if ("closed" === this.state)
          return false;
        this._onlineReconnectListener || Ig.networkState !== PS.OFFLINE || (this._onlineReconnectListener = Ig.onlineWaiter && Ig.onlineWaiter.then(() => {
          this._onlineReconnectListener = void 0;
        }));
        let i3 = true;
        if (this._reconnectInterrupter = () => {
          i3 = false;
        }, t2) {
          const t3 = gE(this._reconnectCount, this._retryConfig);
          OE.debug("[".concat(this._name, "] wait ").concat(t3, "ms to reconnect datachannel, mode: ").concat(e2)), await Sl.race([zI(t3), this._onlineReconnectListener || new Sl(() => {
          })]);
        }
        if ("closed" === this.state || !i3)
          return false;
        this._reconnectCount += 1;
        const n2 = async (e3, t3) => {
          this.emit(FS.RECONNECT_CREATE_CONNECTION, t3), await this.createTransmitterConnection(e3);
        };
        try {
          if ("retry" === e2) {
            const t3 = this._addresses[this.currentURLIndex];
            this.emit(FS.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
          } else if ("tryNext" === e2) {
            this.currentURLIndex += 1;
            for (let e3 = this.currentURLIndex; e3 < this._addresses.length; e3++) {
              if (this._addresses[e3].fingerprint || GE("FINGERPRINT")) {
                this.currentURLIndex = e3;
                break;
              }
              this.currentURLIndex += 1;
            }
            if (this.currentURLIndex >= this._addresses.length)
              return OE.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", false);
            OE.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
            const t3 = this._addresses[this.currentURLIndex];
            this.emit(FS.RECONNECT_WAITTING_FINISH, e2), await n2(t3, e2);
          } else
            "recover" === e2 && (OE.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(FS.RECONNECT_WAITTING_FINISH, e2), this.emit(FS.FAILBACK));
          return true;
        } catch (i4) {
          var r2;
          return OE.error("[".concat(this._name, "] reconnect failed"), i4.toString()), null != i4 && null !== (r2 = i4.data) && void 0 !== r2 && r2.desc && Array.isArray(i4.data.desc) && i4.data.desc.length && i4.data.desc.includes("dynamic key expired") ? (this.emit(FS.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : await this.reconnectWithAction(e2, t2);
        }
      }
    }
    class kC extends EE {
      get connectionState() {
        return this._connectionState;
      }
      set connectionState(e2) {
        e2 !== this._connectionState && (this._connectionState = e2, e2 === Of.CONNECTED ? this.emit(Nf.WS_CONNECTED) : e2 === Of.RECONNECTING ? this.emit(Nf.WS_RECONNECTING, this._websocketReconnectReason) : e2 === Of.CLOSED && this.emit(Nf.WS_CLOSED, this._disconnectedReason));
      }
      get currentURLIndex() {
        return this.websocket.currentURLIndex;
      }
      get url() {
        return this.websocket ? this.websocket.url : null;
      }
      get rtt() {
        return this.rttRolling.mean();
      }
      constructor(e2, t2) {
        super(), _p(this, "_disconnectedReason", void 0), _p(this, "_websocketReconnectReason", void 0), _p(this, "_connectionState", Of.CLOSED), _p(this, "reconnectToken", void 0), _p(this, "websocket", void 0), _p(this, "openConnectionTime", void 0), _p(this, "clientId", void 0), _p(this, "lastMsgTime", Date.now()), _p(this, "uploadCache", []), _p(this, "uploadCacheInterval", void 0), _p(this, "rttRolling", new yC(5)), _p(this, "pingpongTimer", void 0), _p(this, "inflateDataTimer", void 0), _p(this, "pingpongTimeoutCount", 0), _p(this, "joinResponse", void 0), _p(this, "multiIpOption", void 0), _p(this, "initError", void 0), _p(this, "spec", void 0), _p(this, "store", void 0), _p(this, "onWebsocketMessage", (e3) => {
          if (e3 instanceof ArrayBuffer)
            return void this.emit(Nf.ON_BINARY_DATA, e3);
          const t3 = JSON.parse(e3);
          if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t3, "_id")) {
            const e4 = "res-@".concat(t3._id);
            this.emit(e4, t3._result, t3._message);
          } else if (Object.prototype.hasOwnProperty.call(t3, "_type") && (this.emit(t3._type, t3._message), t3._type === Df.ON_NOTIFICATION && this.handleNotification(t3._message), t3._type === Df.ON_USER_BANNED))
            switch (t3._message.error_code) {
              case 14:
                this.close(vf.UID_BANNED);
                break;
              case 15:
                this.close(vf.IP_BANNED);
                break;
              case 16:
                this.close(vf.CHANNEL_BANNED);
            }
        }), this.clientId = e2.clientId, this.spec = e2, this.store = t2, this.websocket = new LC("gateway-".concat(this.clientId), this.spec.retryConfig, true, t2), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
          this.connectionState === Of.CONNECTED && this.reconnect("retry", jS.OFFLINE);
        });
      }
      async request(e2, t2, i3, n2) {
        const r2 = ZI(6, ""), o2 = { _id: r2, _type: e2, _message: t2 }, s2 = this.websocket.connectionID, a2 = () => new Sl((t3, i4) => {
          if (this.connectionState === Of.CONNECTED)
            return t3();
          const n3 = () => {
            this.off(Nf.WS_CLOSED, r3), t3();
          }, r3 = () => {
            this.off(Nf.WS_CONNECTED, n3), i4(new SE(fE.WS_ABORT));
          };
          this.once(Nf.WS_CONNECTED, n3), this.once(Nf.WS_CLOSED, r3), e2 !== bf.PUBLISH && e2 !== bf.SUBSCRIBE && e2 !== bf.UNSUBSCRIBE && e2 !== bf.UNPUBLISH && e2 !== bf.CONTROL && e2 !== bf.RESTART_ICE || this.once(Nf.DISCONNECT_P2P, () => {
            i4(new SE(fE.DISCONNECT_P2P));
          }), e2 !== bf.PUBLISH && e2 !== bf.RESTART_ICE || this.once(Nf.ABORT_P2P_EXECUTION, () => {
            i4(new SE(fE.DISCONNECT_P2P));
          });
        });
        if (this.connectionState !== Of.CONNECTING && this.connectionState !== Of.RECONNECTING || e2 === bf.JOIN || e2 === bf.REJOIN || await a2(), e2 === bf.LEAVE && (this.websocket.unbindDcCloseEventListener(), n2 = true), this.websocket.sendMessage(o2, true, false), n2)
          return;
        const c2 = new Sl((i4, n3) => {
          let o3 = false;
          const a3 = (n4, r3) => {
            o3 = true, i4({ isSuccess: "success" === n4, message: r3 || {} }), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.emit(Nf.REQUEST_SUCCESS, e2, t2);
          };
          this.once("res-@".concat(r2), a3);
          const c3 = () => {
            n3(new SE(fE.WS_ABORT, "type: ".concat(e2))), this.off(Nf.WS_CLOSED, c3), this.off(Nf.WS_RECONNECTING, c3), this.off("res-@".concat(r2), a3);
          };
          this.once(Nf.WS_CLOSED, c3), this.once(Nf.WS_RECONNECTING, c3), zI(GE("SIGNAL_REQUEST_TIMEOUT")).then(() => {
            this.websocket.connectionID !== s2 || o3 || (OE.warning("dc request timeout, type: ".concat(e2)), this.emit(Nf.REQUEST_TIMEOUT, e2, t2));
          });
        });
        let d2 = null;
        try {
          d2 = await c2;
        } catch (n3) {
          if (this.connectionState === Of.CLOSED || e2 === bf.LEAVE)
            throw new SE(fE.WS_ABORT);
          return !this.spec.forceWaitGatewayResponse || i3 ? n3.throw() : e2 === bf.JOIN || e2 === bf.REJOIN ? null : (await a2(), await this.request(e2, t2));
        }
        if (d2.isSuccess)
          return d2.message;
        const u2 = Number(d2.message.error_code || d2.message.code), l2 = IC(u2), h3 = new SE(fE.UNEXPECTED_RESPONSE, "".concat(l2.desc, ": ").concat(d2.message.error_str), { code: u2, data: d2.message });
        return "success" === l2.action ? d2.message : (OE.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e2, ", error_code: ").concat(u2, ", message: ").concat(l2.desc, ", action: ").concat(l2.action)), u2 === If.ERR_TOO_MANY_BROADCASTERS ? e2 === bf.JOIN || e2 === bf.REJOIN ? (this.initError = h3, this.close(), h3.throw()) : h3.throw() : "failed" === l2.action ? h3.throw() : "quit" === l2.action ? (this.initError = h3, this.close(), h3.throw()) : (u2 === If.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d2.message.option, OE.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", jS.MULTI_IP)) : this.reconnect(l2.action, jS.SERVER_ERROR), e2 === bf.JOIN || e2 === bf.REJOIN ? null : await this.request(e2, t2)));
      }
      waitMessage(e2, t2) {
        return new Sl((i3) => {
          const n2 = (r2) => {
            (!t2 || t2(r2)) && (this.off(e2, n2), i3(r2));
          };
          this.on(e2, n2);
        });
      }
      upload(e2, t2) {
        const i3 = { _type: e2, _message: t2 };
        try {
          this.websocket.sendMessage(i3);
        } catch (e3) {
          const t3 = GE("MAX_UPLOAD_CACHE") || 50;
          this.uploadCache.push(i3), this.uploadCache.length > t3 && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
            if (this.connectionState !== Of.CONNECTED)
              return;
            const e4 = this.uploadCache.splice(0, 1)[0];
            0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e4._type, e4._message);
          }, GE("UPLOAD_CACHE_INTERVAL") || 2e3));
        }
      }
      send(e2, t2) {
        const i3 = { _type: e2, _message: t2 };
        this.websocket.sendMessage(i3);
      }
      init(e2, t2) {
        return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Sl((i3, n2) => {
          this.once(Nf.WS_CONNECTED, () => i3(this.joinResponse)), this.once(Nf.WS_CLOSED, () => n2(this.initError || new SE(fE.WS_ABORT))), this.connectionState = Of.CONNECTING, this.websocket.init(e2).catch(n2), this.websocket.once(FS.FAILBACK, () => {
            void 0 === this.openConnectionTime && n2(new SE(fE.INIT_DATACHANNEL_TIMEOUT));
          }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {
            this.handleInflateData();
          }, 2e4), setTimeout(() => {
            t2 && void 0 === this.openConnectionTime && (OE.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), n2(new SE(fE.INIT_DATACHANNEL_TIMEOUT)));
          }, GE("DC_JOIN_WITH_FAILBACK"));
        });
      }
      close(e2) {
        this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e2 || vf.LEAVE, this.connectionState = Of.CLOSED, OE.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e2 === vf.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new LC("gateway-".concat(this.clientId), this.spec.retryConfig, true, this.store), this.handleWebsocketEvents());
      }
      async join() {
        if (!this.joinResponse) {
          this.emit(Nf.ABORT_P2P_EXECUTION);
          const e2 = await nC(this, Nf.DATACHANNEL_CONNECTING), t2 = await this.request(bf.JOIN, e2);
          if (!t2)
            return this.emit(Nf.REPORT_JOIN_GATEWAY, fE.TIMEOUT, this.url || ""), false;
          this.joinResponse = t2, this.emit(Nf.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
        }
        return this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
      }
      async rejoin() {
        if (!this.reconnectToken)
          throw new SE(fE.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
        const e2 = sC(this, Nf.REQUEST_REJOIN_INFO);
        e2.token = this.reconnectToken;
        const t2 = await this.request(bf.REJOIN, e2);
        return !!t2 && (this.connectionState = Of.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t2.peers && t2.peers.forEach((e3) => {
          this.emit(Df.ON_USER_ONLINE, { uid: e3.uid }), e3.audio && this.emit(Df.ON_ADD_AUDIO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, audio: true, ssrcId: e3.audio_ssrc }), e3.video && this.emit(Df.ON_ADD_VIDEO_STREAM, { uid: e3.uid, uint_id: e3.uint_id, video: true, ssrcId: e3.video_ssrc }), e3.audio_mute ? this.emit(Df.MUTE_AUDIO, { uid: e3.uid }) : this.emit(Df.UNMUTE_AUDIO, { uid: e3.uid }), e3.video_mute ? this.emit(Df.MUTE_VIDEO, { uid: e3.uid }) : this.emit(Df.UNMUTE_VIDEO, { uid: e3.uid }), e3.audio_enable_local ? this.emit(Df.ENABLE_LOCAL_AUDIO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_AUDIO, { uid: e3.uid }), e3.video_enable_local ? this.emit(Df.ENABLE_LOCAL_VIDEO, { uid: e3.uid }) : this.emit(Df.DISABLE_LOCAL_VIDEO, { uid: e3.uid }), e3.audio || e3.video || this.emit(Df.ON_REMOVE_STREAM, { uid: e3.uid, uint_id: e3.uint_id });
        }), true);
      }
      reconnect(e2, t2) {
        this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e2, t2);
      }
      handleNotification(e2) {
        OE.debug("[".concat(this.clientId, "] receive notification: "), e2);
        const t2 = IC(e2.code);
        if ("success" !== t2.action) {
          if ("failed" !== t2.action)
            return "quit" === t2.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t2.desc && this.close(vf.UID_BANNED), void this.close()) : void this.reconnect(t2.action, jS.SERVER_ERROR);
          OE.error("[".concat(this.clientId, "] ignore error: "), t2.desc);
        }
      }
      handlePingPong() {
        if (!this.websocket || "connected" !== this.websocket.state)
          return;
        this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
        const e2 = GE("PING_PONG_TIME_OUT"), t2 = Date.now();
        this.pingpongTimeoutCount >= e2 && (OE.warning("PINGPONG Timeout. Last Socket Message: ".concat(t2 - this.lastMsgTime, "ms")), t2 - this.lastMsgTime > GE("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", jS.TIMEOUT) : this.request(bf.PING, void 0, true).then(() => {
          this.pingpongTimeoutCount = 0;
          const e3 = Date.now() - t2;
          this.rttRolling.add(e3), GE("REPORT_STATS") && this.send(bf.PING_BACK, { pingpongElapse: e3 });
        }).catch((e3) => {
        });
      }
      handleInflateData() {
        const { inflateLength: e2, deflateLength: t2 } = this.websocket.getInflateData();
        0 !== e2 && 0 !== t2 && this.upload(wf.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: t2, ws_inflate_length: e2 });
      }
      handleWebsocketEvents() {
        this.websocket.on(FS.RECONNECT_WAITTING_FINISH, (e2) => {
          this.emit(Nf.WS_RECONNECT_WAITTING_FINISH, e2);
        }), this.websocket.on(FS.RECONNECT_CREATE_CONNECTION, (e2) => {
          this.emit(Nf.WS_RECONNECT_CREATE_CONNECTION, e2);
        }), this.websocket.on(FS.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(FS.CLOSED, () => {
          this.connectionState = Of.CLOSED;
        }), this.websocket.on(FS.FAILED, () => {
          this._disconnectedReason = vf.NETWORK_ERROR, this.connectionState = Of.CLOSED;
        }), this.websocket.on(FS.RECONNECTING, (e2) => {
          this._websocketReconnectReason = e2, this.joinResponse = void 0, this.connectionState === Of.CONNECTED ? this.connectionState = Of.RECONNECTING : this.connectionState = Of.CONNECTING;
        }), this.websocket.on(FS.WILL_RECONNECT, (e2, t2) => {
          if (sC(this, Nf.IS_P2P_DISCONNECTED) && "retry" === e2)
            return OE.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P), t2("tryNext");
          "retry" !== e2 && (OE.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e2)), this.reconnectToken = void 0, this.emit(Nf.NEED_RENEW_SESSION), this.emit(Nf.DISCONNECT_P2P)), t2(e2);
        }), this.websocket.on(FS.CONNECTED, () => {
          this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e2) => {
            OE.warning("[".concat(this.clientId, "] rejoin failed ").concat(e2)), this.reconnect("tryNext", jS.SERVER_ERROR);
          }) : this.join().catch((e2) => {
            if (this.emit(Nf.REPORT_JOIN_GATEWAY, e2.message || e2.code, this.url || ""), e2 instanceof SE && e2.code === fE.UNEXPECTED_RESPONSE && e2.data.code === If.ERR_NO_AUTHORIZED)
              return OE.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", jS.SERVER_ERROR);
            OE.error("[".concat(this.clientId, "] join gateway request failed"), e2.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", jS.SERVER_ERROR) : (this.initError = e2, this.close());
          });
        }), this.websocket.on(FS.REQUEST_NEW_URLS, (e2, t2) => {
          nC(this, Nf.REQUEST_RECOVER, this.multiIpOption).then(e2).catch(t2);
        }), this.websocket.on(FS.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
          this.emit(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
        }), this.websocket.on(FS.TO_CONNECT_DATACHANNEL, async (e2, t2, i3) => nC(this, Nf.DATACHANNEL_PRECONNECT, e2).then(t2).catch(i3)), this.websocket.on(FS.FAILBACK, () => {
          void 0 !== this.openConnectionTime && this.emit(Nf.DATACHANNEL_FAILBACK);
        });
      }
    }
    function MC(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function UC(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? MC(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : MC(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    const xC = /* @__PURE__ */ new Map();
    class VC extends EE {
      get state() {
        return this._state;
      }
      set state(e2) {
        if (e2 === this._state)
          return;
        const t2 = this._state;
        this._state = e2, "DISCONNECTED" === e2 && this._disconnectedReason ? this.emit(aS.CONNECTION_STATE_CHANGE, e2, t2, this._disconnectedReason) : this.emit(aS.CONNECTION_STATE_CHANGE, e2, t2);
      }
      get joinGatewayStartTime() {
        return this._joinGatewayStartTime;
      }
      set joinGatewayStartTime(e2) {
        OE.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e2)), this._joinGatewayStartTime = e2;
      }
      constructor(e2, t2) {
        super(), _p(this, "store", void 0), _p(this, "joinInfo", void 0), _p(this, "key", void 0), _p(this, "signal", void 0), _p(this, "role", void 0), _p(this, "inChannelInfo", { joinAt: null, duration: 0 }), _p(this, "spec", void 0), _p(this, "_state", "DISCONNECTED"), _p(this, "_statsCollector", void 0), _p(this, "_disconnectedReason", void 0), _p(this, "isSignalRecover", false), _p(this, "hasChangeBGPAddress", false), _p(this, "trafficStatsInterval", void 0), _p(this, "networkQualityInterval", void 0), _p(this, "_joinGatewayStartTime", 0), _p(this, "_signalTimeout", false), _p(this, "_clientRoleOptions", void 0), _p(this, "_isProactiveJoin", false), this.store = e2, this.spec = t2, this.signal = this.store.useDataChannel ? new kC(UC(UC({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2) : new AC(UC(UC({}, t2), {}, { retryConfig: t2.websocketRetryConfig }), e2), this._statsCollector = t2.statsCollector, this.role = t2.role || "audience", this._clientRoleOptions = t2.clientRoleOptions, this.handleSignalEvents();
      }
      async join(e2, t2, i3) {
        if (this.signal instanceof kC) {
          let t3 = false;
          "disabled" !== e2.cloudProxyServer ? (OE.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e2.cloudProxyServer, ")")), t3 = true) : "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length > 255 || "".concat(e2.apResponse.cid, "_").concat(e2.apResponse.cert).length < 22 ? (OE.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t3 = true) : e2.apResponse.addresses.some((e3) => e3.fingerprint) || GE("FINGERPRINT") || (OE.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t3 = true), t3 && this.resetSignal();
        }
        this.store.joinGatewayStart(), "disabled" !== e2.cloudProxyServer && (this.hasChangeBGPAddress = true);
        const n2 = Date.now();
        let r2 = xC.get(e2.cname);
        if (r2 || (r2 = /* @__PURE__ */ new Map(), xC.set(e2.cname, r2)), this._isProactiveJoin = true, r2.has(e2.uid)) {
          const t3 = new SE(fE.UID_CONFLICT);
          throw Pg.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: null, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e2.proxyServer, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false, t3;
        }
        r2.set(e2.uid, true), this.joinInfo = e2, this.key = t2;
        let o2 = 0;
        this.joinGatewayStartTime = n2;
        const s2 = e2.proxyServer;
        try {
          let t3;
          if (OE.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof kC ? "datachannel" : "websocket", " join uid ").concat(o2)), this.signal instanceof kC)
            t3 = await this.signal.init(e2.apResponse.addresses, i3);
          else {
            const n3 = e2.proxyServer, r3 = n3 ? e2.gatewayAddrs.map((e3) => {
              const t4 = e3.address.split(":");
              return "wss://".concat(n3, "/ws/?h=").concat(t4[0], "&p=").concat(t4[1]);
            }) : e2.gatewayAddrs.map((e3) => "wss://".concat(e3.address));
            t3 = await this.signal.init(r3, i3);
          }
          o2 = t3.uid, OE.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof kC ? "datachannel" : "websocket", " join uid ").concat(o2, " cost ").concat(Date.now() - this.joinGatewayStartTime));
        } catch (t3) {
          if (t3 && t3.code === fE.INIT_WEBSOCKET_TIMEOUT)
            throw OE.warning("[".concat(this.store.clientId, "] User join failed"), t3.toString()), t3;
          if (t3 && t3.code === fE.INIT_DATACHANNEL_TIMEOUT)
            throw OE.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t3.toString()), this.resetSignal(), t3;
          throw OE.error("[".concat(this.store.clientId, "] User join failed"), t3.toString()), Pg.joinGateway(e2.sid, { lts: n2, succ: false, ec: t3.message, addr: this.signal.url, uid: e2.uid, cid: e2.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!s2, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false, r2.delete(e2.uid), this.signal.close(), t3;
        }
        return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), OE.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
          this.updateTrafficStats().catch((e3) => {
            OE.warning("[".concat(this.store.clientId, "] get traffic stats error"), e3.toString());
          });
        }, 3e3), this.networkQualityInterval = window.setInterval(() => {
          navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(aS.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(aS.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(aS.NETWORK_QUALITY, { uplinkNetworkQuality: GI(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: GI(this._statsCollector.trafficStats.B_dnq) }) : this.emit(aS.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
        }, 2e3), this.store.joinGatewayEnd(), o2;
      }
      async leave() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 ? arguments[1] : void 0;
        if ("DISCONNECTED" !== this.state) {
          t2 !== vf.FALLBACK && (this.state = "DISCONNECTING");
          try {
            e2 || this.signal.connectionState !== Of.CONNECTED || await function(e3, t3) {
              return t3 === 1 / 0 ? e3 : Sl.race([e3, QI(t3)]);
            }(this.signal.request(bf.LEAVE, void 0, true), 3e3);
          } catch (e3) {
            OE.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e3);
          }
          this.signal.close(t2), t2 !== vf.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
        }
      }
      async publish(e2, t2, i3) {
        if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
          throw new SE(fE.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
        const n2 = { state: "offer", p2p_id: this.store.p2pId, ortc: t2, mode: this.spec.mode, extend: GE("PUB_EXTEND"), twcc: !!GE("PUBLISH_TWCC"), rtx: !!GE("USE_PUB_RTX") };
        try {
          return (await this.signal.request(bf.PUBLISH, n2, true))._message;
        } catch (n3) {
          if (i3 && n3.data && n3.data.code === If.ERR_PUBLISH_REQUEST_INVALID)
            return OE.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n3.toString()), await this.tryUnpubBeforeRepub(e2, t2), this.publish(e2, t2, false);
          throw n3;
        }
      }
      async unpublish(e2, t2) {
        try {
          if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
            throw new SE(fE.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
          await this.signal.request(bf.UNPUBLISH, { stream_id: t2, ortc: e2 }, true);
        } catch (e3) {
          OE.warning("[".concat(this.store.clientId, "] unpublish warning: "), e3);
        }
      }
      async subscribe(e2, t2, i3) {
        if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
          throw new SE(fE.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
        const n2 = { stream_id: e2, stream_type: t2.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!GE("SUBSCRIBE_TWCC"), rtx: !!GE("USE_SUB_RTX"), extend: GE("SUB_EXTEND"), ssrcId: t2.ssrcId, svc: Array.isArray(GE("SVC")) && 0 !== GE("SVC").length ? GE("SVC") : void 0 };
        try {
          return (await this.signal.request(bf.SUBSCRIBE, n2, true))._message;
        } catch (n3) {
          if (i3 && n3.data && n3.data.code === If.ERR_SUBSCRIBE_REQUEST_INVALID)
            return OE.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n3.toString()), await this.tryUnsubBeforeResub(e2, t2), await this.subscribe(e2, t2, false);
          throw n3;
        }
      }
      async subscribeAll(e2, t2) {
        if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state)
          throw new SE(fE.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
        const i3 = { p2p_id: this.store.p2pId, users: e2, dtx: false, rtx: !!GE("USE_SUB_RTX") };
        try {
          return await this.signal.request(bf.SUBSCRIBE_STREAMS, i3, true);
        } catch (i4) {
          if (t2 && i4.data && i4.data.code === If.ERR_SUBSCRIBE_REQUEST_INVALID)
            return OE.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), i4.toString()), await this.tryMassUnsubBeforeResub(e2), await this.subscribeAll(e2, false);
          throw i4;
        }
      }
      async setVideoProfile(e2) {
        const t2 = function(e3) {
          if (!(e3.bitrateMax && e3.bitrateMin && e3.frameRate && e3.height && e3.width))
            return;
          let t3 = e3.frameRate, i3 = e3.width, n2 = e3.height, r2 = true;
          return "number" != typeof t3 && (t3 = t3.exact || t3.ideal || t3.max || t3.min || 0, t3 || (r2 = false)), "number" != typeof i3 && (i3 = i3.exact || i3.ideal || i3.max || i3.min || 0, i3 || (r2 = false)), "number" != typeof n2 && (n2 = n2.exact || n2.ideal || n2.max || n2.min || 0, t3 || (r2 = false)), r2 ? { stream_type: 0, width: i3, height: n2, fps: t3, start_bps: 1e3 * e3.bitrateMax, min_bps: 1e3 * e3.bitrateMin, target_bps: 1e3 * e3.bitrateMax } : void 0;
        }(e2);
        if (t2)
          return this.signal.request(bf.SET_VIDEO_PROFILE, t2);
        OE.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
      }
      async unsubscribe(e2, t2) {
        try {
          await this.signal.request(bf.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 }, true);
        } catch (e3) {
          OE.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), e3);
        }
      }
      async massUnsubscribe(e2) {
        try {
          await this.signal.request(bf.UNSUBSCRIBE_STREAMS, e2, true);
        } catch (e3) {
          OE.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), e3);
        }
      }
      async reconnectPC(e2) {
        const { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } = e2;
        return { gatewayEstablishParams: await this.signal.request(bf.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
      }
      getGatewayInfo() {
        return this.signal.request(bf.GATEWAY_INFO);
      }
      async renewToken(e2) {
        await this.signal.request(bf.RENEW_TOKEN, e2), this.key = e2.token;
      }
      async setClientRole(e2, t2) {
        if (t2 && (this._clientRoleOptions = Object.assign({}, t2)), "CONNECTED" !== this.state)
          return void (this.role = e2);
        let i3 = void 0;
        i3 = "audience" === e2 ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(bf.SET_CLIENT_ROLE, { role: e2, level: i3, client_ts: Date.now() }), this.role = e2;
      }
      async setRemoteVideoStreamType(e2, t2) {
        await this.signal.request(bf.SWITCH_VIDEO_STREAM, { stream_id: e2, stream_type: t2 });
      }
      async setDefaultRemoteVideoStreamType(e2) {
        await this.signal.request(bf.DEFAULT_VIDEO_STREAM, { stream_type: e2 });
      }
      async setStreamFallbackOption(e2, t2) {
        await this.signal.request(bf.SET_FALLBACK_OPTION, { stream_id: e2, fallback_type: t2 });
      }
      async pickSVCLayer(e2, t2) {
        await this.signal.request(bf.PICK_SVC_LAYER, { stream_id: e2, spatial_layer: t2.spatialLayer, temporal_layer: t2.temporalLayer });
      }
      getInChannelInfo() {
        return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), UC({}, this.inChannelInfo);
      }
      async getGatewayVersion() {
        return (await this.signal.request(bf.GATEWAY_INFO)).version;
      }
      reset() {
        if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
          const e2 = xC.get(this.joinInfo.cname);
          e2 && e2.delete(this.joinInfo.uid);
        }
        this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
      }
      updateTurnConfigFromSignal() {
        if (!this.joinInfo)
          return;
        const e2 = function(e3) {
          let t2;
          return t2 = e3.startsWith("dc") ? e3.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e3.match(/(wss\:\/\/)?([^:]+):(\d+)/), t2 ? { username: PE.username, password: PE.password, turnServerURL: t2[2], tcpport: parseInt(t2[3]) + 30, udpport: parseInt(t2[3]) + 30, forceturn: false } : null;
        }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
        this.joinInfo.turnServer.serversFromGateway = [], e2 && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(UC(UC({}, PE), {}, { turnServerURL: e2.turnServerURL, tcpport: e2.tcpport, udpport: e2.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
      }
      async updateTrafficStats() {
        if ("CONNECTED" !== this.state)
          return;
        const e2 = await this.signal.request(bf.TRAFFIC_STATS, void 0, true);
        e2.timestamp = Date.now(), e2.peer_delay.forEach((e3) => {
          const t2 = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((t3) => t3.peer_uid === e3.peer_uid);
          t2 && t2.B_st !== e3.B_st && dC(() => {
            this.emit(aS.STREAM_TYPE_CHANGE, e3.peer_uid, e3.B_st);
          });
        }), this._statsCollector.updateTrafficStats(e2);
      }
      getJoinMessage(e2) {
        if (!this.joinInfo || !this.key)
          throw new SE(fE.UNEXPECTED_ERROR, "can not generate join message, no join info");
        const t2 = Object.assign({}, this.joinInfo.apResponse);
        let i3 = GE("REPORT_APP_SCENARIO");
        if ("string" != typeof i3)
          try {
            i3 = JSON.stringify(i3);
          } catch (e3) {
            i3 = void 0;
          }
        i3 && i3.length > 128 && (i3 = void 0);
        const n2 = UC({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: bE, browser: navigator.userAgent, process_id: GE("PROCESS_ID"), mode: this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: t2, extend: GE("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i3, attributes: { userAttributes: { enablePublishedUserList: GE("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: GE("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: "number" == typeof GE("SUBSCRIBE_AUDIO_FILTER_TOPN") ? GE("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: "boolean" == typeof GE("ENABLE_PUBLISH_AUDIO_FILTER") ? GE("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: "boolean" == typeof GE("ENABLE_USER_LICENSE_CHECK") ? GE("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: true === GE("USE_PUB_RTX") || true === GE("USE_SUB_RTX") || void 0 } }, join_ts: this.joinGatewayStartTime }, e2);
        return this.joinInfo.stringUid && (n2.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (n2.aes_mode = this.joinInfo.aesmode, GE("ENCRYPT_AES") ? (n2.aes_secret = this.joinInfo.aespassword, n2.aes_encrypt = true) : n2.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (n2.aes_salt = this.joinInfo.aessalt)), t2.addresses[this.signal.websocket.currentURLIndex] && (n2.ap_response.ticket = t2.addresses[this.signal.websocket.currentURLIndex].ticket, delete t2.addresses), void 0 !== this.joinInfo.defaultVideoStream && (n2.default_video_stream = this.joinInfo.defaultVideoStream), n2;
      }
      getRejoinMessage() {
        if (!this.joinInfo)
          throw new SE(fE.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
        return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
      }
      handleSignalEvents() {
        this.signal.on(Nf.WS_RECONNECT_WAITTING_FINISH, (e2) => {
          ["tryNext", "recover"].includes(e2) && this.joinInfo && Pg.adjustSessionStartTime(this.joinInfo.sid);
        }), this.signal.on(Nf.WS_RECONNECT_CREATE_CONNECTION, (e2) => {
          this.joinGatewayStartTime = Date.now();
        }), this.signal.on(Nf.WS_RECONNECTING, (e2) => {
          this.joinInfo && Pg.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e2 || Af.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", Pg.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
        }), this.signal.on(Nf.WS_CLOSED, (e2) => {
          let t2;
          switch (e2) {
            case vf.LEAVE:
              t2 = Af.LEAVE;
              break;
            case vf.UID_BANNED:
            case vf.IP_BANNED:
            case vf.CHANNEL_BANNED:
            case vf.SERVER_ERROR:
              t2 = Af.SERVER_ERROR;
              break;
            case vf.FALLBACK:
              t2 = Af.FALLBACK;
              break;
            case vf.LICENSE_MISSING:
            case vf.LICENSE_EXPIRED:
            case vf.LICENSE_MINUTES_EXCEEDED:
            case vf.LICENSE_PERIOD_INVALID:
            case vf.LICENSE_MULTIPLE_SDK_SERVICE:
            case vf.LICENSE_ILLEGAL:
              t2 = e2;
              break;
            default:
              t2 = Af.NETWORK_ERROR;
          }
          OE.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(t2 || "undefined -> " + Af.NETWORK_ERROR)), this.joinInfo && Pg.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e2 === vf.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: t2 }), this._disconnectedReason = e2, e2 !== vf.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
        }), this.signal.on(Nf.WS_CONNECTED, () => {
          if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (OE.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), Pg.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
            const e2 = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
            if (!e2)
              return void OE.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e2));
            BE("EVENT_REPORT_DOMAIN", e2[1]), BE("EVENT_REPORT_BACKUP_DOMAIN", e2[1]), BE("LOG_UPLOAD_SERVER", "".concat(e2[1], ":6444"));
          }
        }), this.signal.on(Df.ON_UPLINK_STATS, (e2) => {
          this._statsCollector.updateUplinkStats(e2);
        }), this.signal.on(Nf.REQUEST_RECOVER, (e2, t2, i3) => {
          if (!this.joinInfo)
            return i3(new SE(fE.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
          e2 && (this.joinInfo.multiIP = e2, this.hasChangeBGPAddress = true), this.isSignalRecover = true, nC(this, aS.REQUEST_NEW_GATEWAY_LIST).then(t2).catch(i3);
        }), this.signal.on(Nf.REQUEST_JOIN_INFO, async (e2) => {
          var t2;
          this.updateTurnConfigFromSignal();
          const { iceParameters: i3, dtlsParameters: n2, rtpCapabilities: r2 } = await nC(this, aS.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: null === (t2 = this.joinInfo) || void 0 === t2 ? void 0 : t2.turnServer });
          e2(this.getJoinMessage({ ortc: { iceParameters: i3, dtlsParameters: n2, rtpCapabilities: r2, version: "2" } }));
        }), this.signal.on(Nf.REQUEST_REJOIN_INFO, (e2) => {
          e2(this.getRejoinMessage());
        }), this.signal.on(Nf.REPORT_JOIN_GATEWAY, (e2, t2) => {
          this.joinInfo && (Pg.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: e2, addr: t2, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: this.signal instanceof kC ? "1" : "0" }), this._isProactiveJoin = false);
        }), this.signal.on(Nf.IS_P2P_DISCONNECTED, (e2) => {
          e2(sC(this, aS.IS_P2P_DISCONNECTED));
        }), this.signal.on(Nf.DISCONNECT_P2P, () => {
          this.emit(aS.DISCONNECT_P2P);
        }), this.signal.on(Nf.NEED_RENEW_SESSION, () => {
          this.emit(aS.NEED_RENEW_SESSION);
        }), this.signal.on(Nf.REQUEST_SUCCESS, () => {
          this._signalTimeout = false;
        }), this.signal.on(Nf.REQUEST_TIMEOUT, () => {
          this._signalTimeout = true;
        }), this.signal.on(Nf.JOIN_RESPONSE, (e2) => {
          const t2 = this.getCurrentGatewayAddress();
          this.emit(aS.JOIN_RESPONSE, e2, t2);
        }), this.signal.on(Nf.DATACHANNEL_PRECONNECT, async (e2, t2, i3) => {
          this.updateTurnConfigFromSignal();
          const n2 = this.getCurrentGatewayAddress();
          return nC(this, aS.DATACHANNEL_PRECONNECT, e2, n2).then(t2).catch(i3);
        }), this.signal.on(Nf.DATACHANNEL_CONNECTING, async (e2) => {
          const { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } = await nC(this, aS.REQUEST_DC_CONNECTION_PARAMS);
          e2(this.getJoinMessage({ ortc: { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2, version: "2" } }));
        }), this.signal.on(Nf.DATACHANNEL_FAILBACK, () => {
          OE.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(aS.DATACHANNEL_FAILBACK);
        });
      }
      async tryUnsubBeforeResub(e2, t2) {
        try {
          await this.signal.request(bf.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e2, ortc: [t2] }, true);
        } catch (e3) {
          throw OE.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), e3), e3;
        }
      }
      async tryUnpubBeforeRepub(e2, t2) {
        try {
          await this.signal.request(bf.UNPUBLISH, { stream_id: e2, ortc: t2 }, true);
        } catch (e3) {
          throw OE.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), e3), e3;
        }
      }
      async tryMassUnsubBeforeResub(e2) {
        const t2 = { users: e2.map((e3) => ({ stream_id: e3.stream_id, stream_type: e3.stream_type })) };
        try {
          await this.signal.request(bf.UNSUBSCRIBE_STREAMS, t2, true);
        } catch (e3) {
          throw OE.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), e3), e3;
        }
      }
      async muteLocal(e2, t2) {
        const i3 = { action: e2.find((e3) => e3.stream_type === sS.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
        try {
          await this.signal.request(bf.CONTROL, i3, true, true);
        } catch (e3) {
          throw OE.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), e3), e3;
        }
      }
      async unmuteLocal(e2, t2) {
        const i3 = { action: e2.find((e3) => e3.stream_type === sS.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e2, stream_id: t2 };
        try {
          await this.signal.request(bf.CONTROL, i3, true, true);
        } catch (e3) {
          throw OE.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), e3), e3;
        }
      }
      uploadStats(e2, t2) {
        this.signal.upload(e2, t2);
      }
      getSignalRTT() {
        return this.signal.rtt;
      }
      async restartICE(e2) {
        const t2 = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e2 };
        try {
          return await this.signal.request(bf.RESTART_ICE, t2, true);
        } catch (e3) {
          throw OE.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), e3), e3;
        }
      }
      reconnect() {
        "CONNECTED" === this.state && this.signal.reconnect(void 0, Af.P2P_FAILED);
      }
      getCurrentGatewayAddress() {
        var e2;
        if (!GE("GATEWAY_WSS_ADDRESS"))
          return null !== (e2 = this.joinInfo) && void 0 !== e2 && e2.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
      }
      async setPublishAudioFilterEnabled(e2) {
        await this.signal.request(bf.SET_PARAMETER, { enablePublishAudioFilter: e2 });
      }
      resetSignal() {
        this.signal && (this.signal.removeAllListeners(), this.signal.close(vf.FALLBACK)), this.store.useDataChannel = false, this.signal = new AC(UC(UC({}, this.spec), {}, { retryConfig: this.spec.websocketRetryConfig }), this.store), this.handleSignalEvents(), this.emit(aS.RESET_SIGNAL, dS.websocket);
      }
    }
    /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
    !function() {
      var e2;
      function i3(e3) {
        var t2 = 0;
        return function() {
          return t2 < e3.length ? { done: false, value: e3[t2++] } : { done: true };
        };
      }
      var n2 = "function" == typeof Object.defineProperties ? Object.defineProperty : function(e3, t2, i4) {
        return e3 == Array.prototype || e3 == Object.prototype || (e3[t2] = i4.value), e3;
      };
      var r2, o2 = function(e3) {
        e3 = ["object" == typeof globalThis && globalThis, e3, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof t && t];
        for (var i4 = 0; i4 < e3.length; ++i4) {
          var n3 = e3[i4];
          if (n3 && n3.Math == Math)
            return n3;
        }
        throw Error("Cannot find global object");
      }(this);
      function s2(e3, t2) {
        if (t2)
          e: {
            var i4 = o2;
            e3 = e3.split(".");
            for (var r3 = 0; r3 < e3.length - 1; r3++) {
              var s3 = e3[r3];
              if (!(s3 in i4))
                break e;
              i4 = i4[s3];
            }
            (t2 = t2(r3 = i4[e3 = e3[e3.length - 1]])) != r3 && null != t2 && n2(i4, e3, { configurable: true, writable: true, value: t2 });
          }
      }
      function a2(e3) {
        return (e3 = { next: e3 })[Symbol.iterator] = function() {
          return this;
        }, e3;
      }
      function c2(e3) {
        var t2 = "undefined" != typeof Symbol && Symbol.iterator && e3[Symbol.iterator];
        return t2 ? t2.call(e3) : { next: i3(e3) };
      }
      if (s2("Symbol", function(e3) {
        function t2(e4, t3) {
          this.A = e4, n2(this, "description", { configurable: true, writable: true, value: t3 });
        }
        if (e3)
          return e3;
        t2.prototype.toString = function() {
          return this.A;
        };
        var i4 = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", r3 = 0;
        return function e4(n3) {
          if (this instanceof e4)
            throw new TypeError("Symbol is not a constructor");
          return new t2(i4 + (n3 || "") + "_" + r3++, n3);
        };
      }), s2("Symbol.iterator", function(e3) {
        if (e3)
          return e3;
        e3 = Symbol("Symbol.iterator");
        for (var t2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), r3 = 0; r3 < t2.length; r3++) {
          var s3 = o2[t2[r3]];
          "function" == typeof s3 && "function" != typeof s3.prototype[e3] && n2(s3.prototype, e3, { configurable: true, writable: true, value: function() {
            return a2(i3(this));
          } });
        }
        return e3;
      }), "function" == typeof Object.setPrototypeOf)
        r2 = Object.setPrototypeOf;
      else {
        var d2;
        e: {
          var u2 = {};
          try {
            u2.__proto__ = { a: true }, d2 = u2.a;
            break e;
          } catch (e3) {
          }
          d2 = false;
        }
        r2 = d2 ? function(e3, t2) {
          if (e3.__proto__ = t2, e3.__proto__ !== t2)
            throw new TypeError(e3 + " is not extensible");
          return e3;
        } : null;
      }
      var l2 = r2;
      function h3() {
        this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
      }
      function p3(e3) {
        if (e3.m)
          throw new TypeError("Generator is already running");
        e3.m = true;
      }
      function _2(e3, t2) {
        return e3.h = 3, { value: t2 };
      }
      function E2(e3) {
        this.g = new h3(), this.G = e3;
      }
      function m2(e3, t2, i4, n3) {
        try {
          var r3 = t2.call(e3.g.j, i4);
          if (!(r3 instanceof Object))
            throw new TypeError("Iterator result " + r3 + " is not an object");
          if (!r3.done)
            return e3.g.m = false, r3;
          var o3 = r3.value;
        } catch (t3) {
          return e3.g.j = null, e3.g.s(t3), f2(e3);
        }
        return e3.g.j = null, n3.call(e3.g, o3), f2(e3);
      }
      function f2(e3) {
        for (; e3.g.h; )
          try {
            var t2 = e3.G(e3.g);
            if (t2)
              return e3.g.m = false, { value: t2.value, done: false };
          } catch (t3) {
            e3.g.v = void 0, e3.g.s(t3);
          }
        if (e3.g.m = false, e3.g.l) {
          if (t2 = e3.g.l, e3.g.l = null, t2.F)
            throw t2.D;
          return { value: t2.return, done: true };
        }
        return { value: void 0, done: true };
      }
      function S2(e3) {
        this.next = function(t2) {
          return e3.o(t2);
        }, this.throw = function(t2) {
          return e3.s(t2);
        }, this.return = function(t2) {
          return function(e4, t3) {
            p3(e4.g);
            var i4 = e4.g.j;
            return i4 ? m2(e4, "return" in i4 ? i4.return : function(e5) {
              return { value: e5, done: true };
            }, t3, e4.g.return) : (e4.g.return(t3), f2(e4));
          }(e3, t2);
        }, this[Symbol.iterator] = function() {
          return this;
        };
      }
      function T2(e3, t2) {
        return t2 = new S2(new E2(t2)), l2 && e3.prototype && l2(t2, e3.prototype), t2;
      }
      if (h3.prototype.o = function(e3) {
        this.v = e3;
      }, h3.prototype.s = function(e3) {
        this.l = { D: e3, F: true }, this.h = this.C || this.u;
      }, h3.prototype.return = function(e3) {
        this.l = { return: e3 }, this.h = this.u;
      }, E2.prototype.o = function(e3) {
        return p3(this.g), this.g.j ? m2(this, this.g.j.next, e3, this.g.o) : (this.g.o(e3), f2(this));
      }, E2.prototype.s = function(e3) {
        return p3(this.g), this.g.j ? m2(this, this.g.j.throw, e3, this.g.o) : (this.g.s(e3), f2(this));
      }, s2("Array.prototype.entries", function(e3) {
        return e3 || function() {
          return function(e4, t2) {
            e4 instanceof String && (e4 += "");
            var i4 = 0, n3 = false, r3 = { next: function() {
              if (!n3 && i4 < e4.length) {
                var r4 = i4++;
                return { value: t2(r4, e4[r4]), done: false };
              }
              return n3 = true, { done: true, value: void 0 };
            } };
            return r3[Symbol.iterator] = function() {
              return r3;
            }, r3;
          }(this, function(e4, t2) {
            return [e4, t2];
          });
        };
      }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
        var g2 = function(e3, t2) {
          for (var i4 = 0; i4 < e3.length; i4++)
            t2(e3[i4]);
        }, R2 = function(e3) {
          return e3.replace(/\r?\n|\r/g, "\r\n");
        }, I2 = function(e3, t2, i4) {
          return t2 instanceof Blob ? (i4 = void 0 !== i4 ? String(i4 + "") : "string" == typeof t2.name ? t2.name : "blob", t2.name === i4 && "[object Blob]" !== Object.prototype.toString.call(t2) || (t2 = new File([t2], i4)), [String(e3), t2]) : [String(e3), String(t2)];
        }, C2 = function(e3, t2) {
          if (e3.length < t2)
            throw new TypeError(t2 + " argument required, but only " + e3.length + " present.");
        }, v2 = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this, y2 = v2.FormData, A2 = v2.XMLHttpRequest && v2.XMLHttpRequest.prototype.send, O2 = v2.Request && v2.fetch, N2 = v2.navigator && v2.navigator.sendBeacon, b2 = v2.Element && v2.Element.prototype, w3 = v2.Symbol && Symbol.toStringTag;
        w3 && (Blob.prototype[w3] || (Blob.prototype[w3] = "Blob"), "File" in v2 && !File.prototype[w3] && (File.prototype[w3] = "File"));
        try {
          new File([], "");
        } catch (e3) {
          v2.File = function(e4, t2, i4) {
            return e4 = new Blob(e4, i4 || {}), Object.defineProperties(e4, { name: { value: t2 }, lastModified: { value: +(i4 && void 0 !== i4.lastModified ? new Date(i4.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
              return "[object File]";
            } } }), w3 && Object.defineProperty(e4, w3, { value: "File" }), e4;
          };
        }
        var D2 = function(e3) {
          return e3.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        }, P2 = function(e3) {
          this.i = [];
          var t2 = this;
          e3 && g2(e3.elements, function(e4) {
            if (e4.name && !e4.disabled && "submit" !== e4.type && "button" !== e4.type && !e4.matches("form fieldset[disabled] *"))
              if ("file" === e4.type) {
                var i4 = e4.files && e4.files.length ? e4.files : [new File([], "", { type: "application/octet-stream" })];
                g2(i4, function(i5) {
                  t2.append(e4.name, i5);
                });
              } else
                "select-multiple" === e4.type || "select-one" === e4.type ? g2(e4.options, function(i5) {
                  !i5.disabled && i5.selected && t2.append(e4.name, i5.value);
                }) : "checkbox" === e4.type || "radio" === e4.type ? e4.checked && t2.append(e4.name, e4.value) : (i4 = "textarea" === e4.type ? R2(e4.value) : e4.value, t2.append(e4.name, i4));
          });
        };
        if ((e2 = P2.prototype).append = function(e3, t2, i4) {
          C2(arguments, 2), this.i.push(I2(e3, t2, i4));
        }, e2.delete = function(e3) {
          C2(arguments, 1);
          var t2 = [];
          e3 = String(e3), g2(this.i, function(i4) {
            i4[0] !== e3 && t2.push(i4);
          }), this.i = t2;
        }, e2.entries = function e3() {
          var t2, i4 = this;
          return T2(e3, function(e4) {
            if (1 == e4.h && (t2 = 0), 3 != e4.h)
              return t2 < i4.i.length ? e4 = _2(e4, i4.i[t2]) : (e4.h = 0, e4 = void 0), e4;
            t2++, e4.h = 2;
          });
        }, e2.forEach = function(e3, t2) {
          C2(arguments, 1);
          for (var i4 = c2(this), n3 = i4.next(); !n3.done; n3 = i4.next()) {
            var r3 = c2(n3.value);
            n3 = r3.next().value, r3 = r3.next().value, e3.call(t2, r3, n3, this);
          }
        }, e2.get = function(e3) {
          C2(arguments, 1);
          var t2 = this.i;
          e3 = String(e3);
          for (var i4 = 0; i4 < t2.length; i4++)
            if (t2[i4][0] === e3)
              return t2[i4][1];
          return null;
        }, e2.getAll = function(e3) {
          C2(arguments, 1);
          var t2 = [];
          return e3 = String(e3), g2(this.i, function(i4) {
            i4[0] === e3 && t2.push(i4[1]);
          }), t2;
        }, e2.has = function(e3) {
          C2(arguments, 1), e3 = String(e3);
          for (var t2 = 0; t2 < this.i.length; t2++)
            if (this.i[t2][0] === e3)
              return true;
          return false;
        }, e2.keys = function e3() {
          var t2, i4, n3, r3, o3 = this;
          return T2(e3, function(e4) {
            if (1 == e4.h && (t2 = c2(o3), i4 = t2.next()), 3 != e4.h)
              return i4.done ? void (e4.h = 0) : (n3 = i4.value, r3 = c2(n3), _2(e4, r3.next().value));
            i4 = t2.next(), e4.h = 2;
          });
        }, e2.set = function(e3, t2, i4) {
          C2(arguments, 2), e3 = String(e3);
          var n3 = [], r3 = I2(e3, t2, i4), o3 = true;
          g2(this.i, function(t3) {
            t3[0] === e3 ? o3 && (o3 = !n3.push(r3)) : n3.push(t3);
          }), o3 && n3.push(r3), this.i = n3;
        }, e2.values = function e3() {
          var t2, i4, n3, r3, o3 = this;
          return T2(e3, function(e4) {
            if (1 == e4.h && (t2 = c2(o3), i4 = t2.next()), 3 != e4.h)
              return i4.done ? void (e4.h = 0) : (n3 = i4.value, (r3 = c2(n3)).next(), _2(e4, r3.next().value));
            i4 = t2.next(), e4.h = 2;
          });
        }, P2.prototype._asNative = function() {
          for (var e3 = new y2(), t2 = c2(this), i4 = t2.next(); !i4.done; i4 = t2.next()) {
            var n3 = c2(i4.value);
            i4 = n3.next().value, n3 = n3.next().value, e3.append(i4, n3);
          }
          return e3;
        }, P2.prototype._blob = function() {
          var e3 = "----formdata-polyfill-" + Math.random(), t2 = [], i4 = "--" + e3 + '\r\nContent-Disposition: form-data; name="';
          return this.forEach(function(e4, n3) {
            return "string" == typeof e4 ? t2.push(i4 + D2(R2(n3)) + '"\r\n\r\n' + R2(e4) + "\r\n") : t2.push(i4 + D2(R2(n3)) + '"; filename="' + D2(e4.name) + '"\r\nContent-Type: ' + (e4.type || "application/octet-stream") + "\r\n\r\n", e4, "\r\n");
          }), t2.push("--" + e3 + "--"), new Blob(t2, { type: "multipart/form-data; boundary=" + e3 });
        }, P2.prototype[Symbol.iterator] = function() {
          return this.entries();
        }, P2.prototype.toString = function() {
          return "[object FormData]";
        }, b2 && !b2.matches && (b2.matches = b2.matchesSelector || b2.mozMatchesSelector || b2.msMatchesSelector || b2.oMatchesSelector || b2.webkitMatchesSelector || function(e3) {
          for (var t2 = (e3 = (this.document || this.ownerDocument).querySelectorAll(e3)).length; 0 <= --t2 && e3.item(t2) !== this; )
            ;
          return -1 < t2;
        }), w3 && (P2.prototype[w3] = "FormData"), A2) {
          var L3 = v2.XMLHttpRequest.prototype.setRequestHeader;
          v2.XMLHttpRequest.prototype.setRequestHeader = function(e3, t2) {
            L3.call(this, e3, t2), "content-type" === e3.toLowerCase() && (this.B = true);
          }, v2.XMLHttpRequest.prototype.send = function(e3) {
            e3 instanceof P2 ? (e3 = e3._blob(), this.B || this.setRequestHeader("Content-Type", e3.type), A2.call(this, e3)) : A2.call(this, e3);
          };
        }
        O2 && (v2.fetch = function(e3, t2) {
          return t2 && t2.body && t2.body instanceof P2 && (t2.body = t2.body._blob()), O2.call(this, e3, t2);
        }), N2 && (v2.navigator.sendBeacon = function(e3, t2) {
          return t2 instanceof P2 && (t2 = t2._asNative()), N2.call(this, e3, t2);
        }), v2.FormData = P2;
      }
    }();
    const jC = () => {
      const e2 = GE("AREAS");
      0 === e2.length && e2.push(SS.GLOBAL);
      return zi(e2).call(e2, (e3, t2, i3) => {
        const n2 = FC(t2);
        return n2 ? 0 === i3 ? n2 : "".concat(e3, ",").concat(n2) : e3;
      }, "");
    }, FC = (e2) => e2 === SS.OVERSEA ? "".concat(IS.ASIA, ",").concat(IS.EUROPE, ",").concat(IS.AFRICA, ",").concat(IS.NORTH_AMERICA, ",").concat(IS.SOUTH_AMERICA, ",").concat(IS.OCEANIA) : IS[e2], BC = (e2) => {
      const t2 = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
      return e2.map((e3) => {
        const i3 = CS[e3], n2 = Object.keys(i3);
        n2 && n2.map((e4) => {
          "CODE" !== e4 && (t2[e4] = t2[e4].concat(i3[e4]));
        });
      }), t2;
    }, GC = { GLOBAL: { ASIA: [SS.CHINA, SS.JAPAN, SS.INDIA, SS.KOREA, SS.HKMC], EUROPE: [], NORTH_AMERICA: [SS.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } }, WC = Object.keys(GC[SS.GLOBAL]), HC = [SS.CHINA, SS.NORTH_AMERICA, SS.EUROPE, SS.ASIA, SS.JAPAN, SS.INDIA, SS.OCEANIA, SS.SOUTH_AMERICA, SS.AFRICA, SS.KOREA, SS.HKMC, SS.US], KC = function(e2, t2) {
      let i3 = [];
      if (e2.includes(SS.GLOBAL)) {
        const o2 = [SS.GLOBAL, SS.OVERSEA], s2 = Object.keys(CS);
        if (t2 === SS.GLOBAL)
          throw new SE(fE.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
        if (t2 === SS.CHINA)
          i3 = [SS.OVERSEA];
        else if (r2 = t2, WC.includes(r2)) {
          const e3 = (n2 = t2, GC[SS.GLOBAL][n2] || []), r3 = [...o2, t2, ...e3];
          i3 = s2.filter((e4) => !r3.includes(e4));
        } else if (function(e3) {
          let t3 = false;
          return WC.forEach((i4) => {
            GC[SS.GLOBAL][i4].includes(e3) && (t3 = true);
          }), t3;
        }(t2)) {
          const e3 = function(e4) {
            let t3;
            return WC.forEach((i4) => {
              GC[SS.GLOBAL][i4].includes(e4) && (t3 = i4);
            }), t3;
          }(t2), n3 = [...o2, e3, t2];
          i3 = s2.filter((e4) => !n3.includes(e4));
        } else
          i3 = e2;
        i3 = function(e3) {
          const t3 = [];
          return HC.forEach((i4) => {
            e3.includes(i4) && t3.push(i4);
          }), t3.concat(e3.filter((e4) => !HC.includes(e4)));
        }(i3);
      } else
        i3 = e2;
      var n2, r2;
      return i3;
    };
    function YC(e2) {
      if (!e2 && GE("AREAS").includes(SS.EXTENSIONS))
        return OE.debug("update area from ap : reset"), void qC(DE, true);
      if (!GE("AREAS").includes(SS.GLOBAL) || !e2)
        return;
      let t2 = CS.EXTENSIONS;
      t2 && (t2 = { CODE: FC(SS.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(e2, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(e2, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(e2, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(e2, ".agora.io"), "cds-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(e2, ".agora.io"), "sua-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(e2, ".agora.io"), "uap-ap-web-2-".concat(e2, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(e2, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(e2, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(e2, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(e2, ".agora.io")] }, OE.debug("update area from ap success: ".concat(e2, ",config is "), t2), BE("AREAS", [SS.EXTENSIONS], true), Object.keys(t2).map((e3) => {
        if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
          BE(e3, t2[e3][0]);
        } else
          BE(e3, t2[e3]);
      }));
    }
    function qC(e2) {
      let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const i3 = Pg.reportApiInvoke(null, { name: _f.SET_AREA, options: e2, tag: Ef.TRACER });
      try {
        let n2 = [];
        if ("string" == typeof e2 && (n2 = [e2]), Array.isArray(e2) && (e2.forEach((e3) => {
          if (!RS.includes(e3))
            throw new SE(fE.INVALID_PARAMS, "invalid area code");
        }), n2 = e2), "[object Object]" === Object.prototype.toString.call(e2)) {
          const { areaCode: t3, excludedArea: i4 } = e2;
          if (!t3)
            throw new SE(fE.INVALID_PARAMS, "area code is needed");
          let r3 = t3;
          "string" == typeof t3 && (r3 = [t3]), n2 = i4 ? KC(r3, i4) : r3;
        }
        if (!t2) {
          if (HE.AREAS) {
            const e3 = new SE(fE.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
            return i3.onError(e3), void OE.warning("setArea is prohibited because of config-distribute");
          }
          if (n2.includes(SS.GLOBAL) && GE("AREAS") === SS.EXTENSIONS) {
            const e3 = new SE(fE.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
            return i3.onError(e3), void OE.warning("setArea is prohibited because of ap extensions");
          }
        }
        BE("AREAS", n2, t2);
        const r2 = BC(n2);
        Object.keys(r2).map((e3) => {
          if ("LOG_UPLOAD_SERVER" === e3 || "EVENT_REPORT_DOMAIN" === e3 || "EVENT_REPORT_BACKUP_DOMAIN" === e3 || "PROXY_SERVER_TYPE3" === e3) {
            BE(e3, r2[e3][0]);
          } else
            BE(e3, r2[e3]);
        }), OE.debug("set area success:", n2.join(","));
      } catch (e3) {
        throw i3.onError(e3), e3;
      }
      i3.onSuccess();
    }
    function JC(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function XC(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? JC(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : JC(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let zC = 1;
    function QC(e2, t2, i3, n2, r2) {
      zC += 1;
      const o2 = { sid: i3.sid, command: "convergeAllocateEdge", uid: "666", appId: i3.appId, ts: Math.floor(Date.now() / 1e3), seq: zC, requestId: zC, version: bE, cname: i3.cname }, s2 = { service_name: t2, json_body: JSON.stringify(o2) };
      let a2, c2, d2 = e2[0];
      return RE(async () => {
        a2 = Date.now();
        const e3 = await gg(d2, { data: s2, cancelToken: n2, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
        if (c2 = Date.now() - a2, 0 !== e3.code) {
          const t3 = new SE(fE.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e3.code, { retry: true, responseTime: c2 });
          throw OE.error(t3.toString()), t3;
        }
        const i4 = JSON.parse(e3.json_body);
        if (200 !== i4.code) {
          const e4 = new SE(fE.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(i4.code, ", reason: ").concat(i4.reason), { code: i4.code, responseTime: c2 });
          throw OE.error(e4.toString()), e4;
        }
        if (!i4.servers || 0 === i4.servers.length) {
          const e4 = new SE(fE.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: i4.code, responseTime: c2 });
          throw OE.error(e4.toString()), e4;
        }
        const r3 = function(e4, t3) {
          return { addressList: e4.servers.map((e5) => "wss://".concat(e5.address.replace(/\./g, "-"), ".").concat(GE("WORKER_DOMAIN"), ":").concat(e5.wss, "?serviceName=").concat(encodeURIComponent(t3))), workerToken: e4.workerToken, vid: e4.vid };
        }(i4, t2);
        return GE("LIVE_STREAMING_ADDRESS") && (r3.addressList = GE("LIVE_STREAMING_ADDRESS") instanceof Array ? GE("LIVE_STREAMING_ADDRESS") : [GE("LIVE_STREAMING_ADDRESS")]), XC(XC({}, r3), {}, { responseTime: c2 });
      }, (n3, r3) => (Pg.apworkerEvent(i3.sid, { success: true, sc: 200, serviceName: t2, responseDetail: JSON.stringify(n3.addressList), firstSuccess: 0 === r3, responseTime: c2, serverIp: e2[r3 % e2.length] }), false), (n3, r3) => (Pg.apworkerEvent(i3.sid, { success: false, sc: n3.data && n3.data.code || 200, serviceName: t2, responseTime: c2, serverIp: e2[r3 % e2.length] }), !!(n3.code !== fE.OPERATION_ABORTED && n3.code !== fE.UNEXPECTED_RESPONSE || n3.data && n3.data.retry) && (d2 = e2[(r3 + 1) % e2.length], true)), r2);
    }
    let ZC = 1;
    function $C(e2, t2, i3, n2) {
      let { url: r2, areaCode: o2 } = e2;
      const s2 = Date.now();
      let a2;
      const [c2, d2] = rv(t2, o2, [XS.CHOOSE_SERVER]);
      let u2 = Ig.networkState;
      return RE(async () => {
        u2 && Ig.networkState === PS.OFFLINE && Ig.onlineWaiter && await Sl.race([Ig.onlineWaiter, zI(n2 && n2.maxRetryTimeout || TE.maxRetryTimeout)]), u2 = Ig.networkState;
        const { data: e3, headers: o3 } = await gg(r2, { data: c2, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
        a2 = "1" === o3.http3 ? 1 : -1, Pg.reportResourceTiming(r2, t2.sid), tv(e3, r2, t2, s2, [XS.CHOOSE_SERVER], a2);
        const d3 = WI(e3, XS.CHOOSE_SERVER);
        return iv(d3), jI(d3, r2);
      }, (e3) => (e3 && Pg.joinChooseServer(t2.sid, { lts: s2, succ: true, csAddr: r2, opid: d2, serverList: e3.gatewayAddrs.map((e4) => e4.address), ec: null, cid: e3.cid.toString(), uid: e3.uid.toString(), csIp: e3.csIp, unilbsServerIds: [XS.CHOOSE_SERVER].toString(), isHttp3: a2 }), false), (e3) => e3.code !== fE.OPERATION_ABORTED && (e3.code === fE.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (Pg.joinChooseServer(t2.sid, { lts: s2, succ: false, csAddr: r2, serverList: null, opid: d2, ec: e3.code, csIp: e3.data && e3.data.csIp, unilbsServerIds: [XS.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: u2 }), isHttp3: a2 }), OE.warning("[".concat(t2.clientId, "] Choose server network error, retry"), e3), true)), n2);
    }
    function ev(e2, t2, i3, n2) {
      let r2, { url: o2, areaCode: s2, serviceIds: a2 } = e2;
      const c2 = Date.now(), [d2, u2] = rv(t2, s2, a2);
      let l2 = void 0;
      return RE(async () => {
        l2 && Ig.networkState === PS.OFFLINE && Ig.onlineWaiter && await Sl.race([Ig.onlineWaiter, zI(n2 && n2.maxRetryTimeout || TE.maxRetryTimeout)]), l2 = Ig.networkState;
        const { data: e3, headers: s3 } = await gg(o2, { data: d2, cancelToken: i3, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
        r2 = "1" === s3.http3 ? 1 : -1, Pg.reportResourceTiming(o2, t2.sid), tv(e3, o2, t2, c2, a2, r2);
        const u3 = WI(e3, XS.CHOOSE_SERVER), h3 = WI(e3, "proxy5" === t2.cloudProxyServer ? XS.CLOUD_PROXY_5 : "proxy3" === t2.cloudProxyServer || "proxy4" === t2.cloudProxyServer ? XS.CLOUD_PROXY : XS.CLOUD_PROXY_FALLBACK);
        return iv(u3), { gatewayInfo: jI(u3, o2), proxyInfo: h3, url: o2 };
      }, (e3) => (e3.gatewayInfo && Pg.joinChooseServer(t2.sid, { lts: c2, succ: true, csAddr: o2, serverList: e3.gatewayInfo.gatewayAddrs.map((e4) => e4.address), ec: null, opid: u2, cid: e3.gatewayInfo.cid.toString(), uid: e3.gatewayInfo.uid.toString(), csIp: e3.gatewayInfo.csIp, unilbsServerIds: a2.toString(), isHttp3: r2 }), e3.proxyInfo && Pg.joinWebProxyAP(t2.sid, { lts: c2, sucess: 1, apServerAddr: o2, turnServerAddrList: e3.proxyInfo.addresses.map((e4) => e4.ip).join(","), errorCode: null, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString() }), false), (e3) => e3.code !== fE.OPERATION_ABORTED && (e3.code === fE.CAN_NOT_GET_GATEWAY_SERVER ? e3.data.retry : (Pg.joinWebProxyAP(t2.sid, { lts: c2, sucess: 0, apServerAddr: o2, turnServerAddrList: null, errorCode: e3.code, eventType: t2.cloudProxyServer, unilbsServerIds: a2.toString(), extend: JSON.stringify({ networkState: l2 }) }), OE.warning("[".concat(t2.clientId, "] multi unilbs network error, retry"), e3), true)), n2);
    }
    const tv = (e2, t2, i3, n2, r2, o2) => {
      const s2 = [], a2 = (s3) => {
        4096 === s3.flag ? Pg.joinChooseServer(i3.sid, { lts: n2, succ: false, csAddr: t2, opid: e2.opid, serverList: null, ec: s3.error.message, csIp: s3.error.data && s3.error.data.csIp, unilbsServerIds: r2.toString(), isHttp3: o2 }) : 1048576 !== s3.flag && 4194304 !== s3.flag && 4194310 !== s3.flag || Pg.joinWebProxyAP(i3.sid, { lts: n2, sucess: 0, apServerAddr: t2, turnServerAddrList: null, errorCode: s3.error.code, eventType: i3.cloudProxyServer, unilbsServerIds: r2.toString() });
      };
      if (e2.response_body.forEach((t3) => {
        const i4 = t3.buffer.code;
        if (23 === t3.uri && 0 === i4 && !t3.buffer.edges_services)
          if (4194310 === t3.buffer.flag)
            OE.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t3.buffer.edges_services = [];
          else {
            const i5 = { error: new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: e2.detail[502] }), flag: t3.buffer.flag };
            s2.push(i5), a2(i5);
          }
        if (0 !== i4) {
          const n3 = gC(i4), r3 = { error: new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, n3.desc, { desc: n3.desc, retry: n3.retry, csIp: e2.detail[502] }), flag: t3.buffer.flag };
          4194310 === t3.buffer.flag ? OE.warning(r3.error.toString()) : s2.push(r3), a2(r3);
        }
      }), s2.length)
        throw OE.warning("[".concat(i3.clientId, "] multi unilbs ").concat(t2, " failed, ").concat(s2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message, ", retry: ").concat(e3.error.data.retry)).join(" | "))), new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, s2.map((e3) => "flag: ".concat(e3.flag, ", message: ").concat(e3.error.message)).join(" | "), { retry: !!s2.find((e3) => e3.error.data.retry), csIp: e2.detail[502], desc: [...new Set(s2.map((e3) => {
          var t3, i4;
          return null == e3 || null === (t3 = e3.error) || void 0 === t3 || null === (i4 = t3.data) || void 0 === i4 ? void 0 : i4.desc;
        }).filter((e3) => !!e3))] });
    }, iv = (e2) => {
      var t2, i3, n2, r2;
      if (e2.addresses && 0 === e2.addresses.length && 0 === e2.code)
        throw new SE(fE.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: e2.detail && e2.detail[502] });
      GE("AP_AREA") && (null !== (n2 = e2.detail) && void 0 !== n2 && n2[23] && "string" == typeof (null === (r2 = e2.detail) || void 0 === r2 ? void 0 : r2[23]) ? YC(e2.detail[23].toLowerCase()) : YC());
      if (null !== (t2 = e2.detail) && void 0 !== t2 && t2[19] && "string" == typeof (null === (i3 = e2.detail) || void 0 === i3 ? void 0 : i3[19])) {
        const t3 = e2.detail[19], i4 = null == t3 ? void 0 : t3.split(";");
        for (let t4 = 0; t4 < i4.length; t4++) {
          var o2;
          const n3 = mh(o2 = i4[t4]).call(o2);
          e2.addresses[t4] && i4 && (e2.addresses[t4].fingerprint = n3);
        }
      }
      if (GE("GATEWAY_ADDRESS") && GE("GATEWAY_ADDRESS").length > 0) {
        OE.debug("assign gateway address to", GE("GATEWAY_ADDRESS"));
        const t3 = GE("GATEWAY_ADDRESS").map((t4) => {
          var i4, n3;
          const r3 = null !== (i4 = null === (n3 = e2.addresses.find((e3) => e3.ip === t4.ip && e3.port === t4.port)) || void 0 === n3 ? void 0 : n3.fingerprint) && void 0 !== i4 ? i4 : "";
          return { ip: t4.ip, port: t4.port, ticket: e2.addresses[0] && e2.addresses[0].ticket, fingerprint: r3 };
        });
        e2.addresses = t3;
      }
    }, nv = (e2, t2) => {
      if (e2.response_body && e2.response_body.length) {
        const t3 = e2.response_body[0];
        if (0 !== t3.buffer.code) {
          const e3 = gC(t3.buffer.code);
          throw new SE(fE.UPDATE_TICKET_FAILED, "[".concat(t3.buffer.code, "]: ").concat(e3.desc), { retry: e3.retry });
        }
        return t3.buffer.ticket;
      }
      throw OE.debug("update ticket request received ap response without response body:", t2), new SE(fE.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
    }, rv = (e2, t2, i3) => {
      const n2 = Math.floor(Math.random() * 10 ** 12), r2 = { appid: e2.appId, client_ts: Date.now(), opid: n2, sid: e2.sid, request_bodies: [{ uri: 22, buffer: { cname: e2.cname, detail: { 6: e2.stringUid, 11: t2, 12: GE("USE_NEW_TOKEN") ? "1" : void 0, 22: t2 }, key: e2.token, service_ids: i3, uid: e2.uid || 0 } }] };
      r2.request_bodies.forEach((t3) => {
        e2.multiIP && e2.multiIP.gateway_ip && (t3.buffer.detail[5] = JSON.stringify({ vocs_ip: [e2.multiIP.uni_lbs_ip], vos_ip: [e2.multiIP.gateway_ip] }));
      });
      const o2 = new FormData();
      return o2.append("request", JSON.stringify(r2)), [o2, n2];
    }, ov = (e2, t2) => {
      const i3 = Math.floor(Math.random() * 10 ** 12), n2 = { appid: e2.appId, client_ts: Date.now(), opid: i3, sid: e2.sid, request_bodies: [{ uri: 28, buffer: { cname: e2.cname, detail: { 1: "", 6: e2.stringUid, 12: "1" }, token: e2.token, service_ids: t2, uid: e2.uid || 0, edges_services: e2.apResponse.addresses.map((e3) => ({ ip: e3.ip, port: e3.port })) } }] }, r2 = new FormData();
      return r2.append("request", JSON.stringify(n2)), [r2, i3];
    };
    let sv = 0;
    async function av(e2, t2, i3, n2) {
      const r2 = async function(e3, t3, i4, n3) {
        let r3 = null;
        const o2 = [], s2 = async () => {
          const r4 = GE("WEBCS_DOMAIN").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: jC() })), s3 = n3.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r4.map((e4) => e4.url) }), a3 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: r4, asyncMapHandler: (n4) => (OE.debug("[".concat(e3.clientId, "] Connect to choose_server:"), n4.url), $C(n4, e3, t3, i4)), allFailedhandler: (e4) => {
            throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, s3), e4[0];
          }, promisesCollector: o2 });
          return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), a3;
        }, a2 = async () => {
          if (await zI(1e3), null !== r3)
            return r3;
          const s3 = GE("WEBCS_DOMAIN_BACKUP_LIST").map((t4) => ({ url: e3.proxyServer ? "https://".concat(e3.proxyServer, "/ap/?url=").concat(t4 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t4, "/api/v2/transpond/webrtc?v=2"), areaCode: jC() })), a3 = n3.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: s3.map((e4) => e4.url) }), c2 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: s3, asyncMapHandler: (n4) => (OE.debug("[".concat(e3.clientId, "] Connect to backup choose_server:"), n4.url), $C(n4, e3, t3, i4)), allFailedhandler: (e4) => {
            throw n3.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e4 }, a3), e4[0];
          }, promisesCollector: o2 });
          return n3.recordJoinChannelService({ endTs: Date.now(), status: "success" }, a3), c2;
        };
        try {
          return r3 = await iC([s2(), a2()]), o2.length && o2.forEach((e4) => e4.cancel && "function" == typeof e4.cancel && e4.cancel()), r3;
        } catch (e4) {
          throw e4[0];
        }
      }(e2, t2, i3, n2);
      return { gatewayInfo: await r2 };
    }
    async function cv(e2, t2, i3, n2, r2) {
      const o2 = e2.cloudProxyServer;
      if ("disabled" === o2) {
        if (!n2)
          return;
        if (e2.useLocalAccessPoint)
          return await av(e2, t2, i3, r2);
        if (GE("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
          const { gatewayInfo: n3, proxyInfo: o3 } = await lv(e2, t2, i3, r2);
          return e2.turnServer && "auto" !== e2.turnServer.mode || (e2.turnServer = { mode: "manual", servers: o3.map((e3) => ({ turnServerURL: e3.address, tcpport: e3.tcpport || PE.tcpport, udpport: e3.udpport || PE.udpport, username: e3.username || PE.username, password: e3.password || PE.password, forceturn: false, security: true })) }), { gatewayInfo: n3 };
        }
        return await av(e2, t2, i3, r2);
      }
      const { proxyInfo: s2, gatewayInfo: a2 } = await lv(e2, t2, i3, r2), c2 = { gatewayInfo: a2 };
      return e2.turnServer = { mode: "manual", servers: s2.map((e3) => ({ turnServerURL: e3.address, tcpport: "proxy3" === o2 ? void 0 : e3.tcpport ? e3.tcpport : PE.tcpport, udpport: "proxy4" === o2 ? void 0 : e3.udpport ? e3.udpport : PE.udpport, username: e3.username || PE.username, password: e3.password || PE.password, forceturn: "proxy4" !== o2, security: "proxy5" === o2 })) }, OE.debug("[".concat(e2.clientId, "] set proxy server: ").concat(e2.proxyServer, ", mode: ").concat(o2)), c2;
    }
    async function dv(e2, t2, i3, n2, r2) {
      const o2 = GE("ACCOUNT_REGISTER").slice(0, GE("AJAX_REQUEST_CONCURRENT"));
      let s2 = [];
      s2 = t2.proxyServer ? o2.map((e3) => "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1")) : o2.map((e3) => "https://".concat(e3, "/api/v1"));
      const a2 = null == r2 ? void 0 : r2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s2 });
      try {
        const o3 = await async function(e3, t3, i4, n3, r3) {
          const o4 = Date.now(), s3 = { sid: i4.sid, opid: 10, appid: i4.appId, string_uid: t3 };
          let a3 = e3[0];
          const c2 = await RE(() => gg(a3 + "".concat(-1 === a3.indexOf("?") ? "?" : "&", "action=stringuid"), { data: s3, cancelToken: n3, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (i5, n4) => {
            if (0 === i5.code) {
              if (i5.uid <= 0 || i5.uid >= Math.pow(2, 32))
                throw OE.error("Invalid Uint Uid ".concat(t3, " => ").concat(i5.uid), i5), Pg.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i5.uid, errorCode: fE.INVALID_UINT_UID_FROM_STRING_UID, extend: s3 }), new SE(fE.INVALID_UINT_UID_FROM_STRING_UID);
              return Pg.reqUserAccount(s3.sid, { lts: o4, success: true, serverAddr: a3, stringUid: s3.string_uid, uid: i5.uid, errorCode: null, extend: s3 }), false;
            }
            const r4 = gC(i5.code);
            return r4.retry && (a3 = e3[(n4 + 1) % e3.length]), Pg.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: i5.uid, errorCode: r4.desc, extend: s3 }), r4.retry;
          }, (t4, i5) => t4.code !== fE.OPERATION_ABORTED && (Pg.reqUserAccount(s3.sid, { lts: o4, success: false, serverAddr: a3, stringUid: s3.string_uid, uid: null, errorCode: t4.code, extend: s3 }), a3 = e3[(i5 + 1) % e3.length], true), r3);
          if (0 !== c2.code) {
            const e4 = gC(c2.code);
            throw new SE(fE.UNEXPECTED_RESPONSE, e4.desc);
          }
          return c2;
        }(s2, e2, t2, i3, n2);
        return null == r2 || r2.recordJoinChannelService({ status: "success", endTs: Date.now() }, a2), o3.uid;
      } catch (e3) {
        throw null == r2 || r2.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [e3] }, a2), e3;
      }
    }
    async function uv(e2, t2, i3) {
      const n2 = GE("CDS_AP").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1") : "https://".concat(t3, "/api/v1?action=config")).map((n3) => function(e3, t3, i4, n4) {
        const r3 = xh(), o3 = { flag: 64, cipher_method: 0, features: { device: r3.name, system: r3.os, system_general: navigator.userAgent, vendor: t3.appId, version: bE, cname: t3.cname, sid: t3.sid, session_id: t3.sid, detail: "", proxyServer: t3.proxyServer } };
        return RE(() => gg(e3, { data: o3, timeout: 1e3, cancelToken: i4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (e4) => e4.code !== fE.OPERATION_ABORTED, n4);
      }(n3, e2, t2, i3));
      let r2 = null, o2 = null, s2 = {};
      try {
        r2 = await iC(n2);
      } catch (e3) {
        if (e3.code === fE.OPERATION_ABORTED)
          throw e3;
        o2 = e3;
      }
      n2.forEach((e3) => e3.cancel());
      if (Pg.reportApiInvoke(e2.sid, { name: _f.REQUEST_CONFIG_DISTRIBUTE, options: { error: o2, res: r2 } }).onSuccess(), r2 && r2.test_tags)
        try {
          s2 = function(e3) {
            if (!e3.test_tags)
              return {};
            const t3 = e3.test_tags, i4 = Object.keys(t3), n3 = {};
            return i4.forEach((e4) => {
              var i5;
              const r3 = mh(i5 = e4.slice(4)).call(i5), o3 = JSON.parse(t3[e4])[1];
              n3[r3] = o3;
            }), n3;
          }(r2);
        } catch (e3) {
        }
      return s2;
    }
    async function lv(e2, t2, i3, n2) {
      const r2 = GE("PROXY_SERVER_TYPE3"), o2 = (e3, t3, i4) => {
        let n3 = i4 || r2;
        return Array.isArray(n3) && (n3 = t3 % 2 == 0 ? r2[1] : r2[0]), "https://".concat(n3, "/ap/?url=").concat(e3);
      };
      let s2 = null;
      const a2 = [], c2 = async () => {
        const r3 = GE("WEBCS_DOMAIN").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t3, i4) => {
          let n3;
          return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4), { url: n3, areaCode: jC(), serviceIds: [XS.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? XS.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? XS.CLOUD_PROXY : XS.CLOUD_PROXY_FALLBACK] };
        }), s3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), c3 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (OE.debug("[".concat(e2.clientId, "] Connect to choose_server:"), n3.url), ev(n3, e2, t2, i3)), allFailedhandler: (e3) => {
          throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, s3), e3[0];
        }, promisesCollector: a2 });
        return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, s3), c3;
      }, d2 = async () => {
        if (await zI(1e3), null !== s2)
          return s2;
        const r3 = GE("WEBCS_DOMAIN_BACKUP_LIST").map((t3, i4) => {
          let n3;
          return n3 = "disabled" === e2.cloudProxyServer && e2.proxyServer ? o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4, e2.proxyServer) : "disabled" === e2.cloudProxyServer || "fallback" === e2.cloudProxyServer ? "https://".concat(t3, "/api/v2/transpond/webrtc?v=2") : o2("".concat(t3, "/api/v2/transpond/webrtc?v=2"), i4), { url: n3, areaCode: jC(), serviceIds: [XS.CHOOSE_SERVER, "proxy5" === e2.cloudProxyServer ? XS.CLOUD_PROXY_5 : "proxy3" === e2.cloudProxyServer || "proxy4" === e2.cloudProxyServer ? XS.CLOUD_PROXY : XS.CLOUD_PROXY_FALLBACK] };
        }), c3 = n2.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: r3.map((e3) => e3.url) }), d3 = await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: r3, asyncMapHandler: (n3) => (OE.debug("[".concat(e2.clientId, "] Connect to backup choose_server:"), n3.url), ev(n3, e2, t2, i3)), allFailedhandler: (e3) => {
          throw n2.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: e3 }, c3), e3[0];
        }, promisesCollector: a2 });
        return n2.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c3), d3;
      };
      let u2, l2, h3;
      try {
        ({ gatewayInfo: u2, proxyInfo: l2, url: h3 } = await iC([c2(), d2()]));
      } catch (e3) {
        throw e3[0];
      }
      if (a2.length && a2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), !u2 || !l2)
        throw new SE(fE.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
      if (e2.apUrl = h3, "disabled" !== e2.cloudProxyServer && Array.isArray(r2) && h3) {
        const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(h3)[1];
        r2.includes(t3) && (e2.proxyServer = t3, OE.setProxyServer(t3), Pg.setProxyServer(t3));
      }
      return s2 = { gatewayInfo: u2, proxyInfo: await HI(l2, u2.uid) }, s2;
    }
    async function hv(e2, t2, i3, n2) {
      const r2 = GE("UAP_AP").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((e3) => t2.proxyServer ? "https://".concat(t2.proxyServer, "/ap/?url=").concat(e3 + "/api/v1?action=uap") : "https://".concat(e3, "/api/v1?action=uap"));
      return await QC(r2, e2, t2, i3, n2);
    }
    async function pv(e2, t2, i3) {
      const n2 = GE("UAP_AP").slice(0, GE("AJAX_REQUEST_CONCURRENT")).map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v1?action=uap") : "https://".concat(t3, "/api/v1?action=uap")).map((n3) => function(e3, t3, i4, n4) {
        const r2 = { command: "convergeAllocateEdge", sid: t3.sid, appId: t3.appId, token: t3.token, ts: Date.now(), version: bE, cname: t3.cname, uid: t3.uid.toString(), requestId: ZC, seq: ZC };
        ZC += 1;
        const o2 = { service_name: "tele_channel", json_body: JSON.stringify(r2) };
        return RE(async () => {
          const t4 = await gg(e3, { data: o2, cancelToken: i4, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
          if (0 !== t4.code) {
            const e4 = new SE(fE.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t4.code, { retry: true });
            throw OE.error(e4.toString()), e4;
          }
          const n5 = JSON.parse(t4.json_body);
          if (200 !== n5.code) {
            const e4 = new SE(fE.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n5.code, ", reason: ").concat(n5.reason));
            throw OE.error(e4.toString()), e4;
          }
          if (!n5.servers || 0 === n5.servers.length) {
            const e4 = new SE(fE.UNEXPECTED_RESPONSE, "cross channel app center empty server");
            throw OE.error(e4.toString()), e4;
          }
          return { vid: n5.vid, workerToken: n5.workerToken, addressList: (GE("CHANNEL_MEDIA_RELAY_SERVERS") || n5.servers).map((e4) => "wss://".concat(e4.address.replace(/\./g, "-"), ".").concat(GE("WORKER_DOMAIN"), ":").concat(e4.wss)) };
        }, void 0, (e4) => !!(e4.code !== fE.OPERATION_ABORTED && e4.code !== fE.UNEXPECTED_RESPONSE || e4.data && e4.data.retry), n4);
      }(n3, e2, t2, i3));
      try {
        const e3 = await iC(n2);
        return n2.forEach((e4) => e4.cancel()), e3;
      } catch (e3) {
        throw e3[0];
      }
    }
    async function _v(e2, t2, i3) {
      let n2 = null;
      const r2 = [], o2 = async (o3) => {
        const s2 = GE(o3 ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((t3) => e2.proxyServer ? "https://".concat(e2.proxyServer, "/ap/?url=").concat(t3 + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t3, "/api/v2/transpond/webrtc?v=2"));
        return o3 && (await zI(1e3), null !== n2) ? n2 : await fC({ fragementLength: GE("FRAGEMENT_LENGTH"), referenceList: s2, asyncMapHandler: (n3) => (OE.debug("[".concat(e2.clientId, "] update ticket, Connect to ").concat(o3 ? "backup" : "", " choose_server:"), n3), function(e3, t3, i4, n4) {
          const [r3] = ov(t3, [XS.CHOOSE_SERVER]);
          let o4 = Ig.networkState;
          return RE(async () => {
            o4 && Ig.networkState === PS.OFFLINE && Ig.onlineWaiter && await Sl.race([Ig.onlineWaiter, zI(n4 && n4.maxRetryTimeout || TE.maxRetryTimeout)]), o4 = Ig.networkState;
            const t4 = await gg(e3, { data: r3, cancelToken: i4, headers: { "Content-Type": "multipart/form-data;" } }, true);
            return nv(t4, e3);
          }, () => false, (e4) => e4.code !== fE.OPERATION_ABORTED && (e4.code === fE.UPDATE_TICKET_FAILED ? e4.data.retry : (OE.warning("[".concat(t3.clientId, "] update ticket network error, retry"), e4), true)), n4);
        }(n3, e2, t2, i3)), allFailedhandler: (e3) => {
          throw e3[0];
        }, promisesCollector: r2 });
      };
      try {
        return n2 = await iC([o2(false), o2(true)]), r2.length && r2.forEach((e3) => e3.cancel && "function" == typeof e3.cancel && e3.cancel()), n2;
      } catch (e3) {
        throw e3[0];
      }
    }
    function Ev(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function mv(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? Ev(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Ev(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class fv extends EE {
      constructor() {
        super(), _p(this, "configs", void 0), _p(this, "joinInfo", void 0), _p(this, "cancelToken", void 0), _p(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), _p(this, "interval", void 0), _p(this, "mutex", new Ug("config-distribute")), _p(this, "mutableParamsRead", false);
      }
      startGetConfigDistribute(e2, t2) {
        this.joinInfo = e2, this.cancelToken = t2, this.interval && this.stopGetConfigDistribute(), GE("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
          this.updateConfigDistribute();
        }, GE("CONFIG_DISTRIBUTE_INTERVAL")));
      }
      stopGetConfigDistribute() {
        this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
      }
      async awaitConfigDistributeComplete() {
        if (!this.mutex.isLocked)
          return;
        (await this.mutex.lock())();
      }
      async updateConfigDistribute() {
        if (!this.mutableParamsRead) {
          this.mutableParamsRead = true;
          Pg.reportApiInvoke(null, { options: void 0, name: _f.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: Ef.TRACER }).onSuccess(JSON.stringify(HE));
        }
        if (!this.joinInfo || !this.cancelToken || !this.retryConfig)
          return void OE.debug("[config-distribute] get config distribute interrupted have no joininfo");
        let e2;
        const t2 = await this.mutex.lock();
        try {
          e2 = await uv(this.joinInfo, this.cancelToken, this.retryConfig), OE.debug("[config-distribute] get config distribute", JSON.stringify(e2)), e2.limit_bitrate && this.handleBitrateLimit(e2.limit_bitrate), this.cacheGlobalParameterConfig(e2), this.configs = e2;
        } catch (e3) {
          const t3 = new SE(fE.NETWORK_RESPONSE_ERROR, e3);
          OE.warning("[config-distribute] ".concat(t3.toString()));
        } finally {
          t2();
        }
      }
      getBitrateLimit() {
        return this.configs ? this.configs.limit_bitrate : void 0;
      }
      handleBitrateLimit(e2) {
        var t2;
        (t2 = e2) && t2.uplink && t2.id && void 0 !== t2.uplink.max_bitrate && void 0 !== t2.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e2.id && this.emit(vS.UPDATE_BITRATE_LIMIT, e2) : this.emit(vS.UPDATE_BITRATE_LIMIT, e2));
      }
      getLowStreamConfigDistribute() {
        return this.configs && this.configs.limit_bitrate && mv({}, this.configs.limit_bitrate.low_stream_uplink);
      }
      cacheGlobalParameterConfig(e2) {
        var t2;
        const i3 = Hm(t2 = Object.keys(e2).filter((e3) => /^webrtc_ng_global_parameter/.test(e3))).call(t2);
        for (let t3 = 0; t3 < i3.length; t3++)
          for (let n3 = i3.length - 1; n3 > t3; n3--) {
            const t4 = i3[n3];
            if ("number" == typeof e2[t4].__priority) {
              const r2 = e2[t4].__priority, o2 = i3[n3 - 1];
              if ("number" == typeof e2[o2].__priority) {
                if (!(r2 > e2[o2].__priority))
                  continue;
                {
                  const e3 = t4;
                  i3[n3] = i3[n3 - 1], i3[n3 - 1] = e3;
                }
              } else {
                const e3 = t4;
                i3[n3] = i3[n3 - 1], i3[n3 - 1] = e3;
              }
            }
          }
        const n2 = {};
        i3.forEach((t3) => {
          const i4 = e2[t3], r2 = i4.__expires;
          Object.keys(i4).forEach((e3) => {
            "__priority" === e3 || "__expires" === e3 || Object.prototype.hasOwnProperty.call(n2, e3) || (n2[e3] = mv({ value: i4[e3] }, r2 && { expires: r2 }));
          });
        });
        try {
          const e3 = JSON.stringify(n2), t3 = window.btoa(e3);
          window.localStorage.setItem("websdk_ng_global_parameter", t3), OE.debug("Caching global parameters ".concat(e3));
        } catch (e3) {
          OE.error("Error caching global parameters:", e3.message);
        }
      }
    }
    function Sv(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function Tv(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? Sv(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Sv(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class gv extends EE {
      constructor(e2, t2, i3, n2) {
        super(), _p(this, "spec", void 0), _p(this, "token", void 0), _p(this, "websocket", void 0), _p(this, "pingpongTimer", void 0), _p(this, "reconnectMode", "retry"), _p(this, "serviceMode", void 0), _p(this, "reqId", 0), _p(this, "commandReqId", 0), _p(this, "handleWebSocketOpen", () => {
          this.reconnectMode = "retry", this.startPingPong();
        }), _p(this, "handleWebSocketMessage", (e3) => {
          if (!e3.data)
            return;
          const t3 = JSON.parse(e3.data);
          t3.requestId ? this.emit("@".concat(t3.requestId, "-").concat(t3.sid), t3) : this.serviceMode === Kf.INJECT ? this.emit(Zf.INJECT_STREAM_STATUS, t3) : (Pg.workerEvent(this.spec.sid, { actionType: "status", serverCode: t3.code, workerType: this.serviceMode === Kf.TRANSCODE ? 1 : 2 }), this.emit(Zf.PUBLISH_STREAM_STATUS, t3));
        }), this.spec = t2, this.token = e2, this.serviceMode = n2, this.websocket = new vC("live-streaming", i3), this.websocket.on(Hf.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Hf.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Hf.REQUEST_NEW_URLS, (e3, t3) => {
          nC(this, Zf.REQUEST_NEW_ADDRESS).then(e3).catch(t3);
        }), this.websocket.on(Hf.RECONNECTING, () => {
          this.websocket.reconnectMode = this.reconnectMode;
        });
      }
      init(e2) {
        return this.websocket.init(e2);
      }
      async request(e2, t2, i3, n2) {
        this.reqId += 1, "request" === e2 && (this.commandReqId += 1);
        const r2 = this.commandReqId, o2 = this.reqId;
        if (!o2 || !this.websocket)
          throw new SE(fE.UNEXPECTED_ERROR);
        const s2 = Tv({ command: e2, sdkVersion: "4.18.3" === bE ? "0.0.1" : bE, seq: o2, requestId: o2, allocate: i3, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, t2);
        if ("closed" === this.websocket.state)
          throw new SE(fE.WS_DISCONNECT);
        const a2 = () => new Sl((e3, t3) => {
          this.websocket.once(Hf.CLOSED, () => t3(new SE(fE.WS_ABORT))), this.websocket.once(Hf.CONNECTED, e3);
        });
        "connected" !== this.websocket.state && await a2(), s2.clientRequest && (s2.clientRequest.workerToken = this.token);
        const c2 = new Sl((e3, t3) => {
          const i4 = () => {
            t3(new SE(fE.WS_ABORT));
          };
          this.websocket.once(Hf.RECONNECTING, i4), this.websocket.once(Hf.CLOSED, i4), this.once("@".concat(o2, "-").concat(this.spec.sid), (t4) => {
            e3(t4);
          });
        });
        n2 && Pg.workerEvent(this.spec.sid, Tv(Tv({}, n2), {}, { requestId: r2, actionType: "request", payload: JSON.stringify(t2.clientRequest), serverCode: 0, code: 0 }));
        const d2 = Date.now();
        this.websocket.sendMessage(s2);
        let u2 = null;
        try {
          u2 = await c2;
        } catch (n3) {
          if ("closed" === this.websocket.state)
            throw n3;
          return await a2(), await this.request(e2, t2, i3);
        }
        return n2 && Pg.workerEvent(this.spec.sid, Tv(Tv({}, n2), {}, { requestId: r2, actionType: "response", payload: JSON.stringify(u2.serverResponse), serverCode: u2.code, success: 200 === u2.code, responseTime: Date.now() - d2 })), 200 !== u2.code && this.handleResponseError(u2), u2;
      }
      tryNextAddress() {
        this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
      }
      close() {
        const e2 = "4.18.3" === bE ? "0.0.1" : bE;
        this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e2, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
      }
      handleResponseError(e2) {
        switch (e2.code) {
          case eS.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
            return void OE.warning("live stream response already exists stream");
          case eS.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
          case eS.LIVE_STREAM_RESPONSE_BAD_STREAM:
          case eS.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
            return new SE(fE.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e2.code }).throw();
          case eS.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
            if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
              return;
            throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
          case eS.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
            return new SE(fE.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e2.code }).throw();
          case eS.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
            const t2 = new SE(fE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
            return this.emit(Zf.WARNING, t2, e2.serverResponse.url);
          }
          case eS.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
            const t2 = new SE(fE.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
            return this.emit(Zf.WARNING, t2, e2.serverResponse.url);
          }
          case eS.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
            throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
          case eS.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
            return new SE(fE.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e2.code }).throw();
          case eS.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
            const t2 = new SE(fE.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
            return this.emit(Zf.WARNING, t2, e2.serverResponse.url);
          }
          case eS.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
            return new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code }).throw();
          case eS.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
            throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
          case eS.LIVE_STREAM_RESPONSE_WORKER_LOST:
          case eS.LIVE_STREAM_RESPONSE_WORKER_QUIT:
            if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
              return;
            throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
          case eS.ERROR_FAIL_SEND_MESSAGE:
            if ("UnpublishStream" === e2.serverResponse.command || "UninjectStream" === e2.serverResponse.command)
              return;
            if ("UpdateTranscoding" === e2.serverResponse.command || "ControlStream" === e2.serverResponse.command)
              return new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e2.code }).throw();
            throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
          case eS.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
          case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
          case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
          case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
            return new SE(fE.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code }).throw();
        }
      }
      startPingPong() {
        this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
          "connected" === this.websocket.state && this.request("ping", {}).catch(eC);
        }, 6e3);
      }
    }
    function Rv(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function Iv(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? Rv(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Rv(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class Cv extends EE {
      constructor(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : TE, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : TE;
        super(), _p(this, "onLiveStreamWarning", void 0), _p(this, "onLiveStreamError", void 0), _p(this, "onInjectStatusChange", void 0), _p(this, "spec", void 0), _p(this, "retryTimeout", 1e4), _p(this, "connection", void 0), _p(this, "httpRetryConfig", void 0), _p(this, "wsRetryConfig", void 0), _p(this, "streamingTasks", /* @__PURE__ */ new Map()), _p(this, "isStartingStreamingTask", false), _p(this, "taskMutex", new Ug("live-streaming")), _p(this, "cancelToken", pE.CancelToken.source()), _p(this, "transcodingConfig", void 0), _p(this, "injectConfig", Iv({}, Qf)), _p(this, "injectLoopTimes", 0), _p(this, "uapResponse", void 0), _p(this, "lastTaskId", 1), _p(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e2, this.httpRetryConfig = i3, this.wsRetryConfig = t2;
      }
      async setTranscodingConfig(e2) {
        const t2 = Iv(Iv({}, zf), e2);
        66 !== t2.videoCodecProfile && 77 !== t2.videoCodecProfile && 100 !== t2.videoCodecProfile && (OE.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t2.videoCodecProfile, " -> 100")), t2.videoCodecProfile = 100), t2.transcodingUsers || (t2.transcodingUsers = t2.userConfigs), t2.transcodingUsers && (t2.transcodingUsers = t2.transcodingUsers.map((e3) => Iv(Iv(Iv({}, qf), e3), {}, { zOrder: e3.zOrder ? e3.zOrder + 1 : 1 }))), function(e3) {
          $m(e3.width) || qm(e3.width, "config.width", 0, 1e4), $m(e3.height) || qm(e3.height, "config.height", 0, 1e4), $m(e3.videoBitrate) || qm(e3.videoBitrate, "config.videoBitrate", 1, 1e6), $m(e3.videoFrameRate) || qm(e3.videoFrameRate, "config.videoFrameRate"), $m(e3.lowLatency) || Km(e3.lowLatency, "config.lowLatency"), $m(e3.audioSampleRate) || Ym(e3.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), $m(e3.audioBitrate) || qm(e3.audioBitrate, "config.audioBitrate", 1, 128), $m(e3.audioChannels) || Ym(e3.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), $m(e3.videoGop) || qm(e3.videoGop, "config.videoGop"), $m(e3.videoCodecProfile) || Ym(e3.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), $m(e3.userCount) || qm(e3.userCount, "config.userCount", 0, 17), $m(e3.backgroundColor) || qm(e3.backgroundColor, "config.backgroundColor", 0, 16777215), $m(e3.userConfigExtraInfo) || Xm(e3.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), e3.transcodingUsers && !$m(e3.transcodingUsers) && (zm(e3.transcodingUsers, "config.transcodingUsers"), e3.transcodingUsers.forEach((e4, t3) => {
            Zm(e4.uid), $m(e4.x) || qm(e4.x, "transcodingUser[".concat(t3, "].x"), 0, 1e4), $m(e4.y) || qm(e4.y, "transcodingUser[".concat(t3, "].y"), 0, 1e4), $m(e4.width) || qm(e4.width, "transcodingUser[".concat(t3, "].width"), 0, 1e4), $m(e4.height) || qm(e4.height, "transcodingUser[".concat(t3, "].height"), 0, 1e4), $m(e4.zOrder) || qm(e4.zOrder - 1, "transcodingUser[".concat(t3, "].zOrder"), 0, 100), $m(e4.alpha) || qm(e4.alpha, "transcodingUser[".concat(t3, "].alpha"), 0, 1, false);
          })), $m(e3.watermark) || Xf(e3.watermark, "watermark"), $m(e3.backgroundImage) || Xf(e3.backgroundImage, "backgroundImage"), e3.images && !$m(e3.images) && (zm(e3.images, "config.images"), e3.images.forEach((e4, t3) => {
            Xf(e4, "images[".concat(t3, "]"));
          }));
        }(t2);
        const i3 = [];
        t2.images && i3.push(...t2.images.map((e3) => Iv(Iv(Iv({}, Jf), e3), {}, { zOrder: 255 }))), t2.backgroundImage && (i3.push(Iv(Iv(Iv({}, Jf), t2.backgroundImage), {}, { zOrder: 0 })), delete t2.backgroundImage), t2.watermark && (i3.push(Iv(Iv(Iv({}, Jf), t2.watermark), {}, { zOrder: 255 })), delete t2.watermark), t2.images = i3, t2.transcodingUsers && (t2.userConfigs = t2.transcodingUsers.map((e3) => Iv({}, e3)), t2.userCount = t2.transcodingUsers.length, delete t2.transcodingUsers);
        const n2 = (t2.userConfigs || []).map((e3) => "number" == typeof e3.uid ? Sl.resolve(e3.uid) : dv(e3.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
        if ((await Sl.all(n2)).forEach((e3, i4) => {
          t2.userConfigs && t2.userConfigs[i4] && (t2.userConfigs[i4].uid = e3);
        }), this.transcodingConfig = t2, this.connection)
          try {
            var r2;
            const e3 = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(IR(r2 = this.streamingTasks).call(r2)).map((e4) => e4.taskId).join("#") });
            OE.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(e3.code, ", config:"), JSON.stringify(this.transcodingConfig));
          } catch (e3) {
            if (!e3.data || !e3.data.retry)
              throw e3;
            e3.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((t3) => {
              OE.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e3.toString(), "try to republish", t3.url), this.startLiveStreamingTask(t3.url, t3.mode, e3).then(() => {
                OE.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t3.url, " success"));
              }).catch((e4) => {
                OE.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t3.url, e4.toString()), this.onLiveStreamError && this.onLiveStreamError(t3.url, e4);
              });
            });
          }
      }
      setInjectStreamConfig(e2, t2) {
        this.injectConfig = Object.assign({}, this.injectConfig, e2), this.injectLoopTimes = t2;
      }
      async startLiveStreamingTask(e2, t2, i3) {
        var n2;
        if (Array.from(IR(n2 = this.streamingTasks).call(n2)).find((e3) => e3.mode === Kf.INJECT) && t2 === Kf.INJECT)
          return new SE(fE.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
        if (!this.transcodingConfig && t2 === Kf.TRANSCODE)
          throw new SE(fE.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
        let r2 = { command: "PublishStream", ts: Date.now(), url: e2, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
        OE.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e2, ", mode: ").concat(t2));
        const o2 = await this.taskMutex.lock();
        if (!this.connection && i3)
          return void o2();
        if (this.streamingTasks.get(e2) && !i3)
          return o2(), new SE(fE.LIVE_STREAMING_TASK_CONFLICT).throw();
        try {
          this.connection || (this.connection = await this.connect(t2));
        } catch (e3) {
          throw o2(), e3;
        }
        switch (t2) {
          case Kf.TRANSCODE:
            r2.transcodingConfig = Iv({}, this.transcodingConfig);
            break;
          case Kf.RAW:
            break;
          case Kf.INJECT:
            r2 = { cname: this.spec.cname, command: "InjectStream", sid: this.spec.sid, transcodingConfig: this.injectConfig, ts: Date.now(), url: e2, loopTimes: this.injectLoopTimes };
        }
        this.uapResponse && this.uapResponse.vid && (r2.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
        const s2 = this.lastTaskId++;
        try {
          const n3 = new Sl((t3, n4) => {
            zI(this.retryTimeout).then(() => {
              if (i3)
                return n4(i3);
              const t4 = this.statusError.get(e2);
              return t4 ? (this.statusError.delete(e2), n4(t4)) : void 0;
            });
          }), a2 = await Sl.race([this.connection.request("request", { clientRequest: r2 }, true, { url: e2, command: "PublishStream", workerType: t2 === Kf.TRANSCODE ? 1 : 2, requestByUser: !i3, tid: s2.toString() }), n3]);
          this.isStartingStreamingTask = false, OE.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(a2.code)), this.streamingTasks.set(e2, { clientRequest: r2, mode: t2, url: e2, taskId: s2 }), o2();
        } catch (n3) {
          if (o2(), this.isStartingStreamingTask = false, !n3.data || !n3.data.retry || i3)
            throw n3;
          return n3.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e2, t2, n3)) : await this.startLiveStreamingTask(e2, t2, n3);
        }
      }
      stopLiveStreamingTask(e2) {
        return new Sl((t2, i3) => {
          const n2 = this.streamingTasks.get(e2);
          if (!n2 || !this.connection)
            return new SE(fE.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
          const r2 = n2.mode;
          n2.abortTask = () => {
            OE.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e2), t2();
          }, this.connection.request("request", { clientRequest: { command: r2 === Kf.INJECT ? "UninjectStream" : "UnpublishStream", url: n2.url } }, false, { url: e2, command: "UnPublishStream", workerType: r2 === Kf.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((i4) => {
            OE.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(i4.code)), this.streamingTasks.delete(e2), 0 === this.streamingTasks.size && r2 !== Kf.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t2(), r2 === Kf.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e2);
          }).catch(i3);
        });
      }
      async controlInjectStream(e2, t2, i3, n2) {
        const r2 = this.streamingTasks.get(e2);
        if (!r2 || !this.connection || r2.mode !== Kf.INJECT)
          throw new SE(fE.INVALID_OPERATION, "can not find inject stream task to control");
        return (await this.connection.request("request", { clientRequest: { command: "ControlStream", url: e2, control: t2, audioVolume: i3, position: n2 } })).serverResponse;
      }
      resetAllTask() {
        var e2;
        const t2 = Array.from(IR(e2 = this.streamingTasks).call(e2));
        this.terminate();
        for (const e3 of t2)
          this.startLiveStreamingTask(e3.url, e3.mode).catch((t3) => {
            this.onLiveStreamError && this.onLiveStreamError(e3.url, t3);
          });
      }
      terminate() {
        this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = pE.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
      }
      async connect(e2) {
        if (this.connection)
          throw new SE(fE.UNEXPECTED_ERROR, "live streaming connection has already connected");
        const t2 = await nC(this, $f.REQUEST_WORKER_MANAGER_LIST, e2);
        return this.uapResponse = t2, this.connection = new gv(t2.workerToken, this.spec, this.wsRetryConfig, e2), this.connection.on(Zf.WARNING, (e3, t3) => this.onLiveStreamWarning && this.onLiveStreamWarning(t3, e3)), this.connection.on(Zf.PUBLISH_STREAM_STATUS, (e3) => this.handlePublishStreamServer(e3)), this.connection.on(Zf.INJECT_STREAM_STATUS, (e3) => this.handleInjectStreamServerStatus(e3)), this.connection.on(Zf.REQUEST_NEW_ADDRESS, (t3, i3) => {
          if (!this.connection)
            return i3(new SE(fE.UNEXPECTED_ERROR, "can not get new live streaming address list"));
          nC(this, $f.REQUEST_WORKER_MANAGER_LIST, e2).then((e3) => {
            this.uapResponse = e3, t3(e3.addressList);
          }).catch(i3);
        }), await this.connection.init(t2.addressList), this.connection;
      }
      handlePublishStreamServer(e2) {
        const t2 = e2.serverStatus && e2.serverStatus.url || "empty_url", i3 = this.streamingTasks.get(t2), n2 = e2.reason;
        switch (e2.code) {
          case eS.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
          case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
          case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
          case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
            const n3 = new SE(fE.LIVE_STREAMING_CDN_ERROR, "", { code: e2.code });
            if (i3)
              return OE.error(n3.toString()), this.onLiveStreamError && this.onLiveStreamError(t2, n3);
            if (!this.isStartingStreamingTask)
              return;
            this.statusError.set(t2, n3);
          }
          case eS.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
            const e3 = new SE(fE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n2);
            return this.onLiveStreamWarning && this.onLiveStreamWarning(t2, e3);
          }
          case eS.LIVE_STREAM_RESPONSE_WORKER_LOST:
          case eS.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
            var r2;
            if (!this.connection)
              return;
            this.connection.tryNextAddress();
            const t3 = Array.from(IR(r2 = this.streamingTasks).call(r2));
            for (const i4 of t3)
              i4.abortTask ? i4.abortTask() : (OE.warning("[".concat(this.spec.clientId, "] publish stream status code"), e2.code, "try to republish", i4.url), this.startLiveStreamingTask(i4.url, i4.mode, new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e2.code })).then(() => {
                OE.debug("[".concat(this.spec.clientId, "] republish live stream success"), i4.url);
              }).catch((e3) => {
                OE.error(e3.toString()), this.onLiveStreamError && this.onLiveStreamError(i4.url, e3);
              }));
            return;
          }
        }
      }
      handleInjectStreamServerStatus(e2) {
        const t2 = Number(e2.uid), i3 = e2.serverStatus && e2.serverStatus.url;
        switch (e2.code) {
          case 200:
            return void (this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_SUCCESS, t2, i3));
          case 451:
            return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t2, i3), void this.streamingTasks.delete(i3);
          case 453:
            return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t2, i3), void this.streamingTasks.delete(i3);
          case 470:
            return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_BROKEN, t2, i3), void this.streamingTasks.delete(i3);
          case 499:
            return this.onInjectStatusChange && this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_TIMEOUT, t2, i3), void this.streamingTasks.delete(i3);
          default:
            return void OE.debug("inject stream server status", e2);
        }
      }
      hasUrl(e2) {
        return this.streamingTasks.has(e2);
      }
    }
    class vv {
      constructor() {
        _p(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), _p(this, "srcChannelMediaInfo", void 0);
      }
      setSrcChannelInfo(e2) {
        TS(e2), this.srcChannelMediaInfo = e2;
      }
      addDestChannelInfo(e2) {
        TS(e2), this.destChannelMediaInfos.set(e2.channelName, e2);
      }
      removeDestChannelInfo(e2) {
        Qm(e2), this.destChannelMediaInfos.delete(e2);
      }
      getSrcChannelMediaInfo() {
        return this.srcChannelMediaInfo;
      }
      getDestChannelMediaInfo() {
        return this.destChannelMediaInfos;
      }
    }
    function yv(e2) {
      if (!(e2 instanceof vv)) {
        return new SE(fE.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
      }
      const t2 = e2.getSrcChannelMediaInfo(), i3 = e2.getDestChannelMediaInfo();
      if (!t2) {
        return new SE(fE.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
      }
      if (0 === i3.size) {
        return new SE(fE.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
      }
    }
    class Av extends EE {
      constructor(e2, t2, i3) {
        super(), _p(this, "ws", void 0), _p(this, "requestId", 1), _p(this, "heartBeatTimer", void 0), _p(this, "joinInfo", void 0), _p(this, "clientId", void 0), _p(this, "onOpen", () => {
          this.emit("open"), this.startHeartBeatCheck();
        }), _p(this, "onClose", (e3) => {
          this.emit("close"), this.dispose();
        }), _p(this, "onMessage", (e3) => {
          const t3 = JSON.parse(e3.data);
          if (!t3 || "serverResponse" !== t3.command || !t3.requestId)
            return t3 && "serverStatus" === t3.command && t3.serverStatus && t3.serverStatus.command ? (this.emit("status", t3.serverStatus), void this.emit(t3.serverStatus.command, t3.serverStatus)) : void 0;
          this.emit("req_".concat(t3.requestId), t3);
        }), this.joinInfo = e2, this.clientId = t2, this.ws = new vC("cross-channel-".concat(this.clientId), i3), this.ws.on(Hf.RECONNECTING, () => {
          this.ws.reconnectMode = "retry", this.emit("reconnecting");
        }), this.ws.on(Hf.CONNECTED, this.onOpen), this.ws.on(Hf.ON_MESSAGE, this.onMessage), this.ws.on(Hf.CLOSED, this.onClose);
      }
      isConnect() {
        return "connected" === this.ws.state;
      }
      sendMessage(e2) {
        const t2 = this.requestId++;
        return e2.requestId = t2, e2.seq = t2, this.ws.sendMessage(e2), t2;
      }
      waitStatus(e2) {
        return new Sl((t2, i3) => {
          const n2 = window.setTimeout(() => {
            i3(new SE(fE.TIMEOUT, "wait status timeout, status: ".concat(e2)));
          }, 5e3);
          this.once(e2, (r2) => {
            window.clearTimeout(n2), r2.state && 0 !== r2.state ? i3(new SE(fE.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e2))) : t2(void 0);
          }), this.once("dispose", () => {
            window.clearTimeout(n2), i3(new SE(fE.WS_ABORT));
          });
        });
      }
      async request(e2) {
        if ("closed" === this.ws.state)
          throw new SE(fE.WS_DISCONNECT);
        const t2 = () => new Sl((e3, t3) => {
          this.ws.once(Hf.CLOSED, () => t3(new SE(fE.WS_ABORT))), this.ws.once(Hf.CONNECTED, e3);
        });
        "connected" !== this.ws.state && await t2();
        const i3 = this.sendMessage(e2), n2 = new Sl((e3, t3) => {
          const n3 = () => {
            t3(new SE(fE.WS_ABORT));
          };
          this.ws.once(Hf.RECONNECTING, n3), this.ws.once(Hf.CLOSED, n3), this.once("req_".concat(i3), e3), zI(3e3).then(() => {
            this.removeAllListeners("req_".concat(i3)), this.ws.off(Hf.RECONNECTING, n3), this.ws.off(Hf.CLOSED, n3), t3(new SE(fE.TIMEOUT, "cross channel ws request timeout"));
          });
        }), r2 = await n2;
        if (!r2 || 200 !== r2.code)
          throw new SE(fE.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(r2)));
        return r2;
      }
      async connect(e2) {
        this.ws.removeAllListeners(Hf.REQUEST_NEW_URLS), this.ws.on(Hf.REQUEST_NEW_URLS, (t2) => {
          t2(e2);
        }), await this.ws.init(e2);
      }
      dispose() {
        this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
      }
      sendPing(e2) {
        const t2 = this.requestId++;
        return e2.requestId = t2, this.ws.sendMessage(e2), t2;
      }
      startHeartBeatCheck() {
        this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
          this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
        }, 3e3);
      }
      clearHeartBeatCheck() {
        window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
      }
    }
    class Ov extends EE {
      set state(e2) {
        e2 !== this._state && (e2 !== rS.RELAY_STATE_FAILURE && (this.errorCode = oS.RELAY_OK), this.emit("state", e2, this.errorCode), this._state = e2);
      }
      get state() {
        return this._state;
      }
      constructor(e2, t2, i3, n2, r2) {
        super(), _p(this, "joinInfo", void 0), _p(this, "sid", void 0), _p(this, "clientId", void 0), _p(this, "cancelToken", pE.CancelToken.source()), _p(this, "workerToken", void 0), _p(this, "requestId", 0), _p(this, "signal", void 0), _p(this, "prevChannelMediaConfig", void 0), _p(this, "httpRetryConfig", void 0), _p(this, "_resolution", void 0), _p(this, "_state", rS.RELAY_STATE_IDLE), _p(this, "errorCode", oS.RELAY_OK), _p(this, "onStatus", (e3) => {
          OE.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e3))), e3 && e3.command && ("onAudioPacketReceived" === e3.command && this.emit("event", nS.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e3.command && this.emit("event", nS.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e3.command && (this.errorCode = oS.SRC_TOKEN_EXPIRED, this.state = rS.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e3.command && (this.errorCode = oS.DEST_TOKEN_EXPIRED, this.state = rS.RELAY_STATE_FAILURE));
        }), _p(this, "onReconnect", async () => {
          OE.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", nS.NETWORK_DISCONNECTED), this.state = rS.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e3) => {
            this.state !== rS.RELAY_STATE_IDLE && (OE.error("auto restart channel media relay failed", e3.toString()), this.errorCode = oS.SERVER_CONNECTION_LOST, this.state = rS.RELAY_STATE_FAILURE);
          });
        }), this.joinInfo = e2, this.clientId = t2, this.sid = $I(), this.signal = new Av(this.joinInfo, this.clientId, i3), this.httpRetryConfig = n2, this._resolution = r2;
      }
      async startChannelMediaRelay(e2) {
        if (this.state !== rS.RELAY_STATE_IDLE)
          throw new SE(fE.INVALID_OPERATION);
        this.state = rS.RELAY_STATE_CONNECTING, await this.connect(), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
        try {
          await this.sendStartRelayMessage(e2);
        } catch (e3) {
          if (e3.data && e3.data.serverResponse && "SetSourceChannel" === e3.data.serverResponse.command)
            throw new SE(fE.CROSS_CHANNEL_FAILED_JOIN_SRC);
          if (e3.data && e3.data.serverResponse && "SetDestChannelStatus" === e3.serverResponse.command)
            throw new SE(fE.CROSS_CHANNEL_FAILED_JOIN_DEST);
          if (e3.data && e3.data.serverResponse && "StartPacketTransfer" === e3.serverResponse.command)
            throw new SE(fE.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
          throw e3;
        }
        this.prevChannelMediaConfig = e2;
      }
      async updateChannelMediaRelay(e2) {
        if (this.state !== rS.RELAY_STATE_RUNNING)
          throw new SE(fE.INVALID_OPERATION);
        await this.sendUpdateMessage(e2), this.prevChannelMediaConfig = e2;
      }
      async setVideoProfile(e2) {
        if (this._resolution = e2, this.state !== rS.RELAY_STATE_RUNNING)
          throw new SE(fE.INVALID_OPERATION);
        const t2 = this.genMessage(iS.SetVideoProfile);
        await this.signal.request(t2), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
      }
      async stopChannelMediaRelay() {
        await this.sendStopRelayMessage(), OE.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = rS.RELAY_STATE_IDLE, this.dispose();
      }
      dispose() {
        OE.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = pE.CancelToken.source(), this.state = rS.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
      }
      async connect() {
        const e2 = await pv(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
        this.workerToken = e2.workerToken, await this.signal.connect(e2.addressList), this.emit("event", nS.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
      }
      async sendStartRelayMessage(e2) {
        const t2 = this.genMessage(iS.StopPacketTransfer);
        await this.signal.request(t2), await this.signal.waitStatus("Normal Quit"), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
        const i3 = this.genMessage(iS.SetSdkProfile, e2);
        await this.signal.request(i3), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
        const n2 = this.genMessage(iS.SetSourceChannel, e2);
        await this.signal.request(n2), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", nS.PACKET_JOINED_SRC_CHANNEL), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
        const r2 = this.genMessage(iS.SetSourceUserId, e2);
        await this.signal.request(r2), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
        const o2 = this.genMessage(iS.SetDestChannel, e2);
        await this.signal.request(o2), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", nS.PACKET_JOINED_DEST_CHANNEL), OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
        const s2 = this.genMessage(iS.StartPacketTransfer, e2);
        await this.signal.request(s2), this.emit("event", nS.PACKET_SENT_TO_DEST_CHANNEL), this.state = rS.RELAY_STATE_RUNNING, OE.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
      }
      async sendUpdateMessage(e2) {
        const t2 = this.genMessage(iS.UpdateDestChannel, e2);
        await this.signal.request(t2), this.emit("event", nS.PACKET_UPDATE_DEST_CHANNEL), OE.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
      }
      async sendStopRelayMessage() {
        const e2 = this.genMessage(iS.StopPacketTransfer);
        await this.signal.request(e2), OE.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
      }
      genMessage(e2, t2) {
        const i3 = [], n2 = [], r2 = [];
        this.requestId += 1;
        const o2 = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: bE, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
        "4.18.3" === o2.sdkVersion && (o2.sdkVersion = "0.0.1");
        let s2 = null, a2 = null;
        switch (e2) {
          case iS.SetSdkProfile:
            return o2.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, o2;
          case iS.SetSourceChannel:
            if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
              throw new SE(fE.UNEXPECTED_ERROR, "can not find source config");
            return o2.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: a2.channelName, token: a2.token || this.joinInfo.appId }, o2;
          case iS.SetSourceUserId:
            if (a2 = t2 && t2.getSrcChannelMediaInfo(), !a2)
              throw new SE(fE.UNEXPECTED_ERROR, "can not find source config");
            return o2.clientRequest = { command: "SetSourceUserId", uid: a2.uid + "" }, o2;
          case iS.SetDestChannel:
            if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
              throw new SE(fE.UNEXPECTED_ERROR, "can not find dest config");
            return s2.forEach((e3) => {
              i3.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
            }), o2.clientRequest = { command: "SetDestChannel", channelName: i3, uid: n2, token: r2 }, o2;
          case iS.StartPacketTransfer:
            return o2.clientRequest = { command: "StartPacketTransfer" }, o2;
          case iS.Reconnect:
            return o2.clientRequest = { command: "Reconnect" }, o2;
          case iS.StopPacketTransfer:
            return o2.clientRequest = { command: "StopPacketTransfer" }, o2;
          case iS.UpdateDestChannel:
            if (s2 = t2 && t2.getDestChannelMediaInfo(), !s2)
              throw new SE(fE.UNEXPECTED_ERROR, "can not find dest config");
            return s2.forEach((e3) => {
              i3.push(e3.channelName), n2.push(e3.uid + ""), r2.push(e3.token || this.joinInfo.appId);
            }), o2.clientRequest = { command: "UpdateDestChannel", channelName: i3, uid: n2, token: r2 }, o2;
          case iS.SetVideoProfile:
            o2.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
        }
        return o2;
      }
    }
    const Nv = (e2) => {
      const t2 = document.createElement("canvas");
      return t2.width = 2, t2.height = 2, new Sl((i3, n2) => {
        t2.toBlob(async (e3) => {
          if (t2.remove(), e3) {
            const n3 = await bv(e3);
            i3({ buffer: n3, width: t2.width, height: t2.height });
          } else
            n2(new SE(fE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
        }, e2, 1);
      });
    }, bv = async (e2) => {
      const t2 = await e2.arrayBuffer();
      return new Uint8Array(t2);
    };
    function wv(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function Dv(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? wv(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : wv(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class Pv {
      get videoElementStatus() {
        return this._videoElementStatus;
      }
      set videoElementStatus(e2) {
        e2 !== this._videoElementStatus && (OE.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e2)), this._videoElementStatus = e2);
      }
      constructor(e2) {
        _p(this, "trackId", void 0), _p(this, "config", void 0), _p(this, "onFirstVideoFrameDecoded", void 0), _p(this, "freezeTimeCounterList", []), _p(this, "renderFreezeAccTime", 0), _p(this, "isKeepLastFrame", false), _p(this, "timeUpdatedCount", 0), _p(this, "freezeTime", 0), _p(this, "playbackTime", 0), _p(this, "lastTimeUpdatedTime", 0), _p(this, "autoplayFailed", false), _p(this, "videoTrack", void 0), _p(this, "videoElement", void 0), _p(this, "cacheVideoElement", void 0), _p(this, "videoElementCheckInterval", void 0), _p(this, "_videoElementStatus", sf.NONE), _p(this, "isGettingVideoDimensions", false), _p(this, "startGetVideoDimensions", () => {
          const e3 = () => {
            if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4)
              return OE.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
            setTimeout(e3, 500);
          };
          !this.isGettingVideoDimensions && e3();
        }), _p(this, "autoResumeAfterInterruption", () => {
          this.videoTrack && "live" === this.videoTrack.readyState && "running" === Gg.curState && (OE.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(jh())), ep() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
        }), _p(this, "handleVideoEvents", (e3) => {
          switch (e3.type) {
            case "play":
            case "playing":
              this.startGetVideoDimensions(), this.videoElementStatus = sf.PLAYING;
              break;
            case "loadeddata":
              if (this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
                try {
                  this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
                } catch (e4) {
                }
                this.cacheVideoElement = void 0;
              }
              break;
            case "canplay":
              this.videoElementStatus = sf.CANPLAY;
              break;
            case "stalled":
              this.videoElementStatus = sf.STALLED;
              break;
            case "suspend":
              this.videoElementStatus = sf.SUSPEND;
              break;
            case "pause":
              this.videoElementStatus = sf.PAUSED, Yh() || tp() || Hh() && this.autoplayFailed || !this.videoTrack || "live" !== this.videoTrack.readyState || (OE.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
              break;
            case "waiting":
              this.videoElementStatus = sf.WAITING;
              break;
            case "abort":
              this.videoElementStatus = sf.ABORT;
              break;
            case "ended":
              this.videoElementStatus = sf.ENDED;
              break;
            case "emptied":
              this.videoElementStatus = sf.EMPTIED;
              break;
            case "error": {
              this.videoElementStatus = sf.ERROR;
              const e4 = this.videoElement.error;
              e4 && OE.error("[".concat(this.trackId, "] media error, code: ").concat(e4.code, ", message: ").concat(e4.message));
              break;
            }
            case "timeupdate": {
              const e4 = performance.now();
              if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10)
                return void (this.lastTimeUpdatedTime = e4);
              const t2 = e4 - this.lastTimeUpdatedTime, i3 = this.lastTimeUpdatedTime;
              if (this.lastTimeUpdatedTime = e4, MI.lastVisibleTime < MI.lastHiddenTime || i3 < MI.lastHiddenTime || i3 < MI.lastVisibleTime)
                return;
              for (t2 > GE("VIDEO_FREEZE_DURATION") && (this.freezeTime += t2), this.playbackTime += t2; this.playbackTime >= 6e3; ) {
                this.playbackTime -= 6e3;
                const e5 = Math.min(6e3, this.freezeTime);
                this.freezeTimeCounterList.push(e5), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
              }
              break;
            }
          }
        }), _p(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
          this.videoTrack && "live" === this.videoTrack.readyState && (OE.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(jh())), ep() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
        }), this.trackId = e2.trackId, this.config = e2, e2.element instanceof HTMLVideoElement ? this.videoElement = e2.element : this.videoElement = document.createElement("video"), Gg.on(kg.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Gg.on(kg.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
      }
      getVideoElement() {
        return this.videoElement;
      }
      getContainerElement() {
        var e2;
        return null !== (e2 = this.videoElement.parentElement) && void 0 !== e2 ? e2 : void 0;
      }
      updateConfig(e2) {
        this.config = e2, this.trackId = e2.trackId, e2.element !== this.videoElement && (this.destroy(), this.videoElement = e2.element), this.videoTrack && this.initVideoElement();
      }
      updateVideoTrack(e2) {
        this.videoTrack !== e2 && (this.videoTrack = e2, this.initVideoElement());
      }
      play(e2) {
        const t2 = this.videoElement.play();
        t2 && t2.catch && t2.catch((t3) => {
          e2 && Pg.autoplayFailed(e2, "video", t3.message, this.trackId), "NotAllowedError" === t3.name ? (OE.warning("detected video element autoplay failed", t3), this.autoplayFailed = true, this.handleAutoPlayFailed()) : OE.warning("[".concat(this.trackId, "] play warning: "), t3);
        });
        const i3 = xh();
        if (("Safari" === i3.name && 15 === Number(i3.version) || Zh()) && t2 && t2.then && t2.catch) {
          const e3 = () => {
            this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
          };
          t2.then(e3).catch(e3);
        }
      }
      getCurrentFrame() {
        const e2 = document.createElement("canvas");
        e2.width = this.videoElement.videoWidth, e2.height = this.videoElement.videoHeight;
        const t2 = e2.getContext("2d");
        if (!t2)
          return OE.error("create canvas context failed!"), new ImageData(2, 2);
        t2.drawImage(this.videoElement, 0, 0, e2.width, e2.height);
        const i3 = t2.getImageData(0, 0, e2.width, e2.height);
        return e2.remove(), i3;
      }
      async getCurrentFrameToUint8Array(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        const i3 = document.createElement("canvas");
        i3.width = this.videoElement.videoWidth, i3.height = this.videoElement.videoHeight;
        const n2 = i3.getContext("2d");
        return n2 ? (n2.drawImage(this.videoElement, 0, 0, i3.width, i3.height), new Sl((n3, r2) => {
          i3.toBlob(async (e3) => {
            if (i3.remove(), e3) {
              const t3 = await bv(e3);
              n3({ buffer: t3, width: i3.width, height: i3.height });
            } else
              r2(new SE(fE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
          }, e2, t2 < 0 ? 0.1 : t2 > 1 ? 1 : t2);
        })) : await Nv(e2);
      }
      destroy() {
        Gg.off(kg.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), Gg.off(kg.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [];
      }
      initVideoElement() {
        if (this.videoElementStatus = sf.INIT, !this.videoElementCheckInterval && (Lv.forEach((e3) => {
          this.videoElement.addEventListener(e3, this.handleVideoEvents);
        }), this.videoElementCheckInterval = window.setInterval(() => {
          (function(e3) {
            return e3 !== document.body && document.body.contains(e3);
          })(this.videoElement) || (this.videoElementStatus = sf.DESTROYED);
        }, 1e3), GE("ENABLE_VIDEO_FRAME_CALLBACK"))) {
          var e2, t2;
          let i4;
          const n3 = (e3, t3) => {
            if (this.videoElementStatus === sf.PLAYING) {
              if (i4) {
                const e4 = t3.presentationTime - i4.presentationTime;
                e4 > GE("VIDEO_FREEZE_DURATION") && MI.lastVisibleTime >= MI.lastHiddenTime && i4.timestamp > MI.lastVisibleTime && i4.timestamp > MI.lastHiddenTime && (this.renderFreezeAccTime += e4);
              }
              i4 = Dv(Dv({}, t3), {}, { timestamp: e3 });
            }
            var r2, o2;
            GE("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (r2 = (o2 = this.videoElement).requestVideoFrameCallback) || void 0 === r2 || r2.call(o2, n3));
          };
          null === (e2 = (t2 = this.videoElement).requestVideoFrameCallback) || void 0 === e2 || e2.call(t2, n3);
        }
        this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), op() && (this.videoElement.poster = "noposter");
        const i3 = xh();
        if ("Safari" === i3.name && 15 === Number(i3.version) || Zh() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {
          this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Kh() && this.videoElement.load());
        } else
          this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Kh() && this.videoElement.load();
        const n2 = this.videoElement.play();
        void 0 !== n2 && n2.catch((e3) => {
          OE.debug("[".concat(this.trackId, "] playback interrupted"), e3.toString());
        });
      }
      resetVideoElement() {
        Lv.forEach((e2) => {
          this.videoElement && this.videoElement.removeEventListener(e2, this.handleVideoEvents);
        }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = sf.NONE;
      }
      handleAutoPlayFailed() {
        const e2 = (t2) => {
          t2.preventDefault(), this.videoElement.play().then(() => {
            OE.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
          }).catch((e3) => {
            OE.error(e3);
          }), this.autoplayFailed = false, sp() ? document.body.removeEventListener("click", e2, true) : (document.body.removeEventListener("touchstart", e2, true), document.body.removeEventListener("mousedown", e2, true));
        };
        sp() ? document.body.addEventListener("click", e2, true) : (document.body.addEventListener("touchstart", e2, true), document.body.addEventListener("mousedown", e2, true)), yg();
      }
    }
    const Lv = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
    class kv extends Pv {
      constructor(e2) {
        super(e2), _p(this, "container", void 0), _p(this, "slot", void 0), this.slot = e2.element, this.updateConfig(e2);
      }
      updateConfig(e2) {
        this.config = e2, this.trackId = e2.trackId;
        const t2 = e2.element;
        t2 !== this.slot && (this.destroy(), this.slot = t2), this.createElements();
      }
      updateVideoTrack(e2) {
        this.videoTrack !== e2 && (this.videoTrack = e2, this.createElements());
      }
      play(e2) {
        var t2;
        null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) && super.play(e2);
      }
      getCurrentFrame() {
        var e2;
        return null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
      }
      async getCurrentFrameToUint8Array(e2) {
        var t2;
        let i3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        return null !== (t2 = this.container) && void 0 !== t2 && t2.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e2, i3) : await Nv(e2);
      }
      destroy() {
        if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
          try {
            this.container.remove(), this.slot.removeChild(this.container);
          } catch (e2) {
          }
          this.container = void 0;
        }
      }
      createElements() {
        this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", GE("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
      }
      mountedVideoElement() {
        var e2;
        !this.container || null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
      }
      unmountedVideoElement() {
        var e2;
        if (null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement)) {
          super.resetVideoElement();
          try {
            this.container && this.container.removeChild(this.videoElement);
          } catch (e3) {
          }
          this.videoElement = document.createElement("video");
        }
      }
      resetVideoElement() {
        var e2;
        null !== (e2 = this.container) && void 0 !== e2 && e2.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
      }
      getContainerElement() {
        return this.container;
      }
    }
    function Mv(e2) {
      const t2 = {};
      e2.facingMode && (t2.facingMode = e2.facingMode), e2.cameraId && (t2.deviceId = { exact: e2.cameraId });
      const i3 = UE(e2.encoderConfig);
      return t2.width = i3.width, t2.height = i3.height, !np() && i3.frameRate && (t2.frameRate = i3.frameRate), xh().name === wh.EDGE && "object" == typeof t2.frameRate && (t2.frameRate.max = 60), Kh() && (t2.frameRate = { ideal: 30, max: 30 }), t2;
    }
    function Uv(e2) {
      const t2 = {};
      e2.screenSourceType && (t2.mediaSource = e2.screenSourceType), e2.extensionId && Wh() && (t2.extensionId = e2.extensionId);
      const { displaySurface: i3, selfBrowserSurface: n2, surfaceSwitching: r2, systemAudio: o2 } = e2;
      (qh(107) || Jh(107) || Xh(93)) && (i3 && (Ym(i3, "displaySurface", ["browser", "window", "monitor"]), t2.displaySurface = i3), n2 ? (Ym(n2, "selfBrowserSurface", ["exclude", "include"]), t2.selfBrowserSurface = n2) : t2.selfBrowserSurface = "include", r2 && (Ym(r2, "surfaceSwitching", ["exclude", "include"]), t2.surfaceSwitching = r2)), (qh(105) || Jh(105) || Xh(91)) && o2 && (Ym(o2, "systemAudio", ["exclude", "include"]), t2.systemAudio = o2), e2.electronScreenSourceId && (t2.sourceId = e2.electronScreenSourceId);
      const s2 = e2.encoderConfig ? xE(e2.encoderConfig) : null;
      return t2.mandatory = { chromeMediaSource: "desktop", maxWidth: s2 ? s2.width : void 0, maxHeight: s2 ? s2.height : void 0 }, s2 && (s2.frameRate && ("number" == typeof s2.frameRate ? (t2.mandatory.maxFrameRate = s2.frameRate, t2.mandatory.minFrameRate = s2.frameRate) : (t2.mandatory.maxFrameRate = s2.frameRate.max || s2.frameRate.ideal || s2.frameRate.exact || void 0, t2.mandatory.minFrameRate = s2.frameRate.min || s2.frameRate.ideal || s2.frameRate.exact || void 0), t2.frameRate = s2.frameRate), s2.width && (t2.width = s2.width), s2.height && (t2.height = s2.height)), t2;
    }
    function xv(e2) {
      const t2 = {};
      if (np() || (void 0 !== e2.AGC && (t2.autoGainControl = e2.AGC), void 0 !== e2.AEC && (t2.echoCancellation = e2.AEC), void 0 !== e2.ANS && (t2.noiseSuppression = e2.ANS, Wh() && e2.ANS && (t2.googHighpassFilter = e2.ANS))), e2.encoderConfig) {
        const i3 = FE(e2.encoderConfig);
        t2.channelCount = i3.stereo ? 2 : 1, t2.sampleRate = i3.sampleRate, t2.sampleSize = i3.sampleSize;
      }
      return e2.microphoneId && (t2.deviceId = { exact: e2.microphoneId }), op() && (t2.sampleRate = void 0), t2;
    }
    var Vv, jv;
    !function(e2) {
      e2.COVERED = "COVERED", e2.POSITION = "POSITION", e2.SIZE = "SIZE", e2.STYLE = "STYLE";
    }(Vv || (Vv = {})), function(e2) {
      e2.UNMOUNTED = "UNMOUNTED", e2.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT";
    }(jv || (jv = {}));
    var Fv, Bv, Gv, Wv, Hv, Kv, Yv, qv, Jv, Xv, zv, Qv, Zv, $v, ey, ty, iy, ny, ry, oy, sy, ay, cy, dy, uy, ly, hy, py, _y, Ey, my, fy, Sy, Ty, gy = new class {
      constructor() {
        _p(this, "_clientSize", null), _p(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), _p(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), _p(this, "getStyle", (e2) => window.getComputedStyle(e2, null)), _p(this, "checkCssVisibleProperty", (e2) => {
          let t2 = true;
          const i3 = this.getStyle(e2), { display: n2, visibility: r2, opacity: o2, filter: s2 } = i3;
          if (("none" === n2 || ["hidden", "collapse"].includes(r2) || Number(o2) < 0.1) && (t2 = false), !t2)
            return false;
          if (s2) {
            s2.split(" ").filter((e3) => {
              const t3 = e3.split("(")[0];
              return ["brightness", "blur", "opacity"].includes(t3);
            }).map((e3) => {
              const [t3, i4] = e3.split(/\(|\)/);
              return [t3, Number(i4.match(/^[0-9\.]+/))];
            }).forEach((e3) => {
              const [i4, n3] = e3;
              switch (i4) {
                case "brightness":
                  (n3 < 0.1 || n3 > 3) && (t2 = false);
                  break;
                case "blur":
                  n3 > 3 && (t2 = false);
                  break;
                case "opacity":
                  n3 < 0.1 && (t2 = false);
              }
            });
          }
          return t2;
        }), _p(this, "checkPropertyUpToAllParentNodes", (e2, t2) => {
          let i3 = true, n2 = true;
          const r2 = (e3) => t2(e3);
          let o2 = e2;
          for (; o2 && n2; ) {
            r2(o2) || (i3 = false, n2 = false), o2 = o2.parentElement, o2 || (n2 = false);
          }
          return i3;
        }), _p(this, "checkActualCssVisibleIncludeInherit", (e2) => this.checkPropertyUpToAllParentNodes(e2, this.checkCssVisibleProperty)), _p(this, "getSizeAboutClient", (e2) => {
          const { width: t2, height: i3, left: n2, right: r2, top: o2, bottom: s2 } = e2.getBoundingClientRect(), a2 = this.getClientWidth(), c2 = this.getClientHeight();
          return { width: t2, height: i3, left: n2, right: r2, top: o2, bottom: s2, clientWidth: a2, clientHeight: c2, clientMin: Math.min(a2, c2) };
        }), _p(this, "checkActualSize", () => {
          const { width: e2, height: t2, clientMin: i3 } = this._clientSize;
          return this.checkSizeIsVisible(e2, t2, i3);
        }), _p(this, "elementFromPoint", (e2, t2) => document.elementFromPoint ? document.elementFromPoint(e2, t2) : null), _p(this, "checkCoverForAPoint", (e2, t2, i3) => {
          const n2 = this.elementFromPoint(e2, t2);
          return null !== n2 && n2 !== i3;
        }), _p(this, "getPointPositionList", () => {
          const { width: e2, height: t2, left: i3, top: n2 } = this._clientSize, r2 = e2 / 6, o2 = t2 / 6, s2 = [], a2 = 10 ** 6;
          for (let e3 = 0; e3 < 5; e3++)
            for (let t3 = 0; t3 < 5; t3++) {
              const c2 = (i3 * a2 + (0 === e3 ? 0.1 : 4 === e3 ? (r2 * e3 * a2 - 1e5) / a2 : r2 * e3) * a2) / a2, d2 = (n2 * a2 + (0 === t3 ? 0.1 : 4 === t3 ? (o2 * t3 * a2 - 1e5) / a2 : o2 * t3) * a2) / a2;
              s2.push({ x: c2, y: d2 });
            }
          return [...s2];
        }), _p(this, "checkElementCover", (e2) => this.getPointPositionList().map((t2) => this.checkCoverForAPoint(t2.x, t2.y, e2)).filter((e3) => !!e3).length > 6), _p(this, "checkSizeIsVisible", (e2, t2, i3) => (e2 > 50 || i3 / e2 <= 10) && (t2 > 50 || i3 / t2 <= 10)), _p(this, "checkSizeOfPartInClient", () => {
          const { left: e2, right: t2, top: i3, bottom: n2, clientHeight: r2, clientWidth: o2, clientMin: s2 } = this._clientSize;
          let a2, c2, d2, u2;
          if (e2 < 0)
            a2 = 0;
          else {
            if (!(e2 < o2))
              return false;
            a2 = e2;
          }
          if (t2 < 0)
            return false;
          if (c2 = t2 < o2 ? t2 : o2, i3 < 0)
            d2 = 0;
          else {
            if (!(i3 < r2))
              return false;
            d2 = i3;
          }
          if (n2 < 0)
            return false;
          u2 = n2 < r2 ? n2 : r2;
          const l2 = c2 - a2, h3 = u2 - d2;
          return this.checkSizeIsVisible(l2, h3, s2);
        }), _p(this, "returnHiddenResult", (e2) => (this._clientSize = null, { visible: false, reason: e2 })), _p(this, "checkOneElementVisible", (e2) => {
          if (e2 instanceof HTMLElement) {
            if (this.checkElementIsMountedOnDom(e2)) {
              if (this.checkActualCssVisibleIncludeInherit(e2)) {
                if (this._clientSize = this.getSizeAboutClient(e2), this.checkElementCover(e2))
                  return this.returnHiddenResult(Vv.COVERED);
                {
                  const e3 = this.checkActualSize(), t2 = this.checkSizeOfPartInClient();
                  return e3 && !t2 ? this.returnHiddenResult(Vv.POSITION) : e3 ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(Vv.SIZE);
                }
              }
              return this.returnHiddenResult(Vv.STYLE);
            }
            return this.returnHiddenResult(jv.UNMOUNTED);
          }
          return this.returnHiddenResult(jv.INVALID_HTML_ELEMENT);
        }), _p(this, "checkElementIsMountedOnDom", (e2) => this.checkPropertyUpToAllParentNodes(e2, (e3) => "HTML" !== e3.nodeName.toUpperCase() ? null !== e3.parentElement : !!document.documentElement));
      }
    }();
    function Ry(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function Iy(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? Ry(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Ry(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let Cy = (Fv = Dg({ argsMap: (e2, t2, i3) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i3] }), Bv = _R(), Gv = Dg({ argsMap: (e2) => [e2.getTrackId()] }), Wv = xg("LocalVideoTrack", "_enabledMutex"), Hv = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Kv = _R(), Yv = xg("LocalVideoTrack", "_enabledMutex"), qv = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Jv = _R(), Xv = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), zv = _R(), Qv = _R(), Zv = Dg({ argsMap: (e2, t2, i3) => [e2.getTrackId(), t2, i3] }), $v = _R(), ey = _R(), ty = _R(), iy = _R(), ny = _R(), ry = _R(), oy = _R(), sy = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), ay = Dg({ argsMap: (e2) => [e2.getTrackId()] }), cy = Dg({ argsMap: (e2) => [e2.getTrackId()] }), dy = Dg({ argsMap: (e2, t2, i3) => [e2.getTrackId(), t2.label, i3] }), ag((uy = class e2 extends Vg {
      get isPlaying() {
        return !(!this._player || this._player.videoElementStatus !== sf.PLAYING);
      }
      get processorContext() {
        return this._processorContext;
      }
      set processorContext(e3) {
        this._processorContext = e3;
      }
      get __className__() {
        return "LocalVideoTrack";
      }
      constructor(e3, t2, i3, n2, r2, o2) {
        if (super(e3, r2), _p(this, "trackMediaType", "video"), _p(this, "_player", void 0), _p(this, "_videoVisibleTimer", null), _p(this, "_previousVideoVisibleStatus", void 0), _p(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), _p(this, "_encoderConfig", void 0), _p(this, "_scalabiltyMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), _p(this, "_optimizationMode", void 0), _p(this, "_videoHeight", void 0), _p(this, "_videoWidth", void 0), _p(this, "_forceBitrateLimit", void 0), _p(this, "_enabled", true), _p(this, "processorDestination", void 0), _p(this, "_processorContext", void 0), Hh()) {
          const { width: t3, height: i4 } = e3.getSettings();
          this._videoWidth = t3, this._videoHeight = i4;
        } else
          this.updateMediaStreamTrackResolution();
        this._encoderConfig = t2, this._scalabiltyMode = i3, this._optimizationMode = n2, this._hints = o2 || [], -1 === this._hints.indexOf(lS.SCREEN_TRACK) && this.updateBitrateFromProfile(), t2 && -1 !== this._hints.indexOf(lS.CUSTOM_TRACK) && this.setEncoderConfiguration(t2), this.processorContext = new AR(this.getTrackId(), "local"), this.processorDestination = new yR(this.processorContext), this.bindProcessorDestinationEvents();
      }
      play(e3) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if ("string" == typeof e3) {
          const t3 = document.getElementById(e3);
          t3 ? e3 = t3 : (OE.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e3, '" element, use document.body')), e3 = document.body);
        }
        OE.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e3 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
        const i3 = Iy(Iy(Iy({}, this._getDefaultPlayerConfig()), t2), {}, { trackId: this.getTrackId(), element: e3 });
        this._player ? this._player.updateConfig(i3) : (e3 instanceof HTMLVideoElement ? this._player = new Pv(i3) : this._player = new kv(i3), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
          try {
            const e4 = this.getVideoElementVisibleStatus();
            this.safeEmit(mS.VIDEO_ELEMENT_VISIBLE_STATUS, e4);
          } catch (e4) {
          }
        }, GE("CHECK_VIDEO_VISIBLE_INTERVAL"));
      }
      stop() {
        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, OE.debug("[".concat(this.getTrackId(), "] stop video playback")));
      }
      async setEnabled(e3, t2) {
        if (!t2) {
          if (e3 === this._enabled)
            return;
          this.stateCheck("enabled", e3);
        }
        if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e3), !e3) {
          this._originMediaStreamTrack.enabled = false;
          try {
            await rC(this, uS.NEED_DISABLE_TRACK, this);
          } catch (e4) {
            throw OE.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e4.toString()), e4;
          }
          return t2 || (this._enabled = false), void OE.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
        }
        this._originMediaStreamTrack.enabled = true;
        try {
          await rC(this, uS.NEED_ENABLE_TRACK, this);
        } catch (e4) {
          throw OE.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e4.toString()), e4;
        }
        OE.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
      }
      async setMuted(e3) {
        e3 !== this._muted && (this.stateCheck("muted", e3), this._muted = e3, this._originMediaStreamTrack.enabled = !e3, OE.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e3)), e3 ? await rC(this, uS.NEED_MUTE_TRACK, this) : await rC(this, uS.NEED_UNMUTE_TRACK, this));
      }
      async setEncoderConfiguration(e3, t2) {
        if (!this._enabled)
          throw new SE(fE.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
        if (e3 = UE(e3), this._forceBitrateLimit && (e3.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e3.bitrateMax, e3.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e3.bitrateMin), e3.width || e3.height || e3.frameRate) {
          const t3 = Mv({ encoderConfig: e3 });
          (Hh() || Yh() || tp()) && (t3.deviceId = void 0), OE.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e3), JSON.stringify(t3));
          try {
            await this._originMediaStreamTrack.applyConstraints(t3), this.updateMediaStreamTrackResolution();
          } catch (e4) {
            const t4 = new SE(fE.UNEXPECTED_ERROR, e4.toString());
            throw OE.error("[".concat(this.getTrackId(), "] applyConstraints error"), t4.toString()), t4;
          }
        }
        this._encoderConfig = e3, -1 === this._hints.indexOf(lS.SCREEN_TRACK) && this.updateBitrateFromProfile();
        try {
          await rC(this, uS.NEED_UPDATE_VIDEO_ENCODER, this);
        } catch (e4) {
          return e4.throw();
        }
      }
      getStats() {
        hC(() => {
          OE.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
        }, "localVideoTrackGetStatsWarning");
        const e3 = oC(this, uS.GET_STATS);
        return e3 || Iy({}, Ff);
      }
      async setBeautyEffect(e3) {
        OE.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
      }
      getCurrentFrameData() {
        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
      }
      async getCurrentFrameImage(e3) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        return this._player ? this._player.getCurrentFrameToUint8Array(e3, t2) : await Nv(e3);
      }
      clone(t2, i3, n2, r2) {
        const o2 = this._mediaStreamTrack.clone();
        return new e2(o2, t2, i3, n2, r2);
      }
      async setBitrateLimit(e3) {
        if (OE.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e3))), e3) {
          this._forceBitrateLimit = e3, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e3.max_bitrate ? this._encoderConfig.bitrateMax : e3.max_bitrate : this._encoderConfig.bitrateMax = e3.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e3.min_bitrate);
          try {
            await rC(this, uS.NEED_UPDATE_VIDEO_ENCODER, this);
          } catch (e4) {
            return e4.throw();
          }
        }
      }
      async setOptimizationMode(e3) {
        if ("motion" !== e3 && "detail" !== e3 && "balanced" !== e3)
          return void OE.error(fE.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
        const t2 = this._optimizationMode;
        try {
          this._optimizationMode = e3, await rC(this, uS.SET_OPTIMIZATION_MODE, this);
        } catch (e4) {
          throw this._optimizationMode = t2, OE.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e4.toString()), e4;
        }
        OE.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e3, ")"));
      }
      setScalabiltyMode(e3) {
        if (1 === e3.numSpatialLayers && 1 !== e3.numTemporalLayers)
          return OE.error(fE.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabiltyMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
        this._scalabiltyMode = e3, OE.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e3, ")"));
      }
      updateMediaStreamTrackResolution() {
        tC(this._originMediaStreamTrack).then((e3) => {
          let [t2, i3] = e3;
          this._videoHeight = i3, this._videoWidth = t2;
        }).catch(eC);
      }
      _updatePlayerSource() {
        this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
      }
      _getDefaultPlayerConfig() {
        return { fit: "contain" };
      }
      updateBitrateFromProfile() {
        if (!this._encoderConfig)
          return;
        const { width: e3, height: t2, frameRate: i3 } = this.getMediaStreamTrackSettings();
        if (!e3 || !t2 || !i3)
          return;
        const [n2, r2] = function(e4, t3, i4) {
          const n3 = GE("BITRATE_ADAPTER_TYPE");
          let r3;
          const o2 = 200 * Math.pow(i4 / 15, 0.6) * Math.pow(e4 * t3 / 640 / 360, 0.75), s2 = o2;
          if ("STANDARD_BITRATE" === n3)
            r3 = 4 * o2;
          else {
            if ("COMPATIABLE_BITRATE" !== n3)
              return;
            r3 = 2 * o2;
          }
          return [Math.floor(r3), Math.floor(s2)];
        }(e3, t2, i3) || [void 0, void 0];
        this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = r2, this._encoderConfig.bitrateMax = n2, OE.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e3, ", h: ").concat(t2, ", fps: ").concat(i3, "] => [brMax: ").concat(n2, ", brMin: ").concat(r2, "]")));
      }
      getVideoElementVisibleStatus() {
        try {
          var e3, t2;
          const i3 = null == this || null === (e3 = this._player) || void 0 === e3 ? void 0 : e3.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i3 ? void 0 : i3.parentElement }, { element: r2, slot: o2 } = n2;
          if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
            const e4 = gy.checkOneElementVisible(r2), t3 = Object.assign({}, e4);
            if (t3.visible !== this._previousVideoVisibleStatus) {
              this._previousVideoVisibleStatus = t3.visible;
              const e5 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
              t3.visible ? e5.onSuccess("Video is visible") : e5.onSuccess("Invisible because of ".concat(t3.reason));
            }
            return t3;
          }
          return;
        } catch (e4) {
          throw new SE(fE.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e4.message);
        }
      }
      async renewMediaStreamTrack(e3) {
      }
      pipe(e3) {
        if (this.processor === e3)
          return e3;
        if (e3._source)
          throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e3.name, " already piped, please call unpipe beforehand."));
        return this.unpipe(), this.processor = e3, this.processor._source = this, e3.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e3;
      }
      unpipe() {
        if (!this.processor)
          return;
        const e3 = this.processor;
        this.processor._source = void 0, this.processor = void 0, e3.reset();
      }
      close() {
        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
      }
      async replaceTrack(e3, t2) {
        if (!(e3 instanceof MediaStreamTrack))
          throw new SE(fE.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
        if ("video" !== e3.kind)
          throw new SE(fE.INVALID_PARAMS, "track should be a video MediaStreamTrack");
        await this._updateOriginMediaStreamTrack(e3, t2, true), this.updateMediaStreamTrackResolution();
      }
      bindProcessorDestinationEvents() {
        this.processorDestination.on(kS.ON_TRACK, async (e3) => {
          e3 ? e3 !== this._mediaStreamTrack && (this._mediaStreamTrack = e3, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await rC(this, uS.NEED_REPLACE_TRACK, this));
        });
      }
      unbindProcessorDestinationEvents() {
        this.processorDestination.removeAllListeners(kS.ON_TRACK);
      }
      unbindProcessorContextEvents() {
        this.processorContext.removeAllListeners(MS.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(MS.REQUEST_CONSTRAINTS);
      }
    }).prototype, "play", [Fv, Bv], Object.getOwnPropertyDescriptor(uy.prototype, "play"), uy.prototype), ag(uy.prototype, "stop", [Gv], Object.getOwnPropertyDescriptor(uy.prototype, "stop"), uy.prototype), ag(uy.prototype, "setEnabled", [Wv, Hv, Kv], Object.getOwnPropertyDescriptor(uy.prototype, "setEnabled"), uy.prototype), ag(uy.prototype, "setMuted", [Yv, qv, Jv], Object.getOwnPropertyDescriptor(uy.prototype, "setMuted"), uy.prototype), ag(uy.prototype, "setEncoderConfiguration", [Xv, zv], Object.getOwnPropertyDescriptor(uy.prototype, "setEncoderConfiguration"), uy.prototype), ag(uy.prototype, "getStats", [Qv], Object.getOwnPropertyDescriptor(uy.prototype, "getStats"), uy.prototype), ag(uy.prototype, "setBeautyEffect", [Zv, $v], Object.getOwnPropertyDescriptor(uy.prototype, "setBeautyEffect"), uy.prototype), ag(uy.prototype, "getCurrentFrameData", [ey], Object.getOwnPropertyDescriptor(uy.prototype, "getCurrentFrameData"), uy.prototype), ag(uy.prototype, "getCurrentFrameImage", [ty], Object.getOwnPropertyDescriptor(uy.prototype, "getCurrentFrameImage"), uy.prototype), ag(uy.prototype, "setBitrateLimit", [iy], Object.getOwnPropertyDescriptor(uy.prototype, "setBitrateLimit"), uy.prototype), ag(uy.prototype, "setOptimizationMode", [ny], Object.getOwnPropertyDescriptor(uy.prototype, "setOptimizationMode"), uy.prototype), ag(uy.prototype, "setScalabiltyMode", [ry], Object.getOwnPropertyDescriptor(uy.prototype, "setScalabiltyMode"), uy.prototype), ag(uy.prototype, "updateMediaStreamTrackResolution", [oy], Object.getOwnPropertyDescriptor(uy.prototype, "updateMediaStreamTrackResolution"), uy.prototype), ag(uy.prototype, "pipe", [sy], Object.getOwnPropertyDescriptor(uy.prototype, "pipe"), uy.prototype), ag(uy.prototype, "unpipe", [ay], Object.getOwnPropertyDescriptor(uy.prototype, "unpipe"), uy.prototype), ag(uy.prototype, "close", [cy], Object.getOwnPropertyDescriptor(uy.prototype, "close"), uy.prototype), ag(uy.prototype, "replaceTrack", [dy], Object.getOwnPropertyDescriptor(uy.prototype, "replaceTrack"), uy.prototype), uy), vy = (ly = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), hy = _R(), py = xg("CameraVideoTrack", "_enabledMutex"), _y = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), Ey = _R(), my = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), fy = _R(), Sy = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((Ty = class extends Cy {
      get __className__() {
        return "CameraVideoTrack";
      }
      constructor(e2, t2, i3, n2, r2, o2) {
        super(e2, UE(t2.encoderConfig), n2, r2, o2), _p(this, "_config", void 0), _p(this, "_originalConstraints", void 0), _p(this, "_constraints", void 0), _p(this, "_enabled", true), _p(this, "_deviceName", "default"), _p(this, "tryResumeVideoForIOS15_16WeChat", async () => {
          (Zh() || $h()) && !function() {
            const e3 = xh();
            if (e3.os !== bh.IOS || !e3.osVersion)
              return false;
            const t3 = e3.osVersion.split(".");
            return 15 === Number(t3[0]) && Number(t3[1]) >= 2;
          }() && ip() && this._enabled && !this._isClosed && (OE.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
        }), this._config = t2, this._originalConstraints = i3, this._constraints = i3, this._deviceName = e2.label, this._encoderConfig = UE(this._config.encoderConfig), Gg.on(kg.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), Gg.on(kg.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
      }
      async setDevice(e2) {
        if (OE.info("[".concat(this.getTrackId(), "] set device to ").concat(e2)), this._enabled)
          try {
            const t2 = await lR.getDeviceById(e2), i3 = {};
            i3.video = Iy({}, this._constraints), i3.video.deviceId = { exact: e2 }, i3.video.facingMode = void 0, this._originMediaStreamTrack.stop();
            let n2 = null;
            try {
              n2 = await aR(i3, this.getTrackId());
            } catch (e3) {
              throw OE.error("[".concat(this.getTrackId(), "] setDevice failed"), e3.toString()), n2 = await aR({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), e3;
            }
            await this._updateOriginMediaStreamTrack(n2.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
        else
          try {
            const t2 = await lR.getDeviceById(e2);
            this._deviceName = t2.label, this._config.cameraId = e2, this._constraints.deviceId = { exact: e2 };
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setDevice error"), e3.toString()), e3;
          }
        OE.info("[".concat(this.getTrackId(), "] setDevice success"));
      }
      async setEnabled(e2, t2) {
        if (!t2) {
          if (e2 === this._enabled)
            return;
          this.stateCheck("enabled", e2);
        }
        if (OE.info("[".concat(this.getTrackId(), "] start setEnabled"), e2), e2) {
          try {
            if (this.isExternalTrack)
              this._originMediaStreamTrack.enabled = true;
            else {
              const e3 = await aR({ video: this._constraints }, this.getTrackId());
              await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], false);
            }
            await rC(this, uS.NEED_ENABLE_TRACK, this);
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setEnabled true error"), e3.toString()), e3;
          }
          this.updateMediaStreamTrackResolution(), OE.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t2 || (this._enabled = true);
        } else {
          this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), t2 || (this._enabled = false);
          try {
            await rC(this, uS.NEED_DISABLE_TRACK, this);
          } catch (e3) {
            throw OE.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e3.toString()), e3;
          }
          OE.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
        }
      }
      async setEncoderConfiguration(e2, t2) {
        if (!this._enabled)
          throw new SE(fE.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
        e2 = UE(e2), this._forceBitrateLimit && (e2.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e2.bitrateMax, e2.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e2.bitrateMin);
        const i3 = uC(this._config);
        i3.encoderConfig = e2;
        const n2 = Mv(i3);
        (Hh() || Yh() || tp()) && (n2.deviceId = void 0), OE.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e2), JSON.stringify(n2));
        try {
          await this._originMediaStreamTrack.applyConstraints(n2), this.updateMediaStreamTrackResolution();
        } catch (e3) {
          const t3 = new SE(fE.UNEXPECTED_ERROR, e3.toString());
          throw OE.error("[".concat(this.getTrackId(), "] applyConstraints error"), t3.toString()), t3;
        }
        this._config = i3, this._constraints = n2, this._originalConstraints = n2, this._encoderConfig = e2, -1 === this._hints.indexOf(lS.SCREEN_TRACK) && this.updateBitrateFromProfile();
        try {
          await rC(this, uS.NEED_UPDATE_VIDEO_ENCODER, this);
        } catch (e3) {
          return e3.throw();
        }
      }
      _getDefaultPlayerConfig() {
        return { mirror: true, fit: "cover" };
      }
      onTrackEnded() {
        if ((Yh() || tp()) && this._enabled && !this._isClosed && Gg.duringInterruption) {
          const e2 = async () => {
            Gg.off(kg.IOS_INTERRUPTION_END, e2), this._enabled && !this._isClosed && (OE.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
          };
          Gg.on(kg.IOS_INTERRUPTION_END, e2);
        } else
          OE.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(mS.TRACK_ENDED);
      }
      async renewMediaStreamTrack(e2) {
        const t2 = e2 || this._constraints, i3 = lR.searchDeviceIdByName(this._deviceName);
        if (i3 && !t2.deviceId && (t2.deviceId = { exact: i3 }), this._enabled) {
          const e3 = await aR({ video: t2 }, this.getTrackId());
          this._constraints = t2, await this._updateOriginMediaStreamTrack(e3.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
        }
      }
      close() {
        super.close(), Gg.off(kg.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), Gg.off(kg.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
      }
      bindProcessorContextEvents() {
        this.processorContext.on(MS.REQUEST_UPDATE_CONSTRAINTS, async (e2, t2, i3) => {
          try {
            const i4 = Object.assign({}, this._originalConstraints, ...e2);
            await this.renewMediaStreamTrack(i4), t2();
          } catch (e3) {
            i3(e3);
          }
        }), this.processorContext.on(MS.REQUEST_CONSTRAINTS, async (e2) => {
          e2(this._originMediaStreamTrack.getSettings());
        });
      }
    }).prototype, "setDevice", [ly, hy], Object.getOwnPropertyDescriptor(Ty.prototype, "setDevice"), Ty.prototype), ag(Ty.prototype, "setEnabled", [py, _y, Ey], Object.getOwnPropertyDescriptor(Ty.prototype, "setEnabled"), Ty.prototype), ag(Ty.prototype, "setEncoderConfiguration", [my, fy], Object.getOwnPropertyDescriptor(Ty.prototype, "setEncoderConfiguration"), Ty.prototype), ag(Ty.prototype, "close", [Sy], Object.getOwnPropertyDescriptor(Ty.prototype, "close"), Ty.prototype), Ty);
    class yy {
      get hasVideo() {
        return this._video_enabled_ && !this._video_muted_ && this._video_added_;
      }
      get hasAudio() {
        return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
      }
      get audioTrack() {
        if (this.hasAudio)
          return this._audioTrack;
      }
      get videoTrack() {
        if (this.hasVideo)
          return this._videoTrack;
      }
      constructor(e2, t2) {
        _p(this, "uid", void 0), _p(this, "_uintid", void 0), _p(this, "_trust_in_room_", true), _p(this, "_trust_audio_enabled_state_", true), _p(this, "_trust_video_enabled_state_", true), _p(this, "_trust_audio_mute_state_", true), _p(this, "_trust_video_mute_state_", true), _p(this, "_audio_muted_", false), _p(this, "_video_muted_", false), _p(this, "_audio_enabled_", true), _p(this, "_video_enabled_", true), _p(this, "_audio_added_", false), _p(this, "_video_added_", false), _p(this, "_trust_video_stream_added_state_", true), _p(this, "_trust_audio_stream_added_state_", true), _p(this, "_audioTrack", void 0), _p(this, "_videoTrack", void 0), _p(this, "_audioSSRC", void 0), _p(this, "_videoSSRC", void 0), _p(this, "_audioOrtc", void 0), _p(this, "_videoOrtc", void 0), _p(this, "_cname", void 0), _p(this, "_rtxSsrcId", void 0), this.uid = e2, this._uintid = t2;
      }
    }
    var Ay = fl, Oy = pd, Ny = Rd;
    Ii({ target: "Promise", stat: true }, { try: function(e2) {
      var t2 = Oy.f(this), i3 = Ny(e2);
      return (i3.error ? t2.reject : t2.resolve)(i3.value), t2.promise;
    } });
    var by = Ay, wy = Ii, Dy = h2, Py = i2, Ly = QS, ky = q, My = je, Uy = bi, xy = im, Vy = oT, jy = FT, Fy = ae, By = rt("isConcatSpreadable"), Gy = 9007199254740991, Wy = "Maximum allowed index exceeded", Hy = Dy.TypeError, Ky = Fy >= 51 || !Py(function() {
      var e2 = [];
      return e2[By] = false, e2.concat()[0] !== e2;
    }), Yy = jy("concat"), qy = function(e2) {
      if (!ky(e2))
        return false;
      var t2 = e2[By];
      return void 0 !== t2 ? !!t2 : Ly(e2);
    };
    wy({ target: "Array", proto: true, forced: !Ky || !Yy }, { concat: function(e2) {
      var t2, i3, n2, r2, o2, s2 = My(this), a2 = Vy(s2, 0), c2 = 0;
      for (t2 = -1, n2 = arguments.length; t2 < n2; t2++)
        if (qy(o2 = -1 === t2 ? s2 : arguments[t2])) {
          if (c2 + (r2 = Uy(o2)) > Gy)
            throw Hy(Wy);
          for (i3 = 0; i3 < r2; i3++, c2++)
            i3 in o2 && xy(a2, c2, o2[i3]);
        } else {
          if (c2 >= Gy)
            throw Hy(Wy);
          xy(a2, c2++, o2);
        }
      return a2.length = c2, a2;
    } });
    var Jy = {}, Xy = k2, zy = K, Qy = Pn.f, Zy = cm, $y = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    Jy.f = function(e2) {
      return $y && "Window" == Xy(e2) ? function(e3) {
        try {
          return Qy(e3);
        } catch (e4) {
          return Zy($y);
        }
      }(e2) : Qy(zy(e2));
    };
    var eA = {}, tA = rt;
    eA.f = tA;
    var iA = J, nA = Ge, rA = eA, oA = Ht.f, sA = function(e2) {
      var t2 = iA.Symbol || (iA.Symbol = {});
      nA(t2, e2) || oA(t2, e2, { value: rA.f(e2) });
    }, aA = Ii, cA = h2, dA = $, uA = f, lA = C, hA = d, pA = g, _A = ue, EA = i2, mA = Ge, fA = QS, SA = S, TA = q, gA = u, RA = fe, IA = zt, CA = je, vA = K, yA = Et2, AA = wo, OA = w2, NA = Pr, bA = hr, wA = Pn, DA = Jy, PA = Zn, LA = T, kA = Ht, MA = dr, UA = v, xA = pc, VA = xs, jA = we.exports, FA = Gn, BA = qe, GA = rt, WA = eA, HA = sA, KA = ta, YA = bs, qA = pT.forEach, JA = pn("hidden"), XA = "Symbol", zA = GA("toPrimitive"), QA = YA.set, ZA = YA.getterFor(XA), $A = Object.prototype, eO = cA.Symbol, tO = eO && eO.prototype, iO = cA.TypeError, nO = cA.QObject, rO = dA("JSON", "stringify"), oO = LA.f, sO = kA.f, aO = DA.f, cO = UA.f, dO = hA([].push), uO = jA("symbols"), lO = jA("op-symbols"), hO = jA("string-to-symbol-registry"), pO = jA("symbol-to-string-registry"), _O = jA("wks"), EO = !nO || !nO.prototype || !nO.prototype.findChild, mO = pA && EA(function() {
      return 7 != NA(sO({}, "a", { get: function() {
        return sO(this, "a", { value: 7 }).a;
      } })).a;
    }) ? function(e2, t2, i3) {
      var n2 = oO($A, t2);
      n2 && delete $A[t2], sO(e2, t2, i3), n2 && e2 !== $A && sO($A, t2, n2);
    } : sO, fO = function(e2, t2) {
      var i3 = uO[e2] = NA(tO);
      return QA(i3, { type: XA, tag: e2, description: t2 }), pA || (i3.description = t2), i3;
    }, SO = function(e2, t2, i3) {
      e2 === $A && SO(lO, t2, i3), IA(e2);
      var n2 = yA(t2);
      return IA(i3), mA(uO, n2) ? (i3.enumerable ? (mA(e2, JA) && e2[JA][n2] && (e2[JA][n2] = false), i3 = NA(i3, { enumerable: OA(0, false) })) : (mA(e2, JA) || sO(e2, JA, OA(1, {})), e2[JA][n2] = true), mO(e2, n2, i3)) : sO(e2, n2, i3);
    }, TO = function(e2, t2) {
      IA(e2);
      var i3 = vA(t2), n2 = bA(i3).concat(CO(i3));
      return qA(n2, function(t3) {
        pA && !lA(gO, i3, t3) || SO(e2, t3, i3[t3]);
      }), e2;
    }, gO = function(e2) {
      var t2 = yA(e2), i3 = lA(cO, this, t2);
      return !(this === $A && mA(uO, t2) && !mA(lO, t2)) && (!(i3 || !mA(this, t2) || !mA(uO, t2) || mA(this, JA) && this[JA][t2]) || i3);
    }, RO = function(e2, t2) {
      var i3 = vA(e2), n2 = yA(t2);
      if (i3 !== $A || !mA(uO, n2) || mA(lO, n2)) {
        var r2 = oO(i3, n2);
        return !r2 || !mA(uO, n2) || mA(i3, JA) && i3[JA][n2] || (r2.enumerable = true), r2;
      }
    }, IO = function(e2) {
      var t2 = aO(vA(e2)), i3 = [];
      return qA(t2, function(e3) {
        mA(uO, e3) || mA(FA, e3) || dO(i3, e3);
      }), i3;
    }, CO = function(e2) {
      var t2 = e2 === $A, i3 = aO(t2 ? lO : vA(e2)), n2 = [];
      return qA(i3, function(e3) {
        !mA(uO, e3) || t2 && !mA($A, e3) || dO(n2, uO[e3]);
      }), n2;
    };
    (_A || (VA(tO = (eO = function() {
      if (gA(tO, this))
        throw iO("Symbol is not a constructor");
      var e2 = arguments.length && void 0 !== arguments[0] ? AA(arguments[0]) : void 0, t2 = BA(e2), i3 = function(e3) {
        this === $A && lA(i3, lO, e3), mA(this, JA) && mA(this[JA], t2) && (this[JA][t2] = false), mO(this, t2, OA(1, e3));
      };
      return pA && EO && mO($A, t2, { configurable: true, set: i3 }), fO(t2, e2);
    }).prototype, "toString", function() {
      return ZA(this).tag;
    }), VA(eO, "withoutSetter", function(e2) {
      return fO(BA(e2), e2);
    }), UA.f = gO, kA.f = SO, MA.f = TO, LA.f = RO, wA.f = DA.f = IO, PA.f = CO, WA.f = function(e2) {
      return fO(GA(e2), e2);
    }, pA && sO(tO, "description", { configurable: true, get: function() {
      return ZA(this).description;
    } })), aA({ global: true, wrap: true, forced: !_A, sham: !_A }, { Symbol: eO }), qA(bA(_O), function(e2) {
      HA(e2);
    }), aA({ target: XA, stat: true, forced: !_A }, { for: function(e2) {
      var t2 = AA(e2);
      if (mA(hO, t2))
        return hO[t2];
      var i3 = eO(t2);
      return hO[t2] = i3, pO[i3] = t2, i3;
    }, keyFor: function(e2) {
      if (!RA(e2))
        throw iO(e2 + " is not a symbol");
      if (mA(pO, e2))
        return pO[e2];
    }, useSetter: function() {
      EO = true;
    }, useSimple: function() {
      EO = false;
    } }), aA({ target: "Object", stat: true, forced: !_A, sham: !pA }, { create: function(e2, t2) {
      return void 0 === t2 ? NA(e2) : TO(NA(e2), t2);
    }, defineProperty: SO, defineProperties: TO, getOwnPropertyDescriptor: RO }), aA({ target: "Object", stat: true, forced: !_A }, { getOwnPropertyNames: IO, getOwnPropertySymbols: CO }), aA({ target: "Object", stat: true, forced: EA(function() {
      PA.f(1);
    }) }, { getOwnPropertySymbols: function(e2) {
      return PA.f(CA(e2));
    } }), rO) && aA({ target: "JSON", stat: true, forced: !_A || EA(function() {
      var e2 = eO();
      return "[null]" != rO([e2]) || "{}" != rO({ a: e2 }) || "{}" != rO(Object(e2));
    }) }, { stringify: function(e2, t2, i3) {
      var n2 = xA(arguments), r2 = t2;
      if ((TA(t2) || void 0 !== e2) && !RA(e2))
        return fA(t2) || (t2 = function(e3, t3) {
          if (SA(r2) && (t3 = lA(r2, this, e3, t3)), !RA(t3))
            return t3;
        }), n2[1] = t2, uA(rO, null, n2);
    } });
    if (!tO[zA]) {
      var vO = tO.valueOf;
      VA(tO, zA, function(e2) {
        return lA(vO, this);
      });
    }
    KA(eO, XA), FA[JA] = true, sA("asyncIterator"), sA("hasInstance"), sA("isConcatSpreadable"), sA("iterator"), sA("match"), sA("matchAll"), sA("replace"), sA("search"), sA("species"), sA("split"), sA("toPrimitive"), sA("toStringTag"), sA("unscopables"), ta(h2.JSON, "JSON", true);
    var yO = J.Symbol;
    sA("asyncDispose"), sA("dispose"), sA("matcher"), sA("metadata"), sA("observable"), sA("patternMatch"), sA("replaceAll");
    var AO = yO, OO = eA.f("asyncIterator"), NO2 = OO;
    function bO(e2) {
      this.wrapped = e2;
    }
    function wO(e2) {
      var t2, i3;
      function n2(t3, i4) {
        try {
          var o2 = e2[t3](i4), s2 = o2.value, a2 = s2 instanceof bO;
          by.resolve(a2 ? s2.wrapped : s2).then(function(e3) {
            a2 ? n2("return" === t3 ? "return" : "next", e3) : r2(o2.done ? "return" : "normal", e3);
          }, function(e3) {
            n2("throw", e3);
          });
        } catch (e3) {
          r2("throw", e3);
        }
      }
      function r2(e3, r3) {
        switch (e3) {
          case "return":
            t2.resolve({ value: r3, done: true });
            break;
          case "throw":
            t2.reject(r3);
            break;
          default:
            t2.resolve({ value: r3, done: false });
        }
        (t2 = t2.next) ? n2(t2.key, t2.arg) : i3 = null;
      }
      this._invoke = function(e3, r3) {
        return new by(function(o2, s2) {
          var a2 = { key: e3, arg: r3, resolve: o2, reject: s2, next: null };
          i3 ? i3 = i3.next = a2 : (t2 = i3 = a2, n2(e3, r3));
        });
      }, "function" != typeof e2.return && (this.return = void 0);
    }
    function DO(e2) {
      return function() {
        return new wO(e2.apply(this, arguments));
      };
    }
    function PO(e2) {
      return new bO(e2);
    }
    wO.prototype["function" == typeof AO && NO2 || "@@asyncIterator"] = function() {
      return this;
    }, wO.prototype.next = function(e2) {
      return this._invoke("next", e2);
    }, wO.prototype.throw = function(e2) {
      return this._invoke("throw", e2);
    }, wO.prototype.return = function(e2) {
      return this._invoke("return", e2);
    };
    var LO = eA.f("iterator");
    function kO(e2, t2) {
      var i3 = {}, n2 = false;
      function r2(i4, r3) {
        return n2 = true, r3 = new by(function(t3) {
          t3(e2[i4](r3));
        }), { done: false, value: t2(r3) };
      }
      return i3[void 0 !== AO && LO || "@@iterator"] = function() {
        return this;
      }, i3.next = function(e3) {
        return n2 ? (n2 = false, e3) : r2("next", e3);
      }, "function" == typeof e2.throw && (i3.throw = function(e3) {
        if (n2)
          throw n2 = false, e3;
        return r2("throw", e3);
      }), "function" == typeof e2.return && (i3.return = function(e3) {
        return n2 ? (n2 = false, e3) : r2("return", e3);
      }), i3;
    }
    var MO = OO, UO = { exports: {} };
    function xO(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function VO(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? xO(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : xO(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    function jO(e2, t2, i3, n2, r2, o2, s2) {
      let a2 = [], c2 = [], d2 = [], u2 = [], l2 = false, h3 = false;
      if (UO.exports.parse(e2).mediaDescriptions.forEach((e3) => {
        s2 && s2 !== e3.attributes.direction || ("video" !== e3.media.mediaType || l2 || (c2 = e3.attributes.payloads, u2 = e3.attributes.extmaps, l2 = true), "audio" !== e3.media.mediaType || h3 || (a2 = e3.attributes.payloads, d2 = e3.attributes.extmaps, h3 = true));
      }), !u2 || 0 === c2.length)
        throw new Error("Cannot get video capabilities from SDP.");
      if (!d2 || 0 === a2.length)
        throw new Error("Cannot get audio capabilities from SDP.");
      return c2.forEach((e3) => {
        var t3;
        null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate));
      }), a2.forEach((e3) => {
        var t3;
        null !== (t3 = e3.rtpMap) && void 0 !== t3 && t3.clockRate && (e3.rtpMap.clockRate = parseInt(e3.rtpMap.clockRate));
      }), t2 && (a2 = a2.filter((e3) => {
        var t3;
        return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
      }), c2 = c2.filter((e3) => {
        var t3;
        return "rtx" !== (null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase());
      })), i3 && (c2 = c2.filter((e3) => {
        var t3;
        return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
      })), n2 && (a2 = a2.filter((e3) => {
        var t3;
        return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName) || "");
      })), r2 && (null == r2 ? void 0 : r2.length) > 0 && (a2 = a2.filter((e3) => {
        var t3;
        return r2.includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
      })), o2 && (null == o2 ? void 0 : o2.length) > 0 && (c2 = c2.filter((e3) => {
        var t3;
        return o2.includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "");
      })), { audioCodecs: a2, videoCodecs: c2, audioExtensions: d2, videoExtensions: u2 };
    }
    function FO(e2) {
      const t2 = UO.exports.parse(e2);
      let i3, n2;
      for (const e3 of t2.mediaDescriptions) {
        if (!i3) {
          const t3 = e3.attributes.iceUfrag, n3 = e3.attributes.icePwd;
          if (!t3 || !n3)
            throw new Error("Cannot get iceUfrag or icePwd from SDP.");
          i3 = { iceUfrag: t3, icePwd: n3 };
        }
        if (!n2) {
          const t3 = e3.attributes.fingerprints;
          t3.length > 0 && (n2 = { fingerprints: t3 });
        }
      }
      if (!n2 && t2.attributes.fingerprints.length > 0 && (n2 = { fingerprints: t2.attributes.fingerprints }), !n2 || !i3)
        throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
      return { iceParameters: i3, dtlsParameters: n2 };
    }
    function BO(e2, t2) {
      const i3 = [], n2 = e2.attributes.ssrcGroups.filter((e3) => "FID" === e3.semantic), r2 = e2.attributes.ssrcGroups.find((e3) => "SIM" === e3.semantic), o2 = e2.attributes.ssrcs;
      if (r2)
        r2.ssrcIds.forEach((e3) => {
          var r3;
          const o3 = null === (r3 = n2.find((t3) => t3.ssrcIds[0] === e3)) || void 0 === r3 ? void 0 : r3.ssrcIds[1];
          i3.push({ ssrcId: e3, rtx: t2 ? o3 : void 0 });
        });
      else if (n2.length > 0) {
        const e3 = n2[0].ssrcIds[0], r3 = n2[0].ssrcIds[1];
        i3.push({ ssrcId: e3, rtx: t2 ? r3 : void 0 });
      } else {
        if (0 === o2.length)
          throw new Error("No ssrcs found on local media description.");
        i3.push({ ssrcId: o2[0].ssrcId });
      }
      return i3;
    }
    function GO(e2, t2) {
      const { cname: i3 } = e2;
      let n2;
      t2 && t2.ip && "number" == typeof t2.port ? (n2 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip, port: t2.port.toString(), type: "host", extension: {} }], OE.debug("Using remote candidate from AP ".concat(t2.ip, ":").concat(t2.port)), t2.ip6 && (n2.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t2.ip6, port: t2.port.toString(), type: "host", extension: {} }), OE.debug("Using IPV6 remote candidate from AP ".concat(t2.ip6, ":").concat(t2.port)))) : n2 = e2.iceParameters.candidates.map((e3) => ({ foundation: e3.foundation, componentId: "1", transport: e3.protocol, priority: e3.priority.toString(), connectionAddress: e3.ip, port: e3.port.toString(), type: e3.type, extension: {} }));
      const r2 = { fingerprints: e2.dtlsParameters.fingerprints.map((e3) => ({ hashFunction: e3.algorithm, fingerprint: e3.fingerprint })) }, o2 = { iceUfrag: e2.iceParameters.iceUfrag, icePwd: e2.iceParameters.icePwd };
      let s2;
      switch (e2.dtlsParameters.role) {
        case "server":
          s2 = "passive";
          break;
        case "client":
          s2 = "active";
          break;
        case "auto":
          s2 = "actpass";
      }
      return { dtlsParameters: r2, iceParameters: o2, candidates: n2, rtpCapabilities: ZO(e2.rtpCapabilities), setup: s2, cname: i3 };
    }
    function WO(e2, t2, i3) {
      const n2 = [], r2 = [];
      return e2.forEach((e3) => {
        let { ssrcId: o2, rtx: s2 } = e3;
        const a2 = ZI(8, "track-"), c2 = { ssrcId: o2, attributes: VO({ label: a2, mslabel: i3 = i3 || ZI(10, ""), msid: "".concat(i3, " ").concat(a2) }, t2 && { cname: t2 }) };
        if (n2.push(c2), void 0 !== s2) {
          const e4 = { ssrcId: s2, attributes: VO({ label: a2, mslabel: i3, msid: "".concat(i3, " ").concat(a2) }, t2 && { cname: t2 }) };
          n2.push(e4), r2.push({ semantic: "FID", ssrcIds: [o2, s2] });
        }
      }), e2.length > 1 && r2.push({ semantic: "SIM", ssrcIds: e2.map((e3) => {
        let { ssrcId: t3 } = e3;
        return t3;
      }) }), { ssrcs: n2, ssrcGroups: r2 };
    }
    function HO(e2, t2) {
      t2 instanceof yI && e2.attributes.payloads.forEach((e3) => {
        var i3;
        const n2 = null === (i3 = e3.rtpMap) || void 0 === i3 ? void 0 : i3.encodingName.toLowerCase();
        if (!n2 || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n2))
          return;
        e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.minptime = "10", e3.fmtp.parameters.useinbandfec = "1";
        const r2 = t2._encoderConfig;
        r2 && "pcmu" !== n2 && "pcma" !== n2 && "g722" !== n2 && (r2.bitrate && !Kh() && (e3.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * r2.bitrate))), r2.sampleRate && (e3.fmtp.parameters.maxplaybackrate = "".concat(r2.sampleRate), e3.fmtp.parameters["sprop-maxcapturerate"] = "".concat(r2.sampleRate)), r2.stereo && (e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1"));
      });
    }
    function KO(e2) {
      const t2 = e2.attributes.unrecognized.findIndex((e3) => "x-google-flag" === e3.attField && "conference" === e3.attValue);
      -1 !== t2 && e2.attributes.unrecognized.splice(t2, 1);
    }
    function YO(e2, t2) {
      if (!(t2 instanceof Cy && t2._encoderConfig && -1 === t2._hints.indexOf(lS.SCREEN_TRACK)))
        return;
      const i3 = t2._encoderConfig;
      JS().supportMinBitrate && i3.bitrateMin && e2.attributes.payloads.forEach((e3) => {
        var t3;
        ["h264", "h265", "vp8", "vp9", "av1"].includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-min-bitrate"] = "".concat(i3.bitrateMin));
      }), JS().supportMinBitrate && !t2._hints.includes(lS.LOW_STREAM) && i3.bitrateMax && e2.attributes.payloads.forEach((e3) => {
        var t3;
        ["h264", "h265", "vp8", "vp9", "av1"].includes((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "") && (e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters["x-google-start-bitrate"] = "".concat(GE("X_GOOGLE_START_BITRATE") || Math.floor(i3.bitrateMax)));
      });
    }
    function qO(e2) {
      if ("video" !== e2.media.mediaType)
        return;
      const t2 = xh();
      if (t2.name !== wh.SAFARI && t2.os !== bh.IOS)
        return;
      const i3 = e2.attributes.extmaps.findIndex((e3) => /video-orientation/g.test(e3.extensionName));
      -1 !== i3 && e2.attributes.extmaps.splice(i3, 1);
    }
    function JO(e2, t2, i3) {
      if (!t2)
        return;
      let n2, r2;
      if ("video" === e2.media.mediaType ? (n2 = i3.videoExtensions, r2 = i3.videoCodecs) : (n2 = i3.audioExtensions, r2 = i3.audioCodecs), true === t2.twcc) {
        const t3 = n2.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
        if (t3) {
          e2.attributes.extmaps.find((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" });
          (function(e3, t4) {
            return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "transport-cc" === e5.type)));
          })(r2, e2.attributes.payloads).forEach((e3) => {
            e3.rtcpFeedbacks.find((e4) => "transport-cc" === e4.type) || e3.rtcpFeedbacks.push({ type: "transport-cc" });
          });
        }
      } else if (false === t2.twcc) {
        const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e3.extensionName);
        -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
          const t4 = e3.rtcpFeedbacks.findIndex((e4) => "transport-cc" === e4.type);
          -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
        });
      }
      if (true === t2.remb) {
        const t3 = n2.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
        if (t3) {
          e2.attributes.extmaps.find((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName) || e2.attributes.extmaps.push({ entry: t3.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" });
          (function(e3, t4) {
            return t4.filter((t5) => !!e3.find((e4) => e4.payloadType === t5.payloadType && !!e4.rtcpFeedbacks.find((e5) => "goog-remb" === e5.type)));
          })(r2, e2.attributes.payloads).forEach((e3) => {
            e3.rtcpFeedbacks.find((e4) => "goog-remb" === e4.type) || e3.rtcpFeedbacks.push({ type: "goog-remb" });
          });
        }
      } else if (false === t2.remb) {
        const t3 = e2.attributes.extmaps.findIndex((e3) => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e3.extensionName);
        -1 !== t3 && e2.attributes.extmaps.splice(t3, 1), e2.attributes.payloads.forEach((e3) => {
          const t4 = e3.rtcpFeedbacks.findIndex((e4) => "goog-remb" === e4.type);
          -1 !== t4 && e3.rtcpFeedbacks.splice(t4, 1);
        });
      }
    }
    function XO(e2, t2, i3) {
      if (Kh())
        return;
      if ("video" !== e2.media.mediaType)
        return;
      if (!(t2 instanceof Cy))
        return;
      if ("vp9" !== i3 && "vp8" !== i3)
        return;
      if ("vp8" === i3 && !GE("SIMULCAST"))
        return;
      if (void 0 === t2._scalabiltyMode || t2._scalabiltyMode.numSpatialLayers <= 1)
        return;
      const n2 = "vp8" === i3 ? 2 : t2._scalabiltyMode.numSpatialLayers, r2 = e2.attributes.ssrcs[0], o2 = e2.attributes.ssrcGroups.find((e3) => "FID" === e3.semantic && e3.ssrcIds[0] === r2.ssrcId), s2 = { semantic: "SIM", ssrcIds: [r2.ssrcId] };
      for (let t3 = 1; t3 < n2; t3++)
        e2.attributes.ssrcs.push({ ssrcId: r2.ssrcId + t3, attributes: uC(r2.attributes) }), s2.ssrcIds.push(r2.ssrcId + t3), o2 && (e2.attributes.ssrcs.push({ ssrcId: o2.ssrcIds[1] + t3, attributes: uC(r2.attributes) }), e2.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r2.ssrcId + t3, o2.ssrcIds[1] + t3] }));
      e2.attributes.ssrcGroups.unshift(s2);
    }
    async function zO(e2, t2, i3, n2, r2) {
      const o2 = new RTCPeerConnection();
      o2.addTransceiver("video", { direction: "sendonly" }), o2.addTransceiver("audio", { direction: "sendonly" }), o2.addTransceiver("video", { direction: "recvonly" }), o2.addTransceiver("audio", { direction: "recvonly" });
      const s2 = (await o2.createOffer()).sdp, a2 = jO(s2, e2, t2, i3, n2, r2, "sendonly"), c2 = jO(s2, e2, t2, i3, n2, r2, "recvonly"), d2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, u2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, l2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
      if (QO(a2, c2, "videoExtensions", d2, u2, l2), QO(a2, c2, "videoCodecs", d2, u2, l2), QO(a2, c2, "audioExtensions", d2, u2, l2), QO(a2, c2, "audioCodecs", d2, u2, l2), GE("RAISE_H264_BASELINE_PRIORITY")) {
        const e3 = l2.videoCodecs.findIndex((e4) => {
          var t3, i4;
          return "h264" === (null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLocaleLowerCase()) && "42001f" === (null === (i4 = e4.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]);
        });
        if (-1 !== e3) {
          const t3 = l2.videoCodecs.findIndex((e4) => {
            var t4;
            return "h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase());
          });
          if (t3 < e3) {
            OE.debug("raising H264 baseline profile priority");
            const i4 = l2.videoCodecs[e3];
            l2.videoCodecs.splice(e3, 1), l2.videoCodecs.splice(t3, 0, i4);
          }
          -1 !== t3 && (u2.videoCodecs = u2.videoCodecs.filter((e4) => {
            var t4, i4;
            return !("h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e4.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
          })), -1 !== t3 && GE("FILTER_SEND_H264_BASELINE") && (d2.videoCodecs = d2.videoCodecs.filter((e4) => {
            var t4, i4;
            return !("h264" === (null === (t4 = e4.rtpMap) || void 0 === t4 ? void 0 : t4.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (i4 = e4.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]));
          }));
        }
      }
      try {
        o2.close();
      } catch (e3) {
      }
      return { send: d2, recv: u2, sendrecv: l2 };
    }
    function QO(e2, t2, i3, n2, r2, o2) {
      if ("videoExtensions" === i3 || "audioExtensions" === i3) {
        const s2 = [];
        return e2[i3].forEach((e3) => {
          t2[i3].some((t3, i4) => {
            if (e3.entry === t3.entry && e3.extensionName === t3.extensionName)
              return s2.push(i4), true;
          }) ? o2[i3].push(e3) : n2[i3].push(e3);
        }), void t2[i3].forEach((e3, t3) => {
          -1 === s2.indexOf(t3) && r2[i3].push(e3);
        });
      }
      if ("videoCodecs" === i3 || "audioCodecs" === i3) {
        const s2 = [];
        return e2[i3].forEach((e3) => {
          t2[i3].some((t3, i4) => {
            if (e3.payloadType === t3.payloadType && JSON.stringify(e3) === JSON.stringify(t3))
              return s2.push(i4), true;
          }) ? o2[i3].push(e3) : n2[i3].push(e3);
        }), void t2[i3].forEach((e3, t3) => {
          -1 === s2.indexOf(t3) && r2[i3].push(e3);
        });
      }
    }
    function ZO(e2) {
      const { send: t2, recv: i3, sendrecv: n2 } = e2;
      if (!n2) {
        if (!t2 || !i3)
          throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
        return { send: t2, recv: i3 };
      }
      let r2, o2;
      return t2 ? (r2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r2.audioCodecs = [...t2.audioCodecs, ...n2.audioCodecs], r2.videoCodecs = [...t2.videoCodecs, ...n2.videoCodecs], r2.audioExtensions = [...t2.audioExtensions, ...n2.audioExtensions], r2.videoExtensions = [...t2.videoExtensions, ...n2.videoExtensions]) : r2 = n2, i3 ? (o2 = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o2.audioCodecs = [...i3.audioCodecs, ...n2.audioCodecs], o2.videoCodecs = [...i3.videoCodecs, ...n2.videoCodecs], o2.audioExtensions = [...i3.audioExtensions, ...n2.audioExtensions], o2.videoExtensions = [...i3.videoExtensions, ...n2.videoExtensions]) : o2 = n2, { send: r2, recv: o2 };
    }
    function $O(e2) {
      if ("audio" !== e2.media.mediaType)
        return;
      e2.attributes.payloads.filter((e3) => {
        var t2;
        return "opus" === (null === (t2 = e3.rtpMap) || void 0 === t2 ? void 0 : t2.encodingName.toLowerCase());
      }).forEach((e3) => {
        e3.fmtp || (e3.fmtp = { parameters: {} }), e3.fmtp.parameters.stereo = "1", e3.fmtp.parameters["sprop-stereo"] = "1";
      });
    }
    function eN(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function tN(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? eN(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : eN(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    !function(e2, t2) {
      e2.exports = (() => {
        var e3 = { 8: (e4, t4, i4) => {
          i4.r(t4), i4.d(t4, { Parser: () => I2, Printer: () => O2, parse: () => D2, print: () => P2 });
          const n2 = "\n", r2 = "".concat("\r").concat(n2), o2 = " ";
          let s2;
          function a2(e5) {
            return e5 >= "0" && e5 <= "9";
          }
          function c2(e5) {
            return e5 >= "!" && e5 <= "~";
          }
          function d2(e5) {
            return c2(e5) || e5 >= "" && e5 <= "ÿ";
          }
          function u2(e5) {
            return "!" === e5 || e5 >= "#" && e5 <= "'" || e5 >= "*" && e5 <= "+" || e5 >= "-" && e5 <= "." || e5 >= "0" && e5 <= "9" || e5 >= "A" && e5 <= "Z" || e5 >= "^" && e5 <= "~";
          }
          function l2(e5) {
            return e5 >= "1" && e5 <= "9";
          }
          function h3(e5) {
            return e5 >= "A" && e5 <= "Z" || e5 >= "a" && e5 <= "z";
          }
          function p3(e5) {
            return "d" === e5 || "h" === e5 || "m" === e5 || "s" === e5;
          }
          function _2(e5) {
            return e5 > "" && e5 < "	" || e5 > "\v" && e5 < "\f" || e5 > "" && e5 < "ÿ";
          }
          function E2(e5) {
            return h3(e5) || a2(e5) || "+" === e5 || "/" === e5;
          }
          function m2(e5) {
            return a2(e5) || h3(e5) || "+" === e5 || "/" === e5 || "-" === e5 || "_" === e5;
          }
          function f2(e5) {
            return h3(e5) || a2(e5) || "+" === e5 || "/" === e5;
          }
          function S2(e5, t5) {
            var i5 = Object.keys(e5);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(e5);
              t5 && (n3 = n3.filter(function(t6) {
                return Object.getOwnPropertyDescriptor(e5, t6).enumerable;
              })), i5.push.apply(i5, n3);
            }
            return i5;
          }
          function T2(e5) {
            for (var t5 = 1; t5 < arguments.length; t5++) {
              var i5 = null != arguments[t5] ? arguments[t5] : {};
              t5 % 2 ? S2(Object(i5), true).forEach(function(t6) {
                g2(e5, t6, i5[t6]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i5)) : S2(Object(i5)).forEach(function(t6) {
                Object.defineProperty(e5, t6, Object.getOwnPropertyDescriptor(i5, t6));
              });
            }
            return e5;
          }
          function g2(e5, t5, i5) {
            return t5 in e5 ? Object.defineProperty(e5, t5, { value: i5, enumerable: true, configurable: true, writable: true }) : e5[t5] = i5, e5;
          }
          !function(e5) {
            e5.VERSION = "v", e5.ORIGIN = "o", e5.SESSION_NAME = "s", e5.INFORMATION = "i", e5.URI = "u", e5.EMAIL = "e", e5.PHONE = "p", e5.CONNECTION = "c", e5.BANDWIDTH = "b", e5.TIME = "t", e5.REPEAT = "r", e5.ZONE_ADJUSTMENTS = "z", e5.KEY = "k", e5.ATTRIBUTE = "a", e5.MEDIA = "m";
          }(s2 || (s2 = {}));
          class R2 {
            consumeText(e5, t5) {
              let i5 = t5;
              for (; i5 < e5.length; ) {
                const t6 = e5[i5];
                if ("\0" === t6 || "\r" === t6 || t6 === n2)
                  break;
                i5 += 1;
              }
              if (i5 - t5 == 0)
                throw new Error("Invalid text, at ".concat(e5));
              return i5;
            }
            consumeUnicastAddress(e5, t5, i5) {
              return this.consumeTill(e5, t5, o2);
            }
            consumeOneOrMore(e5, t5, i5) {
              let n3 = t5;
              for (; i5(e5[n3]); )
                n3++;
              if (n3 - t5 == 0)
                throw new Error("Invalid rule at ".concat(t5, "."));
              return n3;
            }
            consumeSpace(e5, t5) {
              if (e5[t5] === o2)
                return t5 + 1;
              throw new Error("Invalid space at ".concat(t5, "."));
            }
            consumeIP4Address(e5, t5) {
              let i5 = t5;
              for (let t6 = 0; t6 < 4; t6++)
                if (i5 = this.consumeDecimalUChar(e5, i5), 3 !== t6) {
                  if ("." !== e5[i5])
                    throw new Error("Invalid IP4 address.");
                  i5++;
                }
              return i5;
            }
            consumeDecimalUChar(e5, t5) {
              let i5 = t5;
              for (let t6 = 0; t6 < 3 && a2(e5[i5]); t6++, i5++)
                ;
              if (i5 - t5 == 0)
                throw new Error("Invalid decimal uchar.");
              const n3 = parseInt(e5.slice(t5, i5));
              if (n3 >= 0 && n3 <= 255)
                return i5;
              throw new Error("Invalid decimal uchar");
            }
            consumeIP6Address(e5, t5) {
              let i5 = this.consumeHexpart(e5, t5);
              return ":" === e5[i5] ? (i5 += 1, i5 = this.consumeIP4Address(e5, i5), i5) : i5;
            }
            consumeHexpart(e5, t5) {
              let i5 = t5;
              if (":" === e5[i5] && ":" === e5[i5 + 1]) {
                i5 += 2;
                try {
                  i5 = this.consumeHexseq(e5, i5);
                } catch (e6) {
                }
                return i5;
              }
              if (i5 = this.consumeHexseq(e5, i5), ":" === e5[i5] && ":" === e5[i5 + 1]) {
                i5 += 2;
                try {
                  i5 = this.consumeHexseq(e5, i5);
                } catch (e6) {
                }
                return i5;
              }
              return i5;
            }
            consumeHexseq(e5, t5) {
              let i5 = t5;
              for (; i5 = this.consumeHex4(e5, i5), ":" === e5[i5] && ":" !== e5[i5 + 1]; )
                i5 += 1;
              return i5;
            }
            consumeHex4(e5, t5) {
              let i5 = 0;
              for (; i5 < 4; i5++)
                if (!((n3 = e5[t5 + i5]) >= "0" && n3 <= "9" || n3 >= "a" && n3 <= "f" || n3 >= "A" && n3 <= "F")) {
                  if (0 === i5)
                    throw new Error("Invalid hex 4");
                  break;
                }
              var n3;
              return t5 + i5;
            }
            consumeFQDN(e5, t5) {
              let i5 = t5;
              for (; a2(e5[i5]) || h3(e5[i5]) || "-" === e5[i5] || "." === e5[i5]; )
                i5 += 1;
              if (i5 - t5 < 4)
                throw new Error("Invalid FQDN");
              return i5;
            }
            consumeExtnAddr(e5, t5) {
              return this.consumeOneOrMore(e5, t5, d2);
            }
            consumeMulticastAddress(e5, t5, i5) {
              switch (i5) {
                case "IP4":
                case "ip4":
                  return this.consumeIP4MulticastAddress(e5, t5);
                case "IP6":
                case "ip6":
                  return this.consumeIP6MulticastAddress(e5, t5);
                default:
                  try {
                    return this.consumeFQDN(e5, t5);
                  } catch (i6) {
                    return this.consumeExtnAddr(e5, t5);
                  }
              }
            }
            consumeIP6MulticastAddress(e5, t5) {
              const i5 = this.consumeHexpart(e5, t5);
              return "/" === e5[i5] ? this.consumeInteger(e5, i5 + 1) : i5;
            }
            consumeIP4MulticastAddress(e5, t5) {
              let i5 = t5 + 3;
              const n3 = e5.slice(t5, i5), r3 = parseInt(n3);
              if (r3 < 224 || r3 > 239)
                throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
              for (let t6 = 0; t6 < 3; t6++) {
                if ("." !== e5[i5])
                  throw new Error("Invalid IP4 multicast address.");
                i5 += 1, i5 = this.consumeDecimalUChar(e5, i5);
              }
              return "/" === e5[i5] && (i5 += 1), i5 = this.consumeTTL(e5, i5), "/" === e5[i5] && (i5 = this.consumeInteger(e5, i5)), i5;
            }
            consumeInteger(e5, t5) {
              if (!l2(e5[t5]))
                throw new Error("Invalid integer.");
              for (t5 += 1; a2(e5[t5]); )
                t5 += 1;
              return t5;
            }
            consumeTTL(e5, t5) {
              if ("0" === e5[t5])
                return t5 + 1;
              if (!l2(e5[t5]))
                throw new Error("Invalid TTL.");
              t5 += 1;
              for (let i5 = 0; i5 < 2 && a2(e5[t5]); i5++)
                t5 += 1;
              return t5;
            }
            consumeToken(e5, t5) {
              return this.consumeOneOrMore(e5, t5, u2);
            }
            consumeTime(e5, t5) {
              let i5 = t5;
              if ("0" === e5[i5])
                return i5 + 1;
              for (l2(e5[i5]) && (i5 += 1); a2(e5[i5]); )
                i5++;
              if (i5 - t5 < 10)
                throw new Error("Invalid time");
              return i5;
            }
            consumeAddress(e5, t5) {
              return this.consumeTill(e5, t5, o2);
            }
            consumeTypedTime(e5, t5) {
              let i5 = t5;
              return i5 = this.consumeOneOrMore(e5, i5, a2), p3(e5[i5]) ? i5 + 1 : i5;
            }
            consumeRepeatInterval(e5, t5) {
              if (!l2(e5[t5]))
                throw new Error("Invalid repeat interval");
              for (t5 += 1; a2(e5[t5]); )
                t5 += 1;
              return p3(e5[t5]) && (t5 += 1), t5;
            }
            consumePort(e5, t5) {
              return this.consumeOneOrMore(e5, t5, a2);
            }
            consume(e5, t5, i5) {
              for (let n3 = 0; n3 < i5.length; n3++) {
                if (t5 + n3 >= e5.length)
                  throw new Error("consume exceeding value length");
                if (e5[t5 + n3] !== i5[n3])
                  throw new Error("consume ".concat(i5, " failed at ").concat(n3));
              }
              return t5 + i5.length;
            }
            consumeTill(e5, t5, i5) {
              let n3 = t5;
              for (; n3 < e5.length && ("string" != typeof i5 || e5[n3] !== i5) && ("function" != typeof i5 || !i5(e5[n3])); )
                n3++;
              return n3;
            }
          }
          class I2 extends R2 {
            constructor() {
              super(), g2(this, "records", []), g2(this, "currentLine", 0);
            }
            parse(e5) {
              const t5 = this.probeEOL(e5);
              this.records = e5.split(t5).filter((e6) => !!e6.trim()).map(this.parseLine), this.currentLine = 0;
              const i5 = this.parseVersion(), n3 = this.parseOrigin(), r3 = this.parseSessionName(), o3 = this.parseInformation(), s3 = this.parseUri(), a3 = this.parseEmail(), c3 = this.parsePhone(), d3 = this.parseConnection(), u3 = this.parseBandWidth(), l3 = this.parseTimeFields(), h4 = this.parseKey(), p4 = this.parseSessionAttribute(), _3 = this.parseMediaDescription();
              if (this.currentLine !== this.records.length)
                throw new Error("parsing failed, non exhaustive sdp lines.");
              return { version: i5, origin: n3, sessionName: r3, information: o3, uri: s3, emails: a3, phones: c3, connection: d3, bandwidths: u3, timeFields: l3, key: h4, attributes: p4, mediaDescriptions: _3 };
            }
            getCurrentRecord() {
              const e5 = this.records[this.currentLine];
              if (!e5)
                throw new Error("Record doesn't exit.");
              return e5;
            }
            probeEOL(e5) {
              for (let t5 = 0; t5 < e5.length; t5++)
                if (e5[t5] === n2)
                  return "\r" === e5[t5 - 1] ? r2 : n2;
              throw new Error("Invalid newline character.");
            }
            parseLine(e5, t5) {
              if (e5.length < 2)
                throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
              const i5 = e5[0];
              if ("=" !== e5[1])
                throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
              return { type: i5, value: e5.slice(2), line: t5, cur: 0 };
            }
            parseSessionAttribute() {
              const e5 = new v2();
              for (; this.currentLine < this.records.length; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.ATTRIBUTE)
                  break;
                const i5 = { attField: this.extractOneOrMore(t5, (e6) => u2(e6) && ":" !== e6), _cur: 0 };
                ":" === t5.value[t5.cur] && (t5.cur += 1, i5.attValue = this.extractOneOrMore(t5, _2)), e5.parse(i5), this.currentLine++;
              }
              return e5.digest();
            }
            parseMediaAttributes(e5) {
              const t5 = new y2(e5);
              for (; this.currentLine < this.records.length; ) {
                const e6 = this.getCurrentRecord();
                if (e6.type !== s2.ATTRIBUTE)
                  break;
                const i5 = { attField: this.extractOneOrMore(e6, (e7) => u2(e7) && ":" !== e7), _cur: 0 };
                ":" === e6.value[e6.cur] && (e6.cur += 1, i5.attValue = this.extractOneOrMore(e6, _2)), t5.parse(i5), this.currentLine++;
              }
              return t5.digest();
            }
            parseKey() {
              const e5 = this.getCurrentRecord();
              if (e5.type === s2.KEY) {
                if ("prompt" === e5.value || "clear:" === e5.value || "base64:" === e5.value || "uri:" === e5.value)
                  return e5.value;
                throw this.currentLine++, new Error("Invalid key.");
              }
            }
            parseZone() {
              const e5 = this.getCurrentRecord();
              if (e5.type === s2.ZONE_ADJUSTMENTS) {
                const t5 = [];
                for (; ; )
                  try {
                    const i5 = this.extract(e5, this.consumeTime);
                    this.consumeSpaceForRecord(e5);
                    let n3 = false;
                    "-" === e5.value[e5.cur] && (n3 = true, e5.cur += 1);
                    const r3 = this.extract(e5, this.consumeTypedTime);
                    t5.push({ time: i5, typedTime: r3, back: n3 });
                  } catch (e6) {
                    break;
                  }
                if (0 === t5.length)
                  throw new Error("Invalid zone adjustments");
                return this.currentLine++, t5;
              }
              return [];
            }
            parseRepeat() {
              const e5 = [];
              for (; ; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.REPEAT)
                  break;
                {
                  const i5 = this.extract(t5, this.consumeRepeatInterval), n3 = this.parseTypedTime(t5);
                  e5.push({ repeatInterval: i5, typedTimes: n3 }), this.currentLine++;
                }
              }
              return e5;
            }
            parseTypedTime(e5) {
              const t5 = [];
              for (; ; )
                try {
                  this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeTypedTime));
                } catch (e6) {
                  break;
                }
              if (0 === t5.length)
                throw new Error("Invalid typed time.");
              return t5;
            }
            parseTime() {
              const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeTime);
              this.consumeSpaceForRecord(e5);
              const i5 = this.extract(e5, this.consumeTime);
              return this.currentLine++, { startTime: t5, stopTime: i5 };
            }
            parseBandWidth() {
              const e5 = [];
              for (; this.currentLine < this.records.length; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.BANDWIDTH)
                  break;
                {
                  const i5 = this.extractOneOrMore(t5, u2);
                  if (":" !== t5.value[t5.cur])
                    throw new Error("Invalid bandwidth field.");
                  t5.cur++;
                  const n3 = this.extractOneOrMore(t5, a2);
                  e5.push({ bwtype: i5, bandwidth: n3 }), this.currentLine++;
                }
              }
              return e5;
            }
            parseVersion() {
              const e5 = this.getCurrentRecord();
              if (e5.type !== s2.VERSION)
                throw new Error("first sdp record must be version");
              const t5 = e5.value.slice(0, this.consumeOneOrMore(e5.value, 0, a2));
              if (t5.length !== e5.value.length)
                throw new Error('invalid proto version, "v='.concat(e5.value, '"'));
              return this.currentLine++, t5;
            }
            parseOrigin() {
              const e5 = this.getCurrentRecord();
              if (e5.type !== s2.ORIGIN)
                throw new Error("second line of sdp must be origin");
              const t5 = this.extractOneOrMore(e5, d2);
              this.consumeSpaceForRecord(e5);
              const i5 = this.extractOneOrMore(e5, a2);
              this.consumeSpaceForRecord(e5);
              const n3 = this.extractOneOrMore(e5, a2);
              this.consumeSpaceForRecord(e5);
              const r3 = this.extractOneOrMore(e5, u2);
              this.consumeSpaceForRecord(e5);
              const o3 = this.extractOneOrMore(e5, u2);
              this.consumeSpaceForRecord(e5);
              const c3 = this.extract(e5, this.consumeUnicastAddress);
              return this.currentLine++, { username: t5, sessId: i5, sessVersion: n3, nettype: r3, addrtype: o3, unicastAddress: c3 };
            }
            parseSessionName() {
              const e5 = this.getCurrentRecord();
              if (e5.type === s2.SESSION_NAME) {
                const t5 = this.extract(e5, this.consumeText);
                return this.currentLine++, t5;
              }
            }
            parseInformation() {
              const e5 = this.getCurrentRecord();
              if (e5.type !== s2.INFORMATION)
                return;
              const t5 = this.extract(e5, this.consumeText);
              return this.currentLine++, t5;
            }
            parseUri() {
              const e5 = this.getCurrentRecord();
              if (e5.type === s2.URI)
                return this.currentLine++, e5.value;
            }
            parseEmail() {
              const e5 = [];
              for (; ; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.EMAIL)
                  break;
                e5.push(t5.value), this.currentLine++;
              }
              return e5;
            }
            parsePhone() {
              const e5 = [];
              for (; ; ) {
                const t5 = this.getCurrentRecord();
                if (t5.type !== s2.PHONE)
                  break;
                e5.push(t5.value), this.currentLine++;
              }
              return e5;
            }
            parseConnection() {
              const e5 = this.getCurrentRecord();
              if (e5.type === s2.CONNECTION) {
                const t5 = this.extractOneOrMore(e5, u2);
                this.consumeSpaceForRecord(e5);
                const i5 = this.extractOneOrMore(e5, u2);
                this.consumeSpaceForRecord(e5);
                const n3 = this.extract(e5, this.consumeAddress);
                return this.currentLine++, { nettype: t5, addrtype: i5, address: n3 };
              }
            }
            parseMedia() {
              const e5 = this.getCurrentRecord(), t5 = this.extract(e5, this.consumeToken);
              this.consumeSpaceForRecord(e5);
              let i5 = this.extract(e5, this.consumePort);
              "/" === e5.value[e5.cur] && (e5.cur += 1, i5 += this.extract(e5, this.consumeInteger)), this.consumeSpaceForRecord(e5);
              const n3 = [];
              for (n3.push(this.extract(e5, this.consumeToken)); "/" === e5.value[e5.cur]; )
                e5.cur += 1, n3.push(this.extract(e5, this.consumeToken));
              if (0 === n3.length)
                throw new Error("Invalid proto");
              const r3 = this.parseFmt(e5);
              return this.currentLine++, { mediaType: t5, port: i5, protos: n3, fmts: r3 };
            }
            parseTimeFields() {
              const e5 = [];
              for (; this.getCurrentRecord().type === s2.TIME; ) {
                const t5 = this.parseTime(), i5 = this.parseRepeat(), n3 = this.parseZone();
                e5.push({ time: t5, repeats: i5, zones: n3 });
              }
              return e5;
            }
            parseMediaDescription() {
              const e5 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.MEDIA; ) {
                const t5 = this.parseMedia(), i5 = this.parseInformation(), n3 = this.parseConnections(), r3 = this.parseBandWidth(), o3 = this.parseKey(), s3 = this.parseMediaAttributes(t5);
                e5.push({ media: t5, information: i5, connections: n3, bandwidths: r3, key: o3, attributes: s3 });
              }
              return e5;
            }
            parseConnections() {
              const e5 = [];
              for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s2.CONNECTION; )
                e5.push(this.parseConnection());
              return e5;
            }
            parseFmt(e5) {
              const t5 = [];
              for (; ; )
                try {
                  this.consumeSpaceForRecord(e5), t5.push(this.extract(e5, this.consumeToken));
                } catch (e6) {
                  break;
                }
              if (0 === t5.length)
                throw new Error("Invalid fmts");
              return t5;
            }
            extract(e5, t5, ...i5) {
              const n3 = t5.call(this, e5.value, e5.cur, ...i5), r3 = e5.value.slice(e5.cur, n3);
              return e5.cur = n3, r3;
            }
            extractOneOrMore(e5, t5) {
              const i5 = this.consumeOneOrMore(e5.value, e5.cur, t5), n3 = e5.value.slice(e5.cur, i5);
              return e5.cur = i5, n3;
            }
            consumeSpaceForRecord(e5) {
              if (e5.value[e5.cur] !== o2)
                throw new Error("Invalid space at ".concat(e5.cur, "."));
              e5.cur += 1;
            }
          }
          class C2 extends R2 {
            constructor(...e5) {
              super(...e5), g2(this, "attributes", void 0), g2(this, "digested", false);
            }
            extractOneOrMore(e5, t5, i5) {
              const n3 = this.consumeOneOrMore(e5.attValue, e5._cur, t5), r3 = e5.attValue.slice(e5._cur, n3), [o3, s3] = i5 || [];
              if ("number" == typeof o3 && r3.length < o3)
                throw new Error("error in length, should be more or equal than ".concat(o3, " characters."));
              if ("number" == typeof s3 && r3.length > s3)
                throw new Error("error in length, should be less or equal than ".concat(s3, " characters."));
              return e5._cur = n3, r3;
            }
            consumeAttributeSpace(e5) {
              if (e5.attValue[e5._cur] !== o2)
                throw new Error("Invalid space at ".concat(e5._cur, "."));
              e5._cur += 1;
            }
            extract(e5, t5, ...i5) {
              if (!e5.attValue)
                throw new Error("Nothing to extract from attValue.");
              const n3 = t5.call(this, e5.attValue, e5._cur, ...i5), r3 = e5.attValue.slice(e5._cur, n3);
              return e5._cur = n3, r3;
            }
            atEnd(e5) {
              if (!e5.attValue)
                throw new Error();
              return e5._cur >= e5.attValue.length;
            }
            peekChar(e5) {
              if (!e5.attValue)
                throw new Error();
              return e5.attValue[e5._cur];
            }
            peek(e5, t5) {
              if (!e5.attValue)
                throw new Error();
              for (let i5 = 0; i5 < t5.length; i5++)
                if (t5[i5] !== e5.attValue[e5._cur + i5])
                  return false;
              return true;
            }
            parseIceUfrag(e5) {
              if (this.attributes.iceUfrag)
                throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
              this.attributes.iceUfrag = this.extractOneOrMore(e5, E2, [4, 256]);
            }
            parseIcePwd(e5) {
              if (this.attributes.icePwd)
                throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
              this.attributes.icePwd = this.extractOneOrMore(e5, E2, [22, 256]);
            }
            parseIceOptions(e5) {
              if (this.attributes.iceOptions)
                throw new Error("Invalid ice-options, should be only one 'ice-options' line");
              const t5 = [];
              for (; !this.atEnd(e5); ) {
                t5.push(this.extractOneOrMore(e5, E2));
                try {
                  this.consumeAttributeSpace(e5);
                } catch (t6) {
                  if (this.atEnd(e5))
                    break;
                  throw t6;
                }
              }
              this.attributes.iceOptions = t5;
            }
            parseFingerprint(e5) {
              const t5 = this.extract(e5, this.consumeToken);
              this.consumeAttributeSpace(e5);
              const i5 = this.extract(e5, this.consumeTill);
              this.attributes.fingerprints.push({ hashFunction: t5, fingerprint: i5 });
            }
            parseExtmap(e5) {
              const t5 = this.extractOneOrMore(e5, a2);
              let i5;
              "/" === this.peekChar(e5) && (this.extract(e5, this.consume, "/"), i5 = this.extract(e5, this.consumeToken)), this.consumeAttributeSpace(e5);
              const n3 = this.extract(e5, this.consumeTill, o2), r3 = T2(T2({ entry: parseInt(t5, 10) }, i5 && { direction: i5 }), {}, { extensionName: n3 });
              this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), r3.extensionAttributes = this.extract(e5, this.consumeTill)), this.attributes.extmaps.push(r3);
            }
            parseSetup(e5) {
              if (this.attributes.setup)
                throw new Error("must only be one single 'a=setup' line.");
              const t5 = this.extract(e5, this.consumeTill);
              if ("active" !== t5 && "passive" !== t5 && "actpass" !== t5 && "holdconn" !== t5)
                throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
              this.attributes.setup = t5;
            }
          }
          class v2 extends C2 {
            constructor(...e5) {
              super(...e5), g2(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
            }
            parse(e5) {
              if (this.digested)
                throw new Error("already digested");
              try {
                switch (e5.attField) {
                  case "group":
                    this.parseGroup(e5);
                    break;
                  case "ice-lite":
                    this.parseIceLite();
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e5);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e5);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e5);
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e5);
                    break;
                  case "setup":
                    this.parseSetup(e5);
                    break;
                  case "tls-id":
                    this.parseTlsId(e5);
                    break;
                  case "identity":
                    this.parseIdentity(e5);
                    break;
                  case "extmap":
                    this.parseExtmap(e5);
                    break;
                  case "msid-semantic":
                    this.parseMsidSemantic(e5);
                    break;
                  default:
                    e5.ignored = true, this.attributes.unrecognized.push(e5);
                }
              } catch (t5) {
                throw console.error("parsing session attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
              }
              if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                throw new Error("attribute parsing error");
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseGroup(e5) {
              const t5 = this.extract(e5, this.consumeToken), i5 = [];
              for (; !this.atEnd(e5) && this.peekChar(e5) === o2; )
                this.consumeAttributeSpace(e5), i5.push(this.extract(e5, this.consumeToken));
              this.attributes.groups.push({ semantic: t5, identificationTag: i5 });
            }
            parseIceLite() {
              if (this.attributes.iceLite)
                throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
              this.attributes.iceLite = true;
            }
            parseTlsId(e5) {
              if (this.attributes.tlsId)
                throw new Error("must be only one tld-id line");
              this.attributes.tlsId = this.extractOneOrMore(e5, m2);
            }
            parseIdentity(e5) {
              const t5 = this.extractOneOrMore(e5, f2), i5 = [];
              for (; !this.atEnd(e5) && this.peekChar(e5) === o2; ) {
                this.consumeAttributeSpace(e5);
                const t6 = this.extract(e5, this.consumeToken);
                this.extract(e5, this.consume, "=");
                const n3 = this.extractOneOrMore(e5, (e6) => e6 !== o2 && _2(e6));
                i5.push({ name: t6, value: n3 });
              }
              this.attributes.identities.push({ assertionValue: t5, extensions: i5 });
            }
            parseMsidSemantic(e5) {
              this.peekChar(e5) === o2 && this.consumeAttributeSpace(e5);
              const t5 = { semantic: this.extract(e5, this.consumeToken), identifierList: [] };
              for (; ; ) {
                try {
                  this.consumeAttributeSpace(e5);
                } catch (e6) {
                  break;
                }
                if ("*" === this.peekChar(e5)) {
                  this.extract(e5, this.consume, "*"), t5.applyForAll = true;
                  break;
                }
                {
                  const i5 = this.extract(e5, this.consumeTill, o2);
                  t5.identifierList.push(i5);
                }
              }
              this.attributes.msidSemantic = t5;
            }
          }
          class y2 extends C2 {
            constructor(e5) {
              super(), g2(this, "attributes", void 0), -1 !== e5.protos.indexOf("RTP") || e5.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
            }
            parse(e5) {
              if (this.digested)
                throw new Error("already digested");
              try {
                switch (e5.attField) {
                  case "extmap":
                    this.parseExtmap(e5);
                    break;
                  case "setup":
                    this.parseSetup(e5);
                    break;
                  case "ice-ufrag":
                    this.parseIceUfrag(e5);
                    break;
                  case "ice-pwd":
                    this.parseIcePwd(e5);
                    break;
                  case "ice-options":
                    this.parseIceOptions(e5);
                    break;
                  case "candidate":
                    this.parseCandidate(e5);
                    break;
                  case "remote-candidate":
                    this.parseRemoteCandidate(e5);
                    break;
                  case "end-of-candidates":
                    this.parseEndOfCandidates();
                    break;
                  case "fingerprint":
                    this.parseFingerprint(e5);
                    break;
                  case "rtpmap":
                    this.parseRtpmap(e5);
                    break;
                  case "ptime":
                    this.parsePtime(e5);
                    break;
                  case "maxptime":
                    this.parseMaxPtime(e5);
                    break;
                  case "sendrecv":
                  case "recvonly":
                  case "sendonly":
                  case "inactive":
                    this.parseDirection(e5);
                    break;
                  case "ssrc":
                    this.parseSSRC(e5);
                    break;
                  case "fmtp":
                    this.parseFmtp(e5);
                    break;
                  case "rtcp-fb":
                    this.parseRtcpFb(e5);
                    break;
                  case "rtcp-mux":
                    this.parseRTCPMux();
                    break;
                  case "rtcp-mux-only":
                    this.parseRTCPMuxOnly();
                    break;
                  case "rtcp-rsize":
                    this.parseRTCPRsize();
                    break;
                  case "rtcp":
                    this.parseRTCP(e5);
                    break;
                  case "mid":
                    this.parseMid(e5);
                    break;
                  case "msid":
                    this.parseMsid(e5);
                    break;
                  case "imageattr":
                    this.parseImageAttr(e5);
                    break;
                  case "rid":
                    this.parseRid(e5);
                    break;
                  case "simulcast":
                    this.parseSimulcast(e5);
                    break;
                  case "sctp-port":
                    this.parseSctpPort(e5);
                    break;
                  case "max-message-size":
                    this.parseMaxMessageSize(e5);
                    break;
                  case "ssrc-group":
                    this.parseSSRCGroup(e5);
                    break;
                  default:
                    e5.ignored = true, this.attributes.unrecognized.push(e5);
                }
              } catch (t5) {
                throw console.error("parsing media attribute ".concat(e5.attField, ' error, "a=').concat(e5.attField, ":").concat(e5.attValue, '"')), t5;
              }
              if (!e5.ignored && e5.attValue && !this.atEnd(e5))
                throw new Error("attribute parsing error");
            }
            parseCandidate(e5) {
              const t5 = this.extractOneOrMore(e5, E2, [1, 32]);
              this.consumeAttributeSpace(e5);
              const i5 = this.extractOneOrMore(e5, a2, [1, 5]);
              this.consumeAttributeSpace(e5);
              const n3 = this.extract(e5, this.consumeToken);
              this.consumeAttributeSpace(e5);
              const r3 = this.extractOneOrMore(e5, a2, [1, 10]);
              this.consumeAttributeSpace(e5);
              const s3 = this.extract(e5, this.consumeAddress);
              this.consumeAttributeSpace(e5);
              const d3 = this.extract(e5, this.consumePort);
              this.consumeAttributeSpace(e5), this.extract(e5, this.consume, "typ"), this.consumeAttributeSpace(e5);
              const u3 = { foundation: t5, componentId: i5, transport: n3, priority: r3, connectionAddress: s3, port: d3, type: this.extract(e5, this.consumeToken), extension: {} };
              for (this.peek(e5, " raddr") && (this.extract(e5, this.consume, " raddr"), this.consumeAttributeSpace(e5), u3.relAddr = this.extract(e5, this.consumeAddress)), this.peek(e5, " rport") && (this.extract(e5, this.consume, " rport"), this.consumeAttributeSpace(e5), u3.relPort = this.extract(e5, this.consumePort)); this.peekChar(e5) === o2; ) {
                this.consumeAttributeSpace(e5);
                const t6 = this.extract(e5, this.consumeToken);
                this.consumeAttributeSpace(e5), u3.extension[t6] = this.extractOneOrMore(e5, c2);
              }
              this.attributes.candidates.push(u3);
            }
            parseRemoteCandidate(e5) {
              const t5 = [];
              for (; ; ) {
                const i5 = this.extractOneOrMore(e5, a2, [1, 5]);
                this.consumeAttributeSpace(e5);
                const n3 = this.extract(e5, this.consumeAddress);
                this.consumeAttributeSpace(e5);
                const r3 = this.extract(e5, this.consumePort);
                t5.push({ componentId: i5, connectionAddress: n3, port: r3 });
                try {
                  this.consumeAttributeSpace(e5);
                } catch (e6) {
                  break;
                }
              }
              this.attributes.remoteCandidatesList.push(t5);
            }
            parseEndOfCandidates() {
              if (this.attributes.endOfCandidates)
                throw new Error("must be only one line of end-of-candidates");
              this.attributes.endOfCandidates = true;
            }
            parseRtpmap(e5) {
              const t5 = this.extract(e5, this.consumeToken);
              this.consumeAttributeSpace(e5);
              const i5 = this.extract(e5, this.consumeTill, "/");
              this.extract(e5, this.consume, "/");
              const n3 = { encodingName: i5, clockRate: this.extractOneOrMore(e5, a2) };
              this.atEnd(e5) || "/" !== this.peekChar(e5) || (this.extract(e5, this.consume, "/"), n3.encodingParameters = parseInt(this.extract(e5, this.consumeTill), 10));
              const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
              r3 ? r3.rtpMap = n3 : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtpMap: n3, rtcpFeedbacks: [] });
            }
            parsePtime(e5) {
              if (this.attributes.ptime)
                throw new Error("must be only one line of ptime");
              this.attributes.ptime = this.extract(e5, this.consumeTill);
            }
            parseMaxPtime(e5) {
              if (this.attributes.maxPtime)
                throw new Error("must be only one line of ptime");
              this.attributes.maxPtime = this.extract(e5, this.consumeTill);
            }
            parseDirection(e5) {
              if (this.attributes.direction)
                throw new Error("must be only one line of direction info");
              this.attributes.direction = e5.attField;
            }
            parseSSRC(e5) {
              const t5 = this.extractOneOrMore(e5, a2);
              this.consumeAttributeSpace(e5);
              const i5 = this.extract(e5, this.consumeTill, ":");
              let n3;
              ":" === this.peekChar(e5) && (this.extract(e5, this.consume, ":"), n3 = this.extract(e5, this.consumeTill));
              const r3 = this.attributes.ssrcs.find((e6) => e6.ssrcId === parseInt(t5, 10));
              r3 ? r3.attributes[i5] = n3 : this.attributes.ssrcs.push({ ssrcId: parseInt(t5, 10), attributes: { [i5]: n3 } });
            }
            parseFmtp(e5) {
              const t5 = this.extract(e5, this.consumeTill, o2);
              this.consumeAttributeSpace(e5);
              const i5 = this.extract(e5, this.consumeTill), n3 = {};
              i5.split(";").forEach((e6) => {
                let [t6, i6] = e6.split("=");
                t6 = t6.trim();
                const r4 = "string" == typeof i6 ? i6.trim() : null;
                "string" == typeof t6 && t6.length > 0 && (n3[t6] = r4);
              });
              const r3 = this.attributes.payloads.find((e6) => e6.payloadType === parseInt(t5, 10));
              r3 ? r3.fmtp = { parameters: n3 } : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [], fmtp: { parameters: n3 } });
            }
            parseFmtParameters(e5) {
              const t5 = {}, i5 = this.extract(e5, this.consumeTill, "=");
              e5._cur++;
              const n3 = this.extract(e5, this.consumeTill, ";");
              for (t5[i5] = n3; ";" === e5.attValue[e5._cur]; ) {
                const i6 = this.extract(e5, this.consumeTill, "=");
                e5._cur++;
                const n4 = this.extract(e5, this.consumeTill, ";");
                t5[i6] = n4;
              }
              return t5;
            }
            parseRtcpFb(e5) {
              let t5 = "";
              t5 = "*" === this.peekChar(e5) ? this.extract(e5, this.consume, "*") : this.extract(e5, this.consumeTill, o2), this.consumeAttributeSpace(e5);
              const i5 = this.extract(e5, this.consumeTill, o2);
              let n3;
              switch (i5) {
                case "trr-int":
                  n3 = { type: i5, interval: this.extract(e5, this.consumeTill) };
                  break;
                case "ack":
                case "nack":
                default: {
                  const t6 = { type: i5 };
                  this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t6.parameter = this.extract(e5, this.consumeToken), this.peekChar(e5) === o2 && (t6.additional = this.extract(e5, this.consumeTill))), n3 = t6;
                }
              }
              if ("*" === t5)
                this.attributes.rtcpFeedbackWildcards.push(n3);
              else {
                const e6 = this.attributes.payloads.find((e7) => e7.payloadType === parseInt(t5, 10));
                e6 ? e6.rtcpFeedbacks.push(n3) : this.attributes.payloads.push({ payloadType: parseInt(t5, 10), rtcpFeedbacks: [n3] });
              }
            }
            parseRTCPMux() {
              if (this.attributes.rtcpMux)
                throw new Error("must be single line of rtcp-mux");
              this.attributes.rtcpMux = true;
            }
            parseRTCPMuxOnly() {
              if (this.attributes.rtcpMuxOnly)
                throw new Error("must be single line of rtcp-only");
              this.attributes.rtcpMuxOnly = true;
            }
            parseRTCPRsize() {
              if (this.attributes.rtcpRsize)
                throw new Error("must be single line of rtcp-rsize");
              this.attributes.rtcpRsize = true;
            }
            parseRTCP(e5) {
              if (this.attributes.rtcp)
                throw new Error("must be single line of rtcp");
              const t5 = { port: this.extract(e5, this.consumePort) };
              this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t5.netType = this.extractOneOrMore(e5, u2), this.consumeAttributeSpace(e5), t5.addressType = this.extractOneOrMore(e5, u2), this.consumeAttributeSpace(e5), t5.address = this.extract(e5, this.consumeAddress)), this.attributes.rtcp = t5;
            }
            parseMsid(e5) {
              const t5 = { id: this.extractOneOrMore(e5, u2, [1, 64]) };
              this.peekChar(e5) === o2 && (this.consumeAttributeSpace(e5), t5.appdata = this.extractOneOrMore(e5, u2, [1, 64])), this.attributes.msids.push(t5);
            }
            parseImageAttr(e5) {
              this.attributes.imageattr.push(e5.attValue);
            }
            parseRid(e5) {
              const t5 = this.extractOneOrMore(e5, (e6) => h3(e6) || a2(e6) || "_" === e6 || "-" === e6);
              this.consumeAttributeSpace(e5);
              const i5 = { id: t5, direction: this.extract(e5, this.consumeToken), params: [] };
              if (this.peekChar(e5) === o2) {
                if (this.consumeAttributeSpace(e5), this.peek(e5, "pt=")) {
                  this.extract(e5, this.consume, "pt=");
                  const t6 = [];
                  for (; ; ) {
                    const i6 = this.extract(e5, this.consumeToken);
                    t6.push(i6);
                    try {
                      this.extract(e5, this.consume, ",");
                    } catch (e6) {
                      break;
                    }
                  }
                  i5.payloads = t6, this.peekChar(e5) === o2 && this.extract(e5, this.consume, o2);
                }
                for (; ; ) {
                  const t6 = this.extract(e5, this.consumeToken);
                  switch (t6) {
                    case "depend": {
                      const n3 = { type: t6, rids: this.extract(e5, this.consume, "=").split(",") };
                      i5.params.push(n3);
                      break;
                    }
                    case "max-width":
                    case "height-width":
                    case "max-fps":
                    case "max-fs":
                    case "max-br":
                    case "max-pps":
                    case "max-bpp":
                    default: {
                      const n3 = { type: t6 };
                      "=" === this.peekChar(e5) && (this.extract(e5, this.consume, "="), n3.val = this.extract(e5, this.consumeTill, ";")), i5.params.push(n3);
                    }
                  }
                  try {
                    this.extract(e5, this.consume, ";");
                  } catch (e6) {
                    break;
                  }
                }
              }
              this.attributes.rids.push(i5);
            }
            parseSimulcast(e5) {
              if (this.attributes.simulcast)
                throw new Error("must be single line of simulcast");
              this.attributes.simulcast = e5.attValue, this.extract(e5, this.consumeTill);
            }
            parseSctpPort(e5) {
              this.attributes.sctpPort = this.extractOneOrMore(e5, a2, [1, 5]);
            }
            parseMaxMessageSize(e5) {
              this.attributes.maxMessageSize = this.extractOneOrMore(e5, a2, [1, void 0]);
            }
            digest() {
              return this.digested = true, this.attributes;
            }
            parseMid(e5) {
              this.attributes.mid = this.extract(e5, this.consumeToken);
            }
            parseSSRCGroup(e5) {
              const t5 = this.extract(e5, this.consumeToken), i5 = [];
              for (; ; )
                try {
                  this.consumeAttributeSpace(e5);
                  const t6 = this.extract(e5, this.consumeInteger);
                  i5.push(parseInt(t6, 10));
                } catch (e6) {
                  break;
                }
              this.attributes.ssrcGroups.push({ semantic: t5, ssrcIds: i5 });
            }
          }
          function A2(e5, t5, i5) {
            return t5 in e5 ? Object.defineProperty(e5, t5, { value: i5, enumerable: true, configurable: true, writable: true }) : e5[t5] = i5, e5;
          }
          class O2 {
            constructor() {
              A2(this, "eol", r2);
            }
            print(e5, t5) {
              let i5 = "";
              return t5 && (this.eol = t5), i5 += this.printVersion(e5.version), i5 += this.printOrigin(e5.origin), i5 += this.printSessionName(e5.sessionName), i5 += this.printInformation(e5.information), i5 += this.printUri(e5.uri), i5 += this.printEmail(e5.emails), i5 += this.printPhone(e5.phones), i5 += this.printConnection(e5.connection), i5 += this.printBandwidth(e5.bandwidths), i5 += this.printTimeFields(e5.timeFields), i5 += this.printKey(e5.key), i5 += this.printSessionAttributes(e5.attributes), i5 += this.printMediaDescription(e5.mediaDescriptions), i5;
            }
            printVersion(e5) {
              return "v=".concat(e5).concat(this.eol);
            }
            printOrigin(e5) {
              return "o=".concat(e5.username, " ").concat(e5.sessId, " ").concat(e5.sessVersion, " ").concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.unicastAddress).concat(this.eol);
            }
            printSessionName(e5) {
              return e5 ? "s=".concat(e5).concat(this.eol) : "";
            }
            printInformation(e5) {
              return e5 ? "i=".concat(e5).concat(this.eol) : "";
            }
            printUri(e5) {
              return e5 ? "u=".concat(e5).concat(this.eol) : "";
            }
            printEmail(e5) {
              let t5 = "";
              for (const i5 of e5)
                t5 += "e=".concat(i5).concat(this.eol);
              return t5;
            }
            printPhone(e5) {
              let t5 = "";
              for (const i5 of e5)
                t5 += "e=".concat(i5).concat(this.eol);
              return t5;
            }
            printConnection(e5) {
              return e5 ? "c=".concat(e5.nettype, " ").concat(e5.addrtype, " ").concat(e5.address).concat(this.eol) : "";
            }
            printBandwidth(e5) {
              let t5 = "";
              for (const i5 of e5)
                t5 += "b=".concat(i5.bwtype, ":").concat(i5.bandwidth).concat(this.eol);
              return t5;
            }
            printTimeFields(e5) {
              let t5 = "";
              for (const i5 of e5) {
                t5 += "t=".concat(i5.time.startTime, " ").concat(i5.time.startTime).concat(this.eol);
                for (const e6 of i5.repeats)
                  t5 += "r=".concat(e6.repeatInterval, " ").concat(e6.typedTimes.join(" ")).concat(this.eol);
                i5.zoneAdjustments && (t5 += "z=", t5 += "z=".concat(i5.zoneAdjustments.map((e6) => "".concat(e6.time, " ").concat(e6.back ? "-" : "", " ").concat(e6.typedTime)).join(" ")).concat(this.eol), t5 += this.eol);
              }
              return t5;
            }
            printKey(e5) {
              return e5 ? "k=".concat(e5).concat(this.eol) : "";
            }
            printAttributes(e5) {
              let t5 = "";
              for (const i5 of e5)
                t5 += "a=".concat(i5.attField).concat(i5.attValue ? ":".concat(i5.attValue) : "").concat(this.eol);
              return t5;
            }
            printMediaDescription(e5) {
              let t5 = "";
              for (const i5 of e5)
                t5 += this.printMedia(i5.media), t5 += this.printInformation(i5.information), t5 += this.printConnections(i5.connections), t5 += this.printBandwidth(i5.bandwidths), t5 += this.printKey(i5.key), t5 += this.printMediaAttributes(i5);
              return t5;
            }
            printConnections(e5) {
              let t5 = "";
              for (const i5 of e5)
                t5 += this.printConnection(i5);
              return t5;
            }
            printMedia(e5) {
              return "m=".concat(e5.mediaType, " ").concat(e5.port, " ").concat(e5.protos.join("/"), " ").concat(e5.fmts.join(" ")).concat(this.eol);
            }
            printSessionAttributes(e5) {
              return new b2(this.eol).print(e5);
            }
            printMediaAttributes(e5) {
              return new w3(this.eol).print(e5);
            }
          }
          class N2 {
            constructor(e5) {
              A2(this, "eol", void 0), this.eol = e5;
            }
            printIceUfrag(e5) {
              return void 0 === e5 ? "" : "a=ice-ufrag:".concat(e5).concat(this.eol);
            }
            printIcePwd(e5) {
              return void 0 === e5 ? "" : "a=ice-pwd:".concat(e5).concat(this.eol);
            }
            printIceOptions(e5) {
              return void 0 === e5 ? "" : "a=ice-options:".concat(e5.join(o2)).concat(this.eol);
            }
            printFingerprints(e5) {
              return e5.length > 0 ? e5.map((e6) => "a=fingerprint:".concat(e6.hashFunction).concat(o2).concat(e6.fingerprint)).join(this.eol) + this.eol : "";
            }
            printExtmap(e5) {
              return e5.map((e6) => "a=extmap:".concat(e6.entry).concat(e6.direction ? "/".concat(e6.direction) : "").concat(o2).concat(e6.extensionName).concat(e6.extensionAttributes ? "".concat(o2).concat(e6.extensionAttributes) : "").concat(this.eol)).join("");
            }
            printSetup(e5) {
              return void 0 === e5 ? "" : "a=setup:".concat(e5).concat(this.eol);
            }
            printUnrecognized(e5) {
              return e5.map((e6) => "a=".concat(e6.attField).concat(e6.attValue ? ":".concat(e6.attValue) : "").concat(this.eol)).join("");
            }
          }
          class b2 extends N2 {
            print(e5) {
              let t5 = "";
              return t5 += this.printGroups(e5.groups), t5 += this.printMsidSemantic(e5.msidSemantic), t5 += this.printIceLite(e5.iceLite), t5 += this.printIceUfrag(e5.iceUfrag), t5 += this.printIcePwd(e5.icePwd), t5 += this.printIceOptions(e5.iceOptions), t5 += this.printFingerprints(e5.fingerprints), t5 += this.printSetup(e5.setup), t5 += this.printTlsId(e5.tlsId), t5 += this.printIdentity(e5.identities), t5 += this.printExtmap(e5.extmaps), t5 += this.printUnrecognized(e5.unrecognized), t5;
            }
            printGroups(e5) {
              let t5 = "";
              return e5.length > 0 && (t5 += e5.map((e6) => "a=group:".concat(e6.semantic).concat(e6.identificationTag.map((e7) => "".concat(o2).concat(e7)).join("")).concat(this.eol)).join("")), t5;
            }
            printIceLite(e5) {
              return void 0 === e5 ? "" : "a=ice-lite" + this.eol;
            }
            printTlsId(e5) {
              return e5 ? "a=tls-id:".concat(e5).concat(this.eol) : "";
            }
            printIdentity(e5) {
              return 0 === e5.length ? "" : e5.map((e6) => "a=identity:".concat(e6.assertionValue).concat(e6.extensions.map((e7) => "".concat(o2).concat(e7.name).concat(e7.value ? "=".concat(e7.value) : "")))).join(this.eol) + this.eol;
            }
            printMsidSemantic(e5) {
              if (!e5)
                return "";
              let t5 = "a=msid-semantic:".concat(e5.semantic);
              return e5.applyForAll ? t5 += "".concat(o2, "*") : e5.identifierList.length > 0 && (t5 += e5.identifierList.map((e6) => "".concat(o2).concat(e6))), t5 + this.eol;
            }
          }
          class w3 extends N2 {
            print(e5) {
              const t5 = e5.attributes;
              let i5 = "";
              return i5 += this.printRTCP(t5.rtcp), i5 += this.printIceUfrag(t5.iceUfrag), i5 += this.printIcePwd(t5.icePwd), i5 += this.printIceOptions(t5.iceOptions), i5 += this.printCandidates(t5.candidates), i5 += this.printRemoteCandidatesList(t5.remoteCandidatesList), i5 += this.printEndOfCandidates(t5.endOfCandidates), i5 += this.printFingerprints(t5.fingerprints), i5 += this.printSetup(t5.setup), i5 += this.printMid(t5.mid), i5 += this.printExtmap(t5.extmaps), i5 += this.printRTPRelated(t5), i5 += this.printPtime(t5.ptime), i5 += this.printMaxPtime(t5.maxPtime), i5 += this.printDirection(t5.direction), i5 += this.printSSRCGroups(t5.ssrcGroups), i5 += this.printSSRC(t5.ssrcs), i5 += this.printRTCPMux(t5.rtcpMux), i5 += this.printRTCPMuxOnly(t5.rtcpMuxOnly), i5 += this.printRTCPRsize(t5.rtcpRsize), i5 += this.printMSId(t5.msids), i5 += this.printImageattr(t5.imageattr), i5 += this.printRid(t5.rids), i5 += this.printSimulcast(t5.simulcast), i5 += this.printSCTPPort(t5.sctpPort), i5 += this.printMaxMessageSize(t5.maxMessageSize), i5 += this.printUnrecognized(t5.unrecognized), i5;
            }
            printCandidates(e5) {
              return e5.map((e6) => "a=candidate:".concat(e6.foundation).concat(o2).concat(e6.componentId).concat(o2).concat(e6.transport).concat(o2).concat(e6.priority).concat(o2).concat(e6.connectionAddress).concat(o2).concat(e6.port).concat(o2, "typ").concat(o2).concat(e6.type).concat(e6.relAddr ? "".concat(o2, "raddr").concat(o2).concat(e6.relAddr) : "").concat(e6.relPort ? "".concat(o2, "rport").concat(o2).concat(e6.relPort) : "").concat(Object.keys(e6.extension).map((t5) => "".concat(o2).concat(t5).concat(o2).concat(e6.extension[t5])).join("")).concat(this.eol)).join("");
            }
            printRemoteCandidatesList(e5) {
              return e5.map((e6) => "a=remote-candidates:".concat(e6.join(o2)).concat(this.eol)).join("");
            }
            printEndOfCandidates(e5) {
              return void 0 === e5 ? "" : "a=end-of-candidates" + this.eol;
            }
            printRTPRelated(e5) {
              if (!e5.payloads)
                return "";
              const t5 = e5.payloads;
              let i5 = "";
              i5 += e5.rtcpFeedbackWildcards.map((e6) => this.printRTCPFeedback("*", e6)).join("");
              for (const e6 of t5)
                i5 += this.printRtpMap(e6.payloadType, e6.rtpMap), i5 += this.printFmtp(e6.payloadType, e6.fmtp), i5 += e6.rtcpFeedbacks.map((t6) => this.printRTCPFeedback(e6.payloadType, t6)).join("");
              return i5;
            }
            printFmtp(e5, t5) {
              if (!t5)
                return "";
              const i5 = Object.keys(t5.parameters);
              return 1 === i5.length && null === t5.parameters[i5[0]] ? "a=fmtp:".concat(e5).concat(o2).concat(i5[0]).concat(this.eol) : "a=fmtp:".concat(e5).concat(o2).concat(Object.keys(t5.parameters).map((e6) => "".concat(e6, "=").concat(t5.parameters[e6])).join(";")).concat(this.eol);
            }
            printRtpMap(e5, t5) {
              return t5 ? "a=rtpmap:".concat(e5).concat(o2).concat(t5.encodingName, "/").concat(t5.clockRate).concat(t5.encodingParameters ? "/".concat(t5.encodingParameters) : "").concat(this.eol) : "";
            }
            printRTCPFeedback(e5, t5) {
              let i5 = "a=rtcp-fb:".concat(e5).concat(o2), n3 = t5;
              switch (n3.type) {
                case "trr-int":
                  i5 += "ttr-int".concat(o2).concat(n3.interval);
                  break;
                case "ack":
                case "nack":
                default:
                  n3 = n3, i5 += "".concat(n3.type), n3.parameter && (i5 += "".concat(o2).concat(n3.parameter), n3.additional && (i5 += "".concat(o2).concat(n3.additional)));
              }
              return i5 + this.eol;
            }
            printPtime(e5) {
              return void 0 === e5 ? "" : "a=ptime:".concat(e5).concat(this.eol);
            }
            printMaxPtime(e5) {
              return void 0 === e5 ? "" : "a=maxptime:".concat(e5).concat(this.eol);
            }
            printDirection(e5) {
              return void 0 === e5 ? "" : "a=".concat(e5).concat(this.eol);
            }
            printSSRC(e5) {
              return e5.map((e6) => Object.keys(e6.attributes).map((t5) => "a=ssrc:".concat(e6.ssrcId.toString(10)).concat(o2).concat(t5).concat(e6.attributes[t5] ? ":".concat(e6.attributes[t5]) : "").concat(this.eol)).join("")).join("");
            }
            printRTCPMux(e5) {
              return void 0 === e5 ? "" : "a=rtcp-mux".concat(this.eol);
            }
            printRTCPMuxOnly(e5) {
              return void 0 === e5 ? "" : "a=rtcp-mux-only".concat(this.eol);
            }
            printRTCPRsize(e5) {
              return void 0 === e5 ? "" : "a=rtcp-rsize".concat(this.eol);
            }
            printRTCP(e5) {
              if (void 0 === e5)
                return "";
              let t5 = "a=rtcp:".concat(e5.port);
              return e5.netType && (t5 += "".concat(o2).concat(e5.netType)), e5.addressType && (t5 += "".concat(o2).concat(e5.addressType)), e5.address && (t5 += "".concat(o2).concat(e5.address)), t5 + this.eol;
            }
            printMSId(e5) {
              return e5.map((e6) => "a=msid:".concat(e6.id).concat(e6.appdata ? "".concat(o2).concat(e6.appdata) : "").concat(this.eol)).join("");
            }
            printImageattr(e5) {
              return e5.map((e6) => "a=imageattr:".concat(e6).concat(this.eol)).join("");
            }
            printRid(e5) {
              return e5.map((e6) => {
                let t5 = "a=rid:".concat(e6.id).concat(o2).concat(e6.direction);
                return e6.payloads && (t5 += "".concat(o2, "pt=").concat(e6.payloads.join(","))), e6.params.length > 0 && (t5 += "".concat(o2).concat(e6.params.map((e7) => "depend" === e7.type ? "depend=".concat(e7.rids.join(",")) : "".concat(e7.type, "=").concat(e7.val)).join(";"))), t5 + this.eol;
              }).join("");
            }
            printSimulcast(e5) {
              return void 0 === e5 ? "" : "a=simulcast:".concat(e5).concat(this.eol);
            }
            printSCTPPort(e5) {
              return void 0 === e5 ? "" : "a=sctp-port:".concat(e5).concat(this.eol);
            }
            printMaxMessageSize(e5) {
              return void 0 === e5 ? "" : "a=max-message-size:".concat(e5).concat(this.eol);
            }
            printMid(e5) {
              return void 0 === e5 ? "" : "a=mid:".concat(e5).concat(this.eol);
            }
            printSSRCGroups(e5) {
              return e5.map((e6) => "a=ssrc-group:".concat(e6.semantic).concat(e6.ssrcIds.map((e7) => "".concat(o2).concat(e7.toString(10))).join("")).concat(this.eol)).join("");
            }
          }
          function D2(e5) {
            return new I2().parse(e5);
          }
          function P2(e5, t5) {
            return new O2().print(e5, t5);
          }
        } }, t3 = {};
        function i3(n2) {
          if (t3[n2])
            return t3[n2].exports;
          var r2 = t3[n2] = { exports: {} };
          return e3[n2](r2, r2.exports, i3), r2.exports;
        }
        return i3.d = (e4, t4) => {
          for (var n2 in t4)
            i3.o(t4, n2) && !i3.o(e4, n2) && Object.defineProperty(e4, n2, { enumerable: true, get: t4[n2] });
        }, i3.o = (e4, t4) => Object.prototype.hasOwnProperty.call(e4, t4), i3.r = (e4) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
        }, i3(8);
      })();
    }(UO);
    class iN {
      constructor(e2) {
        _p(this, "sessionDesc", void 0), _p(this, "localCapabilities", void 0), _p(this, "rtpCapabilities", void 0), _p(this, "candidates", void 0), _p(this, "iceParameters", void 0), _p(this, "dtlsParameters", void 0), _p(this, "setup", void 0), _p(this, "currentMidIndex", void 0), _p(this, "cname", void 0), e2 = uC(e2);
        const { remoteIceParameters: t2, remoteDtlsParameters: i3, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: o2, localCapabilities: s2, sdkCodec: a2, cname: c2 } = e2, d2 = UO.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
        this.rtpCapabilities = r2, this.candidates = n2, this.iceParameters = t2, this.dtlsParameters = i3, this.setup = o2, this.localCapabilities = s2, this.cname = c2;
        for (let e3 = 0; e3 < d2.mediaDescriptions.length; e3++) {
          const s3 = d2.mediaDescriptions[e3];
          s3.attributes.iceUfrag = t2.iceUfrag, s3.attributes.icePwd = t2.icePwd, s3.attributes.fingerprints = i3.fingerprints, s3.attributes.candidates = n2, s3.attributes.setup = o2, "video" === s3.media.mediaType && (s3.media.fmts = r2.videoCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = r2.videoCodecs, s3.attributes.extmaps = r2.videoExtensions), "audio" === s3.media.mediaType && (s3.media.fmts = r2.audioCodecs.map((e4) => e4.payloadType.toString(10)), s3.attributes.payloads = r2.audioCodecs, s3.attributes.extmaps = r2.audioExtensions), d2.mediaDescriptions[e3] = this.mungMediaDesc(s3);
        }
        this.sessionDesc = d2, this.currentMidIndex = d2.mediaDescriptions.length - 1;
      }
      toString() {
        return UO.exports.print(this.sessionDesc);
      }
      send(e2, t2, i3) {
        const { ssrcs: n2, ssrcGroups: r2 } = WO(t2, this.cname), o2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === AS.VIDEO ? "video" === t3.media.mediaType : "audio" === t3.media.mediaType), s2 = n2[0].attributes.label, a2 = n2[0].attributes.mslabel;
        return o2.attributes.ssrcs = o2.attributes.ssrcs.concat(n2), o2.attributes.ssrcGroups = o2.attributes.ssrcGroups.concat(r2), { id: s2, mslabel: a2 };
      }
      batchSend(e2) {
        return e2.map((e3) => {
          let { kind: t2, ssrcMsg: i3 } = e3;
          return this.send(t2, i3, void 0);
        });
      }
      stopSending(e2) {
        this.sessionDesc.mediaDescriptions.forEach((t2) => {
          const i3 = [], n2 = [], r2 = [];
          t2.attributes.ssrcs.forEach((t3) => {
            e2.includes(t3.attributes.label || "") ? r2.push(t3) : i3.push(t3);
          }), t2.attributes.ssrcGroups.forEach((e3) => {
            r2.map((e4) => e4.ssrcId).includes(e3.ssrcIds[0]) || n2.push(e3);
          }), t2.attributes.ssrcs = i3, t2.attributes.ssrcGroups = n2;
        });
      }
      mute(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
        if (!t2)
          throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
        t2.attributes.direction = "inactive";
      }
      unmute(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
        if (!t2)
          throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
        t2.attributes.direction = "sendonly";
      }
      receive(e2, t2, i3) {
        e2.forEach((e3, t3) => {
          const i4 = e3._mediaStreamTrack, n2 = this.sessionDesc.mediaDescriptions.findIndex((e4) => e4.attributes.mid === i4.kind), r2 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n2], e3);
          this.sessionDesc.mediaDescriptions[n2] = r2;
        });
      }
      stopReceiving(e2) {
      }
      updateCandidates(e2) {
        e2 === OS.TCP ? this.candidates.forEach((e3) => {
          -1 === this.candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this.candidates.push(tN(tN({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
        }) : this.candidates = this.candidates.filter((e3) => "tcp" !== e3.transport);
        for (const e3 of this.sessionDesc.mediaDescriptions)
          e3.attributes.candidates = this.candidates;
      }
      restartICE(e2) {
        e2 = uC(e2), this.iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
          t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
        });
      }
      predictReceivingMids(e2) {
        const t2 = [];
        for (let i3 = 0; i3 < e2; i3++)
          t2.push((this.currentMidIndex + i3 + 1).toString(10));
        return t2;
      }
      mungRecvMediaDsec(e2, t2) {
        const i3 = uC(e2);
        return HO(i3, t2), YO(i3, t2), i3;
      }
      updateRecvMedia(e2, t2) {
        const i3 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
        if (-1 !== i3) {
          const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t2);
          this.sessionDesc.mediaDescriptions[i3] = e3;
        }
      }
      bumpMid(e2) {
        this.currentMidIndex += e2;
      }
      updateTrackLabel(e2, t2, i3) {
        const n2 = this.sessionDesc.mediaDescriptions.find((t3) => e2 === AS.VIDEO ? "video" === t3.attributes.mid : "audio" === t3.attributes.mid);
        if (n2) {
          const e3 = n2.attributes.ssrcs.find((e4) => e4.attributes.label === t2);
          var r2;
          if (e3)
            e3.attributes.label = i3, null === (r2 = e3.attributes.msid) || void 0 === r2 || r2.replace(t2, i3);
        }
      }
      mungMediaDesc(e2) {
        const t2 = uC(e2);
        return KO(t2), function(e3) {
          const t3 = e3.attributes.extmaps.find((e4) => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e4.extensionName);
          t3 && e3.attributes.extmaps.splice(e3.attributes.extmaps.indexOf(t3), 1), e3.attributes.payloads.forEach((e4) => {
            const t4 = e4.rtcpFeedbacks.findIndex((e5) => "transport-cc" === e5.type);
            -1 !== t4 && e4.rtcpFeedbacks.splice(t4, 1);
          });
        }(t2), t2;
      }
      getSSRC(e2) {
        for (const t2 of this.sessionDesc.mediaDescriptions)
          for (const i3 of t2.attributes.ssrcs)
            if (i3.attributes.label === e2)
              return [i3];
      }
    }
    function nN(e2) {
      if (Array.isArray(e2))
        return e2.map((e3) => e3);
      if (!rN(e2))
        return e2;
      const t2 = {};
      for (const i3 in e2)
        rN(e2[i3]) || Array.isArray(e2[i3]) ? t2[i3] = nN(e2[i3]) : t2[i3] = e2[i3];
      return t2;
    }
    function rN(e2) {
      return !("object" != typeof e2 || Array.isArray(e2) || !e2);
    }
    function oN() {
      const e2 = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
      return e2 && e2[0] ? Number(e2[0].split("/")[1]) : null;
    }
    function sN(e2) {
      if (!window.RTCStatsReport)
        return false;
      return e2.getStats() instanceof Sl;
    }
    class aN {
      constructor(e2) {
        _p(this, "input", []), _p(this, "size", void 0), this.size = e2;
      }
      add(e2) {
        this.input.push(e2), this.input.length > this.size && this.input.splice(0, 1);
      }
      diffMean() {
        return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
      }
    }
    const cN = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" }, dN = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: cN, remoteCandidate: cN } }, uN = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0 }, lN = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, qpSumPerFrame: 0 }, hN = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0 }, pN = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
    function _N(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function EN(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? _N(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : _N(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class mN {
      constructor(e2, t2) {
        _p(this, "onFirstVideoReceived", void 0), _p(this, "onFirstVideoDecoded", void 0), _p(this, "onFirstAudioReceived", void 0), _p(this, "onFirstVideoDecodedTimeout", void 0), _p(this, "onFirstAudioDecoded", void 0), _p(this, "onSelectedLocalCandidateChanged", void 0), _p(this, "onSelectedRemoteCandidateChanged", void 0), _p(this, "videoIsReady", false), _p(this, "videoIsReady2", {}), _p(this, "pc", void 0), _p(this, "options", void 0), _p(this, "intervalTimer", void 0), _p(this, "stats", nN(dN)), _p(this, "isFirstVideoReceived", {}), _p(this, "isFirstVideoDecoded", {}), _p(this, "isFirstAudioReceived", {}), _p(this, "isFirstAudioDecoded", {}), _p(this, "isFirstVideoDecodedTimeout", {}), _p(this, "lossRateWindowStats", []), this.pc = e2, this.options = t2, this.intervalTimer = window.setInterval(async () => {
          this.updateStats();
        }, this.options.updateInterval);
      }
      getStats() {
        return this.stats;
      }
      getSelectedCandidatePair() {
        return new Sl((e2) => {
          e2({ local: EN({}, cN), remote: EN({}, cN) });
        });
      }
      setVideoIsReady(e2) {
        this.videoIsReady = e2;
      }
      setVideoIsReady2(e2, t2) {
        this.videoIsReady2[e2] = t2;
      }
      getVideoIsReady(e2) {
        return this.videoIsReady2[e2] || false;
      }
      setIsFirstAudioDecoded(e2) {
      }
      destroy() {
        window.clearInterval(this.intervalTimer), this.pc = void 0;
      }
      calcLossRate(e2) {
        this.lossRateWindowStats.push(e2), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
        const t2 = this.lossRateWindowStats.length, i3 = ["videoSend", "audioSend", "videoRecv", "audioRecv"];
        let n2 = 0, r2 = 0, o2 = 0, s2 = 0;
        for (const a2 of i3)
          e2[a2].forEach((e3, i4) => {
            if (!this.lossRateWindowStats[t2 - 1][a2][i4] || !this.lossRateWindowStats[0][a2][i4])
              return;
            const c2 = this.lossRateWindowStats[t2 - 1][a2][i4].packets - this.lossRateWindowStats[0][a2][i4].packets, d2 = this.lossRateWindowStats[t2 - 1][a2][i4].packetsLost - this.lossRateWindowStats[0][a2][i4].packetsLost;
            "videoSend" === a2 || "audioSend" === a2 ? (n2 += c2, o2 += d2) : (r2 += c2, s2 += d2), Number.isNaN(c2) || Number.isNaN(c2) ? e3.packetLostRate = 0 : e3.packetLostRate = c2 <= 0 || d2 <= 0 ? 0 : d2 / (c2 + d2);
          });
        e2.sendPacketLossRate = n2 <= 0 || o2 <= 0 ? 0 : o2 / (n2 + o2), e2.recvPacketLossRate = r2 <= 0 || s2 <= 0 ? 0 : s2 / (r2 + s2);
      }
    }
    function fN(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function SN(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? fN(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : fN(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class TN extends mN {
      constructor() {
        super(...arguments), _p(this, "_stats", dN), _p(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
      }
      async updateStats() {
        const e2 = await this._getStats(), t2 = this.statsResponsesToObjects(e2);
        this._stats = nN(dN);
        const i3 = t2.filter((e3) => "ssrc" === e3.type);
        this.processSSRCStats(i3);
        const n2 = t2.find((e3) => "VideoBwe" === e3.type);
        n2 && this.processBandwidthStats(n2), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
      }
      processBandwidthStats(e2) {
        this._stats.bitrate = { actualEncoded: Number(e2.googActualEncBitrate), targetEncoded: Number(e2.googTargetEncBitrate), retransmit: Number(e2.googRetransmitBitrate), transmit: Number(e2.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e2.googAvailableSendBandwidth);
      }
      processSSRCStats(e2) {
        e2.forEach((e3) => {
          const t2 = e3.id.includes("send");
          switch ("".concat(e3.mediaType, "_").concat(t2 ? "send" : "recv")) {
            case "video_send": {
              const t3 = nN(lN);
              t3.codec = e3.googCodecName, t3.adaptionChangeReason = "none", e3.googCpuLimitedResolution && (t3.adaptionChangeReason = "cpu"), e3.googBandwidthLimitedResolution && (t3.adaptionChangeReason = "bandwidth"), t3.avgEncodeMs = Number(e3.googAvgEncodeMs), t3.inputFrame = { width: Number(e3.googFrameWidthInput) || Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightInput) || Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.sentFrame = { width: Number(e3.googFrameWidthSent), height: Number(e3.googFrameHeightSent), frameRate: Number(e3.googFrameRateInput) }, t3.firsCount = Number(e3.googFirReceived), t3.nacksCount = Number(e3.googNacksReceived), t3.plisCount = Number(e3.googPlisReceived), t3.frameCount = Number(e3.framesEncoded), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.videoSend.push(t3), this._stats.rtt = t3.rttMs;
              break;
            }
            case "video_recv": {
              const t3 = nN(uN), i3 = this.lastDecodeVideoReceiverStats.get(Number(e3.ssrc));
              if (t3.codec = e3.googCodecName, t3.targetDelayMs = Number(e3.googTargetDelayMs), t3.renderDelayMs = Number(e3.googRenderDelayMs), t3.currentDelayMs = Number(e3.googCurrentDelayMs), t3.minPlayoutDelayMs = Number(e3.googMinPlayoutDelayMs), t3.decodeMs = Number(e3.googDecodeMs), t3.maxDecodeMs = Number(e3.googMaxDecodeMs), t3.receivedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateReceived) }, t3.decodedFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateDecoded) }, t3.decodeFrameRate = Number(e3.googFrameRateDecoded), t3.outputFrame = { width: Number(e3.googFrameWidthReceived), height: Number(e3.googFrameHeightReceived), frameRate: Number(e3.googFrameRateOutput) }, t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.firsCount = Number(e3.googFirsSent), t3.nacksCount = Number(e3.googNacksSent), t3.plisCount = Number(e3.googPlisSent), t3.framesDecodeCount = Number(e3.framesDecoded), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.packets > 0 && !this.isFirstVideoReceived[t3.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t3.ssrc), this.isFirstVideoReceived[t3.ssrc] = true), t3.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t3.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(t3.ssrc, t3.decodedFrame.width, t3.decodedFrame.height), this.isFirstVideoDecoded[t3.ssrc] = true), i3) {
                const n2 = i3.stats, r2 = Date.now() - i3.lts;
                t3.framesDecodeFreezeTime = n2.framesDecodeFreezeTime, t3.framesDecodeInterval = n2.framesDecodeInterval, t3.framesDecodeCount > n2.framesDecodeCount && this.isFirstVideoDecoded[t3.ssrc] ? (i3.lts = Date.now(), t3.framesDecodeInterval = r2, t3.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e3.ssrc, 10)) ? t3.framesDecodeFreezeTime += t3.framesDecodeInterval : this.setVideoIsReady2(parseInt(e3.ssrc, 10), true))) : t3.framesDecodeCount < i3.stats.framesDecodeCount && (t3.framesDecodeInterval = 0);
              }
              this.lastDecodeVideoReceiverStats.set(t3.ssrc, { stats: SN({}, t3), lts: Date.now() }), this._stats.videoRecv.push(t3);
              break;
            }
            case "audio_recv": {
              const t3 = nN(pN);
              t3.codec = e3.googCodecName, t3.outputLevel = Math.abs(Number(e3.audioOutputLevel)) / 32767, t3.decodingCNG = Number(e3.googDecodingCNG), t3.decodingCTN = Number(e3.googDecodingCTN), t3.decodingCTSG = Number(e3.googDecodingCTSG), t3.decodingNormal = Number(e3.googDecodingNormal), t3.decodingPLC = Number(e3.googDecodingPLC), t3.decodingPLCCNG = Number(e3.googDecodingPLCCNG), t3.expandRate = Number(e3.googExpandRate), t3.accelerateRate = Number(e3.googAccelerateRate), t3.preemptiveExpandRate = Number(e3.googPreemptiveExpandRate), t3.secondaryDecodedRate = Number(e3.googSecondaryDecodedRate), t3.speechExpandRate = Number(e3.googSpeechExpandRate), t3.preferredJitterBufferMs = Number(e3.googPreferredJitterBufferMs), t3.jitterBufferMs = Number(e3.googJitterBufferMs), t3.jitterMs = Number(e3.googJitterReceived), t3.bytes = Number(e3.bytesReceived), t3.packets = Number(e3.packetsReceived), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.receivedFrames = Number(e3.googDecodingCTN) || Number(e3.packetsReceived), t3.droppedFrames = Number(e3.googDecodingPLC) + Number(e3.googDecodingPLCCNG) || Number(e3.packetsLost), t3.receivedFrames > 0 && !this.isFirstAudioReceived[t3.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t3.ssrc), this.isFirstAudioReceived[t3.ssrc] = true), t3.decodingNormal > 0 && !this.isFirstAudioDecoded[t3.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t3.ssrc), this.isFirstAudioDecoded[t3.ssrc] = true), this._stats.audioRecv.push(t3);
              break;
            }
            case "audio_send": {
              const t3 = nN(hN);
              t3.codec = e3.googCodecName, t3.inputLevel = Math.abs(Number(e3.audioInputLevel)) / 32767, t3.aecReturnLoss = Number(e3.googEchoCancellationReturnLoss || 0), t3.aecReturnLossEnhancement = Number(e3.googEchoCancellationReturnLossEnhancement || 0), t3.residualEchoLikelihood = Number(e3.googResidualEchoLikelihood || 0), t3.residualEchoLikelihoodRecentMax = Number(e3.googResidualEchoLikelihoodRecentMax || 0), t3.bytes = Number(e3.bytesSent), t3.packets = Number(e3.packetsSent), t3.packetsLost = Number(e3.packetsLost), t3.ssrc = Number(e3.ssrc), t3.rttMs = Number(e3.googRtt || 0), this._stats.rtt = t3.rttMs, this._stats.audioSend.push(t3);
              break;
            }
          }
        });
      }
      _getStats() {
        return new Sl((e2, t2) => {
          this.pc.getStats(e2, t2);
        });
      }
      statsResponsesToObjects(e2) {
        const t2 = [];
        return e2.result().forEach((e3) => {
          const i3 = { id: e3.id, timestamp: e3.timestamp.valueOf().toString(), type: e3.type };
          e3.names().forEach((t3) => {
            i3[t3] = e3.stat(t3);
          }), t2.push(i3);
        }), t2;
      }
    }
    function gN(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function RN(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? gN(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : gN(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class IN extends mN {
      constructor() {
        super(...arguments), _p(this, "_stats", dN), _p(this, "report", void 0), _p(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), _p(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), _p(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), _p(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), _p(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), _p(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), _p(this, "mediaBytesSent", /* @__PURE__ */ new Map()), _p(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), _p(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), _p(this, "lastEncoderMs", /* @__PURE__ */ new Map());
      }
      async updateStats() {
        this.report = await this.pc.getStats(), this._stats = nN(dN), this.report.forEach((e2) => {
          switch (e2.type) {
            case kh.OUTBOUND:
            case kh.INBOUND: {
              const t2 = e2.mediaType || e2.kind, i3 = !t2 && "frameWidth" in e2, n2 = !t2 && !("frameWidth" in e2);
              e2.type === kh.OUTBOUND ? "audio" === t2 || n2 ? this.processAudioOutboundStats(e2) : ("video" === t2 || i3) && this.processVideoOutboundStats(e2) : e2.type === kh.INBOUND && ("audio" === t2 || n2 ? this.processAudioInboundStats(e2) : ("video" === t2 || i3) && this.processVideoInboundStats(e2));
              break;
            }
            case kh.TRANSPORT: {
              const t2 = this.report.get(e2.selectedCandidatePairId);
              t2 && this.processCandidatePairStats(t2);
              break;
            }
            case kh.CANDIDATE_PAIR:
              e2.selected && this.processCandidatePairStats(e2);
          }
        }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
      }
      async getSelectedCandidatePair() {
        const e2 = await this.pc.getStats(), t2 = { local: RN({}, cN), remote: RN({}, cN) };
        return e2.forEach((i3) => {
          let n2;
          if (i3.type === kh.TRANSPORT && (n2 = e2.get(i3.selectedCandidatePairId)), i3.type === kh.CANDIDATE_PAIR && i3.selected && (n2 = i3), n2) {
            const i4 = (e3, t3) => {
              e3.type = t3.type, e3.id = t3.id, t3.address && (e3.address = t3.address), t3.candidateType && (e3.candidateType = t3.candidateType), t3.port && (e3.port = t3.port), t3.priority && (e3.priority = t3.priority), t3.protocol && (e3.protocol = t3.protocol), t3.relayProtocol && (e3.relayProtocol = t3.relayProtocol);
            };
            if (n2.localCandidateId) {
              const r2 = e2.get(n2.localCandidateId);
              r2 && i4(t2.local, r2);
            }
            if (n2.remoteCandidateId) {
              const r2 = e2.get(n2.remoteCandidateId);
              r2 && i4(t2.remote, r2);
            }
          }
        }), t2;
      }
      processCandidatePairStats(e2) {
        if (this._stats.sendBandwidth = e2.availableOutgoingBitrate || 0, e2.currentRoundTripTime && (this._stats.rtt = 1e3 * e2.currentRoundTripTime), this._stats.videoSend.forEach((t2) => {
          e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
        }), this._stats.audioSend.forEach((t2) => {
          e2.currentRoundTripTime && (t2.rttMs = 1e3 * e2.currentRoundTripTime);
        }), this._stats.selectedCandidatePair.id = e2.id, e2.localCandidateId) {
          const t2 = this.report.get(e2.localCandidateId);
          t2 && this.processCandidateStats(t2);
        }
        if (e2.remoteCandidateId) {
          const t2 = this.report.get(e2.remoteCandidateId);
          t2 && this.processCandidateStats(t2);
        }
      }
      processCandidateStats(e2) {
        let t2;
        e2.type === kh.LOCAL_CANDIDATE && (t2 = this._stats.selectedCandidatePair.localCandidate), e2.type === kh.REMOTE_CANDIDATE && (t2 = this._stats.selectedCandidatePair.remoteCandidate), t2 && (t2.type = e2.type, t2.id = e2.id, e2.address && (t2.address = e2.address), e2.candidateType && (t2.candidateType = e2.candidateType), e2.port && (t2.port = e2.port), e2.priority && (t2.priority = e2.priority), e2.protocol && (t2.protocol = e2.protocol), e2.relayProtocol && (t2.relayProtocol = e2.relayProtocol), e2.type === kh.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t2.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(RN({}, t2), RN({}, this.stats.selectedCandidatePair.localCandidate)), e2.type === kh.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t2.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(RN({}, t2), RN({}, this.stats.selectedCandidatePair.remoteCandidate)));
      }
      processAudioInboundStats(e2) {
        let t2 = this._stats.audioRecv.find((t3) => t3.ssrc === e2.ssrc);
        t2 || (t2 = nN(pN), this._stats.audioRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.jitterMs = 1e3 * e2.jitter, this.processAudioTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), t2.receivedFrames || (t2.receivedFrames = e2.packetsReceived), t2.droppedFrames || (t2.droppedFrames = e2.packetsLost), t2.receivedFrames > 0 && !this.isFirstAudioReceived[t2.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t2.ssrc), this.isFirstAudioReceived[t2.ssrc] = true), t2.outputLevel && t2.outputLevel > 0 && !this.isFirstAudioDecoded[t2.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t2.ssrc), this.isFirstAudioDecoded[t2.ssrc] = true), "number" == typeof e2.concealedSamples && (t2.concealedSamples = e2.concealedSamples);
      }
      processVideoInboundStats(e2) {
        let t2 = this._stats.videoRecv.find((t3) => t3.ssrc === e2.ssrc);
        t2 || (t2 = nN(uN), this._stats.videoRecv.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsReceived, t2.packetsLost = e2.packetsLost, t2.bytes = e2.bytesReceived, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.framesDecodeCount = e2.framesDecoded, t2.totalInterFrameDelay = e2.totalInterFrameDelay, t2.totalSquaredInterFrameDelay = e2.totalSquaredInterFrameDelay;
        const i3 = this.lastDecodeVideoReceiverStats.get(t2.ssrc), n2 = this.lastVideoFramesDecode.get(t2.ssrc), r2 = Date.now();
        if (t2.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t2.ssrc]) {
          const e3 = t2.decodedFrame ? t2.decodedFrame.width : 0, i4 = t2.decodedFrame ? t2.decodedFrame.height : 0;
          this.onFirstVideoDecoded && this.onFirstVideoDecoded(t2.ssrc, e3, i4), this.isFirstVideoDecoded[t2.ssrc] = true;
        }
        if (i3) {
          const n3 = i3.stats, o2 = r2 - i3.lts;
          t2.framesDecodeFreezeTime = n3.framesDecodeFreezeTime, t2.framesDecodeInterval = n3.framesDecodeInterval, !this.isFirstVideoDecoded[t2.ssrc] && o2 > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[t2.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t2.ssrc), this.isFirstVideoDecodedTimeout[t2.ssrc] = true), t2.framesDecodeCount > n3.framesDecodeCount && this.isFirstVideoDecoded[t2.ssrc] ? (i3.lts = Date.now(), t2.framesDecodeInterval = o2, t2.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e2.ssrc)) ? t2.framesDecodeFreezeTime += t2.framesDecodeInterval : this.setVideoIsReady2(parseInt(e2.ssrc, 10), true))) : t2.framesDecodeCount < n3.framesDecodeCount && (t2.framesDecodeInterval = 0), e2.framesDecoded && e2.qpSum && (i3.stats.framesDecodeCount > e2.framesDecoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesDecoded : t2.qpSumPerFrame = (e2.qpSum - i3.qpSum) / (e2.framesDecoded - i3.stats.framesDecodeCount));
        }
        n2 && r2 - n2.lts >= 800 ? (t2.decodeFrameRate = Math.round((t2.framesDecodeCount - n2.count) / ((r2 - n2.lts) / 1e3)), this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: t2.decodeFrameRate })) : n2 ? t2.decodeFrameRate = n2.rate : this.lastVideoFramesDecode.set(t2.ssrc, { count: t2.framesDecodeCount, lts: r2, rate: 0 }), e2.totalDecodeTime && (t2.decodeMs = 1e3 * e2.totalDecodeTime), this.processVideoTrackReceiverStats(e2, e2.trackId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.framerateMean && (t2.framesRateFirefox = e2.framerateMean), t2.packets > 0 && !this.isFirstVideoReceived[t2.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t2.ssrc), this.isFirstVideoReceived[t2.ssrc] = true), this.lastDecodeVideoReceiverStats.set(t2.ssrc, { stats: RN({}, t2), lts: i3 ? i3.lts : Date.now(), qpSum: e2.qpSum });
      }
      processVideoOutboundStats(e2) {
        let t2 = this._stats.videoSend.find((t3) => t3.ssrc === e2.ssrc);
        t2 || (t2 = nN(lN), this._stats.videoSend.push(t2));
        const i3 = this.mediaBytesSent.get(e2.ssrc);
        if (i3)
          i3.add(e2.bytesSent);
        else {
          const t3 = new aN(10);
          t3.add(e2.bytesSent), this.mediaBytesSent.set(e2.ssrc, t3);
        }
        if (void 0 !== e2.retransmittedBytesSent) {
          const t3 = this.mediaBytesRetransmit.get(e2.ssrc);
          if (t3)
            t3.add(e2.retransmittedBytesSent);
          else {
            const t4 = new aN(10);
            t4.add(e2.retransmittedBytesSent), this.mediaBytesRetransmit.set(e2.ssrc, t4);
          }
        }
        if (e2.totalEncodedBytesTarget) {
          const t3 = this.mediaBytesTargetEncode.get(e2.ssrc);
          if (t3)
            t3.add(e2.totalEncodedBytesTarget);
          else {
            const t4 = new aN(10);
            t4.add(e2.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e2.ssrc, t4);
          }
        }
        if (t2.ssrc = e2.ssrc, t2.bytes = e2.bytesSent, t2.packets = e2.packetsSent, t2.firsCount = e2.firCount, t2.nacksCount = e2.nackCount, t2.plisCount = e2.pliCount, t2.frameCount = e2.framesEncoded, t2.adaptionChangeReason = e2.qualityLimitationReason, t2.scalabilityMode = e2.scalabilityMode, e2.totalEncodeTime && e2.framesEncoded) {
          const i4 = this.lastEncoderMs.get(e2.ssrc);
          if (!i4 || i4.lastFrameCount > e2.framesEncoded)
            t2.avgEncodeMs = 1e3 * e2.totalEncodeTime / e2.framesEncoded;
          else {
            const n2 = e2.framesEncoded - i4.lastFrameCount, r2 = e2.totalEncodeTime - i4.lastEncoderTime;
            t2.avgEncodeMs = 1e3 * r2 / n2;
          }
        }
        if (e2.framesEncoded && e2.qpSum) {
          const i4 = this.lastEncoderMs.get(e2.ssrc);
          !i4 || i4.lastFrameCount > e2.framesEncoded ? t2.qpSumPerFrame = e2.qpSum / e2.framesEncoded : t2.qpSumPerFrame = (e2.qpSum - i4.lastQpSum) / (e2.framesEncoded - i4.lastFrameCount);
        }
        if (this.lastEncoderMs.set(e2.ssrc, { lastFrameCount: e2.framesEncoded, lastEncoderTime: e2.totalEncodeTime, lastQpSum: e2.qpSum, lts: Date.now() }), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), e2.mediaSourceId && this.processVideoMediaSource(e2.mediaSourceId, t2), this.processVideoTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
          this.processRemoteInboundStats(e2.remoteId, t2);
        else {
          const i4 = this.findRemoteStatsId(e2.ssrc, kh.REMOTE_INBOUND);
          i4 && this.processRemoteInboundStats(i4, t2);
        }
      }
      processAudioOutboundStats(e2) {
        let t2 = this._stats.audioSend.find((t3) => t3.ssrc === e2.ssrc);
        if (t2 || (t2 = nN(hN), this._stats.audioSend.push(t2)), t2.ssrc = e2.ssrc, t2.packets = e2.packetsSent, t2.bytes = e2.bytesSent, e2.mediaSourceId && this.processAudioMediaSource(e2.mediaSourceId, t2), e2.codecId && (t2.codec = this.getCodecFromCodecStats(e2.codecId)), this.processAudioTrackSenderStats(e2, e2.trackId, t2), e2.remoteId)
          this.processRemoteInboundStats(e2.remoteId, t2);
        else {
          const i3 = this.findRemoteStatsId(e2.ssrc, kh.REMOTE_INBOUND);
          i3 && this.processRemoteInboundStats(i3, t2);
        }
      }
      findRemoteStatsId(e2, t2) {
        var i3;
        const n2 = Array.from(IR(i3 = this.report).call(i3)).find((i4) => i4.type === t2 && i4.ssrc === e2);
        return n2 ? n2.id : null;
      }
      processVideoMediaSource(e2, t2) {
        const i3 = this.report.get(e2);
        i3 && i3.width && i3.height && i3.framesPerSecond && (t2.inputFrame = { width: i3.width, height: i3.height, frameRate: i3.framesPerSecond });
      }
      processAudioMediaSource(e2, t2) {
        const i3 = this.report.get(e2);
        i3 && (t2.inputLevel = i3.audioLevel);
      }
      processVideoTrackSenderStats(e2, t2, i3) {
        var n2, r2, o2;
        const s2 = t2 ? this.report.get(t2) : void 0, a2 = null !== (n2 = null == s2 ? void 0 : s2.framesSent) && void 0 !== n2 ? n2 : e2.framesSent;
        let c2 = null !== (r2 = null == s2 ? void 0 : s2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, d2 = null !== (o2 = null == s2 ? void 0 : s2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight;
        if ("number" != typeof a2)
          return;
        "number" == typeof c2 && "number" == typeof d2 || (c2 = 0, d2 = 0);
        let u2 = 0;
        const l2 = Date.now(), h3 = this.lastVideoFramesSent.get(i3.ssrc);
        h3 && l2 - h3.lts >= 800 ? (u2 = Math.round((a2 - h3.count) / ((l2 - h3.lts) / 1e3)), this.lastVideoFramesSent.set(i3.ssrc, { count: a2, lts: l2, rate: u2 })) : h3 ? u2 = h3.rate : this.lastVideoFramesSent.set(i3.ssrc, { count: a2, lts: l2, rate: 0 }), i3.sentFrame = { width: c2, height: d2, frameRate: Math.max(0, u2) };
      }
      processVideoTrackReceiverStats(e2, t2, i3) {
        var n2, r2, o2, s2, a2;
        const c2 = t2 ? this.report.get(t2) : void 0, d2 = null !== (n2 = null == c2 ? void 0 : c2.framesReceived) && void 0 !== n2 ? n2 : e2.framesReceived, u2 = null !== (r2 = null == c2 ? void 0 : c2.frameWidth) && void 0 !== r2 ? r2 : e2.frameWidth, l2 = null !== (o2 = null == c2 ? void 0 : c2.frameHeight) && void 0 !== o2 ? o2 : e2.frameHeight, h3 = null !== (s2 = null == c2 ? void 0 : c2.jitterBufferDelay) && void 0 !== s2 ? s2 : e2.jitterBufferDelay, p3 = null !== (a2 = null == c2 ? void 0 : c2.jitterBufferEmittedCount) && void 0 !== a2 ? a2 : e2.jitterBufferEmittedCount;
        if ("number" == typeof d2) {
          const e3 = this.lastVideoFramesRecv.get(i3.ssrc), t3 = Date.now();
          i3.framesReceivedCount = d2;
          let n3 = 0;
          e3 && t3 - e3.lts >= 800 ? (n3 = Math.round((d2 - e3.count) / ((t3 - e3.lts) / 1e3)), this.lastVideoFramesRecv.set(i3.ssrc, { count: d2, lts: t3, rate: n3 })) : e3 ? n3 = e3.rate : this.lastVideoFramesRecv.set(i3.ssrc, { count: d2, lts: t3, rate: 0 }), i3.receivedFrame = { width: u2 || 0, height: l2 || 0, frameRate: n3 || 0 }, i3.decodedFrame = { width: u2 || 0, height: l2 || 0, frameRate: i3.decodeFrameRate || 0 }, i3.outputFrame = { width: u2 || 0, height: l2 || 0, frameRate: i3.decodeFrameRate || 0 };
        }
        if (h3 && p3) {
          let e3 = this.lastVideoJBDelay.get(i3.ssrc);
          this.lastVideoJBDelay.set(i3.ssrc, { jitterBufferDelay: h3, jitterBufferEmittedCount: p3 }), e3 || (e3 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
          const t3 = 1e3 * (h3 - e3.jitterBufferDelay) / (p3 - e3.jitterBufferEmittedCount);
          i3.jitterBufferMs = t3, i3.currentDelayMs = Math.round(t3);
        }
      }
      processAudioTrackSenderStats(e2, t2, i3) {
        var n2, r2, o2, s2;
        const a2 = t2 ? this.report.get(t2) : void 0, c2 = null !== (n2 = null !== (r2 = null == a2 ? void 0 : a2.echoReturnLoss) && void 0 !== r2 ? r2 : e2.echoReturnLoss) && void 0 !== n2 ? n2 : 0, d2 = null !== (o2 = null !== (s2 = null == a2 ? void 0 : a2.echoReturnLossEnhancement) && void 0 !== s2 ? s2 : e2.echoReturnLossEnhancement) && void 0 !== o2 ? o2 : 0;
        i3.aecReturnLoss = c2, i3.aecReturnLossEnhancement = d2;
      }
      processAudioTrackReceiverStats(e2, t2, i3) {
        var n2, r2, o2, s2, a2, c2, d2;
        const u2 = t2 ? this.report.get(t2) : void 0, l2 = null !== (n2 = null == u2 ? void 0 : u2.removedSamplesForAcceleration) && void 0 !== n2 ? n2 : e2.removedSamplesForAcceleration, h3 = null !== (r2 = null == u2 ? void 0 : u2.totalSamplesReceived) && void 0 !== r2 ? r2 : e2.totalSamplesReceived, p3 = null !== (o2 = null == u2 ? void 0 : u2.jitterBufferDelay) && void 0 !== o2 ? o2 : e2.jitterBufferDelay, _2 = null !== (s2 = null == u2 ? void 0 : u2.jitterBufferEmittedCount) && void 0 !== s2 ? s2 : e2.jitterBufferEmittedCount, E2 = null !== (a2 = null == u2 ? void 0 : u2.audioLevel) && void 0 !== a2 ? a2 : null == e2 ? void 0 : e2.audioLevel, m2 = null !== (c2 = null == u2 ? void 0 : u2.totalSamplesDuration) && void 0 !== c2 ? c2 : null == e2 ? void 0 : e2.totalSamplesDuration, f2 = null !== (d2 = null == u2 ? void 0 : u2.concealedSamples) && void 0 !== d2 ? d2 : e2.concealedSamples;
        if (l2 && h3 && (i3.accelerateRate = l2 / h3), p3 && _2) {
          let e3 = this.lastAudioJBDelay.get(i3.ssrc);
          this.lastAudioJBDelay.set(i3.ssrc, { jitterBufferDelay: p3, jitterBufferEmittedCount: _2 }), e3 || (e3 = { jitterBufferDelay: 0, jitterBufferEmittedCount: 0 });
          const t3 = 1e3 * (p3 - e3.jitterBufferDelay) / (_2 - e3.jitterBufferEmittedCount);
          i3.jitterBufferMs = Math.round(t3);
        }
        i3.outputLevel = E2;
        let S2 = 1920;
        m2 && h3 && (S2 = h3 / m2 / 50, i3.receivedFrames = Math.round(h3 / S2)), f2 && (i3.droppedFrames = Math.round(f2 / S2));
      }
      processRemoteInboundStats(e2, t2) {
        const i3 = this.report.get(e2);
        i3 && (t2.packetsLost = i3.packetsLost, i3.roundTripTime && (t2.rttMs = 1e3 * i3.roundTripTime));
      }
      getCodecFromCodecStats(e2) {
        const t2 = this.report.get(e2);
        if (!t2)
          return "";
        const i3 = t2.mimeType.match(/\/(.*)$/);
        return i3 && i3[1] ? i3[1] : "";
      }
      updateSendBitrate() {
        let e2 = 0, t2 = null, i3 = null;
        this.mediaBytesSent.forEach((t3) => {
          e2 += t3.diffMean();
        }), this.mediaBytesRetransmit.forEach((e3) => {
          t2 = null === t2 ? e3.diffMean() : t2 + e3.diffMean();
        }), this.mediaBytesTargetEncode.forEach((e3) => {
          i3 = null === i3 ? e3.diffMean() : i3 + e3.diffMean();
        });
        const n2 = null !== t2 ? e2 - t2 : e2;
        this._stats.bitrate = { actualEncoded: 8 * n2 / (this.options.updateInterval / 1e3), transmit: 8 * e2 / (this.options.updateInterval / 1e3) }, null !== t2 && (this._stats.bitrate.retransmit = 8 * t2 / (this.options.updateInterval / 1e3)), null !== i3 && (this._stats.bitrate.targetEncoded = 8 * i3 / (this.options.updateInterval / 1e3));
      }
    }
    class CN extends mN {
      updateStats() {
        return Sl.resolve();
      }
    }
    function vN(e2) {
      let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 250, i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 8, n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 500, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e4;
      const o2 = oN();
      return o2 ? o2 < 76 ? new TN(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new IN(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : sN(e2) ? new IN(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 }) : new CN(e2, { updateInterval: t2, lossRateInterval: i3, freezeRateLimit: n2, firstVideoDecodedTimeout: r2 });
    }
    var yN;
    function AN(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function ON(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? AN(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : AN(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let NN = (ag((yN = class e2 extends YS {
      get peerConnectionState() {
        return this.peerConnection.connectionState;
      }
      get iceConnectionState() {
        return this.peerConnection.iceConnectionState;
      }
      get currentLocalDescription() {
        return this.peerConnection.currentLocalDescription;
      }
      get currentRemoteDescription() {
        return this.peerConnection.currentRemoteDescription;
      }
      constructor(t2, i3) {
        super(t2, i3), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "remoteSDP", void 0), _p(this, "initialOffer", void 0), _p(this, "statsFilter", void 0), _p(this, "useRTX", false), _p(this, "localCapabilities", void 0), _p(this, "localCandidateCount", 0), _p(this, "allCandidatesReceived", false), _p(this, "establishPromise", void 0), _p(this, "mutex", new Ug("P2PConnection-mutex")), this.store = i3, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = vN(this.peerConnection, GE("STATS_UPDATE_INTERVAL"), void 0, Kh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
      }
      async establish() {
        try {
          const e3 = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
          if (!e3.sdp)
            throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
          const t2 = FO(e3.sdp), i3 = jO(e3.sdp, !this.useRTX, GE("FILTER_VIDEO_FEC"), GE("FILTER_AUDIO_FEC"), ["opus"]);
          return this.localCapabilities = i3, this.initialOffer = e3, ON(ON({}, t2), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i3 }, offerSDP: e3.sdp });
        } catch (e3) {
          throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
        }
      }
      async connect(e3, t2, i3, n2, r2, o2) {
        try {
          if (!this.initialOffer)
            throw new Error("Cannot establish P2PConnection without initial offer.");
          this.remoteSDP = new iN({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i3, remoteRTPCapabilities: n2.send, remoteSetup: r2, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec, cname: o2 });
          const s2 = this.remoteSDP.toString();
          await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
        }
      }
      send(e3, t2) {
        var i3 = this;
        return DO(function* () {
          const n2 = yield PO(i3.mutex.lock());
          try {
            if (!i3.remoteSDP)
              throw new Error("Cannot call P2PConnection.send before remote SDP created");
            const r2 = e3.map((e4) => i3.peerConnection.addTrack(e4._mediaStreamTrack)), o2 = yield PO(i3.peerConnection.createOffer()), s2 = UO.exports.parse(o2.sdp), a2 = e3.map((e4) => {
              const t3 = e4._mediaStreamTrack, n3 = s2.mediaDescriptions.find((e5) => e5.attributes.mid === t3.kind);
              if (!n3)
                throw new Error("Cannot extract ssrc from mediaDescription.");
              return function(e5, t4, i4) {
                const n4 = e5.attributes.ssrcs.filter((e6) => e6.attributes.label === t4), r3 = e5.attributes.ssrcGroups;
                if (0 === n4.length)
                  throw new Error("Cannot extract ssrc from plan-b SDP.");
                if (r3 && n4.length > 1) {
                  const e6 = r3.find((e7) => -1 !== e7.ssrcIds.indexOf(n4[0].ssrcId));
                  return e6 ? [{ ssrcId: e6.ssrcIds[0], rtx: i4 ? e6.ssrcIds[1] : void 0 }] : [{ ssrcId: n4[0].ssrcId }];
                }
                return [{ ssrcId: n4[0].ssrcId }];
              }(n3, t3.id, i3.useRTX);
            });
            let c2;
            try {
              c2 = yield a2;
            } catch (e4) {
              throw r2.forEach((e5) => {
                Hh() && e5.replaceTrack(null), i3.peerConnection.removeTrack(e5);
              }), e4;
            }
            const d2 = i3.mungSendOfferSDP(o2.sdp, e3);
            i3.remoteSDP.receive(e3, t2, c2);
            const u2 = i3.remoteSDP.toString();
            return yield PO(i3.peerConnection.setLocalDescription({ type: "offer", sdp: d2 })), yield PO(i3.applySendEncodings(r2, e3)), yield PO(i3.peerConnection.setRemoteDescription({ type: "answer", sdp: u2 })), e3.map((e4, t3) => {
              const i4 = e4._mediaStreamTrack.id;
              return { localSSRC: a2[t3], id: i4 };
            });
          } catch (e4) {
            throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
          } finally {
            n2();
          }
        })();
      }
      async stopSending(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
          const t2 = this.peerConnection.getSenders().filter((t3) => {
            var i4;
            return -1 !== e3.indexOf((null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) || "");
          });
          if (t2.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
          t2.map((e4) => {
            Hh() && e4.replaceTrack(null), this.peerConnection.removeTrack(e4);
          });
          const i3 = await this.peerConnection.createOffer();
          await this.peerConnection.setLocalDescription(i3), this.remoteSDP.stopReceiving(e3);
          const n2 = this.remoteSDP.toString();
          await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
        }
      }
      async receive(e3, t2, i3, n2) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
          const { id: i4, mslabel: r2 } = this.remoteSDP.send(e3, t2, n2), o2 = new Sl((t3, n3) => {
            const o3 = setTimeout(() => {
              n3(new Error("Cannot receive track, id: ".concat(i4)));
            }, 1e4), s3 = (n4) => {
              const a3 = xh();
              if (("Safari" === a3.name && 11 === Number(a3.version) || Yh()) && n4.track.id !== i4 && n4.streams[0].id === r2) {
                var c2;
                const r3 = n4.streams[0].getTracks()[0];
                return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(e3, i4, n4.track.id), this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(r3);
              }
              if (n4.track.id === i4)
                return this.peerConnection.removeEventListener("track", s3), clearTimeout(o3), void t3(n4.track);
            };
            this.peerConnection.addEventListener("track", s3);
          }), s2 = this.remoteSDP.toString();
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: s2 });
          const a2 = await this.peerConnection.createAnswer();
          await this.peerConnection.setLocalDescription(a2);
          return { track: await o2, id: i4 };
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
        }
      }
      async stopReceiving(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
          this.remoteSDP.stopSending(e3);
          const t2 = this.remoteSDP.toString();
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const i3 = await this.peerConnection.createAnswer();
          await this.peerConnection.setLocalDescription(i3);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
        }
      }
      async muteRemote(e3) {
      }
      async unmuteRemote(e3) {
      }
      async muteLocal(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
          const t2 = this.peerConnection.getSenders().filter((t3) => {
            var i3;
            return -1 !== e3.indexOf((null === (i3 = t3.track) || void 0 === i3 ? void 0 : i3.id) || "");
          });
          if (t2.length !== e3.length)
            throw new Error("sender' length doesn't match mids' length.");
          t2.map((e4) => {
            if (Hh() && e4.track)
              e4.track.enabled = false;
            else {
              const t3 = e4.getParameters();
              t3.encodings.forEach((e5) => e5.active = false), e4.setParameters(t3);
            }
          });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
        }
      }
      async unmuteLocal(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
          const t2 = this.peerConnection.getSenders().filter((t3) => {
            var i4;
            return -1 !== e3.indexOf((null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) || "");
          });
          if (t2.length !== e3.length)
            throw new Error("Senders' length doesn't match mids' length.");
          t2.map(async (e4) => {
            if (Hh() && e4.track)
              e4.track.enabled = true;
            else {
              const t3 = e4.getParameters();
              t3.encodings.forEach((e5) => e5.active = true), await e4.setParameters(t3);
            }
          });
          const i3 = await this.peerConnection.createOffer();
          await this.peerConnection.setLocalDescription(i3);
          const n2 = this.remoteSDP.toString();
          await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
        }
      }
      restartICE(e3) {
        var t2 = this;
        return DO(function* () {
          const i3 = yield PO(t2.mutex.lock("From P2PConnection.restartICE"));
          try {
            if (!t2.remoteSDP)
              throw new Error("Cannot restartICE before remoteSDP created.");
            if (JS().supportPCSetConfiguration) {
              const i4 = t2.peerConnection.getConfiguration(), n3 = e3 === OS.RELAY ? "relay" : "all";
              i4.iceTransportPolicy !== n3 && (OE.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i4.iceTransportPolicy, "] to [").concat(n3, "]")), i4.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i4));
            } else if (e3 === OS.RELAY)
              return;
            e3 !== OS.RELAY && t2.remoteSDP.updateCandidates(e3);
            const n2 = yield PO(t2.peerConnection.createOffer({ iceRestart: true }));
            if (!n2.sdp)
              throw new Error("Cannot restartICE because restart offer SDP does not exist.");
            const r2 = FO(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
            t2.remoteSDP.restartICE(o2);
            const s2 = t2.remoteSDP.toString();
            yield PO(t2.peerConnection.setLocalDescription(n2)), yield PO(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
          } catch (e4) {
            OE.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
          } finally {
            i3();
          }
        })();
      }
      close() {
        var e3;
        this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
      }
      getStats() {
        return this.statsFilter.getStats();
      }
      getRemoteVideoIsReady(e3) {
        return this.statsFilter.getVideoIsReady(e3);
      }
      async updateEncoderConfig(e3, t2) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
          const e4 = await this.peerConnection.createOffer(), i3 = this.mungSendOfferSDP(e4.sdp, [t2]);
          this.remoteSDP.updateRecvMedia(t2._mediaStreamTrack.kind, t2);
          const n2 = this.remoteSDP.toString();
          await this.peerConnection.setLocalDescription({ type: "offer", sdp: i3 }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, e4.toString());
        }
      }
      async updateSendParameters(e3, t2) {
        const i3 = this.peerConnection.getSenders().filter((t3) => {
          var i4;
          return (null === (i4 = t3.track) || void 0 === i4 ? void 0 : i4.id) === e3;
        });
        1 === i3.length && await this.applySendEncodings(i3, [t2]);
      }
      setStatsRemoteVideoIsReady(e3, t2) {
        this.statsFilter.setVideoIsReady2(e3, t2);
      }
      async replaceTrack(e3, t2) {
        const i3 = this.peerConnection.getSenders().find((e4) => {
          var i4;
          return (null === (i4 = e4.track) || void 0 === i4 ? void 0 : i4.id) === t2;
        });
        i3 && await i3.replaceTrack(e3._mediaStreamTrack);
      }
      bindPCEvents() {
        this.peerConnection.oniceconnectionstatechange = () => {
          var e3;
          null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
        }, this.peerConnection.onconnectionstatechange = () => {
          var e3;
          null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
        }, this.peerConnection.onicecandidate = (e3) => {
          e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
        }, setTimeout(() => {
          this.allCandidatesReceived || (this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
        }, GE("CANDIDATE_TIMEOUT"));
      }
      unbindPCEvents() {
        this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
      }
      static resolvePCConfiguration(t2) {
        const i3 = { iceServers: [], sdpSemantics: "plan-b" };
        return t2.iceServers ? i3.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i3.iceServers = t2.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t2.turnServer.serversFromGateway && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
          e3.forceturn && (i3.iceTransportPolicy = "relay");
        }))), i3;
      }
      static turnServerConfigToIceServers(e3) {
        const t2 = [];
        return e3.forEach((e4) => {
          e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
        }), t2;
      }
      async applySendEncodings(e3, t2) {
        try {
          if (!JS().supportSetRtpSenderParameters)
            return;
          if (e3.length !== t2.length)
            return;
          for (let n2 = 0; n2 < e3.length; n2++) {
            var i3;
            const r2 = e3[n2], o2 = t2[n2];
            if (!o2)
              continue;
            const s2 = {}, a2 = {};
            if (o2 instanceof Cy)
              switch (o2._optimizationMode) {
                case "motion":
                  s2.degradationPreference = "maintain-framerate";
                  break;
                case "detail":
                  s2.degradationPreference = "maintain-resolution";
                  break;
                default:
                  s2.degradationPreference = "balanced";
              }
            if (GE("DSCP_TYPE") && rp()) {
              const e4 = GE("DSCP_TYPE");
              ["very-low", "low", "medium", "high"].includes(e4) && (a2.networkPriority = e4);
            }
            const c2 = r2.getParameters(), d2 = null === (i3 = c2.encodings) || void 0 === i3 ? void 0 : i3[0];
            d2 && Object.assign(d2, a2), Object.assign(c2, s2), await r2.setParameters(c2);
          }
        } catch (e4) {
          OE.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
        }
      }
      mungSendOfferSDP(e3, t2) {
        const i3 = UO.exports.parse(e3);
        return t2.forEach((e4, t3) => {
          const n2 = e4._mediaStreamTrack, r2 = i3.mediaDescriptions.find((e5) => e5.attributes.mid === n2.kind);
          r2 && HO(r2, e4);
        }), UO.exports.print(i3);
      }
      bindStatsEvents() {
        this.statsFilter.onFirstAudioReceived = (e3) => {
          var t2;
          null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstVideoReceived = (e3) => {
          var t2;
          null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstAudioDecoded = (e3) => {
          var t2;
          null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i3) => {
          var n2;
          null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i3);
        }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
          var i3;
          null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
        }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
          var i3;
          null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
        };
      }
      unbindStatsEvents() {
        this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
      }
      async batchReceive(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
          const t2 = this.remoteSDP.batchSend(e3).map((t3, i4) => {
            let { id: n3, mslabel: r2 } = t3;
            const { kind: o2 } = e3[i4];
            return new Sl((e4, t4) => {
              const i5 = setTimeout(() => {
                t4(new Error("Cannot receive track, id: ".concat(n3)));
              }, 1e4), s2 = (t5) => {
                const a2 = xh();
                if ("Safari" === a2.name && 11 === Number(a2.version) && t5.track.id !== n3 && t5.streams[0].id === r2) {
                  var c2;
                  const r3 = t5.streams[0].getTracks()[0];
                  return null === (c2 = this.remoteSDP) || void 0 === c2 || c2.updateTrackLabel(o2, n3, t5.track.id), this.peerConnection.removeEventListener("track", s2), clearTimeout(i5), void e4({ track: r3, id: n3 });
                }
                if (t5.track.id === n3)
                  return this.peerConnection.removeEventListener("track", s2), clearTimeout(i5), void e4({ track: t5.track, id: n3 });
              };
              this.peerConnection.addEventListener("track", s2);
            });
          }), i3 = this.remoteSDP.toString();
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i3 });
          const n2 = await this.peerConnection.createAnswer();
          return await this.peerConnection.setLocalDescription(n2), await Sl.all(t2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
        }
      }
      async getRemoteSSRC(e3) {
        if (!this.remoteSDP)
          return;
        const t2 = this.remoteSDP.getSSRC(e3);
        return null == t2 ? void 0 : t2[0].ssrcId;
      }
      setConfiguration(t2) {
        if (JS().supportPCSetConfiguration) {
          const i3 = e2.resolvePCConfiguration(t2);
          this.peerConnection.setConfiguration(i3);
        }
      }
    }).prototype, "connect", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "connect"), yN.prototype), ag(yN.prototype, "stopSending", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "stopSending"), yN.prototype), ag(yN.prototype, "receive", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "receive"), yN.prototype), ag(yN.prototype, "stopReceiving", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "stopReceiving"), yN.prototype), ag(yN.prototype, "muteRemote", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "muteRemote"), yN.prototype), ag(yN.prototype, "unmuteRemote", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "unmuteRemote"), yN.prototype), ag(yN.prototype, "muteLocal", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "muteLocal"), yN.prototype), ag(yN.prototype, "unmuteLocal", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "unmuteLocal"), yN.prototype), ag(yN.prototype, "close", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "close"), yN.prototype), ag(yN.prototype, "updateEncoderConfig", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "updateEncoderConfig"), yN.prototype), ag(yN.prototype, "updateSendParameters", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "updateSendParameters"), yN.prototype), ag(yN.prototype, "replaceTrack", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "replaceTrack"), yN.prototype), ag(yN.prototype, "getRemoteSSRC", [bN], Object.getOwnPropertyDescriptor(yN.prototype, "getRemoteSSRC"), yN.prototype), yN);
    function bN(e2, t2, i3) {
      const n2 = e2[t2];
      if ("function" != typeof n2)
        throw new Error("Cannot use mutex on object property.");
      return i3.value = async function() {
        const e3 = this.mutex, i4 = await e3.lock("Locking from P2PConnection.".concat(t2));
        try {
          for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
            o2[s2] = arguments[s2];
          return await n2.apply(this, o2);
        } finally {
          i4();
        }
      }, i3;
    }
    function wN(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function DN(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? wN(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : wN(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    const PN = "9", LN = 4e4;
    class kN {
      get localCapabilities() {
        return uC(this._localCapabilities);
      }
      get rtpCapabilities() {
        return uC(this._rtpCapabilities);
      }
      get candidates() {
        return uC(this._candidates);
      }
      get iceParameters() {
        return uC(this._iceParameters);
      }
      get dtlsParameters() {
        return uC(this._dtlsParameters);
      }
      constructor(e2) {
        _p(this, "sessionDesc", void 0), _p(this, "_localCapabilities", void 0), _p(this, "_rtpCapabilities", void 0), _p(this, "_candidates", void 0), _p(this, "_iceParameters", void 0), _p(this, "_dtlsParameters", void 0), _p(this, "setup", void 0), _p(this, "currentMidIndex", void 0), _p(this, "cname", void 0), _p(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = uC(e2);
        const { remoteIceParameters: t2, remoteDtlsParameters: i3, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: o2, localCapabilities: s2, cname: a2 } = e2, c2 = UO.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
        this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i3, this._localCapabilities = s2, this.setup = o2, this.cname = a2;
        const d2 = this.rtpCapabilities.send;
        for (const e3 of c2.mediaDescriptions) {
          if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i3.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = o2, "video" === e3.media.mediaType && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
            const { ssrcs: t3, ssrcGroups: i4 } = WO([{ ssrcId: LN, rtx: GE("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
            e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i4;
          }
          if ("audio" === e3.media.mediaType && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, $O(e3), GE("PRELOAD_MEDIA_COUNT") > 0)) {
            const { ssrcs: t3, ssrcGroups: i4 } = WO([{ ssrcId: 2e4 }], this.cname);
            e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i4;
          }
        }
        this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
      }
      preloadRemoteMedia() {
        const e2 = GE("PRELOAD_MEDIA_COUNT");
        this.rtpCapabilities;
        const t2 = this.candidates, i3 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
        for (let o2 = 1; o2 < e2; o2++) {
          const e3 = 2 * o2 + 2e4, s2 = 2 * o2 + LN, { ssrcs: a2, ssrcGroups: c2 } = WO([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: u2 } = WO([{ ssrcId: s2, rtx: GE("USE_SUB_RTX") ? s2 + 1 : void 0 }], this.cname);
          this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2 + 1) } }), this.currentMidIndex += 2;
        }
        this.updateBundleMids();
      }
      toString() {
        return UO.exports.print(this.sessionDesc);
      }
      send(e2, t2, i3, n2) {
        const { ssrcs: r2, ssrcGroups: o2 } = WO(t2, this.cname, GE("SYNC_GROUP") ? i3 : void 0), s2 = this.findPreloadMediaDesc(r2);
        if (s2) {
          if (Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, s2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(s2);
            return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(s2, n2), { mid: s2.attributes.mid, needExchangeSDP: true };
          }
          return { mid: s2.attributes.mid, needExchangeSDP: false };
        }
        {
          const t3 = this.findAvailableMediaIndex(e2, r2);
          let i4;
          return -1 === t3 || 1 === t3 && (Hh() || zh()) || 0 === t3 && GE("USE_SUB_RTX") || Qh() ? (i4 = this.createOrRecycleSendMedia(e2, r2, o2, "sendonly", n2), this.updateBundleMids()) : (i4 = uC(this.sessionDesc.mediaDescriptions[t3]), i4.attributes.direction = "sendonly", i4.attributes.ssrcs = r2, i4.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i4, n2)), Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i4.attributes.mid), { mid: i4.attributes.mid, needExchangeSDP: true };
        }
      }
      batchSend(e2) {
        const t2 = e2.map((e3) => {
          let { kind: t3, ssrcMsg: i4, mslabel: n3 } = e3;
          return this.send(t3, i4, n3);
        }), i3 = [];
        let n2 = false;
        return t2.forEach((e3) => {
          let { mid: t3, needExchangeSDP: r2 } = e3;
          r2 && (n2 = true), i3.push(t3);
        }), { mids: i3, needExchangeSDP: n2 };
      }
      stopSending(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
        if (t2.length !== e2.length)
          throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
        t2.forEach((e3) => {
          "0" === e3.attributes.mid || Kh() || Qh() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
        }), this.updateBundleMids();
      }
      mute(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
        if (!t2)
          throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
        t2.attributes.direction = "inactive";
      }
      unmute(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
        if (!t2)
          throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
        t2.attributes.direction = "sendonly";
      }
      muteRemote(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
        if (t2.length !== e2.length)
          throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
        t2.forEach((e3) => {
          e3.attributes.direction = "inactive";
        });
      }
      unmuteRemote(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
        if (t2.length !== e2.length)
          throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
        t2.forEach((e3) => {
          e3.attributes.direction = "recvonly";
        });
      }
      receive(e2, t2, i3, n2) {
        e2.forEach((e3, r2) => {
          this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i3, n2[r2]);
        }), this.updateBundleMids();
      }
      stopReceiving(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
        if (t2.length !== e2.length)
          throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
        t2.forEach((e3) => {
          e3.media.port = "0", e3.attributes.direction = "inactive";
        }), this.updateBundleMids();
      }
      updateCandidates(e2) {
        e2 === OS.TCP ? this._candidates.forEach((e3) => {
          -1 === this._candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this._candidates.push(DN(DN({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
        }) : this._candidates = this._candidates.filter((e3) => "tcp" !== e3.transport);
        for (const e3 of this.sessionDesc.mediaDescriptions)
          e3.attributes.candidates = this.candidates;
      }
      restartICE(e2) {
        e2 = uC(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
          t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
        });
      }
      predictReceivingMids(e2) {
        const t2 = [];
        for (let i3 = 0; i3 < e2; i3++)
          t2.push((this.currentMidIndex + i3 + 1).toString(10));
        return t2;
      }
      findAvailableMediaIndex(e2, t2) {
        return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
          const n2 = i3.media.mediaType === e2 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
          if (Kh()) {
            if (n2) {
              const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
              return !(e3 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e3 || e3 !== i3.attributes.mid);
            }
            return false;
          }
          return n2;
        });
      }
      createOrRecycleRecvMedia(e2, t2, i3, n2, r2, o2) {
        const s2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = this.localCapabilities.send;
        let d2 = [];
        if (s2 === AS.VIDEO) {
          var u2, l2;
          if (GE("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (d2 = a2.videoCodecs.filter((e3) => {
            var t3, i4;
            return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2) && (null == e3 || null === (i4 = e3.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]) === GE("H264_PROFILE_LEVEL_ID");
          })), !d2 || 0 === (null === (u2 = d2) || void 0 === u2 ? void 0 : u2.length)) {
            const e3 = c2.videoCodecs.filter((e4) => {
              var t3;
              return ((null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2);
            });
            0 !== e3.length && (d2 = a2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
          }
          if (GE("USE_PUB_RTX")) {
            const e3 = d2.map((e4) => e4.payloadType.toString()), t3 = a2.videoCodecs.filter((t4) => {
              var i4, n3;
              return "rtx" === (null === (i4 = t4.rtpMap) || void 0 === i4 ? void 0 : i4.encodingName) && e3.includes((null === (n3 = t4.fmtp) || void 0 === n3 ? void 0 : n3.parameters.apt) || "");
            });
            d2 = [...d2, ...t3];
          }
          if (0 === d2.length)
            OE.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (l2 = a2.videoCodecs[0].rtpMap) || void 0 === l2 ? void 0 : l2.encodingName)), d2 = a2.videoCodecs;
        } else
          d2 = a2.audioCodecs.filter((e3) => {
            var t3;
            return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(r2);
          }), 0 === d2.length && (OE.warning("codec ".concat(r2, " not included in rtpCapabilities, fallback to opus")), d2 = a2.audioCodecs.filter((e3) => {
            var t3;
            return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes("opus");
          }));
        const h3 = s2 === AS.VIDEO ? a2.videoExtensions : a2.audioExtensions;
        this.currentMidIndex += 1;
        const p3 = "".concat(this.currentMidIndex);
        let _2 = { media: { mediaType: s2, port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: h3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(p3) } };
        _2 = this.mungRecvMediaDsec(_2, e2, o2);
        const E2 = this.findFirstClosedMedia(s2);
        if (E2) {
          const e3 = this.sessionDesc.mediaDescriptions.indexOf(E2);
          this.sessionDesc.mediaDescriptions[e3] = _2;
        } else
          this.sessionDesc.mediaDescriptions.push(_2);
        return _2;
      }
      createOrRecycleSendMedia(e2, t2, i3, n2, r2) {
        const o2 = this.rtpCapabilities.send, s2 = e2 === AS.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e2 === AS.VIDEO ? o2.videoExtensions : o2.audioExtensions;
        this.currentMidIndex += 1;
        const c2 = "".concat(this.currentMidIndex);
        let d2 = { media: { mediaType: e2, port: PN, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
        d2 = this.mungSendMediaDesc(d2, r2);
        const u2 = this.findFirstClosedMedia(e2);
        if (u2) {
          const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
          this.sessionDesc.mediaDescriptions[e3] = d2;
        } else
          this.sessionDesc.mediaDescriptions.push(d2);
        return d2;
      }
      updateBundleMids() {
        this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
      }
      mungRecvMediaDsec(e2, t2, i3) {
        const n2 = uC(e2);
        return KO(n2), HO(n2, t2), YO(n2, t2), qO(n2), JO(n2, i3, this.localCapabilities.send), n2;
      }
      mungSendMediaDesc(e2, t2) {
        const i3 = uC(e2);
        return JO(i3, t2, this.localCapabilities.recv), $O(i3), i3;
      }
      updateRecvMedia(e2, t2) {
        const i3 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
        if (-1 !== i3) {
          const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t2);
          this.sessionDesc.mediaDescriptions[i3] = e3;
        }
      }
      bumpMid(e2) {
        this.currentMidIndex += e2;
      }
      findFirstClosedMedia(e2) {
        return this.sessionDesc.mediaDescriptions.find((t2) => Kh() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
      }
      findPreloadMediaDesc(e2) {
        return this.sessionDesc.mediaDescriptions.find((t2) => {
          var i3, n2;
          return (null === (i3 = t2.attributes) || void 0 === i3 || null === (n2 = i3.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId) === e2[0].ssrcId;
        });
      }
      getSSRC(e2) {
        var t2;
        return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
      }
    }
    var MN;
    function UN(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function xN(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? UN(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : UN(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let VN = (ag((MN = class e2 extends YS {
      get currentLocalDescription() {
        return this.peerConnection.currentLocalDescription;
      }
      get currentRemoteDescription() {
        return this.peerConnection.currentRemoteDescription;
      }
      get peerConnectionState() {
        return this.peerConnection.connectionState;
      }
      get iceConnectionState() {
        return this.peerConnection.iceConnectionState;
      }
      get dtlsTransportState() {
        var e3, t2, i3;
        return null !== (e3 = null === (t2 = this.peerConnection.getReceivers()[0]) || void 0 === t2 || null === (i3 = t2.transport) || void 0 === i3 ? void 0 : i3.state) && void 0 !== e3 ? e3 : null;
      }
      constructor(t2, i3) {
        super(t2, i3), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "remoteSDP", void 0), _p(this, "initialOffer", void 0), _p(this, "transportEventReceiver", void 0), _p(this, "statsFilter", void 0), _p(this, "localCapabilities", void 0), _p(this, "localCandidateCount", 0), _p(this, "allCandidatesReceived", false), _p(this, "selectedCandidatePairTimer", void 0), _p(this, "establishPromise", void 0), _p(this, "mutex", new Ug("P2PConnection-mutex")), this.store = i3, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.statsFilter = vN(this.peerConnection, GE("STATS_UPDATE_INTERVAL"), void 0, Kh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
      }
      async establish() {
        try {
          this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
          const e3 = await this.peerConnection.createOffer();
          if (!e3.sdp)
            throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
          const t2 = FO(e3.sdp), i3 = await zO(!GE("USE_PUB_RTX") && !GE("USE_SUB_RTX"), GE("FILTER_VIDEO_FEC"), GE("FILTER_AUDIO_FEC"));
          return this.localCapabilities = ZO(i3), this.initialOffer = e3, xN(xN({}, t2), {}, { rtpCapabilities: i3, offerSDP: e3.sdp });
        } catch (e3) {
          throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e3.toString());
        }
      }
      async connect(e3, t2, i3, n2, r2, o2) {
        try {
          if (!this.initialOffer)
            throw new Error("Cannot establish P2PConnection without initial offer.");
          this.remoteSDP = new kN({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i3, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: this.localCapabilities, cname: o2 });
          const s2 = this.remoteSDP.toString(), a2 = UO.exports.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e4) => "audio" === e4.media.mediaType);
          c2 && $O(c2);
          const d2 = UO.exports.print(a2), u2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
          this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == u2 || u2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
          const l2 = this.peerConnection.getTransceivers()[0];
          if (null != l2 && l2.receiver && this.tryBindTransportEvents(l2.receiver), GE("PRELOAD_MEDIA_COUNT") > 0) {
            this.remoteSDP.preloadRemoteMedia();
            const e4 = this.remoteSDP.toString();
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
            const t3 = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(t3);
          }
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e4.toString()));
        }
      }
      send(e3, t2, i3) {
        var n2 = this;
        return DO(function* () {
          const r2 = yield PO(n2.mutex.lock("From P2PConnection.send"));
          try {
            if (!n2.remoteSDP)
              throw new Error("Cannot call P2PConnection.send before remote SDP created");
            const o2 = [];
            e3.forEach((e4) => {
              const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
              o2.push(t3), e4._updateRtpTransceiver(t3);
            }), Kh() && true === GE("SIMULCAST") && (yield PO(n2.applySimulcastForFirefox(o2, e3)));
            const s2 = yield PO(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e3.length), c2 = n2.mungSendOfferSDP(s2.sdp, e3, a2), d2 = UO.exports.parse(c2), u2 = a2.map((e4) => {
              const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
              if (!t3)
                throw new Error("Cannot extract ssrc from mediaDescription.");
              return BO(t3, GE("USE_PUB_RTX"));
            });
            let l2;
            try {
              l2 = yield u2;
            } catch (r3) {
              l2 = [], n2.remoteSDP.receive(e3, t2, i3, l2);
              const o3 = n2.remoteSDP.toString();
              throw yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield PO(n2.stopSending(a2, true)), r3;
            }
            n2.remoteSDP.receive(e3, t2, i3, l2);
            const h3 = n2.remoteSDP.toString(), p3 = n2.logSDPExchange(c2, "offer", "local", "send");
            return yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.applySimulcastEncodings(o2, e3)), yield PO(n2.applySendEncodings(o2, e3)), null == p3 || p3(h3), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h3 })), o2.map((e4, t3) => {
              const i4 = a2[t3];
              return { localSSRC: u2[t3], id: i4, transceiver: e4 };
            });
          } catch (e4) {
            throw e4 instanceof SE ? e4 : new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e4.toString()));
          } finally {
            r2();
          }
        })();
      }
      async stopSending(e3, t2) {
        const i3 = t2 ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
          const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
          if (t3.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
          t3.map((e4) => {
            var t4;
            e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
          });
          const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
          await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
          const o2 = this.remoteSDP.toString();
          null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e4.toString()));
        } finally {
          i3 && i3();
        }
      }
      async receive(e3, t2, i3, n2) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.receive ".concat(e3, " before remoteSDP created."));
          const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i3, n2);
          if (o2) {
            const t3 = this.remoteSDP.toString(), i4 = this.logSDPExchange(t3, "offer", "remote", "receive");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
            null == i4 || i4(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), OE.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " by exchanging SDP."));
          } else
            OE.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e3, " no need to exchange SDP."));
          const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
          if (!s2)
            throw new Error("Cannot get transceiver after setLocalDescription.");
          return { track: s2.receiver.track, id: r2, transceiver: s2 };
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
        }
      }
      async batchReceive(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
          const { mids: t2, needExchangeSDP: i3 } = this.remoteSDP.batchSend(e3);
          if (i3) {
            const e4 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e4, "offer", "remote", "receive");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
            const i4 = await this.peerConnection.createAnswer();
            null == t3 || t3(i4.sdp || ""), await this.peerConnection.setLocalDescription(i4), OE.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."));
          } else
            OE.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive no need to exchange SDP."));
          return t2.map((e4) => {
            const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
            if (!t3)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: t3.receiver.track, id: e4, transceiver: t3 };
          });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e4.toString()));
        }
      }
      async stopReceiving(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
          this.remoteSDP.stopSending(e3);
          const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const n2 = await this.peerConnection.createAnswer();
          null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e4.toString()));
        }
      }
      async muteRemote(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
          this.remoteSDP.mute(e3);
          const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const n2 = await this.peerConnection.createAnswer();
          null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e4.toString()));
        }
      }
      async unmuteRemote(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
          this.remoteSDP.unmute(e3);
          const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const n2 = await this.peerConnection.createAnswer();
          null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e4.toString()));
        }
      }
      async muteLocal(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
          const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
          if (t2.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length.");
          t2.map((e4) => {
            e4.direction = "inactive";
          });
          const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "muteLocal");
          await this.peerConnection.setLocalDescription(i3), this.remoteSDP.muteRemote(e3);
          const r2 = this.remoteSDP.toString();
          null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e4.toString()));
        }
      }
      async unmuteLocal(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
          const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
          if (t2.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length.");
          t2.map(async (e4, t3) => {
            e4.direction = "sendonly";
          });
          const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "unmuteLocal");
          await this.peerConnection.setLocalDescription(i3), this.remoteSDP.unmuteRemote(e3);
          const r2 = this.remoteSDP.toString();
          null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e4.toString()));
        }
      }
      restartICE(e3) {
        var t2 = this;
        return DO(function* () {
          const i3 = yield PO(t2.mutex.lock("From P2PConnection.restartICE"));
          try {
            if (!t2.remoteSDP)
              throw new Error("Cannot restartICE before remoteSDP created.");
            if (JS().supportPCSetConfiguration) {
              const i4 = t2.peerConnection.getConfiguration(), n3 = e3 === OS.RELAY ? "relay" : "all";
              i4.iceTransportPolicy !== n3 && (OE.debug("[".concat(t2.store.clientId, "] restartICE change iceTransportPolicy from [").concat(i4.iceTransportPolicy, "] to [").concat(n3, "]")), i4.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i4));
            } else if (e3 === OS.RELAY)
              return;
            e3 !== OS.RELAY && t2.remoteSDP.updateCandidates(e3);
            const n2 = yield PO(t2.peerConnection.createOffer({ iceRestart: true }));
            if (!n2.sdp)
              throw new Error("Cannot restartICE because restart offer SDP does not exist.");
            const r2 = FO(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
            t2.remoteSDP.restartICE(o2);
            const s2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
            t2.store.descriptionStart(), yield PO(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(s2), yield PO(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
          } catch (e4) {
            OE.warning("[".concat(t2.store.clientId, "] restart ICE failed, abort operation"), e4);
          } finally {
            i3();
          }
        })();
      }
      close() {
        var e3;
        this.peerConnection.close(), null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
      }
      getStats() {
        return this.statsFilter.getStats();
      }
      getRemoteVideoIsReady(e3) {
        return this.statsFilter.getVideoIsReady(e3);
      }
      async updateEncoderConfig(e3, t2) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
          const i3 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i3.sdp, [t2], [e3]);
          this.remoteSDP.updateRecvMedia(e3, t2);
          const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
          await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, e4.toString());
        }
      }
      async updateSendParameters(e3, t2) {
        const i3 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
        1 === i3.length && (this.isVP8Simulcast(t2) ? Kh() || await this.applySimulcastEncodings(i3, [t2]) : await this.applySendEncodings(i3, [t2]));
      }
      setStatsRemoteVideoIsReady(e3, t2) {
        this.statsFilter.setVideoIsReady2(e3, t2);
      }
      async replaceTrack(e3, t2) {
        const i3 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
        i3 && await i3.sender.replaceTrack(e3._mediaStreamTrack);
      }
      async getSelectedCandidatePair() {
        const e3 = this.peerConnection.getReceivers();
        if (e3.length > 0 && e3[0].transport && e3[0].transport.iceTransport && e3[0].transport.iceTransport.getSelectedCandidatePair && e3[0].transport.iceTransport.getSelectedCandidatePair()) {
          const t2 = e3[0].transport.iceTransport, { local: i3, remote: n2 } = t2.getSelectedCandidatePair();
          return { local: xN(xN({}, cN), {}, { candidateType: i3.type, protocol: i3.protocol, address: i3.address, port: i3.port }), remote: xN(xN({}, cN), {}, { candidateType: n2.type, protocol: n2.protocol, address: n2.address, port: n2.port }) };
        }
        return this.statsFilter.getSelectedCandidatePair();
      }
      bindPCEvents() {
        this.peerConnection.oniceconnectionstatechange = () => {
          var e3;
          null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
        }, this.peerConnection.onconnectionstatechange = () => {
          var e3;
          null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
        }, this.peerConnection.onicecandidate = (e3) => {
          e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
        }, setTimeout(() => {
          this.allCandidatesReceived || (this.allCandidatesReceived = true, OE.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
        }, GE("CANDIDATE_TIMEOUT"));
      }
      unbindPCEvents() {
        this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
      }
      static resolvePCConfiguration(t2) {
        const i3 = { iceServers: [] };
        return t2.iceServers ? i3.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i3.iceServers = t2.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t2.turnServer.serversFromGateway && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), GE("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
          e3.forceturn && (i3.iceTransportPolicy = "relay");
        }))), GE("ENABLE_ENCODED_TRANSFORM") && JS().supportWebRTCEncodedTransform && (i3.encodedInsertableStreams = true), i3;
      }
      static turnServerConfigToIceServers(e3) {
        const t2 = [];
        return e3.forEach((e4) => {
          e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(VI(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !GE("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
        }), t2;
      }
      tryBindTransportEvents(e3) {
        const t2 = e3.transport;
        if (t2) {
          this.transportEventReceiver = e3, t2.onstatechange = () => {
            var e4;
            null != t2 && t2.state && (null === (e4 = this.onDTLSTransportStateChange) || void 0 === e4 || e4.call(this, t2.state));
          }, t2.onerror = (e4) => {
            var t3;
            null === (t3 = this.onDTLSTransportError) || void 0 === t3 || t3.call(this, "error" in e4 ? e4.error : e4);
          };
          const i3 = t2.iceTransport;
          i3 && (i3.onstatechange = () => {
            const e4 = null == t2 ? void 0 : t2.iceTransport.state;
            var i4;
            e4 && (null === (i4 = this.onICETransportStateChange) || void 0 === i4 || i4.call(this, e4));
          }, i3.getSelectedCandidatePair && (i3.onselectedcandidatepairchange = () => {
            if (i3.getSelectedCandidatePair()) {
              const { local: e4, remote: t3 } = i3.getSelectedCandidatePair();
              OE.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: e4.type, protocol: e4.protocol }), ", remote ").concat(JSON.stringify({ candidateType: t3.type, protocol: t3.protocol, address: t3.address, port: t3.port }), " )"));
            }
          }));
        }
      }
      tryUnbindTransportEvents() {
        this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
      }
      async applySendEncodings(e3, t2) {
        try {
          if (!JS().supportSetRtpSenderParameters)
            return;
          if (e3.length !== t2.length)
            return;
          for (let c2 = 0; c2 < e3.length; c2++) {
            const d2 = e3[c2], u2 = t2[c2];
            if (u2 && u2 instanceof Cy) {
              var i3, n2;
              if (this.isVP8Simulcast(u2))
                continue;
              const e4 = {}, t3 = {};
              switch (u2._optimizationMode) {
                case "motion":
                  e4.degradationPreference = "maintain-framerate";
                  break;
                case "detail":
                  e4.degradationPreference = "maintain-resolution";
                  break;
                default:
                  e4.degradationPreference = "balanced";
              }
              var r2, o2, s2, a2;
              if (null !== (i3 = u2._encoderConfig) && void 0 !== i3 && i3.bitrateMax)
                t3.maxBitrate = 1e3 * (null === (r2 = u2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax);
              if (u2._hints.includes(lS.LOW_STREAM))
                null !== (o2 = u2._encoderConfig) && void 0 !== o2 && o2.frameRate && (t3.maxFramerate = FI(u2._encoderConfig.frameRate)), null !== (s2 = u2._encoderConfig) && void 0 !== s2 && s2.scaleResolutionDownBy && (null === (a2 = u2._encoderConfig) || void 0 === a2 ? void 0 : a2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = u2._encoderConfig.scaleResolutionDownBy);
              if (GE("DSCP_TYPE") && rp()) {
                const e5 = GE("DSCP_TYPE");
                ["very-low", "low", "medium", "high"].includes(e5) && (t3.networkPriority = e5);
              }
              const c3 = d2.sender.getParameters(), l2 = null === (n2 = c3.encodings) || void 0 === n2 ? void 0 : n2[0];
              Kh() && !l2 && (e4.encodings = [t3]), l2 && Object.assign(l2, t3), Object.assign(c3, e4), await d2.sender.setParameters(c3);
            }
          }
        } catch (e4) {
          OE.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
        }
      }
      mungSendOfferSDP(e3, t2, i3) {
        const n2 = UO.exports.parse(e3);
        return t2.forEach((e4, t3) => {
          const r2 = i3[t3], o2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
          o2 && (HO(o2, e4), XO(o2, e4, this.store.codec));
        }), UO.exports.print(n2);
      }
      mungReceiveAnswerSDP(e3, t2, i3) {
        const n2 = UO.exports.parse(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
        return r2 && i3 === AS.AUDIO && "audio" === r2.media.mediaType && $O(r2), UO.exports.print(n2);
      }
      bindStatsEvents() {
        this.statsFilter.onFirstAudioReceived = (e3) => {
          var t2;
          null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstVideoReceived = (e3) => {
          var t2;
          null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstAudioDecoded = (e3) => {
          var t2;
          null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i3) => {
          var n2;
          null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i3);
        }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
          var i3;
          null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
        }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
          var i3;
          null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
        }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
          var t2;
          null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
        };
      }
      unbindStatsEvents() {
        this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
      }
      async applySimulcastForFirefox(e3, t2) {
        if (e3.length === t2.length)
          for (let s2 = 0; s2 < e3.length; s2++) {
            var i3, n2, r2, o2;
            const a2 = e3[s2], c2 = t2[s2];
            if (c2 instanceof Cy && !c2._hints.includes(lS.LOW_STREAM) && null !== (i3 = c2._encoderConfig) && void 0 !== i3 && i3.bitrateMax && (null === (n2 = c2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = c2._scalabiltyMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = c2._scalabiltyMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t3 = { high: 1e3 * (c2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i4 = a2.sender.getParameters();
              await a2.sender.setParameters(Object.assign(i4, e4));
            }
          }
      }
      async applySimulcastEncodings(e3, t2) {
        if (!Kh() && e3.length === t2.length)
          for (let i3 = 0; i3 < e3.length; i3++) {
            const n2 = t2[i3];
            if (n2 instanceof Cy && this.isVP8Simulcast(n2)) {
              const t3 = e3[i3], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(s2, r2));
            }
          }
      }
      isVP8Simulcast(e3) {
        var t2, i3, n2, r2;
        return !!(e3 instanceof Cy && GE("SIMULCAST") && "vp8" === this.store.codec && !e3._hints.includes(lS.LOW_STREAM) && null !== (t2 = e3._encoderConfig) && void 0 !== t2 && t2.bitrateMax && (null === (i3 = e3._encoderConfig) || void 0 === i3 ? void 0 : i3.bitrateMax) > 200 && null !== (n2 = e3._scalabiltyMode) && void 0 !== n2 && n2.numSpatialLayers && (null === (r2 = e3._scalabiltyMode) || void 0 === r2 ? void 0 : r2.numSpatialLayers) > 1);
      }
      logSDPExchange(e3, t2, i3, n2) {
        if (GE("SDP_LOGGING"))
          return OE.upload("[".concat(this.store.clientId, "] exchanging ").concat(i3, " ").concat(t2, " SDP during P2PConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i3 ? "remote" : "local", n2);
          } : void 0;
      }
      async getRemoteSSRC(e3) {
        if (!this.remoteSDP)
          return;
        const t2 = this.remoteSDP.getSSRC(e3);
        return null == t2 ? void 0 : t2[0].ssrcId;
      }
      setConfiguration(t2) {
        if (JS().supportPCSetConfiguration) {
          const i3 = e2.resolvePCConfiguration(t2);
          this.peerConnection.setConfiguration(i3);
        }
      }
    }).prototype, "connect", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "connect"), MN.prototype), ag(MN.prototype, "receive", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "receive"), MN.prototype), ag(MN.prototype, "batchReceive", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "batchReceive"), MN.prototype), ag(MN.prototype, "stopReceiving", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "stopReceiving"), MN.prototype), ag(MN.prototype, "muteRemote", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "muteRemote"), MN.prototype), ag(MN.prototype, "unmuteRemote", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "unmuteRemote"), MN.prototype), ag(MN.prototype, "muteLocal", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "muteLocal"), MN.prototype), ag(MN.prototype, "unmuteLocal", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "unmuteLocal"), MN.prototype), ag(MN.prototype, "close", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "close"), MN.prototype), ag(MN.prototype, "updateEncoderConfig", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "updateEncoderConfig"), MN.prototype), ag(MN.prototype, "updateSendParameters", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "updateSendParameters"), MN.prototype), ag(MN.prototype, "replaceTrack", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "replaceTrack"), MN.prototype), ag(MN.prototype, "getRemoteSSRC", [jN], Object.getOwnPropertyDescriptor(MN.prototype, "getRemoteSSRC"), MN.prototype), MN);
    function jN(e2, t2, i3) {
      const n2 = e2[t2];
      if ("function" != typeof n2)
        throw new Error("Cannot use mutex on object property.");
      return i3.value = async function() {
        const e3 = this.mutex, i4 = await e3.lock("From P2PConnection.".concat(t2));
        try {
          for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
            o2[s2] = arguments[s2];
          return await n2.apply(this, o2);
        } finally {
          i4();
        }
      }, i3;
    }
    function FN(e2, t2) {
      let i3 = document.createElement("video"), n2 = document.createElement("canvas");
      i3.setAttribute("style", "display:none"), n2.setAttribute("style", "display:none"), i3.setAttribute("muted", ""), i3.muted = true, i3.setAttribute("autoplay", ""), i3.autoplay = true, i3.setAttribute("playsinline", ""), n2.width = FI(t2.width), n2.height = FI(t2.height);
      const r2 = FI(t2.framerate || 15);
      document.body.append(i3), document.body.append(n2);
      let o2 = e2._mediaStreamTrack;
      i3.srcObject = new MediaStream([o2]), i3.play();
      const s2 = n2.getContext("2d");
      if (!s2)
        throw new SE(fE.UNEXPECTED_ERROR, "can not get canvas context");
      const a2 = JS(), c2 = n2.captureStream(a2.supportRequestFrame ? 0 : r2).getVideoTracks()[0], d2 = Jg(() => (() => {
        if (i3.paused && i3.play(), i3.videoHeight > 2 && i3.videoWidth > 2) {
          const e3 = i3.videoWidth, t3 = i3.videoHeight / e3, r3 = n2.width * t3;
          Math.abs(r3 - n2.height) >= 2 && (OE.debug("adjust low stream resolution", "".concat(n2.width, "x").concat(n2.height, " -> ").concat(n2.width, "x").concat(r3)), n2.height = r3);
        }
        s2.drawImage(i3, 0, 0, n2.width, n2.height), c2.requestFrame && c2.requestFrame(), o2 !== e2._mediaStreamTrack && (o2 = e2._mediaStreamTrack, i3.srcObject = new MediaStream([o2]));
      })(), r2), u2 = c2.stop;
      return c2.stop = () => {
        u2.call(c2), d2(), i3 && (i3.remove(), i3 = null), n2 && (n2.width = 0, n2.remove(), n2 = null), OE.debug("clean low stream renderer");
      }, c2;
    }
    var BN, GN, WN, HN, KN, YN, qN, JN, XN, zN, QN, ZN;
    function $N(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function eb(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? $N(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : $N(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class tb extends Lg {
      getUserId() {
        return this._userId;
      }
      constructor(e2, t2, i3, n2) {
        super(e2, "track-".concat(e2.kind, "-").concat(t2, "-").concat(n2.clientId, "_").concat(ZI(5, ""))), _p(this, "_userId", void 0), _p(this, "_uintId", void 0), _p(this, "_isDestroyed", false), _p(this, "store", void 0), _p(this, "processor", void 0), _p(this, "processorContext", void 0), this._userId = t2, this._uintId = i3, this.store = n2;
      }
      _updateOriginMediaStreamTrack(e2) {
        this._originMediaStreamTrack = e2, this._mediaStreamTrack = e2, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
      }
      _destroy() {
        this._isDestroyed = true, OE.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
      }
      getProcessorStats() {
        return this.processorContext.gatherStats();
      }
      getProcessorUsage() {
        return this.processorContext.gatherUsage();
      }
    }
    let ib = (BN = Dg({ argsMap: (e2, t2, i3) => [e2.getTrackId(), "string" == typeof t2 ? t2 : t2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", i3] }), GN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), WN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), HN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((KN = class extends tb {
      get isPlaying() {
        return !(!this._player || this._player.videoElementStatus !== sf.PLAYING);
      }
      get __className__() {
        return "RemoteVideoTrack";
      }
      constructor(e2, t2, i3, n2) {
        super(e2, t2, i3, n2), _p(this, "_videoVisibleTimer", null), _p(this, "_previousVideoVisibleStatus", void 0), _p(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), _p(this, "trackMediaType", "video"), _p(this, "_videoWidth", void 0), _p(this, "_videoHeight", void 0), _p(this, "_player", void 0), _p(this, "processorDestination", void 0), _p(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new AR(this.getTrackId(), "remote"), this.processorDestination = new yR(this.processorContext), this.bindProcessorDestinationEvents();
      }
      getStats() {
        hC(() => {
          OE.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
        }, "remoteVideoTrackGetStatsWarning");
        return oC(this, uS.GET_STATS) || eb({}, Wf);
      }
      play(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if ("string" == typeof e2) {
          const t3 = document.getElementById(e2);
          t3 ? e2 = t3 : (OE.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e2, '" element, use document.body')), e2 = document.body);
        }
        OE.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e2 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(t2));
        const i3 = eb(eb({ fit: "cover" }, t2), {}, { trackId: this.getTrackId(), element: e2 });
        this._player ? this._player.updateConfig(i3) : (e2 instanceof HTMLVideoElement ? this._player = new Pv(i3) : this._player = new kv(i3), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
          this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(fS.FIRST_FRAME_DECODED);
        }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
          try {
            const e3 = this.getVideoElementVisibleStatus();
            this.safeEmit(fS.VIDEO_ELEMENT_VISIBLE_STATUS, e3);
          } catch (e3) {
          }
        }, GE("CHECK_VIDEO_VISIBLE_INTERVAL"));
      }
      stop() {
        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, OE.debug("[".concat(this.getTrackId(), "] stop video playback")));
      }
      getCurrentFrameData() {
        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
      }
      updateMediaStreamTrackResolution() {
        tC(this._originMediaStreamTrack).then((e2) => {
          let [t2, i3] = e2;
          this._videoHeight = i3, this._videoWidth = t2;
        }).catch(eC);
      }
      _updatePlayerSource() {
        OE.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
      }
      getVideoElementVisibleStatus() {
        try {
          var e2, t2;
          const i3 = null == this || null === (e2 = this._player) || void 0 === e2 ? void 0 : e2.getContainerElement(), n2 = { track: this, element: null == this || null === (t2 = this._player) || void 0 === t2 ? void 0 : t2.getVideoElement(), slot: null == i3 ? void 0 : i3.parentElement }, { element: r2, slot: o2 } = n2;
          if (this.isPlaying && r2 instanceof HTMLVideoElement && o2 instanceof HTMLElement) {
            const e3 = gy.checkOneElementVisible(r2), t3 = Object.assign({}, e3);
            if (t3.visible !== this._previousVideoVisibleStatus) {
              this._previousVideoVisibleStatus = t3.visible;
              const e4 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
              t3.visible ? e4.onSuccess("Video is visible") : e4.onSuccess("Invisible because of ".concat(t3.reason));
            }
            return t3;
          }
          return;
        } catch (e3) {
          throw new SE(fE.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e3.message);
        }
      }
      pipe(e2) {
        if (this.processor === e2)
          return e2;
        if (e2._source)
          throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
        return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e2;
      }
      unpipe() {
        if (!this.processor)
          return;
        const e2 = this.processor;
        this.processor._source = void 0, this.processor = void 0, e2.reset();
      }
      bindProcessorDestinationEvents() {
        this.processorDestination.on(kS.ON_TRACK, async (e2) => {
          e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
        });
      }
      unbindProcessorDestinationEvents() {
        this.processorDestination.removeAllListeners(kS.ON_TRACK);
      }
      _destroy() {
        super._destroy(), this.unbindProcessorDestinationEvents();
      }
    }).prototype, "play", [BN], Object.getOwnPropertyDescriptor(KN.prototype, "play"), KN.prototype), ag(KN.prototype, "stop", [GN], Object.getOwnPropertyDescriptor(KN.prototype, "stop"), KN.prototype), ag(KN.prototype, "pipe", [WN], Object.getOwnPropertyDescriptor(KN.prototype, "pipe"), KN.prototype), ag(KN.prototype, "unpipe", [HN], Object.getOwnPropertyDescriptor(KN.prototype, "unpipe"), KN.prototype), KN), nb = (YN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2], throttleTime: 300 }), qN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2] }), JN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), XN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), zN = Dg({ argsMap: (e2, t2) => [e2.getTrackId(), t2.name] }), QN = Dg({ argsMap: (e2) => [e2.getTrackId()] }), ag((ZN = class extends tb {
      get isPlaying() {
        return this._useAudioElement ? pR.isPlaying(this.getTrackId()) : this._source.isPlayed;
      }
      get __className__() {
        return "RemoteAudioTrack";
      }
      constructor(e2, t2, i3, n2) {
        super(e2, t2, i3, n2), _p(this, "trackMediaType", "audio"), _p(this, "_source", void 0), _p(this, "_useAudioElement", true), _p(this, "_volume", 100), _p(this, "processorContext", void 0), _p(this, "processorDestination", void 0), _p(this, "_played", false), _p(this, "_bypassWebAudio", false), GE("DISABLE_WEBAUDIO") ? (this._source = new bR(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new Qg(e2, true), GE("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(Lf.RECEIVE_TRACK_BUFFER, () => {
          this.safeEmit(fS.FIRST_FRAME_DECODED);
        }), this.processorContext = new NR(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new OR(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(Lf.UPDATE_SOURCE, () => {
          this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
        });
      }
      setAudioFrameCallback(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
        if (!e2)
          return this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
        this._source.startGetAudioBuffer(t2), this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER), this._source.on(Lf.ON_AUDIO_BUFFER, (t3) => e2(t3));
      }
      setVolume(e2) {
        this._volume = e2, this._useAudioElement ? pR.setVolume(this.getTrackId(), e2) : this._source.setVolume(e2 / 100);
      }
      async setPlaybackDevice(e2) {
        if (!this._useAudioElement)
          throw new SE(fE.NOT_SUPPORTED, "your browser does not support setting the audio output device");
        await pR.setSinkID(this.getTrackId(), e2);
      }
      getVolumeLevel() {
        return this._source.getAccurateVolumeLevel();
      }
      getStats() {
        hC(() => {
          OE.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
        }, "remoteAudioTrackGetStatsWarning");
        return oC(this, uS.GET_STATS) || eb({}, Bf);
      }
      play() {
        OE.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (OE.debug("[".concat(this.getTrackId(), "] use audio element to play")), pR.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
      }
      stop() {
        OE.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? pR.stop(this.getTrackId()) : this._source.stop();
      }
      _destroy() {
        super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
      }
      _isFreeze() {
        return this._source.isFreeze;
      }
      _updatePlayerSource() {
        let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        OE.debug("[".concat(this.getTrackId(), "] update player source track")), e2 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && pR.updateTrack(this.getTrackId(), this._mediaStreamTrack);
      }
      pipe(e2) {
        if (this._bypassWebAudio)
          throw new SE(fE.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
        if (this.processor === e2)
          return e2;
        if (e2._source)
          throw new SE(fE.INVALID_OPERATION, "Processor ".concat(e2.name, " already piped, please call unpipe beforehand."));
        return this.unpipe(), this.processor = e2, this.processor._source = this, e2.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), e2;
      }
      unpipe() {
        var e2;
        if (this._bypassWebAudio)
          throw new SE(fE.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
        if (!this.processor)
          return;
        const t2 = this.processor;
        null === (e2 = this._source.processSourceNode) || void 0 === e2 || e2.disconnect(), this.processor._source = false, this.processor = void 0, t2.reset();
      }
      bindProcessorDestinationEvents() {
        this.processorDestination.on(kS.ON_TRACK, async (e2) => {
          e2 ? e2 !== this._mediaStreamTrack && (this._mediaStreamTrack = e2, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e2)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
        }), this.processorDestination.on(kS.ON_NODE, (e2) => {
          this._source.processedNode = e2;
          const t2 = !e2;
          this._useAudioElement !== t2 && (this._played ? (this.stop(), this._useAudioElement = t2, this.play()) : this._useAudioElement = t2);
        });
      }
      unbindProcessorDestinationEvents() {
        this.processorDestination.removeAllListeners(kS.ON_TRACK), this.processorDestination.removeAllListeners(kS.ON_NODE);
      }
    }).prototype, "setVolume", [YN], Object.getOwnPropertyDescriptor(ZN.prototype, "setVolume"), ZN.prototype), ag(ZN.prototype, "setPlaybackDevice", [qN], Object.getOwnPropertyDescriptor(ZN.prototype, "setPlaybackDevice"), ZN.prototype), ag(ZN.prototype, "play", [JN], Object.getOwnPropertyDescriptor(ZN.prototype, "play"), ZN.prototype), ag(ZN.prototype, "stop", [XN], Object.getOwnPropertyDescriptor(ZN.prototype, "stop"), ZN.prototype), ag(ZN.prototype, "pipe", [zN], Object.getOwnPropertyDescriptor(ZN.prototype, "pipe"), ZN.prototype), ag(ZN.prototype, "unpipe", [QN], Object.getOwnPropertyDescriptor(ZN.prototype, "unpipe"), ZN.prototype), ZN);
    function rb(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function ob(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? rb(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : rb(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    class sb extends EE {
      constructor() {
        super(), _p(this, "uplinkStatsUploadInterval", void 0), _p(this, "uplinkRelatedStatsUploadInterval", void 0), _p(this, "uplinkDenoiserStatsUploadInterval", void 0), _p(this, "transportStatsUploadInterval", void 0), _p(this, "uplinkExtensionStatsUploadInterval", void 0), _p(this, "downlinkExtensionStatsUploadInterval", void 0), _p(this, "extensionUsageStatsUploadInterval", void 0), _p(this, "downlinkStatsUploadInterval", void 0), _p(this, "downlinkRelatedStatsUploadInterval", void 0), _p(this, "lastStats", void 0), _p(this, "uploadUnplinkStarted", false), _p(this, "uploadDownlinkStarted", false), _p(this, "uploadTransportStarted", false), _p(this, "uploadExtensionUsageStarted", false), _p(this, "requestStats", void 0), _p(this, "requestLocalMedia", void 0), _p(this, "requestRemoteMedia", void 0), _p(this, "requestAllTracks", void 0), _p(this, "requestVideoIsReady", void 0), _p(this, "requestUpload", void 0);
      }
      startUploadTransportStats() {
        this.uploadTransportStarted || (this.uploadTransportStarted = true, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {
          var e2;
          const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
          t2 && this.uploadTransportStats(t2);
        }, 1e3));
      }
      startUploadExtensionUsageStats() {
        if (this.uploadExtensionUsageStarted)
          return;
        this.uploadExtensionUsageStarted = true, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval);
        const e2 = /* @__PURE__ */ new Map();
        this.extensionUsageStatsUploadInterval = window.setInterval(async () => {
          var t2, i3, n2;
          const r2 = Date.now(), o2 = { connectionInterval: GE("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: r2 };
          let s2 = [];
          const a2 = (null === (t2 = this.requestAllTracks) || void 0 === t2 ? void 0 : t2.call(this)) || [];
          for (const e3 of a2)
            !e3.muted && e3.enabled && (s2 = s2.concat(await e3.getProcessorUsage()));
          const c2 = (null === (i3 = this.requestRemoteMedia) || void 0 === i3 ? void 0 : i3.call(this)) || [];
          for (const [e3, t3] of c2)
            t3.has(AS.VIDEO) && e3.videoTrack && (s2 = s2.concat(await e3.videoTrack.getProcessorUsage())), t3.has(AS.AUDIO) && e3.audioTrack && (s2 = s2.concat(await e3.audioTrack.getProcessorUsage()));
          if (0 === s2.length)
            return;
          o2.details = function(e3, t3) {
            const i4 = {};
            for (const { id: s3, value: a3, level: c3, direction: d3 } of e3) {
              var n3;
              const e4 = null !== (n3 = t3.get(s3)) && void 0 !== n3 ? n3 : 0, u3 = 2 === a3 ? e4 + GE("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e4;
              var r3, o3;
              t3.set(s3, u3), i4[s3] ? (2 === a3 && (i4[s3].value = a3), c3 > i4[s3].level && (i4[s3].level = c3), "remote" === d3 && (i4[s3].remoteUidCount += 1), i4[s3].totalTs = null !== (r3 = t3.get(s3)) && void 0 !== r3 ? r3 : 0) : i4[s3] = { value: a3, level: c3, remoteUidCount: "local" === d3 ? 0 : 1, totalTs: null !== (o3 = t3.get(s3)) && void 0 !== o3 ? o3 : 0 };
            }
            return Object.keys(i4).map((e4) => {
              const { level: t4, value: n4, totalTs: r4 } = i4[e4];
              return { id: e4, level: t4, value: n4, totalTs: r4 };
            });
          }(s2, e2);
          const d2 = Date.now(), u2 = d2 > r2 ? d2 : r2 + 1;
          null === (n2 = this.requestUpload) || void 0 === n2 || n2.call(this, wf.EXTENSION_USAGE_STATS, { usageStats: o2, sendTs: u2 });
        }, GE("EXTENSION_USAGE_UPLOAD_INTERVAL"));
      }
      startUploadUplinkStats() {
        this.uploadUnplinkStarted || (this.uploadUnplinkStarted = true, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {
          var e2;
          const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
          t2 && (this.uploadUplinkStats(t2), this.lastStats = t2);
        }, 3e3), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {
          var e2;
          const t2 = null === (e2 = this.requestStats) || void 0 === e2 ? void 0 : e2.call(this);
          t2 && this.uploadRelatedUplinkStats(t2, this.lastStats), this.lastStats = t2;
        }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {
          var e2;
          const t2 = null === (e2 = this.requestAllTracks) || void 0 === e2 ? void 0 : e2.call(this);
          t2 && this.uploadDenoiserStats(t2);
        }, 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval(() => {
          var e2;
          const t2 = null === (e2 = this.requestAllTracks) || void 0 === e2 ? void 0 : e2.call(this);
          t2 && this.uploadExtensionStats(t2);
        }, 2e3));
      }
      uploadTransportStats(e2) {
        dC(() => {
          var t2;
          null === (t2 = this.requestUpload) || void 0 === t2 || t2.call(this, wf.TRANSPORT_STATS, function(e3) {
            const t3 = { connectionType: 100, googRtt: e3.rtt };
            if ("relay" === e3.selectedCandidatePair.localCandidate.candidateType) {
              const i3 = e3.selectedCandidatePair.localCandidate.relayProtocol;
              "udp" === i3 && (t3.connectionType = 101), "tcp" === i3 && (t3.connectionType = 103), "tls" === i3 && (t3.connectionType = 104);
            }
            return t3;
          }(e2));
        });
      }
      uploadUplinkStats(e2) {
        var t2;
        ((null === (t2 = this.requestLocalMedia) || void 0 === t2 ? void 0 : t2.call(this)) || []).forEach((t3) => {
          let [i3, { track: n2, ssrcs: r2 }] = t3;
          switch (i3) {
            case bS.LocalVideoLowTrack:
            case bS.LocalVideoTrack: {
              const t4 = function(e3, t5, i4) {
                var n3;
                const r3 = t5.videoSend.find((t6) => t6.ssrc === e3);
                if (!r3)
                  return null;
                const o3 = { id: ZI(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: r3.ssrc.toString() };
                switch (o3.A_vstd = i4._originMediaStreamTrack && !i4._originMediaStreamTrack.enabled || i4._mediaStreamTrack && !i4._mediaStreamTrack.enabled ? "1" : "0", r3.sentFrame && (o3.A_fhs = r3.sentFrame.height.toString(), o3.A_frs = r3.sentFrame.frameRate.toString(), o3.A_fws = r3.sentFrame.width.toString()), r3.adaptionChangeReason) {
                  case "none":
                    o3.A_ac = "0";
                    break;
                  case "cpu":
                    o3.A_ac = "1";
                    break;
                  case "bandwidth":
                    o3.A_ac = "2";
                    break;
                  case "other":
                    o3.A_ac = "3";
                }
                return o3.A_lvps = af[i4._player ? i4._player.videoElementStatus : "uninit"].toString(), o3.A_nr = null === (n3 = r3.nacksCount) || void 0 === n3 ? void 0 : n3.toString(), r3.avgEncodeMs && (o3.A_aem = r3.avgEncodeMs.toFixed(0).toString()), o3;
              }(r2[0].ssrcId, e2, n2), o2 = i3 === bS.LocalVideoTrack ? function(e3, t5, i4) {
                var n3, r3, o3, s3, a2, c2, d2, u2;
                const l2 = t5.videoSend.find((t6) => t6.ssrc === e3);
                if (!l2)
                  return null;
                const h3 = { id: ZI(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: l2.ssrc.toString() }, p3 = null !== (n3 = null !== (r3 = null === (o3 = l2.inputFrame) || void 0 === o3 ? void 0 : o3.height) && void 0 !== r3 ? r3 : null == i4 ? void 0 : i4._videoHeight) && void 0 !== n3 ? n3 : 0, _2 = null !== (s3 = null !== (a2 = null === (c2 = l2.inputFrame) || void 0 === c2 ? void 0 : c2.width) && void 0 !== a2 ? a2 : null == i4 ? void 0 : i4._videoWidth) && void 0 !== s3 ? s3 : 0, E2 = null !== (d2 = null === (u2 = l2.inputFrame) || void 0 === u2 ? void 0 : u2.frameRate) && void 0 !== d2 ? d2 : 0;
                return p3 && (h3.A_fhi = p3 + ""), _2 && (h3.A_fwi = _2 + ""), E2 && (h3.A_fri = E2 + ""), h3;
              }(r2[0].ssrcId, e2, n2) : null;
              t4 && dC(() => {
                var e3;
                return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.PUBLISH_STATS, { stream_type: i3 === bS.LocalVideoLowTrack ? "low" : "high", stats: ob(ob({}, t4), o2) });
              });
              const s2 = function(e3) {
                const t5 = { id: "bweforvideo", timestamp: new Date(e3.timestamp).toISOString(), type: "VideoBwe" };
                return e3.bitrate.retransmit && (t5.A_rb = e3.bitrate.retransmit.toString()), e3.bitrate.targetEncoded && (t5.A_teb = e3.bitrate.targetEncoded.toString()), t5.A_aeb = e3.bitrate.actualEncoded.toString(), t5.A_tb = e3.bitrate.transmit.toString(), void 0 !== e3.sendBandwidth && (t5.A_asb = e3.sendBandwidth.toString()), t5;
              }(e2);
              s2 && setTimeout(() => {
                var e3;
                return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.PUBLISH_STATS, { stream_type: i3 === bS.LocalVideoLowTrack ? "low" : "high", stats: s2 });
              }, 1e3);
              break;
            }
            case bS.LocalAudioTrack: {
              const t4 = function(e3, t5, i4) {
                const n3 = t5.audioSend.find((t6) => t6.ssrc === e3);
                if (!n3)
                  return null;
                const r3 = { id: ZI(10, ""), timestamp: new Date(t5.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: n3.ssrc.toString() };
                return r3.A_astd = i4._originMediaStreamTrack && !i4._originMediaStreamTrack.enabled || i4._mediaStreamTrack && !i4._mediaStreamTrack.enabled ? "1" : "0", n3.inputLevel ? r3.A_ail = Math.round(100 * n3.inputLevel).toString() : r3.A_ail = Math.round(100 * i4._source.getAccurateVolumeLevel()).toString(), r3.A_apil = Math.round(100 * i4._source.getAccurateVolumeLevel()).toString(), n3.aecReturnLoss && (r3.A_ecrl = Math.round(n3.aecReturnLoss).toString()), n3.aecReturnLossEnhancement && (r3.A_ecrle = Math.round(n3.aecReturnLossEnhancement).toString()), r3;
              }(r2[0].ssrcId, e2, n2);
              t4 && dC(() => {
                var e3;
                return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.PUBLISH_STATS, { stream_type: "high", stats: t4 });
              });
              break;
            }
          }
        });
      }
      uploadRelatedUplinkStats(e2, t2) {
        var i3;
        ((null === (i3 = this.requestLocalMedia) || void 0 === i3 ? void 0 : i3.call(this)) || []).filter((e3) => {
          let [t3] = e3;
          return t3 === bS.LocalVideoLowTrack || t3 === bS.LocalVideoTrack;
        }).forEach((t3) => {
          let [i4, { ssrcs: n2 }] = t3;
          const r2 = function(e3, t4) {
            const i5 = t4.videoSend.find((t5) => t5.ssrc === e3);
            return i5 ? { mediaType: "video", isVideoMute: false, frameRateInput: i5.inputFrame && i5.inputFrame.frameRate.toString(), frameRateSent: i5.sentFrame && i5.sentFrame.frameRate.toString(), googRtt: i5.rttMs.toString(), qpSumPerFrame: Math.floor(i5.qpSumPerFrame).toString() } : null;
          }(n2[0].ssrcId, e2);
          r2 && dC(() => {
            var e3;
            null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, wf.PUBLISH_RELATED_STATS, { stream_type: i4 === bS.LocalVideoLowTrack ? "low" : "high", stats: r2 });
          });
        });
      }
      uploadDenoiserStats(e2) {
        for (let r2 = 0; r2 < e2.length; r2++) {
          const o2 = e2[r2];
          if (o2 instanceof AI) {
            var t2, i3, n2;
            const e3 = null === (t2 = (i3 = o2._external).getDenoiserStats) || void 0 === t2 ? void 0 : t2.call(i3);
            return void (e3 && (null === (n2 = this.requestUpload) || void 0 === n2 || n2.call(this, wf.DENOISER_STATS, e3)));
          }
        }
      }
      uploadExtensionStats(e2) {
        for (let t2 = 0; t2 < e2.length; t2++) {
          e2[t2].getProcessorStats().forEach((e3) => {
            var t3;
            null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e3.type, e3.stats);
          });
        }
      }
      stopUploadUplinkStats() {
        this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0);
      }
      startUploadDownlinkStats() {
        if (this.uploadDownlinkStarted)
          return;
        let e2;
        this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
        let t2 = false;
        this.downlinkStatsUploadInterval = window.setInterval(() => {
          var i3;
          const n2 = null === (i3 = this.requestStats) || void 0 === i3 ? void 0 : i3.call(this);
          n2 && (this.uploadDownlinkStats(n2, t2, e2), e2 = n2), t2 = !t2;
        }, 3e3), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {
          var e3;
          const t3 = null === (e3 = this.requestStats) || void 0 === e3 ? void 0 : e3.call(this);
          t3 && (this.uploadRelatedDownlinkStats(t3, this.lastStats), this.lastStats = t3);
        }, 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval(() => {
          var e3;
          const t3 = null === (e3 = this.requestRemoteMedia) || void 0 === e3 ? void 0 : e3.call(this);
          t3 && this.uploadDownlinkExtensionStats(t3);
        }, 2e3);
      }
      uploadDownlinkStats(e2, t2, i3) {
        var n2;
        ((null === (n2 = this.requestRemoteMedia) || void 0 === n2 ? void 0 : n2.call(this)) || []).forEach((n3) => {
          let [r2, o2] = n3;
          if (o2.has(AS.VIDEO) && r2.videoTrack) {
            const n4 = r2.videoTrack ? function(e3, t3, i4, n5, r3) {
              const o3 = t3.videoRecv.find((t4) => t4.ssrc === e3);
              if (!o3)
                return null;
              const s2 = { id: ZI(10, ""), timestamp: new Date(t3.timestamp).toISOString(), mediaType: "video", type: "ssrc", ssrc: o3.ssrc.toString() };
              var a2, c2;
              if (s2.bytesReceived = o3.bytes.toString(), s2.packetsLost = o3.packetsLost.toString(), s2.packetsReceived = o3.packets.toString(), o3.framesRateFirefox && (s2.A_frr = o3.framesRateFirefox.toString()), o3.receivedFrame ? (s2.A_frr = o3.receivedFrame.frameRate.toString(), s2.A_fhr = o3.receivedFrame.height.toString(), s2.A_fwr = o3.receivedFrame.width.toString()) : (s2.A_fhr = null === (a2 = n5._videoHeight) || void 0 === a2 ? void 0 : a2.toString(), s2.A_fwr = null === (c2 = n5._videoWidth) || void 0 === c2 ? void 0 : c2.toString()), s2.A_frd = o3.decodeFrameRate.toString(), o3.outputFrame && (s2.A_fro = o3.outputFrame.frameRate.toString()), void 0 !== o3.jitterBufferMs && (s2.A_jbm = Math.floor(o3.jitterBufferMs).toString()), void 0 !== o3.currentDelayMs && (s2.A_cdm = Math.floor(o3.currentDelayMs).toString()), s2.A_fs = o3.firsCount.toString(), s2.A_ns = o3.nacksCount.toString(), s2.A_ps = o3.plisCount.toString(), n5 && (s2.A_vrtd = n5._originMediaStreamTrack.enabled && n5._mediaStreamTrack.enabled ? "0" : "1"), n5._player && n5._player.freezeTimeCounterList.length > 0 && (s2.A_vrft = Math.round(n5._player.freezeTimeCounterList.splice(0, 1)[0]).toString()), r3 && n5._player && "visible" === MI.visibility) {
                const e4 = Math.min(6e3, n5._player.renderFreezeAccTime);
                s2.A_vrrft = Math.round(e4).toString(), n5._player.renderFreezeAccTime = Math.max(0, n5._player.renderFreezeAccTime - e4);
              }
              if (s2.A_rvps = af[n5._player ? n5._player.videoElementStatus : "uninit"].toString(), i4) {
                const t4 = i4.videoRecv.find((t5) => t5.ssrc === e3);
                if (t4 && void 0 !== o3.totalInterFrameDelay && void 0 !== o3.totalSquaredInterFrameDelay && void 0 !== t4.totalInterFrameDelay && void 0 !== t4.totalSquaredInterFrameDelay) {
                  const e4 = o3.totalInterFrameDelay - t4.totalInterFrameDelay, i5 = o3.totalSquaredInterFrameDelay - t4.totalSquaredInterFrameDelay, n6 = o3.framesDecodeCount - t4.framesDecodeCount, r4 = e4 / n6 * 1e3, a3 = Math.round(1e3 * Math.sqrt((i5 - Math.pow(e4, 2) / n6) / n6));
                  !isNaN(a3) && r4 + a3 > Math.max(3 * r4, r4 + 150) && (s2.A_ifdsd = a3.toString());
                }
              }
              return s2;
            }(r2._videoSSRC, e2, i3, r2.videoTrack, t2) : void 0;
            n4 && dC(() => {
              var e3;
              return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.SUBSCRIBE_STATS, { stream_id: r2.uid, stats: n4 });
            });
          }
          if (o2.has(AS.AUDIO) && r2.audioTrack) {
            const t3 = r2.audioTrack ? function(e3, t4, i4, n4) {
              const r3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
              if (!r3)
                return null;
              const o3 = { id: ZI(10, ""), timestamp: new Date(t4.timestamp).toISOString(), mediaType: "audio", type: "ssrc", ssrc: r3.ssrc.toString() };
              if (o3.bytesReceived = r3.bytes.toString(), o3.packetsLost = r3.packetsLost.toString(), o3.packetsReceived = r3.packets.toString(), r3.outputLevel ? o3.A_aol = Math.round(100 * r3.outputLevel).toString() : o3.A_aol = Math.round(100 * n4._source.getAccurateVolumeLevel()).toString(), o3.A_apol = Math.round(100 * n4._source.getAccurateVolumeLevel()).toString(), n4 && (o3.A_artd = n4._originMediaStreamTrack.enabled && n4._mediaStreamTrack.enabled ? "0" : "1"), o3.A_jr = r3.jitterMs.toString(), o3.A_jbm = Math.floor(r3.jitterBufferMs).toString(), o3.A_cdm = Math.floor(r3.jitterBufferMs).toString(), o3.A_raps = af[pR.getPlayerState(n4.getTrackId())].toString(), i4) {
                const t5 = i4.audioRecv.find((t6) => t6.ssrc === e3);
                if (t5) {
                  const e4 = r3.concealedSamples - t5.concealedSamples;
                  e4 > 0 && (o3.A_cs = Math.round(e4).toString());
                }
              }
              return o3;
            }(r2._audioSSRC, e2, i3, r2.audioTrack) : void 0;
            t3 && dC(() => {
              var e3;
              return null === (e3 = this.requestUpload) || void 0 === e3 ? void 0 : e3.call(this, wf.SUBSCRIBE_STATS, { stream_id: r2.uid, stats: t3 });
            });
          }
        });
      }
      uploadRelatedDownlinkStats(e2, t2) {
        var i3;
        ((null === (i3 = this.requestRemoteMedia) || void 0 === i3 ? void 0 : i3.call(this)) || []).forEach((i4) => {
          let [n2, r2] = i4;
          if (r2.has(AS.VIDEO) && n2.videoTrack) {
            var o2;
            const i5 = true === (n2._videoSSRC && (null === (o2 = this.requestVideoIsReady) || void 0 === o2 ? void 0 : o2.call(this, n2._videoSSRC)) || false), r3 = function(e3, t3, i6, n3, r4, o3) {
              const s2 = i6.videoRecv.find((t4) => t4.ssrc === e3), a2 = r4 ? r4.videoRecv.find((t4) => t4.ssrc === e3) : void 0;
              if (!s2)
                return null;
              const c2 = kI.isRemoteVideoFreeze(o3, s2, a2) && t3, d2 = { mediaType: "video", isVideoMute: false, peerId: n3, frameRateReceived: s2.receivedFrame && s2.receivedFrame.frameRate.toString(), frameRateDecoded: s2.decodedFrame && s2.decodedFrame.frameRate.toString(), isFreeze: c2, bytesReceived: s2.bytes.toString(), packetsReceived: s2.packets.toString(), packetsLost: s2.packetsLost.toString(), qpSumPerFrame: Math.floor(s2.qpSumPerFrame).toString() };
              return s2.framesRateFirefox && (d2.frameRateDecoded = s2.framesRateFirefox.toString(), d2.frameRateReceived = s2.framesRateFirefox.toString()), d2;
            }(n2._videoSSRC, i5, e2, n2.uid, t2, n2.videoTrack);
            r3 && dC(() => {
              var e3;
              null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, wf.SUBSCRIBE_RELATED_STATS, { stream_id: n2.uid, stats: r3 });
            });
          }
          if (r2.has(AS.AUDIO) && n2.audioTrack) {
            const t3 = function(e3, t4, i5, n3) {
              const r3 = t4.audioRecv.find((t5) => t5.ssrc === e3);
              if (!r3)
                return null;
              const o3 = kI.isRemoteAudioFreeze(n3);
              return { mediaType: "audio", isAudioMute: false, peerId: i5, googJitterReceived: r3.jitterMs.toString(), isFreeze: o3, bytesReceived: r3.bytes.toString(), packetsReceived: r3.packets.toString(), packetsLost: r3.packetsLost.toString(), frameReceived: r3.receivedFrames.toString(), frameDropped: r3.droppedFrames.toString() };
            }(n2._audioSSRC, e2, n2.uid, n2.audioTrack);
            t3 && dC(() => {
              var e3;
              null === (e3 = this.requestUpload) || void 0 === e3 || e3.call(this, wf.SUBSCRIBE_RELATED_STATS, { stream_id: n2.uid, stats: t3 });
            });
          }
        });
      }
      stopUploadDownlinkStats() {
        this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0);
      }
      stopUploadTransportStats() {
        this.uploadTransportStarted && (this.uploadTransportStarted = false, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0);
      }
      stopUploadExtensionUsageStats() {
        this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0);
      }
      uploadDownlinkExtensionStats(e2) {
        e2.forEach((e3) => {
          let [t2, i3] = e3;
          if (i3.has(AS.VIDEO) && t2.videoTrack) {
            t2.videoTrack.getProcessorStats().forEach((e4) => {
              var t3;
              null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e4.type, e4.stats);
            });
          }
          if (i3.has(AS.AUDIO) && t2.audioTrack) {
            t2.audioTrack.getProcessorStats().forEach((e4) => {
              var t3;
              null === (t3 = this.requestUpload) || void 0 === t3 || t3.call(this, e4.type, e4.stats);
            });
          }
        });
      }
    }
    function ab(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function cb(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? ab(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : ab(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    const db = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n", ub = "9", lb = 2e4, hb = 4e4;
    class pb {
      get localCapabilities() {
        return uC(this._localCapabilities);
      }
      get rtpCapabilities() {
        return uC(this._rtpCapabilities);
      }
      get candidates() {
        return uC(this._candidates);
      }
      get iceParameters() {
        return uC(this._iceParameters);
      }
      get dtlsParameters() {
        return uC(this._dtlsParameters);
      }
      constructor(e2) {
        _p(this, "sessionDesc", void 0), _p(this, "_localCapabilities", void 0), _p(this, "_rtpCapabilities", void 0), _p(this, "_candidates", void 0), _p(this, "_iceParameters", void 0), _p(this, "_dtlsParameters", void 0), _p(this, "setup", void 0), _p(this, "currentMidIndex", void 0), _p(this, "cname", void 0), _p(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e2 = uC(e2);
        const { remoteIceParameters: t2, remoteDtlsParameters: i3, candidates: n2, remoteRTPCapabilities: r2, remoteSetup: o2, localCapabilities: s2, cname: a2 } = e2, c2 = UO.exports.parse(db);
        this._rtpCapabilities = r2, this._candidates = n2, this._iceParameters = t2, this._dtlsParameters = i3, this._localCapabilities = s2, this.setup = o2, this.cname = a2;
        const d2 = this.rtpCapabilities.send;
        for (const e3 of c2.mediaDescriptions) {
          if (e3.attributes.iceUfrag = t2.iceUfrag, e3.attributes.icePwd = t2.icePwd, e3.attributes.fingerprints = i3.fingerprints, e3.attributes.candidates = n2, e3.attributes.setup = o2, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = d2.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.videoCodecs, e3.attributes.extmaps = d2.videoExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
            const { ssrcs: t3, ssrcGroups: i4 } = WO([{ ssrcId: hb, rtx: GE("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
            e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i4;
          }
          if ("audio" === e3.media.mediaType && (e3.media.fmts = d2.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = d2.audioCodecs, e3.attributes.extmaps = d2.audioExtensions, $O(e3), GE("PRELOAD_MEDIA_COUNT") > 0)) {
            const { ssrcs: t3, ssrcGroups: i4 } = WO([{ ssrcId: lb }], this.cname);
            e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i4;
          }
        }
        this.sessionDesc = c2, this.currentMidIndex = c2.mediaDescriptions.length - 1;
      }
      updateRemoteRTPCapabilities(e2) {
        const t2 = UO.exports.parse(db);
        this._rtpCapabilities = e2;
        const i3 = this.rtpCapabilities.send;
        for (const e3 of t2.mediaDescriptions) {
          if (e3.attributes.iceUfrag = this._iceParameters.iceUfrag, e3.attributes.icePwd = this._iceParameters.icePwd, e3.attributes.fingerprints = this._dtlsParameters.fingerprints, e3.attributes.candidates = this._candidates, e3.attributes.setup = this.setup, "application" === e3.media.mediaType && (e3.attributes.sctpPort = "5000"), "video" === e3.media.mediaType && (e3.media.fmts = i3.videoCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i3.videoCodecs, e3.attributes.extmaps = i3.videoExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
            const { ssrcs: t3, ssrcGroups: i4 } = WO([{ ssrcId: hb, rtx: GE("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
            e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i4;
          }
          if ("audio" === e3.media.mediaType && (e3.media.fmts = i3.audioCodecs.map((e4) => e4.payloadType.toString(10)), e3.attributes.payloads = i3.audioCodecs, e3.attributes.extmaps = i3.audioExtensions, GE("PRELOAD_MEDIA_COUNT") > 0)) {
            const { ssrcs: t3, ssrcGroups: i4 } = WO([{ ssrcId: lb }], this.cname);
            e3.attributes.ssrcs = t3, e3.attributes.ssrcGroups = i4;
          }
        }
        this.sessionDesc = t2, this.currentMidIndex = t2.mediaDescriptions.length - 1;
      }
      preloadRemoteMedia(e2) {
        this.rtpCapabilities;
        const t2 = this.candidates, i3 = this.dtlsParameters, n2 = this.iceParameters, r2 = this.rtpCapabilities.send;
        for (let o2 = 1; o2 < e2; o2++) {
          const e3 = 2 * o2 + lb, s2 = 2 * o2 + hb, { ssrcs: a2, ssrcGroups: c2 } = WO([{ ssrcId: e3 }], this.cname), { ssrcs: d2, ssrcGroups: u2 } = WO([{ ssrcId: s2, rtx: GE("USE_SUB_RTX") ? s2 + 1 : void 0 }], this.cname);
          this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.videoCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.videoExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: d2, ssrcGroups: u2, rtcpFeedbackWildcards: [], payloads: r2.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2 - 1) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: r2.audioCodecs.map((e4) => e4.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: n2.iceUfrag, icePwd: n2.icePwd, unrecognized: [], candidates: t2, extmaps: r2.audioExtensions, fingerprints: i3.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: a2, ssrcGroups: c2, rtcpFeedbackWildcards: [], payloads: r2.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(2 * o2) } }), this.currentMidIndex += 2;
        }
        this.updateBundleMids();
      }
      toString() {
        return UO.exports.print(this.sessionDesc);
      }
      send(e2, t2, i3, n2) {
        const { ssrcs: r2, ssrcGroups: o2 } = WO(t2, this.cname, GE("SYNC_GROUP") ? i3 : void 0), s2 = this.findPreloadMediaDesc(r2);
        if (s2) {
          if (Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, s2.attributes.mid), n2 && (n2.twcc || n2.remb)) {
            const e3 = this.sessionDesc.mediaDescriptions.indexOf(s2);
            return this.sessionDesc.mediaDescriptions[e3] = this.mungSendMediaDesc(s2, n2), { mid: s2.attributes.mid, needExchangeSDP: true };
          }
          return { mid: s2.attributes.mid, needExchangeSDP: false };
        }
        {
          const t3 = this.findAvailableMediaIndex(e2, r2);
          let i4;
          return -1 === t3 || Hh() || Yh() || zh() || 0 === t3 && GE("USE_SUB_RTX") ? (i4 = this.createOrRecycleSendMedia(e2, r2, o2, "sendonly", n2), this.updateBundleMids()) : (i4 = uC(this.sessionDesc.mediaDescriptions[t3]), i4.attributes.direction = "sendonly", i4.attributes.ssrcs = r2, i4.attributes.ssrcGroups = o2, this.sessionDesc.mediaDescriptions[t3] = this.mungSendMediaDesc(i4, n2)), Kh() && this.firefoxSsrcMidMap.set(r2[0].ssrcId, i4.attributes.mid), { mid: i4.attributes.mid, needExchangeSDP: true };
        }
      }
      batchSend(e2) {
        const t2 = e2.map((e3) => {
          let { kind: t3, ssrcMsg: i4, mslabel: n3 } = e3;
          return this.send(t3, i4, n3);
        }), i3 = [];
        let n2 = false;
        return t2.forEach((e3) => {
          let { mid: t3, needExchangeSDP: r2 } = e3;
          r2 && (n2 = true), i3.push(t3);
        }), { mids: i3, needExchangeSDP: n2 };
      }
      stopSending(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => t3.attributes.mid && -1 !== e2.indexOf(t3.attributes.mid));
        if (t2.length !== e2.length)
          throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
        t2.forEach((e3) => {
          "0" === e3.attributes.mid || Kh() || Hh() || Yh() ? e3.attributes.ssrcs = [] : (e3.attributes.ssrcs = [], e3.attributes.direction = "inactive", e3.media.port = "0");
        }), this.updateBundleMids();
      }
      mute(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
        if (!t2)
          throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.mute."));
        t2.attributes.direction = "inactive";
      }
      unmute(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2);
        if (!t2)
          throw new Error("mediaDescription not found with ".concat(e2, " in remote SDP when calling RemoteSDP.unmute."));
        t2.attributes.direction = "sendonly";
      }
      muteRemote(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
        if (t2.length !== e2.length)
          throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
        t2.forEach((e3) => {
          e3.attributes.direction = "inactive";
        });
      }
      unmuteRemote(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => e2.includes(t3.attributes.mid || ""));
        if (t2.length !== e2.length)
          throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
        t2.forEach((e3) => {
          e3.attributes.direction = "recvonly";
        });
      }
      receive(e2, t2, i3, n2) {
        e2.forEach((e3, r2) => {
          this.createOrRecycleRecvMedia(e3, [], "recvonly", t2, i3, n2[r2]);
        }), this.updateBundleMids();
      }
      stopReceiving(e2) {
        const t2 = this.sessionDesc.mediaDescriptions.filter((t3) => -1 !== e2.indexOf(t3.attributes.mid));
        if (t2.length !== e2.length)
          throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
        t2.forEach((e3) => {
          e3.media.port = "0", e3.attributes.direction = "inactive";
        }), this.updateBundleMids();
      }
      updateCandidates(e2) {
        e2 === OS.TCP ? this._candidates.forEach((e3) => {
          -1 === this._candidates.findIndex((t2) => "tcp" === t2.transport && t2.connectionAddress === e3.connectionAddress && t2.port === e3.port) && this._candidates.push(cb(cb({}, e3), {}, { foundation: "tcpcandidate", priority: Number(e3.priority) - 1 + "", transport: "tcp", port: Number(e3.port) + 90 + "" }));
        }) : this._candidates = this._candidates.filter((e3) => "tcp" !== e3.transport);
        for (const e3 of this.sessionDesc.mediaDescriptions)
          e3.attributes.candidates = this.candidates;
      }
      restartICE(e2) {
        e2 = uC(e2), this._iceParameters = e2, this.sessionDesc.mediaDescriptions.forEach((t2) => {
          t2.attributes.iceUfrag = e2.iceUfrag, t2.attributes.icePwd = e2.icePwd;
        });
      }
      predictReceivingMids(e2) {
        const t2 = [];
        for (let i3 = 0; i3 < e2; i3++)
          t2.push((this.currentMidIndex + i3 + 1).toString(10));
        return t2;
      }
      findAvailableMediaIndex(e2, t2) {
        return this.sessionDesc.mediaDescriptions.findIndex((i3) => {
          const n2 = i3.media.mediaType === e2 && "0" !== i3.media.port && ("sendonly" === i3.attributes.direction || "sendrecv" === i3.attributes.direction) && 0 === i3.attributes.ssrcs.length;
          if (Kh()) {
            if (n2) {
              const e3 = this.firefoxSsrcMidMap.get(t2[0].ssrcId);
              return !(e3 || "0" !== i3.attributes.mid && "1" !== i3.attributes.mid) || !(!e3 || e3 !== i3.attributes.mid);
            }
            return false;
          }
          return n2;
        });
      }
      createOrRecycleRecvMedia(e2, t2, i3, n2, r2, o2) {
        const s2 = e2._mediaStreamTrack.kind, a2 = this.rtpCapabilities.recv, c2 = this.localCapabilities.send;
        let d2 = [];
        if (s2 === AS.VIDEO) {
          var u2, l2;
          if (GE("H264_PROFILE_LEVEL_ID") && "h264" === n2 && (d2 = a2.videoCodecs.filter((e3) => {
            var t3, i4;
            return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2) && (null == e3 || null === (i4 = e3.fmtp) || void 0 === i4 ? void 0 : i4.parameters["profile-level-id"]) === GE("H264_PROFILE_LEVEL_ID");
          })), !d2 || 0 === (null === (u2 = d2) || void 0 === u2 ? void 0 : u2.length)) {
            const e3 = c2.videoCodecs.filter((e4) => {
              var t3;
              return ((null === (t3 = e4.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(n2);
            });
            0 !== e3.length && (d2 = a2.videoCodecs.filter((t3) => e3.some((e4) => e4.payloadType === t3.payloadType)));
          }
          if (GE("USE_PUB_RTX")) {
            const e3 = d2.map((e4) => e4.payloadType.toString()), t3 = a2.videoCodecs.filter((t4) => {
              var i4, n3;
              return "rtx" === (null === (i4 = t4.rtpMap) || void 0 === i4 ? void 0 : i4.encodingName) && e3.includes((null === (n3 = t4.fmtp) || void 0 === n3 ? void 0 : n3.parameters.apt) || "");
            });
            d2 = [...d2, ...t3];
          }
          if (0 === d2.length)
            OE.warning("codec ".concat(n2, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (l2 = a2.videoCodecs[0].rtpMap) || void 0 === l2 ? void 0 : l2.encodingName)), d2 = a2.videoCodecs;
        } else
          d2 = a2.audioCodecs.filter((e3) => {
            var t3;
            return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes(r2);
          }), 0 === d2.length && (OE.warning("codec ".concat(r2, " not included in rtpCapabilities, fallback to opus")), d2 = a2.audioCodecs.filter((e3) => {
            var t3;
            return ((null === (t3 = e3.rtpMap) || void 0 === t3 ? void 0 : t3.encodingName.toLowerCase()) || "").includes("opus");
          }));
        const h3 = s2 === AS.VIDEO ? a2.videoExtensions : a2.audioExtensions;
        this.currentMidIndex += 1;
        const p3 = "".concat(this.currentMidIndex);
        let _2 = { media: { mediaType: s2, port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: h3, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i3, rtcpMux: true, rtcpRsize: true, mid: "".concat(p3) } };
        _2 = this.mungRecvMediaDsec(_2, e2, o2);
        const E2 = this.findFirstClosedMedia(s2);
        if (E2) {
          const e3 = this.sessionDesc.mediaDescriptions.indexOf(E2);
          this.sessionDesc.mediaDescriptions[e3] = _2;
        } else
          this.sessionDesc.mediaDescriptions.push(_2);
        return _2;
      }
      createOrRecycleSendMedia(e2, t2, i3, n2, r2) {
        const o2 = this.rtpCapabilities.send, s2 = e2 === AS.VIDEO ? o2.videoCodecs : o2.audioCodecs, a2 = e2 === AS.VIDEO ? o2.videoExtensions : o2.audioExtensions;
        this.currentMidIndex += 1;
        const c2 = "".concat(this.currentMidIndex);
        let d2 = { media: { mediaType: e2, port: ub, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: s2.map((e3) => e3.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: a2, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: t2, ssrcGroups: i3, rtcpFeedbackWildcards: [], payloads: s2, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n2, rtcpMux: true, rtcpRsize: true, mid: "".concat(c2) } };
        d2 = this.mungSendMediaDesc(d2, r2);
        const u2 = this.findFirstClosedMedia(e2);
        if (u2) {
          const e3 = this.sessionDesc.mediaDescriptions.indexOf(u2);
          this.sessionDesc.mediaDescriptions[e3] = d2;
        } else
          this.sessionDesc.mediaDescriptions.push(d2);
        return d2;
      }
      updateBundleMids() {
        this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e2) => "0" !== e2.media.port).map((e2) => e2.attributes.mid);
      }
      mungRecvMediaDsec(e2, t2, i3) {
        const n2 = uC(e2);
        return KO(n2), HO(n2, t2), YO(n2, t2), qO(n2), JO(n2, i3, this.localCapabilities.send), n2;
      }
      mungSendMediaDesc(e2, t2) {
        const i3 = uC(e2);
        return JO(i3, t2, this.localCapabilities.recv), $O(i3), i3;
      }
      updateRecvMedia(e2, t2) {
        const i3 = this.sessionDesc.mediaDescriptions.findIndex((t3) => t3.attributes.mid === e2);
        if (-1 !== i3) {
          const e3 = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i3], t2);
          this.sessionDesc.mediaDescriptions[i3] = e3;
        }
      }
      bumpMid(e2) {
        this.currentMidIndex += e2;
      }
      findFirstClosedMedia(e2) {
        return this.sessionDesc.mediaDescriptions.find((t2) => Kh() ? "0" === t2.media.port && t2.media.mediaType === e2 : "0" === t2.media.port);
      }
      findPreloadMediaDesc(e2) {
        return this.sessionDesc.mediaDescriptions.find((t2) => {
          var i3, n2;
          return (null === (i3 = t2.attributes) || void 0 === i3 || null === (n2 = i3.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId) === e2[0].ssrcId;
        });
      }
      getSSRC(e2) {
        var t2;
        return null === (t2 = this.sessionDesc.mediaDescriptions.find((t3) => t3.attributes.mid === e2)) || void 0 === t2 ? void 0 : t2.attributes.ssrcs;
      }
    }
    var _b;
    function Eb(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function mb(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? Eb(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Eb(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let fb = (ag((_b = class e2 extends YS {
      get currentLocalDescription() {
        return this.peerConnection.currentLocalDescription;
      }
      get currentRemoteDescription() {
        return this.peerConnection.currentRemoteDescription;
      }
      get peerConnectionState() {
        return this.peerConnection.connectionState;
      }
      get iceConnectionState() {
        return this.peerConnection.iceConnectionState;
      }
      constructor(e3, t2, i3) {
        super(e3, t2), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "remoteSDP", void 0), _p(this, "initialOffer", void 0), _p(this, "transportEventReceiver", void 0), _p(this, "statsFilter", void 0), _p(this, "localCapabilities", void 0), _p(this, "localCandidateCount", 0), _p(this, "allCandidatesReceived", false), _p(this, "establishPromise", void 0), _p(this, "mutex", new Ug("NVExtentionsConnection-mutex")), _p(this, "rtcMedia", void 0), this.store = t2, this.peerConnection = i3, this.statsFilter = vN(this.peerConnection, GE("STATS_UPDATE_INTERVAL"), void 0, Kh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
      }
      async establish(e3) {
        try {
          const e4 = await this.peerConnection.createOffer();
          if (!e4.sdp)
            throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
          const t2 = FO(e4.sdp), i3 = await zO(!GE("USE_PUB_RTX") && !GE("USE_SUB_RTX"), GE("FILTER_VIDEO_FEC"), GE("FILTER_AUDIO_FEC"));
          return this.localCapabilities = i3, this.initialOffer = e4, mb(mb({}, t2), {}, { rtpCapabilities: i3, offerSDP: e4.sdp });
        } catch (e4) {
          throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e4.toString());
        }
      }
      async connect(e3, t2, i3, n2, r2, o2) {
        try {
          if (!this.initialOffer)
            throw new Error("Cannot establish NVConnection without initial offer.");
          this.remoteSDP = new pb({ remoteIceParameters: e3, remoteDtlsParameters: t2, candidates: i3, remoteRTPCapabilities: n2, remoteSetup: r2, localCapabilities: ZO(this.localCapabilities), cname: o2 });
          const s2 = this.remoteSDP.toString(), a2 = UO.exports.parse(this.initialOffer.sdp), c2 = a2.mediaDescriptions.find((e4) => "audio" === e4.media.mediaType);
          c2 && $O(c2);
          const d2 = UO.exports.print(a2), u2 = this.logSDPExchange(d2 || "", "offer", "local", "connect");
          await this.peerConnection.setLocalDescription({ type: "offer", sdp: d2 }), null == u2 || u2(s2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e4.toString()));
        }
      }
      async updateRemoteConnect(e3) {
        var t2, i3, n2;
        null === (t2 = this.remoteSDP) || void 0 === t2 || t2.updateRemoteRTPCapabilities(e3), null === (i3 = this.remoteSDP) || void 0 === i3 || i3.preloadRemoteMedia(2);
        const r2 = null === (n2 = this.remoteSDP) || void 0 === n2 ? void 0 : n2.toString();
        await this.peerConnection.setRemoteDescription({ type: "offer", sdp: r2 });
        const o2 = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(o2), OE.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");
      }
      send(e3, t2, i3) {
        var n2 = this;
        return DO(function* () {
          const r2 = yield PO(n2.mutex.lock("From NVExtentionsConnection.send"));
          try {
            if (!n2.remoteSDP)
              throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");
            const o2 = [];
            e3.forEach((e4) => {
              const t3 = n2.peerConnection.addTransceiver(e4._mediaStreamTrack, { direction: "sendonly" });
              o2.push(t3);
            }), Kh() && true === GE("SIMULCAST") && (yield PO(n2.applySimulcastForFirefox(o2, e3)));
            const s2 = yield PO(n2.peerConnection.createOffer()), a2 = n2.remoteSDP.predictReceivingMids(e3.length), c2 = n2.mungSendOfferSDP(s2.sdp, e3, a2), d2 = UO.exports.parse(c2), u2 = a2.map((e4) => {
              const t3 = d2.mediaDescriptions.find((t4) => t4.attributes.mid === e4);
              if (!t3)
                throw new Error("Cannot extract ssrc from mediaDescription.");
              return BO(t3, GE("USE_PUB_RTX"));
            });
            let l2;
            try {
              l2 = yield u2;
            } catch (r3) {
              l2 = [], n2.remoteSDP.receive(e3, t2, i3, l2);
              const o3 = n2.remoteSDP.toString();
              throw yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: o3 })), yield PO(n2.stopSending(a2, true)), r3;
            }
            n2.remoteSDP.receive(e3, t2, i3, l2);
            const h3 = n2.remoteSDP.toString(), p3 = n2.logSDPExchange(c2, "offer", "local", "send");
            return yield PO(n2.peerConnection.setLocalDescription({ type: "offer", sdp: c2 })), yield PO(n2.applySimulcastEncodings(o2, e3)), yield PO(n2.applySendEncodings(o2, e3)), null == p3 || p3(h3), yield PO(n2.peerConnection.setRemoteDescription({ type: "answer", sdp: h3 })), o2.map((e4, t3) => {
              const i4 = a2[t3];
              return { localSSRC: u2[t3], id: i4, transceiver: e4 };
            });
          } catch (e4) {
            throw e4 instanceof SE ? e4 : new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e4.toString()));
          } finally {
            r2();
          }
        })();
      }
      async stopSending(e3, t2) {
        const i3 = t2 ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending");
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");
          const t3 = this.peerConnection.getTransceivers().filter((t4) => -1 !== e3.indexOf(t4.mid));
          if (t3.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");
          t3.map((e4) => {
            var t4;
            e4.direction = "inactive", null === (t4 = e4.stop) || void 0 === t4 || t4.call(e4);
          });
          const n2 = await this.peerConnection.createOffer(), r2 = this.logSDPExchange(n2.sdp || "", "offer", "local", "stopSending");
          await this.peerConnection.setLocalDescription(n2), this.remoteSDP.stopReceiving(e3);
          const o2 = this.remoteSDP.toString();
          null == r2 || r2(o2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e4.toString()));
        } finally {
          i3 && i3();
        }
      }
      async receive(e3, t2, i3, n2) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e3, " before remoteSDP created."));
          const { mid: r2, needExchangeSDP: o2 } = this.remoteSDP.send(e3, t2, i3, n2);
          if (o2) {
            const t3 = this.remoteSDP.toString(), i4 = this.logSDPExchange(t3, "offer", "remote", "receive");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t3 });
            const n3 = await this.peerConnection.createAnswer(), o3 = this.mungReceiveAnswerSDP(n3.sdp, r2, e3);
            null == i4 || i4(o3 || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: o3 }), OE.debug("[NVExtentionsConnection] receive ".concat(e3, " by exchanging SDP."));
          } else
            OE.debug("[NVExtentionsConnection] receive ".concat(e3, " no need to exchange SDP."));
          const s2 = this.peerConnection.getTransceivers().find((e4) => e4.mid === r2);
          if (!s2)
            throw new Error("Cannot get transceiver after setLocalDescription.");
          return { track: s2.receiver.track, id: r2 };
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e4.toString()));
        }
      }
      async batchReceive(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");
          const { mids: t2, needExchangeSDP: i3 } = this.remoteSDP.batchSend(e3);
          if (i3) {
            const e4 = this.remoteSDP.toString(), t3 = this.logSDPExchange(e4, "offer", "remote", "receive");
            await this.peerConnection.setRemoteDescription({ type: "offer", sdp: e4 });
            const i4 = await this.peerConnection.createAnswer();
            null == t3 || t3(i4.sdp || ""), await this.peerConnection.setLocalDescription(i4), OE.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");
          } else
            OE.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");
          return t2.map((e4) => {
            const t3 = this.peerConnection.getTransceivers().find((t4) => t4.mid === e4);
            if (!t3)
              throw new Error("Cannot get transceiver after setLocalDescription.");
            return { track: t3.receiver.track, id: e4 };
          });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e4.toString()));
        }
      }
      async stopReceiving(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");
          this.remoteSDP.stopSending(e3);
          const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "stopReceiving");
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const n2 = await this.peerConnection.createAnswer();
          null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e4.toString()));
        }
      }
      async muteRemote(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e3, " before remote SDP created."));
          this.remoteSDP.mute(e3);
          const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "muteRemote");
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const n2 = await this.peerConnection.createAnswer();
          null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e4.toString()));
        }
      }
      async unmuteRemote(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e3, " before remote SDP created."));
          this.remoteSDP.unmute(e3);
          const t2 = this.remoteSDP.toString(), i3 = this.logSDPExchange(t2, "offer", "remote", "unmuteRemote");
          await this.peerConnection.setRemoteDescription({ type: "offer", sdp: t2 });
          const n2 = await this.peerConnection.createAnswer();
          null == i3 || i3(n2.sdp || ""), await this.peerConnection.setLocalDescription(n2);
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e4.toString()));
        }
      }
      async muteLocal(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");
          const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
          if (t2.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length.");
          t2.map((e4) => {
            e4.direction = "inactive";
          });
          const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "muteLocal");
          await this.peerConnection.setLocalDescription(i3), this.remoteSDP.muteRemote(e3);
          const r2 = this.remoteSDP.toString();
          null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e4.toString()));
        }
      }
      async unmuteLocal(e3) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");
          const t2 = this.peerConnection.getTransceivers().filter((t3) => t3.mid && -1 !== e3.indexOf(t3.mid));
          if (t2.length !== e3.length)
            throw new Error("Transceivers' length doesn't match mids' length.");
          t2.map(async (e4, t3) => {
            e4.direction = "sendonly";
          });
          const i3 = await this.peerConnection.createOffer(), n2 = this.logSDPExchange(i3.sdp || "", "offer", "local", "unmuteLocal");
          await this.peerConnection.setLocalDescription(i3), this.remoteSDP.unmuteRemote(e3);
          const r2 = this.remoteSDP.toString();
          null == n2 || n2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e4.toString()));
        }
      }
      restartICE(e3) {
        var t2 = this;
        return DO(function* () {
          const i3 = yield PO(t2.mutex.lock("From NVExtentionsConnection.restartICE"));
          try {
            if (!t2.remoteSDP)
              throw new Error("Cannot restartICE before remoteSDP created.");
            if (JS().supportPCSetConfiguration) {
              const i4 = t2.peerConnection.getConfiguration(), n3 = e3 === OS.RELAY ? "relay" : "all";
              i4.iceTransportPolicy !== n3 && (OE.debug("restartICE change iceTransportPolicy from [".concat(i4.iceTransportPolicy, "] to [").concat(n3, "]")), i4.iceTransportPolicy = n3, t2.peerConnection.setConfiguration(i4));
            } else if (e3 === OS.RELAY)
              return;
            e3 !== OS.RELAY && t2.remoteSDP.updateCandidates(e3);
            const n2 = yield PO(t2.peerConnection.createOffer({ iceRestart: true }));
            if (!n2.sdp)
              throw new Error("Cannot restartICE because restart offer SDP does not exist.");
            const r2 = FO(n2.sdp), { remoteIceParameters: o2 } = yield r2.iceParameters;
            t2.remoteSDP.restartICE(o2);
            const s2 = t2.remoteSDP.toString(), a2 = t2.logSDPExchange(n2.sdp || "", "offer", "local", "restartICE");
            yield PO(t2.peerConnection.setLocalDescription(n2)), null == a2 || a2(s2), yield PO(t2.peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
          } catch (e4) {
            OE.warning("restart ICE failed, abort operation", e4);
          } finally {
            i3();
          }
        })();
      }
      close() {
        var e3;
        null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();
      }
      getStats() {
        return this.statsFilter.getStats();
      }
      getRemoteVideoIsReady(e3) {
        return this.statsFilter.getVideoIsReady(e3);
      }
      async updateEncoderConfig(e3, t2) {
        try {
          if (!this.remoteSDP)
            throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");
          const i3 = await this.peerConnection.createOffer(), n2 = this.mungSendOfferSDP(i3.sdp, [t2], [e3]);
          this.remoteSDP.updateRecvMedia(e3, t2);
          const r2 = this.remoteSDP.toString(), o2 = this.logSDPExchange(n2, "offer", "local", "updateEncoderConfig");
          await this.peerConnection.setLocalDescription({ type: "offer", sdp: n2 }), null == o2 || o2(r2), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r2 });
        } catch (e4) {
          throw new SE(fE.EXCHANGE_SDP_FAILED, e4.toString());
        }
      }
      async updateSendParameters(e3, t2) {
        const i3 = this.peerConnection.getTransceivers().filter((t3) => t3.mid === e3);
        1 === i3.length && (this.isVP8Simulcast(t2) ? Kh() || await this.applySimulcastEncodings(i3, [t2]) : await this.applySendEncodings(i3, [t2]));
      }
      setStatsRemoteVideoIsReady(e3, t2) {
        this.statsFilter.setVideoIsReady2(e3, t2);
      }
      async replaceTrack(e3, t2) {
        const i3 = this.peerConnection.getTransceivers().find((e4) => e4.mid === t2);
        i3 && await i3.sender.replaceTrack(e3._mediaStreamTrack);
      }
      getP2PConnectionParams() {
        var e3;
        if (null === (e3 = this.peerConnection.currentLocalDescription) || void 0 === e3 || !e3.sdp || !this.localCapabilities)
          throw new Error();
        return mb(mb({}, FO(this.peerConnection.currentLocalDescription.sdp)), {}, { rtpCapabilities: this.localCapabilities });
      }
      bindPCEvents() {
        this.peerConnection.oniceconnectionstatechange = () => {
          var e3;
          null === (e3 = this.onICEConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.iceConnectionState);
        }, this.peerConnection.onconnectionstatechange = () => {
          var e3;
          null === (e3 = this.onConnectionStateChange) || void 0 === e3 || e3.call(this, this.peerConnection.connectionState);
        }, this.peerConnection.onicecandidate = (e3) => {
          e3.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, OE.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
        }, setTimeout(() => {
          this.allCandidatesReceived || (this.allCandidatesReceived = true, OE.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
        }, GE("CANDIDATE_TIMEOUT"));
      }
      unbindPCEvents() {
        this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
      }
      static resolvePCConfiguration(t2) {
        const i3 = { iceServers: [] };
        return t2.iceServers ? i3.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i3.iceServers = t2.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t2.turnServer.serversFromGateway && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), GE("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
          e3.forceturn && (i3.iceTransportPolicy = "relay");
        }))), i3;
      }
      static turnServerConfigToIceServers(e3) {
        const t2 = [];
        return e3.forEach((e4) => {
          e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(VI(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !GE("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
        }), t2;
      }
      async applySendEncodings(e3, t2) {
        try {
          if (!JS().supportSetRtpSenderParameters)
            return;
          if (e3.length !== t2.length)
            return;
          for (let c2 = 0; c2 < e3.length; c2++) {
            const d2 = e3[c2], u2 = t2[c2];
            if (u2 && u2 instanceof Cy) {
              var i3, n2;
              if (this.isVP8Simulcast(u2))
                continue;
              const e4 = {}, t3 = {};
              switch (u2._optimizationMode) {
                case "motion":
                  e4.degradationPreference = "maintain-framerate";
                  break;
                case "detail":
                  e4.degradationPreference = "maintain-resolution";
                  break;
                default:
                  e4.degradationPreference = "balanced";
              }
              var r2, o2, s2, a2;
              if (null !== (i3 = u2._encoderConfig) && void 0 !== i3 && i3.bitrateMax)
                t3.maxBitrate = 1e3 * (null === (r2 = u2._encoderConfig) || void 0 === r2 ? void 0 : r2.bitrateMax);
              if (u2._hints.includes(lS.LOW_STREAM))
                null !== (o2 = u2._encoderConfig) && void 0 !== o2 && o2.frameRate && (t3.maxFramerate = FI(u2._encoderConfig.frameRate)), null !== (s2 = u2._encoderConfig) && void 0 !== s2 && s2.scaleResolutionDownBy && (null === (a2 = u2._encoderConfig) || void 0 === a2 ? void 0 : a2.scaleResolutionDownBy) > 1 && (t3.scaleResolutionDownBy = u2._encoderConfig.scaleResolutionDownBy);
              if (GE("DSCP_TYPE") && rp()) {
                const e5 = GE("DSCP_TYPE");
                ["very-low", "low", "medium", "high"].includes(e5) && (t3.networkPriority = e5);
              }
              const c3 = d2.sender.getParameters(), l2 = null === (n2 = c3.encodings) || void 0 === n2 ? void 0 : n2[0];
              Kh() && !l2 && (e4.encodings = [t3]), l2 && Object.assign(l2, t3), Object.assign(c3, e4), await d2.sender.setParameters(c3);
            }
          }
        } catch (e4) {
          OE.debug("Apply RTPSendEncodings failed.");
        }
      }
      mungSendOfferSDP(e3, t2, i3) {
        const n2 = UO.exports.parse(e3);
        return t2.forEach((e4, t3) => {
          const r2 = i3[t3], o2 = n2.mediaDescriptions.find((e5) => e5.attributes.mid === r2);
          o2 && (HO(o2, e4), XO(o2, e4, this.store.codec));
        }), UO.exports.print(n2);
      }
      mungReceiveAnswerSDP(e3, t2, i3) {
        const n2 = UO.exports.parse(e3), r2 = n2.mediaDescriptions.find((e4) => e4.attributes.mid === t2);
        return r2 && i3 === AS.AUDIO && "audio" === r2.media.mediaType && $O(r2), UO.exports.print(n2);
      }
      bindStatsEvents() {
        this.statsFilter.onFirstAudioReceived = (e3) => {
          var t2;
          null === (t2 = this.onFirstAudioReceived) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstVideoReceived = (e3) => {
          var t2;
          null === (t2 = this.onFirstVideoReceived) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstAudioDecoded = (e3) => {
          var t2;
          null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 || t2.call(this, e3);
        }, this.statsFilter.onFirstVideoDecoded = (e3, t2, i3) => {
          var n2;
          null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 || n2.call(this, e3, t2, i3);
        }, this.statsFilter.onSelectedLocalCandidateChanged = (e3, t2) => {
          var i3;
          null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
        }, this.statsFilter.onSelectedRemoteCandidateChanged = (e3, t2) => {
          var i3;
          null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 || i3.call(this, e3, t2);
        }, this.statsFilter.onFirstVideoDecodedTimeout = (e3) => {
          var t2;
          null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 || t2.call(this, e3);
        };
      }
      unbindStatsEvents() {
        this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
      }
      async applySimulcastForFirefox(e3, t2) {
        if (e3.length === t2.length)
          for (let s2 = 0; s2 < e3.length; s2++) {
            var i3, n2, r2, o2;
            const a2 = e3[s2], c2 = t2[s2];
            if (c2 instanceof Cy && !c2._hints.includes(lS.LOW_STREAM) && null !== (i3 = c2._encoderConfig) && void 0 !== i3 && i3.bitrateMax && (null === (n2 = c2._encoderConfig) || void 0 === n2 ? void 0 : n2.bitrateMax) > 200 && null !== (r2 = c2._scalabiltyMode) && void 0 !== r2 && r2.numSpatialLayers && (null === (o2 = c2._scalabiltyMode) || void 0 === o2 ? void 0 : o2.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
              const e4 = {}, t3 = { high: 1e3 * (c2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              e4.encodings = [{ rid: "m", active: true, maxBitrate: t3.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: t3.high }];
              const i4 = a2.sender.getParameters();
              await a2.sender.setParameters(Object.assign(i4, e4));
            }
          }
      }
      async applySimulcastEncodings(e3, t2) {
        if (!Kh() && e3.length === t2.length)
          for (let i3 = 0; i3 < e3.length; i3++) {
            const n2 = t2[i3];
            if (n2 instanceof Cy && this.isVP8Simulcast(n2)) {
              const t3 = e3[i3], r2 = {}, o2 = { high: 1e3 * (n2._encoderConfig.bitrateMax - 50), medium: 5e4 };
              r2.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: o2.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: o2.medium, scaleResolutionDownBy: 4 }];
              const s2 = t3.sender.getParameters();
              await t3.sender.setParameters(Object.assign(s2, r2));
            }
          }
      }
      isVP8Simulcast(e3) {
        var t2, i3, n2, r2;
        return !!(e3 instanceof Cy && GE("SIMULCAST") && "vp8" === this.store.codec && !e3._hints.includes(lS.LOW_STREAM) && null !== (t2 = e3._encoderConfig) && void 0 !== t2 && t2.bitrateMax && (null === (i3 = e3._encoderConfig) || void 0 === i3 ? void 0 : i3.bitrateMax) > 200 && null !== (n2 = e3._scalabiltyMode) && void 0 !== n2 && n2.numSpatialLayers && (null === (r2 = e3._scalabiltyMode) || void 0 === r2 ? void 0 : r2.numSpatialLayers) > 1);
      }
      logSDPExchange(e3, t2, i3, n2) {
        if (GE("SDP_LOGGING"))
          return OE.upload("exchanging ".concat(i3, " ").concat(t2, " SDP during NVExtentionsConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i3 ? "remote" : "local", n2);
          } : void 0;
      }
      async getRemoteSSRC(e3) {
        if (!this.remoteSDP)
          return;
        const t2 = this.remoteSDP.getSSRC(e3);
        return null == t2 ? void 0 : t2[0].ssrcId;
      }
      setConfiguration(t2) {
        if (JS().supportPCSetConfiguration) {
          const i3 = e2.resolvePCConfiguration(t2);
          this.peerConnection.setConfiguration(i3);
        }
      }
    }).prototype, "connect", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "connect"), _b.prototype), ag(_b.prototype, "updateRemoteConnect", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "updateRemoteConnect"), _b.prototype), ag(_b.prototype, "receive", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "receive"), _b.prototype), ag(_b.prototype, "batchReceive", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "batchReceive"), _b.prototype), ag(_b.prototype, "stopReceiving", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "stopReceiving"), _b.prototype), ag(_b.prototype, "muteRemote", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "muteRemote"), _b.prototype), ag(_b.prototype, "unmuteRemote", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "unmuteRemote"), _b.prototype), ag(_b.prototype, "muteLocal", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "muteLocal"), _b.prototype), ag(_b.prototype, "unmuteLocal", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "unmuteLocal"), _b.prototype), ag(_b.prototype, "close", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "close"), _b.prototype), ag(_b.prototype, "updateEncoderConfig", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "updateEncoderConfig"), _b.prototype), ag(_b.prototype, "updateSendParameters", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "updateSendParameters"), _b.prototype), ag(_b.prototype, "replaceTrack", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "replaceTrack"), _b.prototype), ag(_b.prototype, "getRemoteSSRC", [Sb], Object.getOwnPropertyDescriptor(_b.prototype, "getRemoteSSRC"), _b.prototype), _b);
    function Sb(e2, t2, i3) {
      const n2 = e2[t2];
      if ("function" != typeof n2)
        throw new Error("Cannot use mutex on object property.");
      return i3.value = async function() {
        const e3 = this.mutex, i4 = await e3.lock("From NVExtentionsConnection.".concat(t2));
        try {
          for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
            o2[s2] = arguments[s2];
          return await n2.apply(this, o2);
        } finally {
          i4();
        }
      }, i3;
    }
    var Tb;
    function gb(e2) {
      var t2, i3, n2, r2 = 2;
      for ("undefined" != typeof Symbol && (i3 = MO, n2 = Symbol.iterator); r2--; ) {
        if (i3 && null != (t2 = e2[i3]))
          return t2.call(e2);
        if (n2 && null != (t2 = e2[n2]))
          return new Rb(t2.call(e2));
        i3 = "@@asyncIterator", n2 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }
    function Rb(e2) {
      function t2(e3) {
        if (Object(e3) !== e3)
          return Sl.reject(new TypeError(e3 + " is not an object."));
        var t3 = e3.done;
        return Sl.resolve(e3.value).then(function(e4) {
          return { value: e4, done: t3 };
        });
      }
      return (Rb = function(e3) {
        this.s = e3, this.n = e3.next;
      }).prototype = { s: null, n: null, next: function() {
        return t2(this.n.apply(this.s, arguments));
      }, return: function(e3) {
        var i3 = this.s.return;
        return void 0 === i3 ? Sl.resolve({ value: e3, done: true }) : t2(i3.apply(this.s, arguments));
      }, throw: function(e3) {
        var i3 = this.s.return;
        return void 0 === i3 ? Sl.reject(e3) : t2(i3.apply(this.s, arguments));
      } }, new Rb(e2);
    }
    let Ib = (ag((Tb = class e2 extends YS {
      get currentLocalDescription() {
        return this.peerConnection.currentLocalDescription;
      }
      get currentRemoteDescription() {
        return this.peerConnection.currentRemoteDescription;
      }
      get peerConnectionState() {
        return this.peerConnection.connectionState;
      }
      get iceConnectionState() {
        return this.peerConnection.iceConnectionState;
      }
      constructor(t2, i3) {
        super(t2, i3), _p(this, "store", void 0), _p(this, "peerConnection", void 0), _p(this, "cname", void 0), _p(this, "mutex", new Ug("DataChannelConnection-mutex")), _p(this, "dataChannel", void 0), _p(this, "_p2pConnection", void 0), _p(this, "establishPromise", void 0), _p(this, "_nvMedia", void 0), this.store = i3, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e2.resolvePCConfiguration(t2), { optional: [{ googDscp: true }] }), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", { ordered: false, maxPacketLifeTime: 50 }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new fb(t2, i3, this.peerConnection), this.bindPCEvents(), this.establishPromise = this._p2pConnection.establishPromise;
      }
      async establish() {
        var e3;
        const t2 = null === (e3 = this._nvMedia) || void 0 === e3 ? void 0 : e3.getLocalRtpCapabilities();
        return await this._p2pConnection.establish(t2);
      }
      getP2PConnectionParams() {
        return this._p2pConnection.getP2PConnectionParams();
      }
      async connect(e3, t2, i3, n2, r2, o2) {
        return this.cname = o2, await this._p2pConnection.connect(e3, t2, i3, n2, r2, o2), await new Sl((e4, t3) => {
          const n3 = setTimeout(() => {
            this.closeSignal(), t3(new SE(fE.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(i3))));
          }, 2e3);
          this.dataChannel.onopen = () => {
            if ("open" === this.dataChannel.readyState)
              return clearTimeout(n3), void e4();
          }, this.dataChannel.onerror = (e5) => {
            this.closeSignal(), t3(e5);
          };
        }), { transmitter: this.dataChannel, close: this.closeSignal.bind(this) };
      }
      send(e3, t2, i3) {
        var n2 = this;
        return DO(function* () {
          const r2 = yield PO(n2.mutex.lock("From DataChannelConnection.send"));
          try {
            return yield* kO(gb(n2._p2pConnection.send(e3, t2, i3)), PO);
          } finally {
            r2();
          }
        })();
      }
      async stopSending(e3, t2) {
        return this._p2pConnection.stopSending(e3, t2);
      }
      async receive(e3, t2, i3, n2) {
        return this._nvMedia ? (OE.debug("[DataChannelConnection] receive ".concat(e3, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e3, t2, this.cname)) : (OE.debug("[DataChannelConnection] receive ".concat(e3, " by WebRTC.")), await this._p2pConnection.receive(e3, t2, i3, n2));
      }
      async batchReceive(e3) {
        return [...await this._p2pConnection.batchReceive(e3)];
      }
      async stopReceiving(e3) {
        return await this._p2pConnection.stopReceiving(e3);
      }
      async muteRemote(e3) {
        return await this._p2pConnection.muteRemote(e3);
      }
      async unmuteRemote(e3) {
        return await this._p2pConnection.unmuteRemote(e3);
      }
      async muteLocal(e3) {
        return await this._p2pConnection.muteLocal(e3);
      }
      async unmuteLocal(e3) {
        return await this._p2pConnection.unmuteLocal(e3);
      }
      restartICE(e3) {
        var t2 = this;
        return DO(function* () {
          return yield* kO(gb(t2._p2pConnection.restartICE(e3)), PO);
        })();
      }
      close() {
        var e3;
        null === (e3 = this._nvMedia) || void 0 === e3 || e3.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);
      }
      getStats() {
        return this._p2pConnection.getStats();
      }
      getRemoteVideoIsReady(e3) {
        return this._p2pConnection.getRemoteVideoIsReady(e3);
      }
      updateRemoteConnect(e3) {
        var t2;
        null === (t2 = this._nvMedia) || void 0 === t2 || t2.setRemoteRtpCapabilities(e3), this._p2pConnection.updateRemoteConnect(e3);
      }
      async updateEncoderConfig(e3, t2) {
        return await this._p2pConnection.updateEncoderConfig(e3, t2);
      }
      async updateSendParameters(e3, t2) {
        return await this._p2pConnection.updateSendParameters(e3, t2);
      }
      setStatsRemoteVideoIsReady(e3, t2) {
        this._p2pConnection.setStatsRemoteVideoIsReady(e3, t2);
      }
      async replaceTrack(e3, t2) {
        return await this._p2pConnection.replaceTrack(e3, t2);
      }
      async getRemoteSSRC(e3) {
        return this._p2pConnection.getRemoteSSRC(e3);
      }
      logSDPExchange(e3, t2, i3, n2) {
        if (GE("SDP_LOGGING"))
          return OE.upload("exchanging ".concat(i3, " ").concat(t2, " SDP during DataChannelConnection.").concat(n2, "\n"), e3), "offer" === t2 ? (e4) => {
            this.logSDPExchange(e4, "answer", "local" === i3 ? "remote" : "local", n2);
          } : void 0;
      }
      static resolvePCConfiguration(t2) {
        const i3 = { iceServers: [] };
        return t2.iceServers ? i3.iceServers = t2.iceServers : t2.turnServer && "off" !== t2.turnServer.mode && (Uf(t2.turnServer.servers) ? i3.iceServers = t2.turnServer.servers : (i3.iceServers && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.servers)), GE("USE_TURN_SERVER_OF_GATEWAY") && i3.iceServers && t2.turnServer.serversFromGateway && i3.iceServers.push(...e2.turnServerConfigToIceServers(t2.turnServer.serversFromGateway)), GE("FORCE_TURN_TCP") ? i3.iceTransportPolicy = "relay" : t2.turnServer.servers.concat(t2.turnServer.serversFromGateway || []).forEach((e3) => {
          e3.forceturn && (i3.iceTransportPolicy = "relay");
        }))), i3;
      }
      static turnServerConfigToIceServers(e3) {
        const t2 = [];
        return e3.forEach((e4) => {
          e4.security ? e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turns:".concat(VI(e4.turnServerURL), ":").concat(e4.tcpport, "?transport=tcp") }) : (e4.udpport && !GE("FORCE_TURN_TCP") && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.udpport, "?transport=udp") }), e4.tcpport && t2.push({ username: e4.username, credential: e4.password, credentialType: "password", urls: "turn:".concat(e4.turnServerURL, ":").concat(e4.tcpport, "?transport=tcp") }));
        }), t2;
      }
      bindPCEvents() {
        this._p2pConnection.onICEConnectionStateChange = (e3) => {
          var t2;
          return null === (t2 = this.onICEConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onConnectionStateChange = (e3) => {
          var t2;
          return null === (t2 = this.onConnectionStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onDTLSTransportStateChange = (e3) => {
          var t2;
          return null === (t2 = this.onDTLSTransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onDTLSTransportError = (e3) => {
          var t2;
          return null === (t2 = this.onDTLSTransportError) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onICETransportStateChange = (e3) => {
          var t2;
          return null === (t2 = this.onICETransportStateChange) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onFirstAudioReceived = (e3) => {
          var t2;
          return null === (t2 = this.onFirstAudioReceived) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onFirstVideoReceived = (e3) => {
          var t2;
          return null === (t2 = this.onFirstVideoReceived) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onFirstAudioDecoded = (e3) => {
          var t2;
          return null === (t2 = this.onFirstAudioDecoded) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onFirstVideoDecoded = (e3, t2, i3) => {
          var n2;
          return null === (n2 = this.onFirstVideoDecoded) || void 0 === n2 ? void 0 : n2.call(this, e3, t2, i3);
        }, this._p2pConnection.onFirstVideoDecodedTimeout = (e3) => {
          var t2;
          return null === (t2 = this.onFirstVideoDecodedTimeout) || void 0 === t2 ? void 0 : t2.call(this, e3);
        }, this._p2pConnection.onSelectedLocalCandidateChanged = (e3, t2) => {
          var i3;
          return null === (i3 = this.onSelectedLocalCandidateChanged) || void 0 === i3 ? void 0 : i3.call(this, e3, t2);
        }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e3, t2) => {
          var i3;
          return null === (i3 = this.onSelectedRemoteCandidateChanged) || void 0 === i3 ? void 0 : i3.call(this, e3, t2);
        };
      }
      closeSignal() {
        this.dataChannel.close(), this.peerConnection.close();
      }
      unbindConnectionEvents(e3) {
        e3.onConnectionStateChange = void 0, e3.onICEConnectionStateChange = void 0, e3.onICETransportStateChange = void 0, e3.onDTLSTransportStateChange = void 0, e3.onDTLSTransportError = void 0, e3.onFirstAudioDecoded = void 0, e3.onFirstAudioReceived = void 0, e3.onFirstVideoDecoded = void 0, e3.onFirstVideoReceived = void 0, e3.onSelectedLocalCandidateChanged = void 0, e3.onSelectedRemoteCandidateChanged = void 0, e3.onFirstVideoDecodedTimeout = void 0;
      }
      setConfiguration(e3) {
        this._p2pConnection.setConfiguration(e3);
      }
    }).prototype, "connect", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "connect"), Tb.prototype), ag(Tb.prototype, "receive", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "receive"), Tb.prototype), ag(Tb.prototype, "stopReceiving", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "stopReceiving"), Tb.prototype), ag(Tb.prototype, "muteRemote", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "muteRemote"), Tb.prototype), ag(Tb.prototype, "unmuteRemote", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "unmuteRemote"), Tb.prototype), ag(Tb.prototype, "muteLocal", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "muteLocal"), Tb.prototype), ag(Tb.prototype, "unmuteLocal", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "unmuteLocal"), Tb.prototype), ag(Tb.prototype, "close", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "close"), Tb.prototype), ag(Tb.prototype, "updateEncoderConfig", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "updateEncoderConfig"), Tb.prototype), ag(Tb.prototype, "updateSendParameters", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "updateSendParameters"), Tb.prototype), ag(Tb.prototype, "replaceTrack", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "replaceTrack"), Tb.prototype), ag(Tb.prototype, "getRemoteSSRC", [Cb], Object.getOwnPropertyDescriptor(Tb.prototype, "getRemoteSSRC"), Tb.prototype), Tb);
    function Cb(e2, t2, i3) {
      const n2 = e2[t2];
      if ("function" != typeof n2)
        throw new Error("Cannot use mutex on object property.");
      return i3.value = async function() {
        const e3 = this.mutex, i4 = await e3.lock("From DataChannelConnection.".concat(t2));
        try {
          for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
            o2[s2] = arguments[s2];
          return await n2.apply(this, o2);
        } finally {
          i4();
        }
      }, i3;
    }
    var vb;
    function yb(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function Ab(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? yb(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : yb(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    function Ob(e2) {
      var t2, i3, n2, r2 = 2;
      for ("undefined" != typeof Symbol && (i3 = MO, n2 = Symbol.iterator); r2--; ) {
        if (i3 && null != (t2 = e2[i3]))
          return t2.call(e2);
        if (n2 && null != (t2 = e2[n2]))
          return new Nb(t2.call(e2));
        i3 = "@@asyncIterator", n2 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }
    function Nb(e2) {
      function t2(e3) {
        if (Object(e3) !== e3)
          return Sl.reject(new TypeError(e3 + " is not an object."));
        var t3 = e3.done;
        return Sl.resolve(e3.value).then(function(e4) {
          return { value: e4, done: t3 };
        });
      }
      return (Nb = function(e3) {
        this.s = e3, this.n = e3.next;
      }).prototype = { s: null, n: null, next: function() {
        return t2(this.n.apply(this.s, arguments));
      }, return: function(e3) {
        var i3 = this.s.return;
        return void 0 === i3 ? Sl.resolve({ value: e3, done: true }) : t2(i3.apply(this.s, arguments));
      }, throw: function(e3) {
        var i3 = this.s.return;
        return void 0 === i3 ? Sl.reject(e3) : t2(i3.apply(this.s, arguments));
      } }, new Nb(e2);
    }
    let bb = (ag((vb = class extends EE {
      get state() {
        return this._state;
      }
      set state(e2) {
        const t2 = this._state;
        this._state = e2, this.emit(DS.StateChange, t2, this._state);
      }
      constructor(e2, t2) {
        super(), _p(this, "store", void 0), _p(this, "statsUploader", void 0), _p(this, "connection", void 0), _p(this, "localTrackMap", /* @__PURE__ */ new Map()), _p(this, "remoteUserMap", /* @__PURE__ */ new Map()), _p(this, "pendingLocalTracks", []), _p(this, "pendingRemoteTracks", []), _p(this, "statsCollector", void 0), _p(this, "isPlanB", false), _p(this, "shouldForwardP2PCreation", void 0), _p(this, "iceFailedCount", 0), _p(this, "dtlsFailedCount", 0), _p(this, "mutex", new Ug("P2PChannel-mutex")), _p(this, "_state", wS.Disconnected), _p(this, "_pcStatsUploadType", GE("NEW_ICE_RESTART") ? NS.FIRST_CONNECTION : NS.OLD_FIRST_CONNECTION), _p(this, "_isInRestartIce", false), _p(this, "_isStartRestartIce", false), _p(this, "_restartStates", ["disconnected", "failed"]), _p(this, "_restartTimer", void 0), _p(this, "_isFirstConnected", true), _p(this, "handleMuteLocalTrack", async (e3, t3, i3) => {
          const n2 = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
          try {
            if (!this.connection || this.state !== wS.Connected)
              return void i3(new SE(fE.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
            const r2 = this.filterTobeMutedTracks(e3);
            if (0 === r2.length)
              return void t3();
            const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
            if (o2) {
              o2[1].track._originMediaStreamTrack.stop();
            }
            await this.connection.muteLocal(r2.map((e4) => {
              let [, { id: t4 }] = e4;
              return t4;
            }));
            const s2 = this.createMuteMessage(r2);
            await rC(this, DS.RequestMuteLocal, s2), t3();
          } catch (e4) {
            i3(e4);
          } finally {
            n2();
          }
        }), _p(this, "handleUnmuteLocalTrack", async (e3, t3, i3) => {
          const n2 = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
          try {
            if (!this.connection || this.state !== wS.Connected)
              return void i3(new SE(fE.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
            const r2 = this.filterTobeUnmutedTracks(e3);
            if (0 === r2.length)
              return void t3();
            const o2 = r2.find((e4) => "videoLowTrack" === e4[0]);
            if (o2) {
              const t4 = o2[1];
              if (t4.track._originMediaStreamTrack.stop(), JS().supportDualStreamEncoding) {
                const i4 = e3._mediaStreamTrack.clone();
                t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4;
              } else {
                const i4 = FN(e3, sC(this, DS.RequestLowStreamParameter));
                t4.track._mediaStreamTrack = i4, t4.track._originMediaStreamTrack = i4;
              }
              await new Sl((e4, i4) => {
                this.handleReplaceTrack(t4.track, e4, i4, true);
              });
            }
            await this.connection.unmuteLocal(r2.map((e4) => {
              let [, { id: t4 }] = e4;
              return t4;
            }));
            const s2 = this.createUnmuteMessage(r2);
            await rC(this, DS.RequestUnmuteLocal, s2), t3();
          } catch (e4) {
            i3(e4);
          } finally {
            n2();
          }
        }), _p(this, "handleUpdateVideoEncoder", async (e3, t3, i3) => {
          const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
          try {
            const i4 = this.localTrackMap.get(bS.LocalVideoTrack);
            if (!this.connection || !i4 || i4.track !== e3 || this.state !== wS.Connected)
              return void t3();
            const { id: r2, track: o2 } = i4;
            await this.connection.updateSendParameters(r2, o2), await this.connection.updateEncoderConfig(r2, o2), this.emit(DS.UpdateVideoEncoder, o2), t3();
          } catch (e4) {
            i3(e4);
          } finally {
            n2();
          }
        }), _p(this, "handleSetOptimizationMode", async (e3, t3, i3) => {
          const n2 = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
          try {
            const i4 = this.localTrackMap.get(bS.LocalVideoTrack);
            if (!this.connection || !i4 || i4.track !== e3 || this.state !== wS.Connected)
              return;
            const { id: r2, track: o2 } = i4;
            await this.connection.updateSendParameters(r2, o2), t3();
          } catch (e4) {
            i3(e4);
          } finally {
            n2();
          }
        }), _p(this, "handleReplaceTrack", async (e3, t3, i3, n2) => {
          let r2;
          OE.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(e3.getTrackId(), "]")), "boolean" == typeof n2 && n2 || (r2 = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
          try {
            var o2;
            const i4 = Array.from(this.localTrackMap.entries()).find((t4) => {
              let [, { track: i5 }] = t4;
              return e3 === i5;
            });
            if (!this.connection || !i4 || this.state !== wS.Connected)
              return void t3();
            if (await (null === (o2 = this.connection) || void 0 === o2 ? void 0 : o2.replaceTrack(e3, i4[1].id)), this.isPlanB) {
              const t4 = i4[1];
              t4.id = e3._mediaStreamTrack.id, this.localTrackMap.set(i4[0], t4);
            }
            if (i4[0] === bS.LocalVideoTrack && JS().supportDualStreamEncoding) {
              const t4 = this.localTrackMap.get(bS.LocalVideoLowTrack);
              if (t4) {
                const i5 = e3._mediaStreamTrack.clone();
                t4.track._originMediaStreamTrack.stop(), t4.track._mediaStreamTrack = i5, t4.track._originMediaStreamTrack = i5, await new Sl((e4, i6) => {
                  this.handleReplaceTrack(t4.track, e4, i6, true);
                });
              }
            }
            t3();
          } catch (e4) {
            i3(e4);
          } finally {
            var s2;
            null === (s2 = r2) || void 0 === s2 || s2();
          }
        }), _p(this, "handleGetLocalVideoStats", (e3) => {
          e3(this.statsCollector.getLocalVideoTrackStats());
        }), _p(this, "handleGetLocalAudioStats", (e3) => {
          e3(this.statsCollector.getLocalAudioTrackStats());
        }), _p(this, "handleGetRemoteVideoStats", (e3) => this.statsCollector.getRemoteVideoTrackStats(e3.uid)[e3.uid]), _p(this, "handleGetRemoteAudioStats", (e3) => this.statsCollector.getRemoteAudioTrackStats(e3.uid)[e3.uid]), this.store = e2, this.statsCollector = t2, this.statsCollector.addP2PChannel(this), this.statsUploader = new sb(), this.bindStatsUploaderEvents(), this.isPlanB = !JS().supportUnifiedPlan || GE("CHROME_FORCE_PLAN_B") && rp(), this.shouldForwardP2PCreation = GE("FORWARD_P2P_CREATION") && JS().supportPCSetConfiguration, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection));
      }
      async startP2PConnection(e2, t2) {
        var i3;
        this.state = wS.New;
        const n2 = this.shouldForwardP2PCreation && "closed" === (null === (i3 = this.connection) || void 0 === i3 ? void 0 : i3.peerConnectionState);
        if (this.shouldForwardP2PCreation && !n2 || (n2 && this.connection && (OE.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.store.useDataChannel ? new Ib(e2, this.store) : this.isPlanB ? new NN(e2, this.store) : new VN(e2, this.store), this.bindConnectionEvents(this.connection)), !this.connection)
          throw new SE(fE.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
        return this._pcStatsUploadType = GE("NEW_ICE_RESTART") ? NS.FIRST_CONNECTION : NS.OLD_FIRST_CONNECTION, this._isFirstConnected = true, this._isInRestartIce = false, this._isStartRestartIce = false, this.connection.setConfiguration(e2), this.connection.establishPromise;
      }
      async connect(e2, t2, i3, n2, r2, o2) {
        if (!this.connection)
          throw new SE(fE.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
        this.connection instanceof Ib ? this.connection.updateRemoteConnect(n2) : (this.store.peerConnectionStart(), await this.connection.connect(e2, t2, i3, n2, r2, o2), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = wS.Connected);
      }
      async preConnect(e2, t2, i3, n2, r2, o2) {
        if (!this.connection)
          throw new SE(fE.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
        this.store.peerConnectionStart();
        const s2 = await this.connection.connect(e2, t2, i3, n2, r2, o2);
        return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = wS.Connected, s2;
      }
      getEstablishParams() {
        if (this.connection instanceof Ib)
          return this.connection.getP2PConnectionParams();
        throw new Error("Only DataChannelConnection needs to obtain establishParams");
      }
      publish(e2, t2, i3) {
        var n2 = this;
        return DO(function* () {
          const r2 = yield PO(n2.mutex.lock("From P2PChannel.publish"));
          try {
            if (!n2.connection || n2.state !== wS.Connected) {
              if (n2.state === wS.Disconnected)
                throw new SE(fE.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
              n2.throwIfTrackTypeNotMatch(e2);
              const t3 = e2.filter((e3) => -1 === n2.pendingLocalTracks.indexOf(e3));
              return void (n2.pendingLocalTracks = n2.pendingLocalTracks.concat(t3));
            }
            n2.store.pubId = n2.store.pubId + 1, DI.markPublishStart(n2.store.clientId, n2.store.pubId);
            const o2 = n2.filterTobePublishedTracks(e2, t2, i3);
            if (0 === o2.length)
              return void (yield PO(n2.tryToUnmuteAudio(e2)));
            yield* kO(Ob(n2.doPublish(n2.connection, o2)), PO);
          } finally {
            r2();
          }
        })();
      }
      doPublish(e2, t2) {
        var i3 = this;
        return DO(function* () {
          t2.forEach((e3) => {
            let { track: t3, type: n3 } = e3;
            const r3 = Date.now();
            i3.store.publish(t3.getTrackId(), n3 === bS.LocalAudioTrack ? "audio" : "video", r3);
          }), i3.bindLocalTrackEvents(t2);
          const n2 = yield PO(e2.send(t2.map((e3) => {
            let { track: t3 } = e3;
            return t3;
          }), i3.store.codec, i3.store.audioCodec)), r2 = (yield PO(n2.next())).value, o2 = i3.createGatewayPublishMessage(t2, r2);
          let s2;
          try {
            s2 = yield o2;
          } catch (e3) {
            throw n2.throw(e3), (null == e3 ? void 0 : e3.code) === fE.WS_ABORT && t2.forEach((e4) => {
              let { track: t3 } = e4;
              -1 === i3.pendingLocalTracks.indexOf(t3) && i3.pendingLocalTracks.push(t3);
            }), i3.unbindLocalTrackEvents(t2), e3;
          }
          const a2 = i3.mapPubResToRemoteConfig(o2, s2), c2 = (yield PO(n2.next(a2))).value;
          t2.forEach((e3) => {
            let { type: t3 } = e3;
            i3.statsCollector.addLocalStats(t3);
          }), i3.assignLocalTracks(t2, c2), i3.statsUploader.startUploadUplinkStats(), t2.forEach((e3) => {
            let { track: t3, type: n3 } = e3;
            const r3 = Date.now();
            i3.store.publish(t3.getTrackId(), n3 === bS.LocalAudioTrack ? "audio" : "video", void 0, r3);
          });
        })();
      }
      publishLowStream(e2) {
        var t2 = this;
        return DO(function* () {
          if (!t2.connection || t2.state !== wS.Connected)
            return;
          const i3 = yield PO(t2.mutex.lock("Locking from P2PChannel.publishLowStream"));
          try {
            const r2 = t2.localTrackMap.get(bS.LocalVideoTrack);
            if (!r2)
              throw new SE(fE.UNEXPECTED_ERROR, "Could not find high stream");
            if (t2.localTrackMap.has(bS.LocalVideoLowTrack))
              throw new SE(fE.UNEXPECTED_ERROR, "[".concat(t2.store.clientId, "] Can't publish low stream when stream already publish"));
            const o2 = [{ track: t2.getLowVideoTrack(r2.track, e2), type: bS.LocalVideoLowTrack }];
            if (yield* kO(Ob(t2.doPublish(t2.connection, o2)), PO), r2.track.muted || !r2.track.enabled) {
              var n2;
              const e3 = null === (n2 = t2.localTrackMap.get(bS.LocalVideoLowTrack)) || void 0 === n2 ? void 0 : n2.id;
              void 0 !== e3 && (yield PO(t2.connection.muteLocal([e3])));
            }
          } finally {
            i3();
          }
        })();
      }
      async republish() {
        this.pendingLocalTracks.length > 0 && (OE.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await nC(this, DS.RequestRePublish, this.pendingLocalTracks), this.emit(DS.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
      }
      async reSubscribe(e2) {
        for (let e3 = this.pendingRemoteTracks.length - 1; e3 >= 0; e3--) {
          const { user: t2, kind: i3 } = this.pendingRemoteTracks[e3];
          (i3 !== AS.AUDIO || t2._audio_added_ && t2._audioSSRC) && (i3 !== AS.VIDEO || t2._video_added_ && t2._videoSSRC) || this.pendingRemoteTracks.splice(e3, 1);
        }
        if (e2)
          await nC(this, DS.RequestReSubscribe, this.pendingRemoteTracks);
        else
          for (const { user: e3, kind: t2 } of this.pendingRemoteTracks)
            await this.subscribe(e3, t2, t2 === AS.VIDEO ? e3._videoSSRC : e3._audioSSRC);
        this.pendingRemoteTracks.forEach((e3) => {
          let { user: t2 } = e3;
          this.emit(DS.MediaReconnectEnd, t2.uid);
        }), this.pendingRemoteTracks = [];
      }
      async unpublish(e2) {
        if (!this.connection || this.state !== wS.Connected)
          return void e2.forEach((e3) => {
            const t3 = this.pendingLocalTracks.indexOf(e3);
            -1 !== t3 && this.pendingLocalTracks.splice(t3, 1);
          });
        const t2 = this.filterTobeUnpublishedTracks(e2);
        if (0 === t2.length)
          return;
        const i3 = t2.find((e3) => "videoLowTrack" === e3[0]);
        if (i3) {
          i3[1].track.close();
        }
        return this.doUnpublish(this.connection, t2);
      }
      async unpublishLowStream() {
        if (!this.connection || this.state !== wS.Connected)
          return;
        const e2 = this.localTrackMap.get(bS.LocalVideoLowTrack);
        if (!e2)
          return;
        e2.track.close();
        const t2 = [[bS.LocalVideoLowTrack, e2]];
        return this.doUnpublish(this.connection, t2);
      }
      async doUnpublish(e2, t2) {
        const i3 = this.createGatewayUnpublishMessage(t2);
        return await e2.stopSending(t2.map((e3) => {
          let [, { id: t3 }] = e3;
          return t3;
        })), this.withdrawLocalTracks(t2), this.unbindLocalTrackEvents(t2.map((e3) => {
          let [t3, { track: i4 }] = e3;
          return { type: t3, track: i4 };
        })), t2.forEach((e3) => {
          let [t3] = e3;
          this.statsCollector.removeLocalStats(t3);
        }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), i3;
      }
      async subscribe(e2, t2, i3, n2, r2) {
        var o2;
        if (!this.connection || this.state !== wS.Connected)
          throw new SE(fE.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
        if (null !== (o2 = this.remoteUserMap.get(e2)) && void 0 !== o2 && o2.has(t2))
          return;
        let s2, a2, c2 = void 0;
        if (r2) {
          const i4 = r2.find((e3) => {
            let { stream_type: i5 } = e3;
            return i5 === t2;
          });
          if (!i4)
            throw new SE(fE.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t2, " for user: ").concat(e2.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t2, "."));
          const n3 = await this.connection.receive(t2, i4.ssrcs, String(e2._uintid), i4.attributes);
          this.connection instanceof VN && (c2 = n3.transceiver), s2 = n3.track, a2 = n3.id;
        } else {
          const r3 = await this.connection.receive(t2, [{ ssrcId: i3, rtx: n2 }], String(e2._uintid), void 0);
          this.connection instanceof VN && (c2 = r3.transceiver), s2 = r3.track, a2 = r3.id;
        }
        t2 === AS.AUDIO ? (e2._audioTrack ? e2._audioTrack._updateOriginMediaStreamTrack(s2) : (e2._audioTrack = new nb(s2, e2.uid, e2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(e2._audioTrack.getTrackId()))), c2 && e2._audioTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._audioTrack)) : (e2._videoTrack ? e2._videoTrack._updateOriginMediaStreamTrack(s2) : (e2._videoTrack = new ib(s2, e2.uid, e2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(e2._videoTrack.getTrackId()))), c2 && e2._videoTrack._updateRtpTransceiver(c2), this.bindRemoteTrackEvents(e2, e2._videoTrack));
        const d2 = this.remoteUserMap.get(e2);
        d2 ? d2.set(t2, a2) : this.remoteUserMap.set(e2, /* @__PURE__ */ new Map([[t2, a2]])), this.statsCollector.addRemoteStats(e2.uid), this.statsUploader.startUploadDownlinkStats();
        const u2 = this.pendingRemoteTracks.findIndex((i4) => {
          let { user: n3, kind: r3 } = i4;
          return n3.uid === e2.uid && t2 === r3;
        });
        -1 !== u2 && (this.pendingRemoteTracks.splice(u2, 1), this.emit(DS.MediaReconnectEnd, e2.uid));
      }
      async massSubscribe(e2) {
        return this.massSubscribeNoLock(e2);
      }
      async massSubscribeNoLock(e2) {
        if (!this.connection || this.state !== wS.Connected)
          throw new SE(fE.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
        e2 = e2.filter((e3) => {
          var t3;
          let { user: i3, mediaType: n2 } = e3;
          return !(null !== (t3 = this.remoteUserMap.get(i3)) && void 0 !== t3 && t3.has(n2));
        });
        const t2 = await this.connection.batchReceive(e2.map((e3) => {
          let { user: t3, mediaType: i3, ssrcId: n2, rtxSsrcId: r2 } = e3;
          return { kind: i3, ssrcMsg: [{ ssrcId: n2, rtx: r2 }], mslabel: String(t3._uintid) };
        }));
        e2.forEach((e3, i3) => {
          let { user: n2, mediaType: r2 } = e3;
          const { track: o2, id: s2, transceiver: a2 } = t2[i3];
          r2 === AS.AUDIO ? (n2._audioTrack ? n2._audioTrack._updateOriginMediaStreamTrack(o2) : (n2._audioTrack = new nb(o2, n2.uid, n2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(n2._audioTrack.getTrackId()))), a2 && n2._audioTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._audioTrack)) : (n2._videoTrack ? n2._videoTrack._updateOriginMediaStreamTrack(o2) : (n2._videoTrack = new ib(o2, n2.uid, n2._uintid, this.store), OE.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(n2._videoTrack.getTrackId()))), a2 && n2._videoTrack._updateRtpTransceiver(a2), this.bindRemoteTrackEvents(n2, n2._videoTrack));
          const c2 = this.remoteUserMap.get(n2);
          c2 ? c2.set(r2, s2) : this.remoteUserMap.set(n2, /* @__PURE__ */ new Map([[r2, s2]])), this.statsCollector.addRemoteStats(n2.uid), this.statsUploader.startUploadDownlinkStats();
          const d2 = this.pendingRemoteTracks.findIndex((e4) => {
            let { user: t3, kind: i4 } = e4;
            return t3.uid === n2.uid && r2 === i4;
          });
          -1 !== d2 && (this.pendingRemoteTracks.splice(d2, 1), this.emit(DS.MediaReconnectEnd, n2.uid));
        });
      }
      async unsubscribe(e2, t2, i3) {
        const n2 = this.pendingRemoteTracks.filter((i4) => {
          let { user: n3, kind: r3 } = i4;
          return void 0 !== t2 ? n3.uid === e2.uid && t2 === r3 : n3.uid === e2.uid;
        });
        if (n2.forEach((e3) => {
          const t3 = this.pendingRemoteTracks.indexOf(e3);
          this.pendingRemoteTracks.splice(t3, 1);
        }), this.connection && this.state === wS.Connected || i3 || n2.forEach((t3) => {
          let { kind: i4 } = t3;
          var n3;
          if (i4 === AS.AUDIO)
            null === (n3 = e2._audioTrack) || void 0 === n3 || n3._destroy(), e2._audioTrack = void 0;
          else if (i4 === AS.VIDEO) {
            var r3;
            null === (r3 = e2._videoTrack) || void 0 === r3 || r3._destroy(), e2._videoTrack = void 0;
          }
        }), !this.connection || this.state !== wS.Connected)
          return;
        const r2 = this.filterTobeUnSubscribedTracks(e2, t2);
        if (0 === r2.length)
          return;
        await this.connection.stopReceiving(r2.map((e3) => {
          let [, { id: t3 }] = e3;
          return t3;
        }));
        const o2 = this.createUnsubscribeMessage(r2);
        return this.withdrawRemoteTracks(r2), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), r2.forEach((e3) => {
          let [t3, { kind: n3 }] = e3;
          var r3, o3;
          n3 === AS.VIDEO && t3._videoSSRC && (null === (r3 = this.connection) || void 0 === r3 || r3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
          if (n3 === AS.VIDEO)
            this.unbindRemoteTrackEvents(t3._videoTrack), i3 || (null === (o3 = t3._videoTrack) || void 0 === o3 || o3._destroy(), t3._videoTrack = void 0);
          else if (n3 === AS.AUDIO) {
            var s2;
            if (this.unbindRemoteTrackEvents(t3._audioTrack), !i3)
              null === (s2 = t3._audioTrack) || void 0 === s2 || s2._destroy(), t3._audioTrack = void 0;
          }
        }), o2;
      }
      async massUnsubscribe(e2) {
        return this.massUnsubscribeNoLock(e2);
      }
      async massUnsubscribeNoLock(e2) {
        let t2 = [];
        for (const { user: i4, mediaType: n3 } of e2) {
          const e3 = this.pendingRemoteTracks.filter((e4) => {
            let { user: t3, kind: r2 } = e4;
            return void 0 !== n3 ? t3.uid === i4.uid && n3 === r2 : t3.uid === i4.uid;
          });
          e3.forEach((e4) => {
            const t3 = this.pendingRemoteTracks.indexOf(e4);
            this.pendingRemoteTracks.splice(t3, 1);
          }), t2 = t2.concat(e3);
        }
        if (!this.connection || this.state !== wS.Connected)
          return void t2.forEach((e3) => {
            let { user: t3, kind: i4 } = e3;
            var n3;
            if (i4 === AS.AUDIO)
              null === (n3 = t3._audioTrack) || void 0 === n3 || n3._destroy(), t3._audioTrack = void 0;
            else if (i4 === AS.VIDEO) {
              var r2;
              null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
            }
          });
        const i3 = zi(e2).call(e2, (e3, t3) => {
          let { user: i4, mediaType: n3 } = t3;
          const r2 = this.filterTobeUnSubscribedTracks(i4, n3);
          return e3.concat(r2);
        }, []);
        if (0 === i3.length)
          return;
        await this.connection.stopReceiving(i3.map((e3) => {
          let [, { id: t3 }] = e3;
          return t3;
        }));
        const n2 = this.createUnsubscribeAllMessage(i3);
        return this.withdrawRemoteTracks(i3), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), i3.forEach((e3) => {
          let [t3, { kind: i4 }] = e3;
          var n3, r2;
          i4 === AS.VIDEO && t3._videoSSRC && (null === (n3 = this.connection) || void 0 === n3 || n3.setStatsRemoteVideoIsReady(t3._videoSSRC, false));
          if (i4 === AS.VIDEO)
            this.unbindRemoteTrackEvents(t3._videoTrack), null === (r2 = t3._videoTrack) || void 0 === r2 || r2._destroy(), t3._videoTrack = void 0;
          else if (i4 === AS.AUDIO) {
            var o2;
            this.unbindRemoteTrackEvents(t3._audioTrack), null === (o2 = t3._audioTrack) || void 0 === o2 || o2._destroy(), t3._audioTrack = void 0;
          }
        }), n2;
      }
      async muteRemote(e2, t2) {
        if (!this.connection)
          return;
        const i3 = this.remoteUserMap.get(e2);
        if (!i3)
          return void OE.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, "."));
        if (!i3.get(t2))
          return void OE.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
        const n2 = t2 === AS.VIDEO ? e2._videoSSRC : e2._audioSSRC;
        void 0 !== n2 && this.connection.setStatsRemoteVideoIsReady(n2, false);
      }
      async unmuteRemote(e2, t2) {
        return this.unmuteRemoteNoLock(e2, t2);
      }
      async unmuteRemoteNoLock(e2, t2) {
        if (!this.connection)
          return;
        const i3 = this.remoteUserMap.get(e2);
        if (!i3)
          return void OE.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, "."));
        i3.get(t2) || OE.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(e2.uid, " media type ").concat(t2, "."));
      }
      getAllTracks(e2) {
        const t2 = this.localTrackMap.get(bS.LocalAudioTrack);
        if ((null == t2 ? void 0 : t2.track) instanceof NI) {
          const i3 = t2.track;
          return Array.from(this.localTrackMap.entries()).filter((e3) => {
            let [t3] = e3;
            return t3 !== bS.LocalAudioTrack;
          }).filter((t3) => {
            let [i4] = t3;
            return !(e2 && i4 === bS.LocalVideoLowTrack);
          }).map((e3) => {
            let [, { track: t3 }] = e3;
            return t3;
          }).concat(i3.trackList);
        }
        return Array.from(this.localTrackMap.entries()).filter((t3) => {
          let [i3] = t3;
          return !(e2 && i3 === bS.LocalVideoLowTrack);
        }).map((e3) => {
          let [, { track: t3 }] = e3;
          return t3;
        });
      }
      reportPublishEvent(e2, t2, i3, n2, r2) {
        if (e2) {
          const i4 = this.localTrackMap.get(bS.LocalAudioTrack), o3 = n2 ? this.localTrackMap.get(bS.LocalVideoLowTrack) : this.localTrackMap.get(bS.LocalVideoTrack);
          Pg.publish(this.store.sessionId, { eventElapse: DI.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == i4 ? void 0 : i4.track.getTrackLabel(), videoName: null == o3 ? void 0 : o3.track.getTrackLabel(), screenshare: -1 !== (null == o3 ? void 0 : o3.track._hints.indexOf(lS.SCREEN_TRACK)), audio: !!i4, video: !!o3, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
        } else {
          var o2;
          i3 || (i3 = []);
          const s2 = i3.find((e3) => e3 instanceof yI), a2 = n2 ? null === (o2 = this.localTrackMap.get(bS.LocalVideoTrack)) || void 0 === o2 ? void 0 : o2.track : i3.find((e3) => e3 instanceof Cy);
          Pg.publish(this.store.sessionId, { eventElapse: DI.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: e2, ec: t2, audioName: null == s2 ? void 0 : s2.getTrackLabel(), videoName: null == a2 ? void 0 : a2.getTrackLabel(), screenshare: -1 !== (null == a2 ? void 0 : a2._hints.indexOf(lS.SCREEN_TRACK)), audio: !!s2, video: !!a2, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r2 });
        }
      }
      reportSubscribeEvent(e2, t2, i3, n2) {
        const r2 = n2 === AS.VIDEO ? i3._videoSSRC : i3._audioSSRC;
        r2 && Pg.subscribe(this.store.sessionId, { succ: e2, ec: t2, video: n2 === AS.VIDEO, audio: n2 === AS.AUDIO, peerid: i3.uid, subscribeRequestid: n2 === AS.VIDEO ? i3._videoSSRC : i3._audioSSRC, p2pid: this.store.p2pId, eventElapse: DI.measureFromSubscribeStart(this.store.clientId, r2) });
      }
      reset() {
        OE.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new Ug("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
        const e2 = this.localTrackMap.get(bS.LocalAudioTrack);
        if ((null == e2 ? void 0 : e2.track) instanceof NI) {
          if (e2.track.trackList.length > 0) {
            const t2 = e2.track;
            e2.track.trackList.forEach((e3) => {
              t2.removeAudioTrack(e3);
            });
          }
          e2.track.close();
        }
        this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = wS.Disconnected;
      }
      getStats() {
        var e2;
        return null === (e2 = this.connection) || void 0 === e2 ? void 0 : e2.getStats();
      }
      getRemoteVideoIsReady(e2) {
        var t2;
        return (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.getRemoteVideoIsReady(e2)) || false;
      }
      getLocalAudioVolume() {
        const e2 = this.localTrackMap.get(bS.LocalAudioTrack);
        if (e2)
          return e2.track.getVolumeLevel();
      }
      getLocalVideoSize() {
        const e2 = this.localTrackMap.get(bS.LocalVideoTrack);
        if (e2)
          return { width: e2.track._videoWidth || 0, height: e2.track._videoHeight || 0 };
      }
      getEncoderConfig(e2) {
        const t2 = this.localTrackMap.get(e2);
        return t2 && t2.track instanceof Cy || t2 && t2.track instanceof yI ? t2.track._encoderConfig : void 0;
      }
      getLocalMedia(e2) {
        return this.localTrackMap.get(e2);
      }
      hasLocalMedia() {
        return this.localTrackMap.size > 0;
      }
      hasRemoteMedia(e2, t2) {
        if (!e2)
          return this.remoteUserMap.size > 0;
        const i3 = this.remoteUserMap.get(e2);
        return !!i3 && (!t2 || i3.has(t2));
      }
      async hasRemoteMediaWithLock(e2, t2) {
        if (!e2)
          return this.remoteUserMap.size > 0;
        const i3 = this.remoteUserMap.get(e2);
        return !!i3 && (!t2 || i3.has(t2));
      }
      getRemoteMedia(e2) {
        var t2;
        const i3 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3.uid === e2);
        return i3 ? { audioTrack: i3.audioTrack, audioSSRC: i3._audioSSRC, videoTrack: i3.videoTrack, videoSSRC: i3._videoSSRC } : {};
      }
      getAudioLevels() {
        let e2 = Array.from(this.remoteUserMap.entries()).map((e3) => {
          let [t3] = e3;
          return { uid: t3.uid, level: t3.audioTrack ? 100 * t3.audioTrack._source.getAccurateVolumeLevel() : 0 };
        });
        const t2 = this.localTrackMap.get(bS.LocalAudioTrack);
        return t2 && e2.push({ level: 100 * t2.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), e2 = Hm(e2).call(e2, (e3, t3) => e3.level - t3.level), e2;
      }
      async disconnectForReconnect() {
        this.connection && (OE.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = wS.Reconnecting, GE("KEEP_LAST_FRAME") && 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
          let [t2] = e2;
          var i3;
          t2._videoTrack && t2._videoTrack._player && (null === (i3 = t2._videoTrack._player.getVideoElement()) || void 0 === i3 || i3.pause(), t2._videoTrack._player.isKeepLastFrame = true, t2._videoTrack._originMediaStreamTrack.stop());
        }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.store.useDataChannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection)), 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach((e2) => {
          let [t2, { track: i3 }] = e2;
          switch (t2) {
            case bS.LocalVideoTrack:
              i3._hints.includes(lS.LOW_STREAM) ? i3.close() : this.pendingLocalTracks.push(i3);
              break;
            case bS.LocalAudioTrack:
              i3 instanceof NI ? this.pendingLocalTracks = this.pendingLocalTracks.concat(i3.trackList) : this.pendingLocalTracks.push(i3);
              break;
            case bS.LocalVideoLowTrack:
          }
        }), this.emit(DS.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach((e2) => {
          let [t2, i3] = e2;
          Array.from(Eg(i3).call(i3)).forEach((e3) => {
            this.setPendingRemoteMedia(t2, e3);
          }), this.emit(DS.MediaReconnectStart, t2.uid);
        }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), OE.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
      }
      hasPendingRemoteMedia(e2, t2) {
        for (const i3 of this.pendingRemoteTracks) {
          const { user: n2, kind: r2 } = i3;
          if ((e2 instanceof yy ? e2.uid : e2) === n2.uid && t2 === r2)
            return true;
        }
        return false;
      }
      setPendingRemoteMedia(e2, t2) {
        this.hasPendingRemoteMedia(e2, t2) || this.pendingRemoteTracks.push({ user: e2, kind: t2 });
      }
      restartICE(e2) {
        var t2 = this;
        return DO(function* () {
          if (!t2.connection || t2.state !== wS.Connected || t2.connection instanceof Ib)
            return;
          const i3 = yield PO(t2.mutex.lock("From P2PChannel.restartICE"));
          let n2;
          try {
            n2 = yield PO(t2.connection.restartICE(e2));
            const r3 = yield PO(n2.next());
            if (r3.done)
              return;
            const o2 = r3.value, s2 = yield o2;
            switch (t2.reportPCDisconnectedOrFailed(e2), e2) {
              case OS.TCP:
                t2._pcStatsUploadType = NS.TCP_RESTART;
                break;
              case OS.RELAY:
                t2._pcStatsUploadType = NS.RELAY_RESTART;
                break;
              default:
                t2._pcStatsUploadType = NS.OLD_RESTART;
            }
            t2._isInRestartIce = true, n2.next(s2);
          } catch (e3) {
            var r2;
            null === (r2 = n2) || void 0 === r2 || r2.throw(e3);
          } finally {
            i3();
          }
        })();
      }
      getUplinkNetworkQuality() {
        if (!this.connection)
          return 0;
        const e2 = this.connection.getStats(), t2 = this.localTrackMap.get(bS.LocalVideoTrack), i3 = this.localTrackMap.get(bS.LocalAudioTrack), n2 = e2.videoSend.find((e3) => e3.ssrc === (null == t2 ? void 0 : t2.ssrcs[0].ssrcId)), r2 = e2.audioSend.find((e3) => e3.ssrc === (null == i3 ? void 0 : i3.ssrcs[0].ssrcId));
        if (!n2 || !r2)
          return 1;
        const o2 = oC(this, DS.NeedSignalRTT), s2 = n2 ? n2.rttMs : void 0, a2 = r2 ? r2.rttMs : void 0, c2 = s2 && a2 ? (s2 + a2) / 2 : s2 || a2, d2 = (c2 && o2 ? (c2 + o2) / 2 : c2 || o2) || 0, u2 = 100 * e2.sendPacketLossRate * 0.7 / 50 + 0.3 * d2 / 1500, l2 = u2 < 0.17 ? 1 : u2 < 0.36 ? 2 : u2 < 0.59 ? 3 : u2 < 0.1 ? 4 : 5, h3 = null == t2 ? void 0 : t2.track;
        if (h3 && h3._encoderConfig && -1 === h3._hints.indexOf(lS.SCREEN_TRACK)) {
          const t3 = h3._encoderConfig.bitrateMax, i4 = e2.bitrate.actualEncoded;
          if (t3 && i4) {
            const e3 = (1e3 * t3 - i4) / (1e3 * t3);
            return XE[e3 < 0.15 ? 0 : e3 < 0.3 ? 1 : e3 < 0.45 ? 2 : e3 < 0.6 ? 3 : 4][l2];
          }
        }
        return l2;
      }
      getDownlinkNetworkQuality() {
        if (!this.connection)
          return 0;
        const e2 = this.connection.getStats();
        let t2 = 0;
        return Array.from(this.remoteUserMap.entries()).forEach((i3) => {
          let [n2] = i3;
          const r2 = n2._audioSSRC, o2 = n2._videoSSRC, s2 = e2.audioRecv.find((e3) => e3.ssrc === r2), a2 = e2.videoRecv.find((e3) => e3.ssrc === o2);
          if (!s2 && !a2)
            return void (t2 += 1);
          const c2 = oC(this, DS.NeedSignalRTT), d2 = e2.rtt, u2 = (d2 && c2 ? (d2 + c2) / 2 : d2 || c2) || 0, l2 = s2 ? s2.jitterMs : void 0, h3 = e2.recvPacketLossRate;
          let p3 = 0.7 * h3 * 100 / 50 + 0.3 * u2 / 1500;
          l2 && (p3 = 0.6 * h3 * 100 / 50 + 0.2 * u2 / 1500 + 0.2 * l2 / 400);
          t2 += p3 < 0.1 ? 1 : p3 < 0.17 ? 2 : p3 < 0.36 ? 3 : p3 < 0.59 ? 4 : 5;
        }), this.remoteUserMap.size > 0 ? Math.round(t2 / this.remoteUserMap.size) : t2;
      }
      async muteLocalTrack(e2) {
        return new Sl((t2, i3) => {
          this.handleMuteLocalTrack(e2, t2, i3);
        });
      }
      filterTobePublishedTracks(e2, t2, i3) {
        const n2 = [], r2 = JS(), o2 = this.getAllTracks();
        e2 = cC(e2 = e2.filter((e3) => -1 === o2.indexOf(e3)));
        let s2 = false, a2 = false;
        for (const o3 of e2) {
          if (o3 instanceof Cy && (this.localTrackMap.has(bS.LocalVideoTrack) || s2 ? new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n2.push({ track: o3, type: bS.LocalVideoTrack }), s2 = true), t2)) {
            const e3 = this.getLowVideoTrack(o3, i3);
            n2.push({ track: e3, type: bS.LocalVideoLowTrack });
          }
          if (o3 instanceof yI) {
            const e3 = this.localTrackMap.get(bS.LocalAudioTrack);
            if (e3) {
              if (!(e3.track instanceof NI))
                throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
              if (o3._bypassWebAudio)
                throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
              e3.track.addAudioTrack(o3), this.bindLocalAudioTrackEvents(o3, true);
            } else if (a2) {
              const e4 = n2.find((e5) => {
                let { type: t3 } = e5;
                return t3 === bS.LocalAudioTrack;
              });
              if (!(e4.track instanceof NI))
                throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
              if (o3._bypassWebAudio)
                throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
              e4.track.addAudioTrack(o3);
            } else {
              if (!r2.webAudioMediaStreamDest || o3 instanceof NI || o3._bypassWebAudio)
                n2.push({ track: o3, type: bS.LocalAudioTrack });
              else {
                const e4 = new NI();
                e4.addAudioTrack(o3), n2.push({ track: e4, type: bS.LocalAudioTrack });
              }
              a2 = true;
            }
          }
        }
        return n2;
      }
      filterTobeUnpublishedTracks(e2) {
        const t2 = [], i3 = this.getAllTracks();
        e2 = cC(e2 = e2.filter((e3) => -1 !== i3.indexOf(e3)));
        for (const i4 of e2) {
          if (i4 instanceof yI) {
            const e3 = this.localTrackMap.get(bS.LocalAudioTrack);
            if (!e3)
              continue;
            e3.track instanceof NI ? (e3.track.removeAudioTrack(i4), this.unbindLocalAudioTrackEvents(i4), 0 === e3.track.trackList.length && (t2.push([bS.LocalAudioTrack, e3]), e3.track.close())) : t2.push([bS.LocalAudioTrack, e3]);
          }
          if (i4 instanceof Cy) {
            const e3 = this.localTrackMap.get(bS.LocalVideoTrack);
            if (!e3)
              continue;
            t2.push([bS.LocalVideoTrack, e3]);
            const i5 = this.localTrackMap.get(bS.LocalVideoLowTrack);
            i5 && t2.push([bS.LocalVideoLowTrack, i5]);
          }
        }
        return t2;
      }
      bindLocalTrackEvents(e2) {
        e2.forEach((e3) => {
          let { track: t2, type: i3 } = e3;
          switch (i3) {
            case bS.LocalVideoTrack:
              t2.addListener(uS.GET_STATS, this.handleGetLocalVideoStats), t2.addListener(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.addListener(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.addListener(uS.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.addListener(uS.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.addListener(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.addListener(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.addListener(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
              break;
            case bS.LocalAudioTrack:
              this.bindLocalAudioTrackEvents(t2);
              break;
            case bS.LocalVideoLowTrack:
          }
        });
      }
      bindLocalAudioTrackEvents(e2, t2) {
        e2 instanceof NI ? e2.trackList.forEach((e3) => {
          e3.addListener(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.addListener(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.addListener(uS.GET_STATS, this.handleGetLocalAudioStats), e3.addListener(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.addListener(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
        }) : (e2.addListener(uS.GET_STATS, this.handleGetLocalAudioStats), e2.addListener(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.addListener(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.addListener(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.addListener(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t2 || e2.addListener(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack));
      }
      unbindLocalTrackEvents(e2) {
        e2 || (e2 = Array.from(this.localTrackMap.entries()).map((e3) => {
          let [t2, { track: i3 }] = e3;
          return { track: i3, type: t2 };
        })), e2.forEach((e3) => {
          let { track: t2, type: i3 } = e3;
          switch (i3) {
            case bS.LocalVideoTrack:
              t2.off(uS.GET_STATS, this.handleGetLocalVideoStats), t2.off(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t2.off(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t2.off(uS.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t2.off(uS.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t2.off(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack), t2.off(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t2.off(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
              break;
            case bS.LocalAudioTrack:
              this.unbindLocalAudioTrackEvents(t2);
              break;
            case bS.LocalVideoLowTrack:
          }
        });
      }
      unbindLocalAudioTrackEvents(e2) {
        e2 instanceof NI ? e2.trackList.forEach((e3) => {
          e3.off(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e3.off(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e3.off(uS.GET_STATS, this.handleGetLocalAudioStats), e3.off(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e3.off(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
        }) : (e2.off(uS.GET_STATS, this.handleGetLocalAudioStats), e2.off(uS.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e2.off(uS.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e2.off(uS.NEED_REPLACE_TRACK, this.handleReplaceTrack), e2.off(uS.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e2.off(uS.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
      }
      bindRemoteTrackEvents(e2, t2) {
        t2 instanceof ib && t2.addListener(uS.GET_STATS, (t3) => {
          t3(this.handleGetRemoteVideoStats(e2));
        }), t2 instanceof nb && t2.addListener(uS.GET_STATS, (t3) => {
          t3(this.handleGetRemoteAudioStats(e2));
        });
      }
      unbindRemoteTrackEvents(e2) {
        e2 && e2.removeAllListeners(uS.GET_STATS);
      }
      unbindAllRemoteTrackEvents() {
        Array.from(this.remoteUserMap.entries()).forEach((e2) => {
          let [t2, i3] = e2;
          i3.has(AS.AUDIO) && this.unbindRemoteTrackEvents(t2._audioTrack), i3.has(AS.VIDEO) && this.unbindRemoteTrackEvents(t2._videoTrack);
        });
      }
      createGatewayPublishMessage(e2, t2) {
        return e2.map((e3, i3) => {
          let n2, r2, { track: o2, type: s2 } = e3;
          switch (s2) {
            case bS.LocalAudioTrack:
              n2 = sS.Audio, r2 = { dtx: o2 instanceof AI && o2._config.DTX, hq: false, lq: false, stereo: false, speech: false };
              break;
            case bS.LocalVideoTrack:
              n2 = o2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High, r2 = Ab(Ab({}, BI(o2)), {}, { codec: this.store.codec });
              break;
            case bS.LocalVideoLowTrack:
              n2 = sS.Low, r2 = Ab(Ab({}, BI(o2)), {}, { codec: this.store.codec });
          }
          return { stream_type: n2, attributes: r2, ssrcs: t2[i3] };
        });
      }
      createGatewayUnpublishMessage(e2) {
        return e2.map((e3) => {
          let t2, [i3, { track: n2, ssrcs: r2, id: o2 }] = e3;
          switch (i3) {
            case bS.LocalVideoTrack:
              t2 = n2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High;
              break;
            case bS.LocalAudioTrack:
              t2 = sS.Audio;
              break;
            case bS.LocalVideoLowTrack:
              t2 = sS.Low;
          }
          return { stream_type: t2, ssrcs: r2, mid: o2 };
        });
      }
      assignLocalTracks(e2, t2) {
        e2.forEach((e3, i3) => {
          let { track: n2, type: r2 } = e3;
          this.localTrackMap.set(r2, { track: n2, id: t2[i3].id, ssrcs: t2[i3].localSSRC });
        });
      }
      withdrawLocalTracks(e2) {
        e2.forEach((e3) => {
          let [t2] = e3;
          this.localTrackMap.delete(t2);
        });
      }
      bindConnectionEvents(e2) {
        e2.onConnectionStateChange = async (t2) => {
          if (OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t2, ")")), this.emit(DS.PeerConnectionStateChange, t2), "connected" !== t2 || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "connected" === t2 && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isInRestartIce = false, this._isFirstConnected = false, this._isStartRestartIce = false), GE("NEW_ICE_RESTART")) {
            if (this._restartStates.includes(t2)) {
              if (this._isStartRestartIce)
                return;
              this._isStartRestartIce = true;
              const t3 = (t4) => {
                if ("disconnected" === e2.iceConnectionState || "checking" === e2.iceConnectionState || "failed" === e2.iceConnectionState) {
                  OE.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(t4));
                  "CONNECTED" === oC(this, DS.QueryClientConnectionState) && this.emit(DS.RequestRestartICE, t4);
                }
              }, i3 = () => {
                "disconnected" !== e2.iceConnectionState && "checking" !== e2.iceConnectionState && "failed" !== e2.iceConnectionState || (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), OE.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(DS.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
              }, n2 = GE("ICE_RESTART_INTERVAL");
              return void (this._restartTimer = window.setTimeout(() => {
                if (GE("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && JS().supportPCSetConfiguration)
                  t3(OS.RELAY), this._restartTimer = window.setTimeout(i3, n2);
                else if (Kh())
                  t3(OS.UDP), this._restartTimer = window.setTimeout(i3, 4e3);
                else {
                  if (t3(OS.TCP), JS().supportPCSetConfiguration)
                    return void (this._restartTimer = window.setTimeout(() => {
                      t3(OS.RELAY), this._restartTimer = window.setTimeout(i3, n2);
                    }, n2));
                  this._restartTimer = window.setTimeout(i3, n2);
                }
              }, 800));
            }
          } else {
            if ("disconnected" === t2 && "disconnected" === e2.iceConnectionState)
              return setTimeout(() => {
                if ("disconnected" === e2.iceConnectionState && GE("ICE_RESTART")) {
                  "CONNECTED" === oC(this, DS.QueryClientConnectionState) && this.emit(DS.RequestRestartICE);
                }
              }, 800), void setTimeout(() => {
                "disconnected" === e2.peerConnectionState && (OE.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isInRestartIce = false, setTimeout(() => this.emit(DS.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
              }, 4e3);
            "failed" === t2 && (OE.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(DS.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
          }
        }, e2.onICEConnectionStateChange = (e3) => {
          "connected" !== e3 || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e3, ")")), Pg.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e3, tag: Ef.TRACER }).onSuccess(), this.emit(DS.IceConnectionStateChange, e3);
        }, e2.onICETransportStateChange = (e3) => {
          OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e3, ")"));
        }, e2.onDTLSTransportStateChange = (e3) => {
          OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e3, ")"));
        }, e2.onDTLSTransportError = (e3) => {
          OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e3, ")"));
        }, e2.onFirstAudioDecoded = (e3) => {
          var t2;
          const i3 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
          var n2;
          i3 && (this.store.subscribe(i3.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n2 = i3.audioTrack) || void 0 === n2 || n2.emit(fS.FIRST_FRAME_DECODED), Pg.firstRemoteFrame(this.store.sessionId, uf.FIRST_AUDIO_DECODE, lf.FIRST_AUDIO_DECODE, { peer: i3._uintid, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId }));
        }, e2.onFirstAudioReceived = (e3) => {
          var t2;
          const i3 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._audioSSRC === e3);
          i3 && Pg.firstRemoteFrame(this.store.sessionId, uf.FIRST_AUDIO_RECEIVED, lf.FIRST_AUDIO_RECEIVED, { peer: i3._uintid, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
        }, e2.onFirstVideoDecoded = (e3, t2, i3) => {
          this.reportVideoFirstFrameDecoded(e3, t2, i3);
        }, e2.onFirstVideoReceived = (e3) => {
          var t2;
          const i3 = Array.from(Eg(t2 = this.remoteUserMap).call(t2)).find((t3) => t3._videoSSRC === e3);
          i3 && Pg.firstRemoteFrame(this.store.sessionId, uf.FIRST_VIDEO_RECEIVED, lf.FIRST_VIDEO_RECEIVED, { peer: i3._uintid, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e3), subscribeRequestid: e3, p2pid: this.store.p2pId });
        }, e2.onSelectedLocalCandidateChanged = (e3, t2) => {
          const i3 = "relay" === e3.candidateType, n2 = "relay" === t2.candidateType;
          "unknown" !== t2.candidateType && i3 === n2 || this.emit(DS.ConnectionTypeChange, i3), OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(YI(t2)), " -> ").concat(JSON.stringify(YI(e3)), ")"));
        }, e2.onSelectedRemoteCandidateChanged = (e3, t2) => {
          OE.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(YI(t2)), " -> ").concat(JSON.stringify(YI(e3)), ")"));
        }, e2.onFirstVideoDecodedTimeout = (e3) => {
          this.reportVideoFirstFrameDecoded(e3, void 0, void 0, true);
        };
      }
      unbindConnectionEvents(e2) {
        e2.onConnectionStateChange = void 0, e2.onICEConnectionStateChange = void 0, e2.onICETransportStateChange = void 0, e2.onDTLSTransportStateChange = void 0, e2.onDTLSTransportError = void 0, e2.onFirstAudioDecoded = void 0, e2.onFirstAudioReceived = void 0, e2.onFirstVideoDecoded = void 0, e2.onFirstVideoReceived = void 0, e2.onSelectedLocalCandidateChanged = void 0, e2.onSelectedRemoteCandidateChanged = void 0, e2.onFirstVideoDecodedTimeout = void 0;
      }
      filterTobeMutedTracks(e2) {
        const t2 = [];
        if (-1 === this.getAllTracks().indexOf(e2))
          return t2;
        const i3 = this.localTrackMap.get(bS.LocalAudioTrack);
        if (e2 instanceof yI && (null == i3 ? void 0 : i3.track) instanceof NI)
          return i3.track.isActive || t2.push([bS.LocalAudioTrack, i3]), t2;
        const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
          let [, { track: i4 }] = t3;
          return e2 === i4;
        });
        if (n2 && (t2.push(n2), n2[0] === bS.LocalVideoTrack)) {
          const e3 = this.localTrackMap.get(bS.LocalVideoLowTrack);
          e3 && t2.push([bS.LocalVideoLowTrack, e3]);
        }
        return t2;
      }
      filterTobeUnmutedTracks(e2) {
        const t2 = [], i3 = this.localTrackMap.get(bS.LocalAudioTrack);
        if (e2 instanceof yI && (null == i3 ? void 0 : i3.track) instanceof NI)
          return i3.track.isActive && t2.push([bS.LocalAudioTrack, i3]), t2;
        const n2 = Array.from(this.localTrackMap.entries()).find((t3) => {
          let [, { track: i4 }] = t3;
          return e2 === i4;
        });
        if (n2)
          if (n2[0] === bS.LocalVideoTrack) {
            t2.push(n2);
            const e3 = this.localTrackMap.get(bS.LocalVideoLowTrack);
            e3 && t2.push([bS.LocalVideoLowTrack, e3]);
          } else
            t2.push(n2);
        return t2;
      }
      createMuteMessage(e2) {
        return e2.map((e3) => {
          let t2, [i3, { track: n2, ssrcs: r2, id: o2 }] = e3;
          switch (i3) {
            case bS.LocalAudioTrack:
              t2 = sS.Audio;
              break;
            case bS.LocalVideoTrack:
              t2 = n2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High;
              break;
            case bS.LocalVideoLowTrack:
              t2 = sS.Low;
          }
          return { stream_type: t2, ssrcs: r2, mid: o2 };
        });
      }
      createUnmuteMessage(e2) {
        return e2.map((e3) => {
          let t2, [i3, { track: n2, ssrcs: r2, id: o2 }] = e3;
          switch (i3) {
            case bS.LocalAudioTrack:
              t2 = sS.Audio;
              break;
            case bS.LocalVideoTrack:
              t2 = n2._hints.includes(lS.SCREEN_TRACK) ? sS.Screen : sS.High;
              break;
            case bS.LocalVideoLowTrack:
              t2 = sS.Low;
          }
          return { stream_type: t2, ssrcs: r2, mid: o2 };
        });
      }
      filterTobeUnSubscribedTracks(e2, t2) {
        const i3 = [], n2 = this.remoteUserMap.get(e2);
        if (!n2)
          return i3;
        if (t2) {
          const r2 = n2.get(t2);
          if (!r2)
            return i3;
          i3.push([e2, { kind: t2, id: r2 }]);
        } else
          Array.from(n2.entries()).forEach((t3) => {
            let [n3, r2] = t3;
            i3.push([e2, { kind: n3, id: r2 }]);
          });
        return i3;
      }
      createUnsubscribeMessage(e2) {
        const t2 = [];
        return e2.forEach((e3) => {
          let [i3, { kind: n2, id: r2 }] = e3;
          switch (n2) {
            case AS.VIDEO:
              return void (i3._videoSSRC && t2.push({ stream_type: AS.VIDEO, ssrcId: i3._videoSSRC }));
            case AS.AUDIO:
              return void (i3._audioSSRC && t2.push({ stream_type: AS.AUDIO, ssrcId: i3._audioSSRC }));
          }
        }), t2;
      }
      createUnsubscribeAllMessage(e2) {
        const t2 = /* @__PURE__ */ new Map();
        return e2.forEach((e3) => {
          let [i3, { kind: n2 }] = e3;
          if (t2.has(i3)) {
            let e4 = t2.get(i3);
            n2 === AS.VIDEO ? e4 |= cS.Video : e4 |= cS.Audio, t2.set(i3, e4);
          } else
            n2 === AS.VIDEO ? t2.set(i3, cS.Video) : t2.set(i3, cS.Audio);
        }), { users: Array.from(t2.entries()).map((e3) => {
          let [t3, i3] = e3;
          return { stream_id: t3.uid, stream_type: i3 };
        }) };
      }
      withdrawRemoteTracks(e2) {
        e2.forEach((e3) => {
          let [t2, { kind: i3 }] = e3;
          const n2 = this.remoteUserMap.get(t2);
          n2 && (n2.delete(i3), 0 === Array.from(n2.entries()).length && this.remoteUserMap.delete(t2));
        });
      }
      async updateBitrateLimit(e2) {
        const t2 = this.localTrackMap.get(bS.LocalVideoTrack), i3 = this.localTrackMap.get(bS.LocalVideoLowTrack);
        t2 && await t2.track.setBitrateLimit(e2.uplink), i3 && e2.low_stream_uplink && await i3.track.setBitrateLimit({ max_bitrate: e2.low_stream_uplink.bitrate, min_bitrate: e2.low_stream_uplink.bitrate || 0 });
      }
      isP2PDisconnected() {
        if (this.connection) {
          return "connected" !== this.connection.peerConnectionState;
        }
        return true;
      }
      mapPubResToRemoteConfig(e2, t2) {
        return e2.map((e3, i3) => {
          var n2;
          let { stream_type: r2 } = e3;
          return null === (n2 = t2.find((e4) => {
            let { stream_type: t3 } = e4;
            return r2 === t3;
          })) || void 0 === n2 ? void 0 : n2.attributes;
        });
      }
      async tryToUnmuteAudio(e2) {
        for (let i3 = 0; i3 < e2.length; i3++)
          if (e2[i3] instanceof yI) {
            var t2;
            const n2 = this.filterTobeUnmutedTracks(e2[i3]);
            if (0 === n2.length)
              continue;
            await (null === (t2 = this.connection) || void 0 === t2 ? void 0 : t2.unmuteLocal(n2.map((e3) => {
              let [, { id: t3 }] = e3;
              return t3;
            })));
            const r2 = this.createUnmuteMessage(n2);
            return void await rC(this, DS.RequestUnmuteLocal, r2);
          }
      }
      bindStatsUploaderEvents() {
        this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (e2) => {
          var t2;
          return !(null === (t2 = this.connection) || void 0 === t2 || !t2.getRemoteVideoIsReady(e2));
        }, this.statsUploader.requestUpload = (e2, t2) => this.emit(DS.RequestUploadStats, e2, t2), this.statsUploader.requestAllTracks = () => this.getAllTracks();
      }
      unbindStatsUploaderEvents() {
        this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
      }
      async requestReconnect() {
        this.dtlsFailedCount += 1, await zI(gE(this.dtlsFailedCount, TE)), this.emit(DS.RequestReconnect);
      }
      async reconnectP2P() {
        const e2 = Array.from(this.localTrackMap.entries()), t2 = this.createGatewayUnpublishMessage(e2);
        Array.from(this.remoteUserMap.entries()), t2.length > 0 && await nC(this, DS.RequestUnpublishForReconnectPC, t2), this.disconnectForReconnect(), this.emit(DS.RequestReconnectPC);
      }
      canPublishLowStream() {
        return this.localTrackMap.has(bS.LocalVideoTrack) || this.pendingLocalTracks.some((e2) => e2 instanceof Cy);
      }
      throwIfTrackTypeNotMatch(e2) {
        if (e2.filter((e3) => e3 instanceof Cy).length > 1)
          throw new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
        if (e2.filter((e3) => e3 instanceof yI).length > 1 && (e2.some((e3) => e3 instanceof yI && e3._bypassWebAudio) || !JS().webAudioMediaStreamDest))
          throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
        for (const t2 of e2) {
          if (t2 instanceof Cy && this.pendingLocalTracks.some((e3) => e3 instanceof Cy))
            throw new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
          if (t2 instanceof yI && this.pendingLocalTracks.some((e3) => e3 instanceof yI) && (!JS().webAudioMediaStreamDest || t2._bypassWebAudio || this.pendingLocalTracks.some((e3) => e3 instanceof yI && e3._bypassWebAudio)))
            throw new SE(fE.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
        }
      }
      getLowVideoTrack(e2, t2) {
        const i3 = JS().supportDualStreamEncoding, n2 = Ab(Ab({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), t2);
        let r2;
        r2 = i3 ? e2._mediaStreamTrack.clone() : FN(e2, n2);
        const o2 = ZI(8, "track-low-"), s2 = new Cy(r2, Ab(Ab({}, i3 && { scaleResolutionDownBy: KI(n2, e2) }), {}, { frameRate: n2.framerate, bitrateMax: n2.bitrate, bitrateMin: n2.bitrate }), void 0, void 0, o2);
        return s2.on(ES.TRANSCEIVER_UPDATED, (t3) => {
          e2._updateRtpTransceiver(t3, hS.LOW_STREAM);
        }), s2._hints.push(lS.LOW_STREAM), e2.addListener(uS.NEED_CLOSE, () => {
          s2.close();
        }), s2;
      }
      async globalLock() {
        return this.mutex.lock("From P2PChannel.globalLock");
      }
      async reportPCStats(e2, t2, i3) {
        let n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
        if (this.connection && this.connection instanceof VN) {
          var r2, o2, s2, a2;
          const c2 = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d2, dtlsTransportState: u2, peerConnectionState: l2 } = this.connection, { local: h3, remote: p3 } = await this.connection.getSelectedCandidatePair();
          Pg.pcStats(this.store.sessionId, { startTime: c2, eventElapse: e2 - c2 || 0, iceconnectionsate: d2, dtlsstate: u2, connectionstate: l2, intSucc: t2 ? 1 : 2, error: n2, selectedLocalCandidateProtocol: null !== (r2 = null == h3 ? void 0 : h3.protocol) && void 0 !== r2 ? r2 : "", selectedLocalCandidateType: null !== (o2 = h3.candidateType) && void 0 !== o2 ? o2 : "", selectedLocalCandidateAddress: "".concat(h3.address, ":").concat(h3.port), selectedRemoteCandidateProtocol: null !== (s2 = p3.protocol) && void 0 !== s2 ? s2 : "", selectedRemoteCandidateType: null !== (a2 = p3.candidateType) && void 0 !== a2 ? a2 : "", selectedRemoteCandidateAddress: "".concat(p3.address, ":").concat(p3.port), restartCnt: i3 });
        }
      }
      reportVideoFirstFrameDecoded(e2, t2, i3, n2) {
        var r2;
        const o2 = Array.from(Eg(r2 = this.remoteUserMap).call(r2)).find((t3) => t3._videoSSRC === e2);
        if (o2) {
          n2 || this.store.subscribe(o2.uid, "video", void 0, void 0, void 0, void 0, Date.now());
          const r3 = this.store.keyMetrics, s2 = r3.subscribe.find((e3) => e3.userId === o2.uid && "video" === e3.type);
          Pg.firstRemoteVideoDecode(this.store.sessionId, uf.FIRST_VIDEO_DECODE, lf.FIRST_VIDEO_DECODE, { peer: o2._uintid, videowidth: t2, videoheight: i3, subscribeElapse: DI.measureFromSubscribeStart(this.store.clientId, e2), subscribeRequestid: e2, p2pid: this.store.p2pId, apEnd: r3.requestAPEnd || 0, apStart: r3.requestAPStart || 0, joinGwEnd: r3.joinGatewayEnd || 0, joinGwStart: r3.joinGatewayStart || 0, pcEnd: r3.peerConnectionEnd || 0, pcStart: r3.peerConnectionStart || 0, subscriberEnd: (null == s2 ? void 0 : s2.subscribeEnd) || 0, subscriberStart: (null == s2 ? void 0 : s2.subscribeStart) || 0, videoAddNotify: (null == s2 ? void 0 : s2.streamAdded) || 0, state: n2 ? 1 : 0 });
        }
      }
      async remoteMediaSsrcChanged(e2, t2, i3) {
        if (!this.connection)
          return false;
        const n2 = this.remoteUserMap.get(e2);
        if (!n2)
          return false;
        const r2 = n2.get(t2);
        if (!r2)
          return false;
        const o2 = await this.connection.getRemoteSSRC(r2);
        return void 0 !== o2 && o2 !== i3;
      }
      resetConnection(e2) {
        OE.debug("[".concat(this.store.clientId, "] [P2PChannel] reset connection to ").concat(e2)), this.state === wS.Connected ? (OE.debug("[".concat(this.store.clientId, "] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")), this.disconnectForReconnect()) : (this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = e2 === dS.datachannel ? new Ib({}, this.store) : this.isPlanB ? new NN({}, this.store) : new VN({}, this.store), this.bindConnectionEvents(this.connection)));
      }
      unbindRtpTransceiver() {
        0 !== this.localTrackMap.size && Array.from(this.localTrackMap.entries()).forEach((e2) => {
          let [t2, { track: i3 }] = e2;
          t2 === bS.LocalVideoLowTrack ? i3._updateRtpTransceiver(void 0, hS.LOW_STREAM) : i3._updateRtpTransceiver(void 0);
        });
      }
      reportPCDisconnectedOrFailed(e2) {
        this.connection && this.connection instanceof VN && ("disconnected" !== this.connection.iceConnectionState && "checking" !== this.connection.iceConnectionState && "failed" !== this.connection.iceConnectionState || (this._isFirstConnected ? (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isFirstConnected = false) : this._pcStatsUploadType === NS.TCP_RESTART && e2 === OS.RELAY ? this.reportPCStats(Date.now(), false, this._pcStatsUploadType) : this.reportPCStats(Date.now(), false, NS.DISCONNECTED_OR_FAILED)));
      }
    }).prototype, "startP2PConnection", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "startP2PConnection"), vb.prototype), ag(vb.prototype, "connect", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "connect"), vb.prototype), ag(vb.prototype, "preConnect", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "preConnect"), vb.prototype), ag(vb.prototype, "unpublish", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unpublish"), vb.prototype), ag(vb.prototype, "unpublishLowStream", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unpublishLowStream"), vb.prototype), ag(vb.prototype, "subscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "subscribe"), vb.prototype), ag(vb.prototype, "massSubscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "massSubscribe"), vb.prototype), ag(vb.prototype, "unsubscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unsubscribe"), vb.prototype), ag(vb.prototype, "massUnsubscribe", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "massUnsubscribe"), vb.prototype), ag(vb.prototype, "muteRemote", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "muteRemote"), vb.prototype), ag(vb.prototype, "unmuteRemote", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "unmuteRemote"), vb.prototype), ag(vb.prototype, "hasRemoteMediaWithLock", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "hasRemoteMediaWithLock"), vb.prototype), ag(vb.prototype, "disconnectForReconnect", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "disconnectForReconnect"), vb.prototype), ag(vb.prototype, "updateBitrateLimit", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "updateBitrateLimit"), vb.prototype), ag(vb.prototype, "remoteMediaSsrcChanged", [wb], Object.getOwnPropertyDescriptor(vb.prototype, "remoteMediaSsrcChanged"), vb.prototype), vb);
    function wb(e2, t2, i3) {
      const n2 = e2[t2];
      if ("function" != typeof n2)
        throw new Error("Cannot use mutex on object property.");
      return i3.value = async function() {
        const e3 = this.mutex, i4 = await e3.lock("From P2PChannel.".concat(t2));
        try {
          for (var r2 = arguments.length, o2 = new Array(r2), s2 = 0; s2 < r2; s2++)
            o2[s2] = arguments[s2];
          return await n2.apply(this, o2);
        } finally {
          i4();
        }
      }, i3;
    }
    function Db(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function Pb(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? Db(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : Db(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    var Lb;
    !function(e2) {
      e2.SET_SESSION_ID = "SET_SESSION_ID", e2.SET_P2P_ID = "SET_P2P_id", e2.SET_DC_ID = "SET_DC_id", e2.SET_UID = "SET_UID", e2.SET_PUB_ID = "SET_PUB_ID", e2.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e2.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e2.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e2.AVOID_JOIN_START = "AVOID_JOIN_START", e2.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e2.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e2.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e2.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e2.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e2.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e2.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e2.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", e2.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e2.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e2.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e2.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e2.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e2.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e2.RESET_KEY_METRICS = "RESET_KEY_METRICS", e2.SET_USE_DATACHANNEL = "SET_USE_DATACHANNEL";
    }(Lb || (Lb = {}));
    class kb {
      constructor(e2, t2, i3, n2) {
        _p(this, "state", void 0), this.state = { codec: e2, audioCodec: t2, mode: i3, clientId: n2, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useDataChannel: false };
      }
      dispatch(e2) {
        this.state = function(e3, t2) {
          switch (t2.type) {
            case Lb.SET_SESSION_ID:
              return Pb(Pb({}, e3), {}, { sessionId: t2.sessionId });
            case Lb.SET_P2P_ID:
              return Pb(Pb({}, e3), {}, { p2pId: t2.p2pId });
            case Lb.SET_UID:
              return Pb(Pb({}, e3), {}, { uid: t2.uid });
            case Lb.SET_PUB_ID:
              return Pb(Pb({}, e3), {}, { pubId: t2.pubId });
            case Lb.KEY_METRIC_CLIENT_CREATED:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { clientCreated: t2.metric }) });
            case Lb.KEY_METRIC_JOIN_START:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinStart: t2.metric }) });
            case Lb.AVOID_JOIN_START:
              return Pb(Pb({}, e3), {}, { avoidJoinStart: t2.avoidJoinStart });
            case Lb.KEY_METRIC_JOIN_END:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinEnd: t2.metric }) });
            case Lb.KEY_METRIC_REQUEST_AP_START:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { requestAPStart: t2.metric }) });
            case Lb.KEY_METRIC_REQUEST_AP_END:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { requestAPEnd: t2.metric }) });
            case Lb.KEY_METRIC_JOIN_GATEWAY_START:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinGatewayStart: t2.metric }) });
            case Lb.KEY_METRIC_JOIN_GATEWAY_END:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { joinGatewayEnd: t2.metric }) });
            case Lb.KEY_METRIC_PEER_CONNECTION_START:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { peerConnectionStart: t2.metric }) });
            case Lb.KEY_METRIC_PEER_CONNECTION_END:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { peerConnectionEnd: t2.metric }) });
            case Lb.KEY_METRIC_DESCRIPTION_START:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { descriptionStart: t2.metric }) });
            case Lb.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { signalChannelOpen: t2.metric }) });
            case Lb.KEY_METRIC_ICE_CONNECTION_END:
              return Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { iceConnectionEnd: t2.metric }) });
            case Lb.KEY_METRIC_PUBLISH: {
              const i3 = e3.keyMetrics.publish, n2 = i3.findIndex((e4) => e4.trackId === t2.metric.trackId);
              return -1 !== n2 ? (i3[n2] = Pb(Pb({}, i3[n2]), t2.metric), Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { publish: [...i3] }) })) : Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { publish: [...e3.keyMetrics.publish, t2.metric] }) });
            }
            case Lb.KEY_METRIC_SUBSCRIBE: {
              const i3 = e3.keyMetrics.subscribe, n2 = i3.findIndex((e4) => e4.userId === t2.metric.userId && e4.type === t2.metric.type);
              return -1 !== n2 ? (i3[n2] = Pb(Pb({}, i3[n2]), t2.metric), Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { subscribe: [...i3] }) })) : Pb(Pb({}, e3), {}, { keyMetrics: Pb(Pb({}, e3.keyMetrics), {}, { subscribe: [...e3.keyMetrics.subscribe, t2.metric] }) });
            }
            case Lb.SET_CLOUD_PROXY_SERVER_MODE:
              return e3.cloudProxyServerMode = t2.mode, e3;
            case Lb.RECORD_JOIN_CHANNEL_SERVICE:
              return "number" != typeof t2.index ? e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords, t2.record] : (e3.joinChannelServiceRecords[t2.index] = Pb(Pb({}, e3.joinChannelServiceRecords[t2.index]), t2.record), e3.joinChannelServiceRecords = [...e3.joinChannelServiceRecords]), e3;
            case Lb.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
              return e3.joinChannelServiceRecords = [], e3;
            case Lb.RESET_KEY_METRICS:
              return e3.keyMetrics = { publish: [], subscribe: [] }, e3;
            case Lb.SET_USE_DATACHANNEL:
              return Pb(Pb({}, e3), {}, { useDataChannel: t2.val });
            default:
              return e3;
          }
        }(this.state, e2);
      }
      set sessionId(e2) {
        this.dispatch({ type: Lb.SET_SESSION_ID, sessionId: e2 });
      }
      get sessionId() {
        return this.state.sessionId;
      }
      get codec() {
        return this.state.codec;
      }
      get audioCodec() {
        return this.state.audioCodec;
      }
      get clientId() {
        return this.state.clientId;
      }
      set p2pId(e2) {
        this.dispatch({ type: Lb.SET_P2P_ID, p2pId: e2 });
      }
      get p2pId() {
        return this.state.p2pId;
      }
      set dcId(e2) {
        this.dispatch({ type: Lb.SET_DC_ID, dcId: e2 });
      }
      get dcId() {
        return this.state.dcId;
      }
      set uid(e2) {
        this.dispatch({ type: Lb.SET_UID, uid: e2 });
      }
      get uid() {
        return this.state.uid;
      }
      set pubId(e2) {
        this.dispatch({ type: Lb.SET_PUB_ID, pubId: e2 });
      }
      get pubId() {
        return this.state.pubId;
      }
      set cloudProxyServerMode(e2) {
        this.dispatch({ type: Lb.SET_CLOUD_PROXY_SERVER_MODE, mode: e2 });
      }
      get cloudProxyServerMode() {
        return this.state.cloudProxyServerMode;
      }
      set useDataChannel(e2) {
        this.dispatch({ type: Lb.SET_USE_DATACHANNEL, val: e2 });
      }
      get useDataChannel() {
        return this.state.useDataChannel;
      }
      clientCreated() {
        this.dispatch({ type: Lb.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
      }
      joinStart() {
        this.dispatch({ type: Lb.KEY_METRIC_JOIN_START, metric: Date.now() });
      }
      joinEnd() {
        this.dispatch({ type: Lb.KEY_METRIC_JOIN_END, metric: Date.now() });
      }
      requestAPStart() {
        this.dispatch({ type: Lb.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
      }
      requestAPEnd() {
        this.dispatch({ type: Lb.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
      }
      joinGatewayStart() {
        this.dispatch({ type: Lb.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
      }
      joinGatewayEnd() {
        this.dispatch({ type: Lb.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
      }
      peerConnectionStart() {
        this.dispatch({ type: Lb.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
      }
      peerConnectionEnd() {
        this.dispatch({ type: Lb.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
      }
      descriptionStart() {
        this.dispatch({ type: Lb.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
      }
      signalChannelOpen() {
        this.dispatch({ type: Lb.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
      }
      iceConnectionEnd() {
        this.dispatch({ type: Lb.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
      }
      publish(e2, t2, i3, n2) {
        this.dispatch({ type: Lb.KEY_METRIC_PUBLISH, metric: Pb(Pb({ trackId: e2, type: t2 }, i3 && { publishStart: i3 }), n2 && { publishEnd: n2 }) });
      }
      subscribe(e2, t2, i3, n2, r2, o2, s2) {
        this.dispatch({ type: Lb.KEY_METRIC_SUBSCRIBE, metric: Pb(Pb(Pb(Pb(Pb({ userId: e2, type: t2 }, i3 && { subscribeStart: i3 }), n2 && { subscribeEnd: n2 }), r2 && { firstFrame: r2 }), o2 && { streamAdded: o2 }), s2 && { firstDecoded: s2 }) });
      }
      massSubscribe(e2, t2, i3, n2) {
        e2.forEach((e3) => {
          this.dispatch({ type: Lb.KEY_METRIC_SUBSCRIBE, metric: Pb(Pb(Pb({ userId: e3.userId, type: e3.type }, t2 && { subscribeStart: t2 }), i3 && { subscribeEnd: i3 }), n2 && { firstFrame: n2 }) });
        });
      }
      get keyMetrics() {
        return this.state.keyMetrics;
      }
      recordJoinChannelService(e2, t2) {
        "gateway" === e2.service && Array.isArray(e2.urls) && (e2.urls = e2.urls.map((e3) => e3.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
        try {
          return "number" != typeof t2 ? (this.dispatch({ type: Lb.RECORD_JOIN_CHANNEL_SERVICE, record: Pb(Pb({}, e2), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (t2 < 0 || t2 >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: Lb.RECORD_JOIN_CHANNEL_SERVICE, record: e2, index: t2 }), t2);
        } catch (e3) {
          return 0;
        }
      }
      resetJoinChannelServiceRecords() {
        this.dispatch({ type: Lb.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
      }
      resetKeyMetrics() {
        this.dispatch({ type: Lb.RESET_KEY_METRICS });
      }
      get joinChannelServiceRecords() {
        try {
          return this.state.joinChannelServiceRecords;
        } catch (e2) {
          return [];
        }
      }
      get avoidJoinStart() {
        return this.state.avoidJoinStart;
      }
      set avoidJoinStart(e2) {
        this.dispatch({ type: Lb.AVOID_JOIN_START, avoidJoinStart: e2 });
      }
    }
    let Mb;
    const Ub = () => "HTTPS" === (Mb || Mb || (Mb = (window.location.protocol.split(":")[0] || "").toUpperCase(), Mb)), xb = () => void 0 !== window.isSecureContext;
    function Vb(e2) {
      let t2 = Xb();
      return function(e3, t3) {
        let i3 = e3.appId;
        void 0 !== i3 && (dw(t3, 10), iw(t3, i3));
        let n2 = e3.cid;
        void 0 !== n2 && (dw(t3, 16), dw(t3, n2));
        let r2 = e3.cname;
        void 0 !== r2 && (dw(t3, 26), iw(t3, r2));
        let o2 = e3.deviceId;
        void 0 !== o2 && (dw(t3, 34), iw(t3, o2));
        let s2 = e3.elapse;
        void 0 !== s2 && (dw(t3, 40), uw(t3, s2));
        let a2 = e3.fileSize;
        void 0 !== a2 && (dw(t3, 48), uw(t3, qb(a2)));
        let c2 = e3.height;
        void 0 !== c2 && (dw(t3, 56), uw(t3, qb(c2)));
        let d2 = e3.jpg;
        void 0 !== d2 && (dw(t3, 66), dw(t3, d2.length), function(e4, t4) {
          let i4 = $b(e4, t4.length);
          e4.bytes.set(t4, i4);
        }(t3, d2));
        let u2 = e3.networkType;
        void 0 !== u2 && (dw(t3, 72), uw(t3, qb(u2)));
        let l2 = e3.osType;
        void 0 !== l2 && (dw(t3, 80), uw(t3, qb(l2)));
        let h3 = e3.requestId;
        void 0 !== h3 && (dw(t3, 90), iw(t3, h3));
        let p3 = e3.sdkVersion;
        void 0 !== p3 && (dw(t3, 98), iw(t3, p3));
        let _2 = e3.sequence;
        void 0 !== _2 && (dw(t3, 104), uw(t3, qb(_2)));
        let E2 = e3.sid;
        void 0 !== E2 && (dw(t3, 114), iw(t3, E2));
        let m2 = e3.timestamp;
        void 0 !== m2 && (dw(t3, 120), uw(t3, m2));
        let f2 = e3.uid;
        void 0 !== f2 && (dw(t3, 128), dw(t3, f2));
        let S2 = e3.vid;
        void 0 !== S2 && (dw(t3, 136), dw(t3, S2));
        let T2 = e3.width;
        void 0 !== T2 && (dw(t3, 144), uw(t3, qb(T2)));
        let g2 = e3.service;
        void 0 !== g2 && (dw(t3, 152), dw(t3, g2));
        let R2 = e3.callbackData;
        void 0 !== R2 && (dw(t3, 162), iw(t3, R2));
        let I2 = e3.jpgEncryption;
        void 0 !== I2 && (dw(t3, 168), dw(t3, I2));
        let C2 = e3.requestType;
        void 0 !== C2 && (dw(t3, 176), dw(t3, C2));
        let v2 = e3.scorePorn;
        void 0 !== v2 && (dw(t3, 185), aw(t3, v2));
        let y2 = e3.scoreSexy;
        void 0 !== y2 && (dw(t3, 193), aw(t3, y2));
        let A2 = e3.scoreNeutral;
        void 0 !== A2 && (dw(t3, 201), aw(t3, A2));
        let O2 = e3.scene;
        void 0 !== O2 && (dw(t3, 208), dw(t3, O2));
        let N2 = e3.ossFilePrefix;
        void 0 !== N2 && (dw(t3, 218), iw(t3, N2));
        let b2 = e3.serviceVendor;
        if (void 0 !== b2)
          for (let e4 of b2) {
            dw(t3, 226);
            let i4 = Xb();
            Bb(e4, i4), dw(t3, i4.limit), nw(t3, i4), zb(i4);
          }
      }(e2, t2), function(e3) {
        let t3 = e3.bytes, i3 = e3.limit;
        return t3.length === i3 ? t3 : t3.subarray(0, i3);
      }(t2);
    }
    function jb(e2) {
      return function(e3) {
        let t3 = {};
        e:
          for (; !Zb(e3); ) {
            let i3 = cw(e3);
            switch (i3 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.code = cw(e3);
                break;
              case 2:
                t3.msg = tw(e3, cw(e3));
                break;
              case 3: {
                let i4 = Gb(e3);
                t3.data = Fb(e3), e3.limit = i4;
                break;
              }
              default:
                Wb(e3, 7 & i3);
            }
          }
        return t3;
      }({ bytes: t2 = e2, offset: 0, limit: t2.length });
      var t2;
    }
    function Fb(e2) {
      let t2 = {};
      e:
        for (; !Zb(e2); ) {
          let i3 = cw(e2);
          switch (i3 >>> 3) {
            case 0:
              break e;
            case 1:
              t2.requestId = tw(e2, cw(e2));
              break;
            case 2:
              t2.requestType = cw(e2) >>> 0;
              break;
            case 3:
              t2.scorePorn = sw(e2);
              break;
            case 4:
              t2.scoreSexy = sw(e2);
              break;
            case 5:
              t2.scoreNeutral = sw(e2);
              break;
            case 6:
              t2.requestScene = cw(e2) >>> 0;
              break;
            case 7:
              t2.scene = cw(e2) >>> 0;
              break;
            default:
              Wb(e2, 7 & i3);
          }
        }
      return t2;
    }
    function Bb(e2, t2) {
      let i3 = e2.service;
      void 0 !== i3 && (dw(t2, 8), dw(t2, i3));
      let n2 = e2.vendor;
      void 0 !== n2 && (dw(t2, 16), dw(t2, n2));
      let r2 = e2.token;
      void 0 !== r2 && (dw(t2, 26), iw(t2, r2));
      let o2 = e2.callbackUrl;
      void 0 !== o2 && (dw(t2, 34), iw(t2, o2));
    }
    function Gb(e2) {
      let t2 = cw(e2), i3 = e2.limit;
      return e2.limit = e2.offset + t2, i3;
    }
    function Wb(e2, t2) {
      switch (t2) {
        case 0:
          for (; 128 & rw(e2); )
            ;
          break;
        case 2:
          Qb(e2, cw(e2));
          break;
        case 5:
          Qb(e2, 4);
          break;
        case 1:
          Qb(e2, 8);
          break;
        default:
          throw new Error("Unimplemented type: " + t2);
      }
    }
    let Hb = new Float32Array(1);
    new Uint8Array(Hb.buffer);
    let Kb = new Float64Array(1), Yb = new Uint8Array(Kb.buffer);
    function qb(e2) {
      return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
    }
    let Jb = [];
    function Xb() {
      const e2 = Jb.pop();
      return e2 ? (e2.offset = e2.limit = 0, e2) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
    }
    function zb(e2) {
      Jb.push(e2);
    }
    function Qb(e2, t2) {
      if (e2.offset + t2 > e2.limit)
        throw new Error("Skip past limit");
      e2.offset += t2;
    }
    function Zb(e2) {
      return e2.offset >= e2.limit;
    }
    function $b(e2, t2) {
      let i3 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
      if (o2 > i3.length) {
        let t3 = new Uint8Array(2 * o2);
        t3.set(i3), e2.bytes = t3;
      }
      return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
    }
    function ew(e2, t2) {
      let i3 = e2.offset;
      if (i3 + t2 > e2.limit)
        throw new Error("Read past limit");
      return e2.offset += t2, i3;
    }
    function tw(e2, t2) {
      let i3 = ew(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "�", s2 = "";
      for (let e3 = 0; e3 < t2; e3++) {
        let a2, c2, d2, u2, l2 = r2[e3 + i3];
        0 == (128 & l2) ? s2 += n2(l2) : 192 == (224 & l2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], 128 != (192 & a2) ? s2 += o2 : (u2 = (31 & l2) << 6 | 63 & a2, u2 < 128 ? s2 += o2 : (s2 += n2(u2), e3++))) : 224 == (240 & l2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & c2, u2 < 2048 || u2 >= 55296 && u2 <= 57343 ? s2 += o2 : (s2 += n2(u2), e3 += 2))) : 240 == (248 & l2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], d2 = r2[e3 + i3 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (u2 = (7 & l2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, u2 < 65536 || u2 > 1114111 ? s2 += o2 : (u2 -= 65536, s2 += n2(55296 + (u2 >> 10), 56320 + (1023 & u2)), e3 += 3))) : s2 += o2;
      }
      return s2;
    }
    function iw(e2, t2) {
      let i3 = t2.length, n2 = 0;
      for (let e3 = 0; e3 < i3; e3++) {
        let r3 = t2.charCodeAt(e3);
        r3 >= 55296 && r3 <= 56319 && e3 + 1 < i3 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
      }
      dw(e2, n2);
      let r2 = $b(e2, n2), o2 = e2.bytes;
      for (let e3 = 0; e3 < i3; e3++) {
        let n3 = t2.charCodeAt(e3);
        n3 >= 55296 && n3 <= 56319 && e3 + 1 < i3 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
      }
    }
    function nw(e2, t2) {
      let i3 = $b(e2, t2.limit), n2 = e2.bytes, r2 = t2.bytes;
      for (let e3 = 0, o2 = t2.limit; e3 < o2; e3++)
        n2[e3 + i3] = r2[e3];
    }
    function rw(e2) {
      return e2.bytes[ew(e2, 1)];
    }
    function ow(e2, t2) {
      let i3 = $b(e2, 1);
      e2.bytes[i3] = t2;
    }
    function sw(e2) {
      let t2 = ew(e2, 8), i3 = e2.bytes;
      return Yb[0] = i3[t2++], Yb[1] = i3[t2++], Yb[2] = i3[t2++], Yb[3] = i3[t2++], Yb[4] = i3[t2++], Yb[5] = i3[t2++], Yb[6] = i3[t2++], Yb[7] = i3[t2++], Kb[0];
    }
    function aw(e2, t2) {
      let i3 = $b(e2, 8), n2 = e2.bytes;
      Kb[0] = t2, n2[i3++] = Yb[0], n2[i3++] = Yb[1], n2[i3++] = Yb[2], n2[i3++] = Yb[3], n2[i3++] = Yb[4], n2[i3++] = Yb[5], n2[i3++] = Yb[6], n2[i3++] = Yb[7];
    }
    function cw(e2) {
      let t2, i3 = 0, n2 = 0;
      do {
        t2 = rw(e2), i3 < 32 && (n2 |= (127 & t2) << i3), i3 += 7;
      } while (128 & t2);
      return n2;
    }
    function dw(e2, t2) {
      for (t2 >>>= 0; t2 >= 128; )
        ow(e2, 127 & t2 | 128), t2 >>>= 7;
      ow(e2, t2);
    }
    function uw(e2, t2) {
      let i3 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i3 < 16384 ? i3 < 128 ? 1 : 2 : i3 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = $b(e2, o2), a2 = e2.bytes;
      switch (o2) {
        case 10:
          a2[s2 + 9] = r2 >>> 7 & 1;
        case 9:
          a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
        case 8:
          a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
        case 7:
          a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
        case 6:
          a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
        case 5:
          a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
        case 4:
          a2[s2 + 3] = 4 !== o2 ? i3 >>> 21 | 128 : i3 >>> 21 & 127;
        case 3:
          a2[s2 + 2] = 3 !== o2 ? i3 >>> 14 | 128 : i3 >>> 14 & 127;
        case 2:
          a2[s2 + 1] = 2 !== o2 ? i3 >>> 7 | 128 : i3 >>> 7 & 127;
        case 1:
          a2[s2] = 1 !== o2 ? 128 | i3 : 127 & i3;
      }
    }
    const lw = async (e2, t2, i3) => {
      const n2 = function(e3) {
        const t3 = [];
        for (let i4 = 0; i4 < e3.length; i4 += 2)
          t3.push(parseInt(e3.slice(i4, i4 + 2), 16));
        return Uint8Array.from(t3);
      }(function(e3) {
        const t3 = "0123456789abcdef";
        function i4(e4) {
          let i5, n4 = "";
          for (i5 = 0; i5 <= 3; i5++)
            n4 += t3.charAt(e4 >> 8 * i5 + 4 & 15) + t3.charAt(e4 >> 8 * i5 & 15);
          return n4;
        }
        function n3(e4, t4) {
          const i5 = (65535 & e4) + (65535 & t4);
          return (e4 >> 16) + (t4 >> 16) + (i5 >> 16) << 16 | 65535 & i5;
        }
        function r3(e4, t4, i5, r4, o4, s3) {
          return n3(function(e5, t5) {
            return e5 << t5 | e5 >>> 32 - t5;
          }(n3(n3(t4, e4), n3(r4, s3)), o4), i5);
        }
        function o3(e4, t4, i5, n4, o4, s3, a3) {
          return r3(t4 & i5 | ~t4 & n4, e4, t4, o4, s3, a3);
        }
        function s2(e4, t4, i5, n4, o4, s3, a3) {
          return r3(t4 & n4 | i5 & ~n4, e4, t4, o4, s3, a3);
        }
        function a2(e4, t4, i5, n4, o4, s3, a3) {
          return r3(t4 ^ i5 ^ n4, e4, t4, o4, s3, a3);
        }
        function c2(e4, t4, i5, n4, o4, s3, a3) {
          return r3(i5 ^ (t4 | ~n4), e4, t4, o4, s3, a3);
        }
        const d2 = function(e4) {
          let t4;
          const i5 = 1 + (e4.length + 8 >> 6), n4 = new Array(16 * i5);
          for (t4 = 0; t4 < 16 * i5; t4++)
            n4[t4] = 0;
          for (t4 = 0; t4 < e4.length; t4++)
            n4[t4 >> 2] |= e4.charCodeAt(t4) << t4 % 4 * 8;
          return n4[t4 >> 2] |= 128 << t4 % 4 * 8, n4[16 * i5 - 2] = 8 * e4.length, n4;
        }(e3);
        let u2, l2, h3, p3, _2, E2 = 1732584193, m2 = -271733879, f2 = -1732584194, S2 = 271733878;
        for (u2 = 0; u2 < d2.length; u2 += 16)
          l2 = E2, h3 = m2, p3 = f2, _2 = S2, E2 = o3(E2, m2, f2, S2, d2[u2 + 0], 7, -680876936), S2 = o3(S2, E2, m2, f2, d2[u2 + 1], 12, -389564586), f2 = o3(f2, S2, E2, m2, d2[u2 + 2], 17, 606105819), m2 = o3(m2, f2, S2, E2, d2[u2 + 3], 22, -1044525330), E2 = o3(E2, m2, f2, S2, d2[u2 + 4], 7, -176418897), S2 = o3(S2, E2, m2, f2, d2[u2 + 5], 12, 1200080426), f2 = o3(f2, S2, E2, m2, d2[u2 + 6], 17, -1473231341), m2 = o3(m2, f2, S2, E2, d2[u2 + 7], 22, -45705983), E2 = o3(E2, m2, f2, S2, d2[u2 + 8], 7, 1770035416), S2 = o3(S2, E2, m2, f2, d2[u2 + 9], 12, -1958414417), f2 = o3(f2, S2, E2, m2, d2[u2 + 10], 17, -42063), m2 = o3(m2, f2, S2, E2, d2[u2 + 11], 22, -1990404162), E2 = o3(E2, m2, f2, S2, d2[u2 + 12], 7, 1804603682), S2 = o3(S2, E2, m2, f2, d2[u2 + 13], 12, -40341101), f2 = o3(f2, S2, E2, m2, d2[u2 + 14], 17, -1502002290), m2 = o3(m2, f2, S2, E2, d2[u2 + 15], 22, 1236535329), E2 = s2(E2, m2, f2, S2, d2[u2 + 1], 5, -165796510), S2 = s2(S2, E2, m2, f2, d2[u2 + 6], 9, -1069501632), f2 = s2(f2, S2, E2, m2, d2[u2 + 11], 14, 643717713), m2 = s2(m2, f2, S2, E2, d2[u2 + 0], 20, -373897302), E2 = s2(E2, m2, f2, S2, d2[u2 + 5], 5, -701558691), S2 = s2(S2, E2, m2, f2, d2[u2 + 10], 9, 38016083), f2 = s2(f2, S2, E2, m2, d2[u2 + 15], 14, -660478335), m2 = s2(m2, f2, S2, E2, d2[u2 + 4], 20, -405537848), E2 = s2(E2, m2, f2, S2, d2[u2 + 9], 5, 568446438), S2 = s2(S2, E2, m2, f2, d2[u2 + 14], 9, -1019803690), f2 = s2(f2, S2, E2, m2, d2[u2 + 3], 14, -187363961), m2 = s2(m2, f2, S2, E2, d2[u2 + 8], 20, 1163531501), E2 = s2(E2, m2, f2, S2, d2[u2 + 13], 5, -1444681467), S2 = s2(S2, E2, m2, f2, d2[u2 + 2], 9, -51403784), f2 = s2(f2, S2, E2, m2, d2[u2 + 7], 14, 1735328473), m2 = s2(m2, f2, S2, E2, d2[u2 + 12], 20, -1926607734), E2 = a2(E2, m2, f2, S2, d2[u2 + 5], 4, -378558), S2 = a2(S2, E2, m2, f2, d2[u2 + 8], 11, -2022574463), f2 = a2(f2, S2, E2, m2, d2[u2 + 11], 16, 1839030562), m2 = a2(m2, f2, S2, E2, d2[u2 + 14], 23, -35309556), E2 = a2(E2, m2, f2, S2, d2[u2 + 1], 4, -1530992060), S2 = a2(S2, E2, m2, f2, d2[u2 + 4], 11, 1272893353), f2 = a2(f2, S2, E2, m2, d2[u2 + 7], 16, -155497632), m2 = a2(m2, f2, S2, E2, d2[u2 + 10], 23, -1094730640), E2 = a2(E2, m2, f2, S2, d2[u2 + 13], 4, 681279174), S2 = a2(S2, E2, m2, f2, d2[u2 + 0], 11, -358537222), f2 = a2(f2, S2, E2, m2, d2[u2 + 3], 16, -722521979), m2 = a2(m2, f2, S2, E2, d2[u2 + 6], 23, 76029189), E2 = a2(E2, m2, f2, S2, d2[u2 + 9], 4, -640364487), S2 = a2(S2, E2, m2, f2, d2[u2 + 12], 11, -421815835), f2 = a2(f2, S2, E2, m2, d2[u2 + 15], 16, 530742520), m2 = a2(m2, f2, S2, E2, d2[u2 + 2], 23, -995338651), E2 = c2(E2, m2, f2, S2, d2[u2 + 0], 6, -198630844), S2 = c2(S2, E2, m2, f2, d2[u2 + 7], 10, 1126891415), f2 = c2(f2, S2, E2, m2, d2[u2 + 14], 15, -1416354905), m2 = c2(m2, f2, S2, E2, d2[u2 + 5], 21, -57434055), E2 = c2(E2, m2, f2, S2, d2[u2 + 12], 6, 1700485571), S2 = c2(S2, E2, m2, f2, d2[u2 + 3], 10, -1894986606), f2 = c2(f2, S2, E2, m2, d2[u2 + 10], 15, -1051523), m2 = c2(m2, f2, S2, E2, d2[u2 + 1], 21, -2054922799), E2 = c2(E2, m2, f2, S2, d2[u2 + 8], 6, 1873313359), S2 = c2(S2, E2, m2, f2, d2[u2 + 15], 10, -30611744), f2 = c2(f2, S2, E2, m2, d2[u2 + 6], 15, -1560198380), m2 = c2(m2, f2, S2, E2, d2[u2 + 13], 21, 1309151649), E2 = c2(E2, m2, f2, S2, d2[u2 + 4], 6, -145523070), S2 = c2(S2, E2, m2, f2, d2[u2 + 11], 10, -1120210379), f2 = c2(f2, S2, E2, m2, d2[u2 + 2], 15, 718787259), m2 = c2(m2, f2, S2, E2, d2[u2 + 9], 21, -343485551), E2 = n3(E2, l2), m2 = n3(m2, h3), f2 = n3(f2, p3), S2 = n3(S2, _2);
        return i4(E2) + i4(m2) + i4(f2) + i4(S2);
      }("" + t2 + i3)).slice(0, 16), r2 = n2.slice(0, 12), o2 = await window.crypto.subtle.importKey("raw", n2, "AES-GCM", true, ["encrypt"]);
      return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r2 }, o2, e2));
    }, hw = async (e2, t2, i3) => await lw(e2.buffer, t2, i3);
    function pw(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    const _w = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
    class Ew extends EE {
      get connectionState() {
        return this._connectionState;
      }
      set connectionState(e2) {
        if (this._connectionState === e2)
          return;
        const t2 = this._connectionState;
        this._connectionState = e2, this.emit(VS.CONNECTION_STATE_CHANGE, t2, e2);
      }
      get inspectType() {
        return this._inspectType;
      }
      set inspectType(e2) {
        var t2;
        this._inspectMode = zi(t2 = e2.map((e3) => _w.get(e3) || 0)).call(t2, (e3, t3) => e3 + t3), this._inspectType = e2;
      }
      get quality() {
        return this._quality;
      }
      set quality(e2) {
        this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
          this.quality = this._quality / this.qualityRatio;
        }, 6e4));
      }
      constructor(e2) {
        super(), _p(this, "name", "AgoraRTCVideoContentInspect"), _p(this, "_connectionState", US.CONNECTING), _p(this, "_innerConnectionState", void 0), _p(this, "sequence", 0), _p(this, "inspectStartTime", void 0), _p(this, "workerManagerConnection", void 0), _p(this, "workerConnection", void 0), _p(this, "workerMessageLengthLimit", void 0), _p(this, "inspectIntervalMinimum", void 0), _p(this, "qualityRatio", void 0), _p(this, "_connectInfo", void 0), _p(this, "_cancelTokenSource", pE.CancelToken.source()), _p(this, "_retryConfig", void 0), _p(this, "wmSequence", 0), _p(this, "inspectInterval", void 0), _p(this, "inspectTimer", null), _p(this, "ossFilePrefix", void 0), _p(this, "extraInfo", void 0), _p(this, "_inspectType", void 0), _p(this, "_inspectMode", void 0), _p(this, "_quality", 1), _p(this, "qualityTimer", null), _p(this, "_inspectId", void 0), _p(this, "_needWorkUrlOnly", false), _p(this, "inspectImage", () => {
          if (this.connectionState !== US.CONNECTED)
            throw new SE(fE.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
          this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
            this.connectionState === US.CONNECTED ? this.requestToInspectImage() : OE.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
          }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
        }), this._inspectId = ZI(5, "inspect-"), this.workerMessageLengthLimit = GE("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = GE("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = GE("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e2.interval, this.ossFilePrefix = e2.ossFilePrefix, this.extraInfo = e2.extraInfo, this.inspectType = e2.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new vC("worker-manager-" + this._inspectId, TE), this.on(VS.STATE_CHANGE, (e3, t2) => {
          this._innerConnectionState = e3, OE.debug("[".concat(this._inspectId, "] Inspect operation :").concat(xS[e3], " ").concat(t2 || ""));
        }), this.handleWorkerManagerEvents(), this.workerConnection = new vC("worker-" + this._inspectId, TE), this.handleWorkerEvents();
      }
      async init(e2, t2) {
        this.emit(VS.STATE_CHANGE, xS.CONNECT_AP), this._connectInfo = e2;
        const i3 = this._cancelTokenSource.token;
        return this._retryConfig = t2, new Sl((n2, r2) => {
          this.on(VS.CONNECTION_STATE_CHANGE, (e3, t3) => {
            t3 === US.CONNECTED && n2();
          }), this.requestAP(e2, i3, t2).then((e3) => {
            this.connectWorkerManager(e3);
          }).catch((e3) => {
            r2(e3);
          });
        });
      }
      async requestAP(e2, t2, i3) {
        const n2 = GE("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i4, n3) {
          let { appId: r3, areaCode: o3, cname: s2, sid: a2, token: c2, uid: d2 } = t3;
          sv++;
          const u2 = "image_moderation_api", l2 = { service_name: u2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s2, command: "allocateEdge", requestId: sv, seq: sv, sid: a2, token: c2, ts: Date.now(), uid: d2 + "" }) };
          let h3, p3, _2 = e3[0];
          return RE(async () => {
            h3 = Date.now();
            const e4 = await gg(_2, { data: l2, cancelToken: i4, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
            if (p3 = Date.now() - h3, 0 !== e4.code) {
              const t5 = new SE(fE.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e4.code, { retry: true, responseTime: p3 });
              throw OE.error(t5.toString()), t5;
            }
            const t4 = JSON.parse(e4.json_body);
            if (200 !== t4.code) {
              const e5 = new SE(fE.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p3 });
              throw OE.error(e5.toString()), e5;
            }
            if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
              const e5 = new SE(fE.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: t4.code, responseTime: p3 });
              throw OE.error(e5.toString()), e5;
            }
            const n4 = GE("VIDEO_INSPECT_WORKER_MANAGER_HOST"), r4 = GE("VIDEO_INSPECT_WORKER_MANAGER_PORT");
            return { addressList: t4.servers.map((e5) => {
              let { address: t5, wss: i5 } = e5;
              if (t5 && i5)
                return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(r4 || i5);
            }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, responseTime: p3 };
          }, (t4, i5) => (Pg.apworkerEvent(a2, { success: true, sc: 200, serviceName: u2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i5, responseTime: p3, serverIp: e3[i5 % e3.length] }), false), (t4, i5) => (Pg.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: u2, responseTime: p3, serverIp: e3[i5 % e3.length] }), !!(t4.code !== fE.OPERATION_ABORTED && t4.code !== fE.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i5 + 1) % e3.length], true)), n3);
        }(n2, e2, t2, i3);
        this.emit(VS.STATE_CHANGE, xS.AP_CONNECTED);
        const { addressList: o2 } = r2;
        return this.wmSequence++, o2;
      }
      async connectWorkerManager(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        this._needWorkUrlOnly = t2, this.emit(VS.STATE_CHANGE, xS.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e2, 1e4);
      }
      async connectWorker(e2) {
        await this.workerConnection.init([e2]);
      }
      handleWorkerManagerEvents() {
        this.workerManagerConnection.on(Hf.CONNECTED, async () => {
          this.emit(VS.STATE_CHANGE, xS.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.18.3", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
        }), this.workerManagerConnection.on(Hf.CLOSED, () => {
          this._innerConnectionState < xS.GET_WORKER_MANAGER_RESPONSE && OE.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
        }), this.workerManagerConnection.on(Hf.FAILED, () => {
          this._innerConnectionState < xS.GET_WORKER_MANAGER_RESPONSE && OE.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
        }), this.workerManagerConnection.on(Hf.RECONNECTING, () => {
          this._innerConnectionState < xS.GET_WORKER_MANAGER_RESPONSE && OE.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
        }), this.workerManagerConnection.on(Hf.ON_MESSAGE, async (e2) => {
          this.emit(VS.STATE_CHANGE, xS.GET_WORKER_MANAGER_RESPONSE);
          const t2 = this.workerManagerConnection.url;
          this.workerManagerConnection.close();
          const i3 = JSON.parse(e2.data);
          if (200 !== i3.code)
            throw OE.error("[".concat(this._inspectId, "] Unexpected code ").concat(i3.code, " from worker manager")), new SE(fE.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i3);
          if (!(i3.serverResponse && i3.serverResponse.portWss && t2))
            throw OE.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i3))), new SE(fE.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i3);
          {
            const e3 = GE("VIDEO_INSPECT_WORKER_PORT") || i3.serverResponse.portWss, n2 = t2.replace(/:\d+\/?$/, ":".concat(e3));
            this.emit(VS.STATE_CHANGE, xS.CONNECT_WORKER, n2), this._needWorkUrlOnly ? this.emit(VS.REQUEST_NEW_WORKER_URL, n2) : await this.connectWorker(n2);
          }
        }), this.workerManagerConnection.on(Hf.WILL_RECONNECT, (e2, t2) => {
          t2(e2);
        }), this.workerManagerConnection.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
          this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
        });
      }
      handleWorkerEvents() {
        this.workerConnection.on(Hf.CONNECTED, async () => {
          this.emit(VS.STATE_CHANGE, xS.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = US.CONNECTED;
        }), this.workerConnection.on(Hf.ON_MESSAGE, async (e2) => {
          if (e2.data instanceof ArrayBuffer) {
            const i3 = jb(new Uint8Array(e2.data));
            if (GE("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && OE.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i3)), 200 === i3.code) {
              if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0])
                return void this.emit(VS.INSPECT_RESULT, void 0, void 0);
              if (i3.data && i3.data.scorePorn && i3.data.scoreSexy && i3.data.scoreNeutral) {
                var t2;
                const e3 = { porn: i3.data.scorePorn, sexy: i3.data.scoreSexy, neutral: i3.data.scoreNeutral }, n2 = zi(t2 = Object.keys(e3)).call(t2, (t3, i4) => e3[t3] > e3[i4] ? t3 : i4, "porn"), r2 = Object.keys(e3).find((e4) => e4 === n2);
                this.emit(VS.INSPECT_RESULT, r2);
              } else
                this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.UNEXPECTED_RESPONSE, i3.code + "", "There is an unexpected data on message"));
            } else
              this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.UNEXPECTED_RESPONSE, i3.code + "", i3.msg));
          } else
            OE.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.UNEXPECTED_RESPONSE, "invalid worker message type"));
        }), this.workerConnection.on(Hf.CLOSED, () => {
          this.connectionState = US.CLOSED;
        }), this.workerConnection.on(Hf.FAILED, () => {
          this.connectionState = US.CLOSED;
        }), this.workerConnection.on(Hf.RECONNECTING, () => {
          this.connectionState = this.connectionState === US.CONNECTED ? US.RECONNECTING : US.CONNECTING;
        }), this.workerConnection.on(Hf.WILL_RECONNECT, (e2, t2) => {
          "recover" === e2 && t2(e2), t2("tryNext");
        }), this.workerConnection.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
          this.workerManagerConnection.close(), this.once(VS.REQUEST_NEW_WORKER_URL, (t3) => {
            e2([t3]);
          }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((e3) => {
            this.connectWorkerManager(e3, true);
          }).catch((e3) => {
            t2(e3);
          });
        });
      }
      static intToLong(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      async requestToInspectImage() {
        this.sequence++;
        const e2 = oC(this, VS.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
        if (e2) {
          if (!e2.isPlaying)
            return void this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.INVALID_OPERATION, "Only the track being played can be inspected"));
          const i3 = await this.generateRequestData(e2, t2);
          this.workerConnection.sendMessage(i3, true, true);
        } else
          this.emit(VS.INSPECT_RESULT, void 0, new SE(fE.INVALID_OPERATION, "Only the track being published can be inspected"));
      }
      async generateRequestData(e2, t2) {
        let { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
        const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), u2 = await hw(d2, i3, n2), l2 = this.sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + ZI(12, ""), h3 = { appId: i3, cid: r2, cname: n2, deviceId: "", elapse: Ew.intToLong(Number(c2 - this.inspectStartTime)), fileSize: u2.byteLength, jpgEncryption: 2, height: d2.height, width: d2.width, jpg: u2, networkType: 6, osType: 7, requestId: l2, sdkVersion: "4.18.3", sequence: this.sequence, sid: s2, timestamp: Ew.intToLong(c2), uid: a2, vid: o2, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
        void 0 === this.extraInfo && delete h3.callbackData, void 0 === this.ossFilePrefix && delete h3.ossFilePrefix;
        const p3 = Vb(h3);
        if (p3.byteLength < this.workerMessageLengthLimit) {
          if (GE("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
            const e3 = function(e4) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var i4 = null != arguments[t3] ? arguments[t3] : {};
                t3 % 2 ? pw(Object(i4), true).forEach(function(t4) {
                  _p(e4, t4, i4[t4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : pw(Object(i4)).forEach(function(t4) {
                  Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i4, t4));
                });
              }
              return e4;
            }({}, h3);
            delete e3.jpg, OE.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e3));
          }
          return p3;
        }
        {
          const t3 = this.quality * this.qualityRatio;
          return this.quality = t3, await this.generateRequestData(e2, { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
        }
      }
      close() {
        this._cancelTokenSource.cancel(), this._cancelTokenSource = pE.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = US.CLOSED, this.emit(VS.STATE_CHANGE, xS.CLOSED);
      }
    }
    function mw(e2) {
      let t2 = function() {
        const e3 = gw.pop();
        return e3 ? (e3.offset = e3.limit = 0, e3) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
      }();
      return function(e3, t3) {
        let i3 = e3.appId;
        void 0 !== i3 && (Dw(t3, 10), Ow(t3, i3));
        let n2 = e3.cid;
        void 0 !== n2 && (Dw(t3, 16), Dw(t3, n2));
        let r2 = e3.cname;
        void 0 !== r2 && (Dw(t3, 26), Ow(t3, r2));
        let o2 = e3.deviceId;
        void 0 !== o2 && (Dw(t3, 34), Ow(t3, o2));
        let s2 = e3.elapse;
        void 0 !== s2 && (Dw(t3, 40), Lw(t3, s2));
        let a2 = e3.fileSize;
        void 0 !== a2 && (Dw(t3, 48), Lw(t3, Tw(a2)));
        let c2 = e3.height;
        void 0 !== c2 && (Dw(t3, 56), Lw(t3, Tw(c2)));
        let d2 = e3.jpg;
        void 0 !== d2 && (Dw(t3, 66), Dw(t3, d2.length), yw(t3, d2));
        let u2 = e3.networkType;
        void 0 !== u2 && (Dw(t3, 72), Lw(t3, Tw(u2)));
        let l2 = e3.osType;
        void 0 !== l2 && (Dw(t3, 80), Lw(t3, Tw(l2)));
        let h3 = e3.requestId;
        void 0 !== h3 && (Dw(t3, 90), Ow(t3, h3));
        let p3 = e3.sdkVersion;
        void 0 !== p3 && (Dw(t3, 98), Ow(t3, p3));
        let _2 = e3.sequence;
        void 0 !== _2 && (Dw(t3, 104), Lw(t3, Tw(_2)));
        let E2 = e3.sid;
        void 0 !== E2 && (Dw(t3, 114), Ow(t3, E2));
        let m2 = e3.timestamp;
        void 0 !== m2 && (Dw(t3, 120), Lw(t3, m2));
        let f2 = e3.uid;
        void 0 !== f2 && (Dw(t3, 128), Dw(t3, f2));
        let S2 = e3.vid;
        void 0 !== S2 && (Dw(t3, 136), Dw(t3, S2));
        let T2 = e3.width;
        void 0 !== T2 && (Dw(t3, 144), Lw(t3, Tw(T2)));
        let g2 = e3.service;
        void 0 !== g2 && (Dw(t3, 152), Dw(t3, g2));
        let R2 = e3.callbackData;
        void 0 !== R2 && (Dw(t3, 162), Dw(t3, R2.length), yw(t3, R2));
        let I2 = e3.ticket;
        void 0 !== I2 && (Dw(t3, 170), Ow(t3, I2));
      }(e2, t2), function(e3) {
        let t3 = e3.bytes, i3 = e3.limit;
        return t3.length === i3 ? t3 : t3.subarray(0, i3);
      }(t2);
    }
    function fw(e2) {
      return function(e3) {
        let t3 = {};
        e:
          for (; !Iw(e3); ) {
            let i3 = ww(e3);
            switch (i3 >>> 3) {
              case 0:
                break e;
              case 1:
                t3.code = ww(e3);
                break;
              case 2:
                t3.msg = Aw(e3, ww(e3));
                break;
              case 3:
                t3.requestId = Aw(e3, ww(e3));
                break;
              case 4:
                t3.timestamp = Pw(e3, false);
                break;
              default:
                Sw(e3, 7 & i3);
            }
          }
        return t3;
      }({ bytes: t2 = e2, offset: 0, limit: t2.length });
      var t2;
    }
    function Sw(e2, t2) {
      switch (t2) {
        case 0:
          for (; 128 & Nw(e2); )
            ;
          break;
        case 2:
          Rw(e2, ww(e2));
          break;
        case 5:
          Rw(e2, 4);
          break;
        case 1:
          Rw(e2, 8);
          break;
        default:
          throw new Error("Unimplemented type: " + t2);
      }
    }
    function Tw(e2) {
      return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
    }
    let gw = [];
    function Rw(e2, t2) {
      if (e2.offset + t2 > e2.limit)
        throw new Error("Skip past limit");
      e2.offset += t2;
    }
    function Iw(e2) {
      return e2.offset >= e2.limit;
    }
    function Cw(e2, t2) {
      let i3 = e2.bytes, n2 = e2.offset, r2 = e2.limit, o2 = n2 + t2;
      if (o2 > i3.length) {
        let t3 = new Uint8Array(2 * o2);
        t3.set(i3), e2.bytes = t3;
      }
      return e2.offset = o2, o2 > r2 && (e2.limit = o2), n2;
    }
    function vw(e2, t2) {
      let i3 = e2.offset;
      if (i3 + t2 > e2.limit)
        throw new Error("Read past limit");
      return e2.offset += t2, i3;
    }
    function yw(e2, t2) {
      let i3 = Cw(e2, t2.length);
      e2.bytes.set(t2, i3);
    }
    function Aw(e2, t2) {
      let i3 = vw(e2, t2), n2 = String.fromCharCode, r2 = e2.bytes, o2 = "�", s2 = "";
      for (let e3 = 0; e3 < t2; e3++) {
        let a2, c2, d2, u2, l2 = r2[e3 + i3];
        0 == (128 & l2) ? s2 += n2(l2) : 192 == (224 & l2) ? e3 + 1 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], 128 != (192 & a2) ? s2 += o2 : (u2 = (31 & l2) << 6 | 63 & a2, u2 < 128 ? s2 += o2 : (s2 += n2(u2), e3++))) : 224 == (240 & l2) ? e3 + 2 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], 32896 != (49344 & (a2 | c2 << 8)) ? s2 += o2 : (u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & c2, u2 < 2048 || u2 >= 55296 && u2 <= 57343 ? s2 += o2 : (s2 += n2(u2), e3 += 2))) : 240 == (248 & l2) ? e3 + 3 >= t2 ? s2 += o2 : (a2 = r2[e3 + i3 + 1], c2 = r2[e3 + i3 + 2], d2 = r2[e3 + i3 + 3], 8421504 != (12632256 & (a2 | c2 << 8 | d2 << 16)) ? s2 += o2 : (u2 = (7 & l2) << 18 | (63 & a2) << 12 | (63 & c2) << 6 | 63 & d2, u2 < 65536 || u2 > 1114111 ? s2 += o2 : (u2 -= 65536, s2 += n2(55296 + (u2 >> 10), 56320 + (1023 & u2)), e3 += 3))) : s2 += o2;
      }
      return s2;
    }
    function Ow(e2, t2) {
      let i3 = t2.length, n2 = 0;
      for (let e3 = 0; e3 < i3; e3++) {
        let r3 = t2.charCodeAt(e3);
        r3 >= 55296 && r3 <= 56319 && e3 + 1 < i3 && (r3 = (r3 << 10) + t2.charCodeAt(++e3) - 56613888), n2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
      }
      Dw(e2, n2);
      let r2 = Cw(e2, n2), o2 = e2.bytes;
      for (let e3 = 0; e3 < i3; e3++) {
        let n3 = t2.charCodeAt(e3);
        n3 >= 55296 && n3 <= 56319 && e3 + 1 < i3 && (n3 = (n3 << 10) + t2.charCodeAt(++e3) - 56613888), n3 < 128 ? o2[r2++] = n3 : (n3 < 2048 ? o2[r2++] = n3 >> 6 & 31 | 192 : (n3 < 65536 ? o2[r2++] = n3 >> 12 & 15 | 224 : (o2[r2++] = n3 >> 18 & 7 | 240, o2[r2++] = n3 >> 12 & 63 | 128), o2[r2++] = n3 >> 6 & 63 | 128), o2[r2++] = 63 & n3 | 128);
      }
    }
    function Nw(e2) {
      return e2.bytes[vw(e2, 1)];
    }
    function bw(e2, t2) {
      let i3 = Cw(e2, 1);
      e2.bytes[i3] = t2;
    }
    function ww(e2) {
      let t2, i3 = 0, n2 = 0;
      do {
        t2 = Nw(e2), i3 < 32 && (n2 |= (127 & t2) << i3), i3 += 7;
      } while (128 & t2);
      return n2;
    }
    function Dw(e2, t2) {
      for (t2 >>>= 0; t2 >= 128; )
        bw(e2, 127 & t2 | 128), t2 >>>= 7;
      bw(e2, t2);
    }
    function Pw(e2, t2) {
      let i3, n2 = 0, r2 = 0, o2 = 0;
      return i3 = Nw(e2), n2 = 127 & i3, 128 & i3 && (i3 = Nw(e2), n2 |= (127 & i3) << 7, 128 & i3 && (i3 = Nw(e2), n2 |= (127 & i3) << 14, 128 & i3 && (i3 = Nw(e2), n2 |= (127 & i3) << 21, 128 & i3 && (i3 = Nw(e2), r2 = 127 & i3, 128 & i3 && (i3 = Nw(e2), r2 |= (127 & i3) << 7, 128 & i3 && (i3 = Nw(e2), r2 |= (127 & i3) << 14, 128 & i3 && (i3 = Nw(e2), r2 |= (127 & i3) << 21, 128 & i3 && (i3 = Nw(e2), o2 = 127 & i3, 128 & i3 && (i3 = Nw(e2), o2 |= (127 & i3) << 7))))))))), { low: n2 | r2 << 28, high: r2 >>> 4 | o2 << 24, unsigned: t2 };
    }
    function Lw(e2, t2) {
      let i3 = t2.low >>> 0, n2 = (t2.low >>> 28 | t2.high << 4) >>> 0, r2 = t2.high >>> 24, o2 = 0 === r2 ? 0 === n2 ? i3 < 16384 ? i3 < 128 ? 1 : 2 : i3 < 1 << 21 ? 3 : 4 : n2 < 16384 ? n2 < 128 ? 5 : 6 : n2 < 1 << 21 ? 7 : 8 : r2 < 128 ? 9 : 10, s2 = Cw(e2, o2), a2 = e2.bytes;
      switch (o2) {
        case 10:
          a2[s2 + 9] = r2 >>> 7 & 1;
        case 9:
          a2[s2 + 8] = 9 !== o2 ? 128 | r2 : 127 & r2;
        case 8:
          a2[s2 + 7] = 8 !== o2 ? n2 >>> 21 | 128 : n2 >>> 21 & 127;
        case 7:
          a2[s2 + 6] = 7 !== o2 ? n2 >>> 14 | 128 : n2 >>> 14 & 127;
        case 6:
          a2[s2 + 5] = 6 !== o2 ? n2 >>> 7 | 128 : n2 >>> 7 & 127;
        case 5:
          a2[s2 + 4] = 5 !== o2 ? 128 | n2 : 127 & n2;
        case 4:
          a2[s2 + 3] = 4 !== o2 ? i3 >>> 21 | 128 : i3 >>> 21 & 127;
        case 3:
          a2[s2 + 2] = 3 !== o2 ? i3 >>> 14 | 128 : i3 >>> 14 & 127;
        case 2:
          a2[s2 + 1] = 2 !== o2 ? i3 >>> 7 | 128 : i3 >>> 7 & 127;
        case 1:
          a2[s2] = 1 !== o2 ? 128 | i3 : 127 & i3;
      }
    }
    const kw = {}, Mw = {}, Uw = 4294967296, xw = 18446744073709552e3, Vw = xw / 2, jw = Hw(0, true), Fw = Hw(0), Bw = Kw(0, -2147483648, false), Gw = Kw(-1, 2147483647, false), Ww = Kw(-1, -1, true);
    function Hw(e2, t2) {
      let i3, n2, r2;
      return t2 ? (r2 = 0 <= (e2 >>>= 0) && e2 < 256) && (n2 = Mw[e2], n2) ? n2 : (i3 = Kw(e2, 0, true), r2 && (Mw[e2] = i3), i3) : (r2 = -128 <= (e2 |= 0) && e2 < 128) && (n2 = kw[e2], n2) ? n2 : (i3 = Kw(e2, e2 < 0 ? -1 : 0, false), r2 && (kw[e2] = i3), i3);
    }
    function Kw(e2, t2, i3) {
      return { low: 0 | e2, high: 0 | t2, unsigned: !!i3 };
    }
    function Yw(e2, t2) {
      if (isNaN(e2))
        return t2 ? jw : Fw;
      if (t2) {
        if (e2 < 0)
          return jw;
        if (e2 >= xw)
          return Ww;
      } else {
        if (e2 <= -Vw)
          return Bw;
        if (e2 + 1 >= Vw)
          return Gw;
      }
      return e2 < 0 ? t2 ? jw : Fw : Kw(e2 % Uw | 0, e2 / Uw | 0, t2);
    }
    function qw(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    class Jw extends EE {
      get connectionState() {
        return this._connectionState;
      }
      set connectionState(e2) {
        if (this._connectionState === e2)
          return;
        const t2 = this._connectionState;
        this._connectionState = e2, this.emit(HS.CONNECTION_STATE_CHANGE, e2, t2);
      }
      get quality() {
        return this._quality;
      }
      set quality(e2) {
        this._quality = e2 > 1 ? 1 : e2 < 0.1 ? 0.1 : e2, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
          this.quality = this._quality / this._qualityRatio;
        }, 6e4));
      }
      constructor(e2) {
        var t2;
        super(), _p(this, "name", "AgoraRTCImageModeration"), _p(this, "_connectionState", WS2.CONNECTING), _p(this, "_sequence", 0), _p(this, "_moderationStartTime", void 0), _p(this, "_workerConnection", void 0), _p(this, "_workerMessageLengthLimit", void 0), _p(this, "_qualityRatio", void 0), _p(this, "_connectInfo", void 0), _p(this, "_cancelTokenSource", pE.CancelToken.source()), _p(this, "_retryConfig", void 0), _p(this, "_moderationInterval", void 0), _p(this, "_moderationTimer", null), _p(this, "_moderationMode", 1), _p(this, "_quality", 1), _p(this, "_qualityTimer", null), _p(this, "_ticket", void 0), _p(this, "_moderationIntervalMinimum", void 0), _p(this, "_uploadFailedNum", 0), _p(this, "_uploadNum", 0), _p(this, "_uploadTimer", null), _p(this, "_moderationId", void 0), _p(this, "inspectImage", () => {
          if (this.connectionState !== WS2.CONNECTED)
            throw new SE(fE.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
          this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
            this.connectionState === WS2.CONNECTED ? this.requestToInspectImage() : OE.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
          }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
        }), this._moderationId = ZI(5, "image-moderation-"), this._workerMessageLengthLimit = GE("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = GE("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, this._qualityRatio = GE("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new vC("worker-" + this._moderationId, TE), this.on(HS.STATE_CHANGE, (e3, t3) => {
          OE.debug("[".concat(this._moderationId, "] Moderation operation :").concat(KS[e3], " ").concat(t3 || ""));
        }), this.handleWorkerEvents();
      }
      async init(e2, t2) {
        this.emit(HS.STATE_CHANGE, KS.CONNECT_AP), this._connectInfo = e2;
        const i3 = this._cancelTokenSource.token;
        return this._retryConfig = t2, new Sl((n2, r2) => {
          this.on(HS.CONNECTION_STATE_CHANGE, (e3, t3) => {
            e3 === WS2.CONNECTED && n2();
          }), this.requestAP(e2, i3, t2).then((e3) => {
            this.connectWorker(e3);
          }).catch((e3) => {
            r2(e3);
          });
        });
      }
      updateConfig(e2) {
        var t2;
        this._moderationInterval = null !== (t2 = e2.interval) && void 0 !== t2 ? t2 : 1e3, OE.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e2))), this.connectionState === WS2.CONNECTED && this.inspectImage();
      }
      async requestAP(e2, t2, i3) {
        const n2 = GE("WEBCS_DOMAIN").map((e3) => "https://".concat(e3, "/api/v1")), r2 = await function(e3, t3, i4, n3) {
          let { appId: r3, areaCode: o3, cname: s3, sid: a2, token: c2, uid: d2 } = t3;
          sv++;
          const u2 = "moderation_plugin", l2 = { service_name: u2, json_body: JSON.stringify({ appId: r3, areaCode: o3, cname: s3, command: "allocateEdge", requestId: sv, seq: sv, sid: a2, appToken: c2, ts: Date.now(), uid: d2 + "" }) };
          let h3, p3, _2 = e3[0];
          return RE(async () => {
            h3 = Date.now();
            const e4 = await gg(_2, { data: l2, cancelToken: i4, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
            if (p3 = Date.now() - h3, 0 !== e4.code) {
              const t5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + e4.code, { retry: true, responseTime: p3 });
              throw OE.error(t5.toString()), t5;
            }
            const t4 = JSON.parse(e4.json_body);
            if (200 !== t4.code) {
              const e5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(t4.code, ", reason: ").concat(t4.reason), { code: t4.code, responseTime: p3 });
              throw OE.error(e5.toString()), e5;
            }
            if (!t4.servers || !Array.isArray(t4.servers) || 0 === t4.servers.length) {
              const e5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: t4.code, responseTime: p3 });
              throw OE.error(e5.toString()), e5;
            }
            if (!t4.servers.some((e5) => !!e5.wss)) {
              const e5 = new SE(fE.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: t4.code, responseTime: p3 });
              throw OE.error(e5.toString()), e5;
            }
            const n4 = GE("IMAGE_MODERATION_WORKER_HOST");
            return { addressList: t4.servers.map((e5) => {
              let { address: t5, wss: i5 } = e5;
              if (t5 && i5)
                return "wss://".concat(t5.replace(/\./g, "-"), ".").concat(n4, ":").concat(i5, "/moderation");
            }).filter((e5) => !!e5), workerToken: t4.workerToken, vid: t4.vid, ticket: t4.appTicket, responseTime: p3 };
          }, (t4, i5) => (Pg.apworkerEvent(a2, { success: true, sc: 200, serviceName: u2, responseDetail: JSON.stringify(t4.addressList), firstSuccess: 0 === i5, responseTime: p3, serverIp: e3[i5 % e3.length] }), false), (t4, i5) => (Pg.apworkerEvent(a2, { success: false, sc: t4.data && t4.data.code || 200, serviceName: u2, responseTime: p3, serverIp: e3[i5 % e3.length] }), !!(t4.code !== fE.OPERATION_ABORTED && t4.code !== fE.UNEXPECTED_RESPONSE || t4.data && t4.data.retry) && (_2 = e3[(i5 + 1) % e3.length], true)), n3);
        }(n2, e2, t2, i3);
        this.emit(HS.STATE_CHANGE, KS.AP_CONNECTED);
        const { addressList: o2, ticket: s2 } = r2;
        return this._ticket = s2, o2;
      }
      async connectWorker(e2) {
        this.emit(HS.STATE_CHANGE, KS.CONNECT_WORKER), await this._workerConnection.init(e2, 1e4);
      }
      handleWorkerEvents() {
        this._workerConnection.on(Hf.CONNECTED, async () => {
          this.emit(HS.STATE_CHANGE, KS.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = WS2.CONNECTED;
        }), this._workerConnection.on(Hf.CLOSED, () => {
          this.connectionState = WS2.CLOSED;
        }), this._workerConnection.on(Hf.FAILED, () => {
          this.connectionState = WS2.CLOSED;
        }), this._workerConnection.on(Hf.RECONNECTING, () => {
          this.connectionState = this.connectionState === WS2.CONNECTED ? WS2.RECONNECTING : WS2.CONNECTING;
        }), this._workerConnection.on(Hf.ON_MESSAGE, async (e2) => {
          if (e2.data instanceof ArrayBuffer) {
            const t2 = fw(new Uint8Array(e2.data));
            GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && OE.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(t2)), this._uploadNum++, void 0 === t2.code || 0 === t2.code || (this._uploadFailedNum++, OE.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(t2.code, ", msg is ").concat(t2.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
              Pg.reportApiInvoke(this._connectInfo.sid || null, { name: _f.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, t2.code], tag: Ef.TRACER }).onError(new SE(fE.IMAGE_MODERATION_UPLOAD_FAILED, t2.msg)), this._uploadTimer = null;
            }, GE("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
          } else
            OE.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
        }), this._workerConnection.on(Hf.WILL_RECONNECT, (e2, t2) => {
          "recover" === e2 && t2(e2), t2("tryNext");
        }), this._workerConnection.on(Hf.REQUEST_NEW_URLS, (e2, t2) => {
          this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e2).catch(t2);
        });
      }
      static intToLong(e2) {
        return { low: e2 |= 0, high: e2 >> 31, unsigned: e2 >= 0 };
      }
      async requestToInspectImage() {
        const e2 = oC(this, HS.CLIENT_LOCAL_VIDEO_TRACK), t2 = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
        if (e2) {
          if (!e2.isPlaying)
            return void (GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && OE.debug("Only the track being played can be inspected"));
          this._sequence++;
          const i3 = await this.generateRequestData(e2, t2);
          this._workerConnection.sendMessage(i3, true, true);
        } else
          GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && OE.debug("Only the track being published can be inspected");
      }
      async generateRequestData(e2, t2) {
        let { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 } = t2;
        const c2 = Date.now(), d2 = await e2.getCurrentFrameImage("image/jpeg", this.quality), u2 = await hw(d2, i3, n2), l2 = this._sequence + "-" + r2 + "-" + a2 + "-" + c2 + "-" + ZI(12, ""), h3 = { appId: i3, cid: r2, cname: n2, deviceId: "", elapse: Jw.intToLong(Number(c2 - this._moderationStartTime)), fileSize: d2.buffer.byteLength, height: d2.height, width: d2.width, jpg: u2, networkType: 6, osType: 7, requestId: l2, sdkVersion: "4.18.3", sequence: this._sequence, sid: s2, timestamp: Yw(c2), uid: a2, vid: o2, service: this._moderationMode, ticket: this._ticket }, p3 = mw(h3);
        if (p3.byteLength < this._workerMessageLengthLimit) {
          if (GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
            const e3 = function(e4) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var i4 = null != arguments[t3] ? arguments[t3] : {};
                t3 % 2 ? qw(Object(i4), true).forEach(function(t4) {
                  _p(e4, t4, i4[t4]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i4)) : qw(Object(i4)).forEach(function(t4) {
                  Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(i4, t4));
                });
              }
              return e4;
            }({}, h3);
            delete e3.jpg, OE.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(e3));
          }
          return p3;
        }
        {
          const t3 = this.quality * this._qualityRatio;
          return this.quality = t3, await this.generateRequestData(e2, { appId: i3, cname: n2, cid: r2, vid: o2, sid: s2, uid: a2 });
        }
      }
      close() {
        this._cancelTokenSource.cancel(), this._cancelTokenSource = pE.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = WS2.CLOSED, this.emit(HS.STATE_CHANGE, KS.CLOSED);
      }
    }
    var Xw, zw, Qw, Zw, $w, eD, tD, iD, nD, rD, oD, sD, aD, cD, dD, uD, lD, hD, pD, _D, ED, mD, fD, SD, TD, gD, RD, ID, CD, vD, yD, AD, OD, ND, bD, wD, DD, PD, LD, kD;
    function MD(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function UD(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? MD(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : MD(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    let xD = (Xw = Dg(), zw = Dg({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3 ? Object(e3).toString() : "null")) }), Qw = Dg({ argsMap: (e2, t2) => (t2 || (t2 = []), Array.isArray(t2) || (t2 = [t2]), t2.map((e3) => e3.getTrackId())) }), Zw = Dg({ argsMap: (e2, t2, i3) => [t2.uid, i3] }), $w = Dg({ argsMap: (e2, t2) => t2.map((e3) => {
      let { user: t3, mediaType: i3 } = e3;
      return [null == t3 ? void 0 : t3.uid, i3];
    }) }), eD = Dg({ argsMap: (e2, t2, i3) => [t2.uid, i3] }), tD = Dg({ argsMap: (e2, t2) => t2.map((e3) => {
      let { user: t3, mediaType: i3 } = e3;
      return { uid: null == t3 ? void 0 : t3.uid, mediaType: i3 };
    }) }), iD = Dg(), nD = Dg(), rD = Dg(), oD = Dg(), sD = Dg(), aD = Dg(), cD = Dg(), dD = Dg(), uD = Dg(), lD = Dg(), hD = Dg(), pD = Dg(), _D = Dg(), ED = Dg(), mD = Dg({ argsMap: (e2, t2) => [t2] }), fD = Dg(), SD = Dg(), TD = Dg(), gD = Dg(), RD = Dg(), ID = Dg(), CD = Dg(), vD = Dg(), yD = Dg(), AD = Dg(), OD = Dg({ argsMap: (e2, t2) => (Array.isArray(t2) || (t2 = [t2]), [JSON.stringify(t2)]) }), ND = Dg(), bD = Dg(), wD = Dg(), DD = Dg(), PD = Dg({ reportResult: true }), LD = Dg(), ag((kD = class extends EE {
      get connectionState() {
        return this._gateway.state;
      }
      get remoteUsers() {
        return this._users;
      }
      get localTracks() {
        return this._p2pChannel.getAllTracks(true);
      }
      get uid() {
        return this._uid;
      }
      get channelName() {
        return this._channelName;
      }
      get mode() {
        return this._config.mode;
      }
      get role() {
        var e2;
        return (null === (e2 = this._config) || void 0 === e2 ? void 0 : e2.role) || "audience";
      }
      get codec() {
        return this._config.codec;
      }
      get audioCodec() {
        return this._config.audioCodec || "opus";
      }
      get isStringUID() {
        return !!this._joinInfo && !!this._joinInfo.stringUid;
      }
      get __className__() {
        return "Client";
      }
      constructor(e2) {
        let t2;
        if (super(), _p(this, "store", void 0), _p(this, "_uid", void 0), _p(this, "_channelName", void 0), _p(this, "_uintUid", void 0), _p(this, "_users", []), _p(this, "_config", void 0), _p(this, "_clientId", void 0), _p(this, "_appId", void 0), _p(this, "_sessionId", null), _p(this, "_key", void 0), _p(this, "_joinInfo", void 0), _p(this, "_gateway", void 0), _p(this, "_statsCollector", void 0), _p(this, "_configDistribute", void 0), _p(this, "_leaveMutex", new Ug("client-leave")), _p(this, "_publishMutex", new Ug("client-publish")), _p(this, "_renewTokenMutex", new Ug("client-renewtoken")), _p(this, "_subscribeMutex", new Ug("client-subscribe")), _p(this, "_encryptionMode", "none"), _p(this, "_encryptionSecret", null), _p(this, "_encryptionSalt", null), _p(this, "_proxyServer", void 0), _p(this, "_turnServer", { servers: [], mode: "auto" }), _p(this, "_cloudProxyServerMode", "disabled"), _p(this, "_isDualStreamEnabled", false), _p(this, "_defaultStreamFallbackType", void 0), _p(this, "_lowStreamParameter", void 0), _p(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), _p(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), _p(this, "_axiosCancelSource", pE.CancelToken.source()), _p(this, "_audioVolumeIndicationInterval", void 0), _p(this, "_networkQualityInterval", void 0), _p(this, "_userOfflineTimeout", void 0), _p(this, "_streamRemovedTimeout", void 0), _p(this, "_injectStreamingClient", void 0), _p(this, "_liveTranscodeStreamingClient", void 0), _p(this, "_liveRawStreamingClient", void 0), _p(this, "_channelMediaRelayClient", void 0), _p(this, "_networkQualitySensitivity", "normal"), _p(this, "_p2pChannel", void 0), _p(this, "_useLocalAccessPoint", false), _p(this, "_setLocalAPVersion", void 0), _p(this, "_joinAndNotLeaveYet", false), _p(this, "_numberOfJoinCount", 0), _p(this, "_remoteDefaultVideoStreamType", void 0), _p(this, "_inspect", void 0), _p(this, "_moderation", void 0), _p(this, "_license", void 0), _p(this, "_handleLocalTrackEnable", (e3, t3, i3) => {
          this.publish(e3, false).then(t3).catch(i3);
        }), _p(this, "_handleLocalTrackDisable", (e3, t3, i3) => {
          this.unpublish(e3).then(t3).catch(i3);
        }), _p(this, "_handleUserOnline", (e3) => {
          if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3.uid, this.channelName))
            return void OE.debug("[".concat(e3.uid, "] will be ignored in local"));
          this.isStringUID && "string" != typeof e3.uid && OE.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
          const t3 = this._users.find((t4) => t4.uid === e3.uid);
          if (t3)
            t3._trust_in_room_ = true;
          else {
            const t4 = new yy(e3.uid, e3.uint_id || e3.uid);
            this._users.push(t4), OE.debug("[".concat(this._clientId, "] user online"), e3.uid), this.safeEmit(yf.USER_JOINED, t4);
          }
        }), _p(this, "_handleUserOffline", (e3) => {
          if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3.uid, this.channelName))
            return;
          const t3 = this._users.find((t4) => t4.uid === e3.uid);
          t3 && (this._handleRemoveStream(e3), aC(this._users, t3), this._remoteStreamTypeCacheMap.delete(t3.uid), this._streamFallbackTypeCacheMap.delete(t3.uid), OE.debug("[".concat(this._clientId, "] user offline"), e3.uid, "reason:", e3.reason), this.safeEmit(yf.USER_LEAVED, t3, e3.reason));
        }), _p(this, "_handleAddAudioOrVideoStream", (e3, t3, i3, n2, r2, o2, s2) => {
          if (GE("BLOCK_LOCAL_CLIENT") && ZE(t3, this.channelName))
            return;
          const a2 = this._users.find((e4) => e4.uid === t3);
          if (!a2)
            return void OE.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
          OE.debug("[".concat(this._clientId, "] stream added with uid ").concat(t3, ", type ").concat(e3)), this.store.subscribe(a2.uid, e3, void 0, void 0, void 0, Date.now());
          const c2 = "audio" === e3 ? a2.hasAudio : a2.hasVideo;
          a2._uintid || (a2._uintid = r2 || t3), "audio" === e3 ? a2._trust_audio_stream_added_state_ = true : a2._trust_video_stream_added_state_ = true, "audio" === e3 ? (a2._audio_added_ = true, void 0 !== i3 && (a2._audioSSRC = i3), void 0 !== n2 && (a2._cname = n2), o2 && (a2._audioOrtc = o2)) : (a2._video_added_ = true, void 0 !== i3 && (a2._videoSSRC = i3), void 0 !== n2 && (a2._cname = n2), void 0 !== s2 && (a2._rtxSsrcId = s2), o2 && (a2._videoOrtc = o2)), ("audio" === e3 ? a2.hasAudio : a2.hasVideo) && !c2 && (OE.info("[".concat(this._clientId, "] remote user ").concat(a2.uid, " published ").concat(e3)), this.safeEmit(yf.USER_PUBLISHED, a2, e3)), "video" === e3 ? Pg.onGatewayStream(this._sessionId, uf.ON_ADD_VIDEO_STREAM, lf.ON_ADD_VIDEO_STREAM, { peer: r2 || t3 }) : Pg.onGatewayStream(this._sessionId, uf.ON_ADD_AUDIO_STREAM, lf.ON_ADD_AUDIO_STREAM, { peer: r2 || t3 }), this._p2pChannel.remoteMediaSsrcChanged(a2, e3, i3).then((t4) => {
            if (t4)
              return OE.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after rejoin because SSRC id changed.")), this._p2pChannel.unsubscribe(a2, e3, true).then(() => this._subscribe(a2, e3, true).catch((e4) => {
                OE.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
              }));
          }), this._p2pChannel.hasPendingRemoteMedia(a2, e3) && (OE.debug("[".concat(this._clientId, "] resubscribe ").concat(e3, " for user ").concat(a2.uid, " after reconnect.")), this._subscribe(a2, e3, true).catch((e4) => {
            OE.error("[".concat(this._clientId, "] resubscribe error"), e4.toString());
          }));
        }), _p(this, "_handleRemoveStream", (e3) => {
          if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3.uid, this.channelName))
            return;
          const t3 = this._users.find((t4) => t4.uid === e3.uid);
          if (!t3)
            return void OE.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
          OE.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e3.uid));
          let i3 = () => {
          };
          t3.hasAudio && t3.hasVideo ? i3 = () => {
            OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "audio"), OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "video");
          } : t3.hasVideo ? i3 = () => {
            OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished video track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "video");
          } : t3.hasAudio && (i3 = () => {
            OE.info("[".concat(this._clientId, "] remote user ").concat(t3.uid, " unpublished audio track")), this.safeEmit(yf.USER_UNPUBLISHED, t3, "audio");
          }), t3._trust_audio_stream_added_state_ = true, t3._trust_video_stream_added_state_ = true, t3._audio_added_ = false, t3._video_added_ = false, this._p2pChannel.unsubscribe(t3).then((e4) => {
            if (e4)
              return this._gateway.unsubscribe(e4, t3.uid);
          }), t3._audioSSRC = void 0, t3._videoSSRC = void 0, t3._audioOrtc = void 0, t3._videoOrtc = void 0, t3._rtxSsrcId = void 0, Pg.onGatewayStream(this._sessionId, uf.ON_REMOVE_STREAM, lf.ON_REMOVE_STREAM, { peer: e3.uint_id || e3.uid }), i3();
        }), _p(this, "_handleSetStreamLocalEnable", (e3, t3, i3) => {
          if (GE("BLOCK_LOCAL_CLIENT") && ZE(t3, this.channelName))
            return;
          const n2 = this._users.find((e4) => e4.uid === t3);
          if (!n2)
            return void OE.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
          OE.debug("[".concat(this._clientId, "] local ").concat(e3, " ").concat(i3 ? "enabled" : "disabled", " with uid ").concat(t3));
          const r2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
          if ("audio" === e3) {
            n2._trust_audio_enabled_state_ = true;
            const e4 = n2._audio_enabled_;
            if (n2._audio_enabled_ = i3, n2._audio_enabled_ === e4)
              return;
            {
              const e5 = n2._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
              OE.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(yf.USER_INFO_UPDATED, t3, e5);
            }
          } else {
            n2._trust_video_enabled_state_ = true;
            const e4 = n2._video_enabled_;
            if (n2._video_enabled_ = i3, n2._video_enabled_ === e4)
              return;
            {
              const e5 = n2._video_enabled_ ? "enable-local-video" : "disable-local-video";
              OE.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t3, ", msg: ").concat(e5)), this.safeEmit(yf.USER_INFO_UPDATED, t3, e5);
            }
          }
          const o2 = "audio" === e3 ? n2.hasAudio : n2.hasVideo;
          return r2 !== o2 ? !r2 && o2 ? (OE.info("[".concat(this._clientId, "] remote user ").concat(t3, " published ").concat(e3)), void this.safeEmit(yf.USER_PUBLISHED, n2, e3)) : ("video" === e3 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === e3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, e3), OE.info("[".concat(this._clientId, "] remote user ").concat(t3, " unpublished ").concat(e3)), void this.safeEmit(yf.USER_UNPUBLISHED, n2, e3)) : void 0;
        }), _p(this, "_handleMuteStream", (e3, t3, i3) => {
          if (GE("BLOCK_LOCAL_CLIENT") && ZE(e3, this.channelName))
            return;
          OE.debug("[".concat(this._clientId, "] receive mute message"), e3, t3, i3);
          const n2 = this._users.find((t4) => t4.uid === e3);
          if (!n2)
            return void OE.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e3));
          const r2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
          if ("audio" === t3) {
            n2._trust_audio_mute_state_ = true;
            const t4 = n2._audio_muted_;
            if (n2._audio_muted_ = i3, n2._audio_muted_ === t4)
              return;
            {
              const t5 = n2._audio_muted_ ? "mute-audio" : "unmute-audio";
              OE.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(yf.USER_INFO_UPDATED, e3, t5);
            }
          } else {
            n2._trust_video_mute_state_ = true;
            const t4 = n2._video_muted_;
            if (n2._video_muted_ = i3, n2._video_muted_ === t4)
              return;
            {
              const t5 = n2._video_muted_ ? "mute-video" : "unmute-video";
              OE.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e3, ", msg: ").concat(t5)), this.safeEmit(yf.USER_INFO_UPDATED, e3, t5);
            }
          }
          const o2 = "audio" === t3 ? n2.hasAudio : n2.hasVideo;
          if (r2 !== o2) {
            if (!r2 && o2) {
              return ("audio" === t3 ? n2._audioSSRC : n2._videoSSRC) ? (OE.info("[".concat(this._clientId, "] remote user ").concat(e3, " published ").concat(t3)), void this.safeEmit(yf.USER_PUBLISHED, n2, t3)) : void OE.warning("[".concat(this._clientId, "] remote user ").concat(e3, " receive ").concat(t3, " unmute message  before add stream message, ").concat(t3, " SSRC doesn't exist yet."));
            }
            "video" === t3 && n2._videoTrack && n2._videoTrack._destroy(), "audio" === t3 && n2._audioTrack, this._p2pChannel.muteRemote(n2, t3), OE.info("[".concat(this._clientId, "] remote user ").concat(e3, " unpublished ").concat(t3)), this.safeEmit(yf.USER_UNPUBLISHED, n2, t3);
          }
        }), _p(this, "_handleP2PLost", async (e3) => {
          OE.debug("[".concat(this._clientId, "] receive p2p lost"), e3), parseInt(e3.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : OE.warning("[".concat(this._clientId, "] P2PLost stream not found"), e3);
        }), _p(this, "_handleTokenWillExpire", () => {
          OE.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(yf.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
        }), _p(this, "_handleBeforeUnload", (e3) => {
          "beforeunload" === e3.type && void 0 !== e3.returnValue && "" !== e3.returnValue || (this.leave(), OE.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
        }), _p(this, "_handleUpdateNetworkQuality", () => {
          if ("normal" === this._networkQualitySensitivity)
            return;
          if (navigator && void 0 !== navigator.onLine && !navigator.onLine)
            return void this.safeEmit(yf.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
          const e3 = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
          e3.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e3.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(yf.NETWORK_QUALITY, e3);
        }), this._config = e2, this._clientId = ZI(5, "client-"), this.store = new kb(e2.codec, e2.audioCodec, e2.mode, this._clientId), this.store.clientCreated(), e2.proxyServer && this.setProxyServer(e2.proxyServer, true), e2.turnServer && this.setTurnServer(e2.turnServer, true), OE.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(bE, " build: ").concat(NE, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), e2.clientRoleOptions)
          try {
            Vf(e2.clientRoleOptions), t2 = Object.assign({}, e2.clientRoleOptions);
          } catch (e3) {
            OE.warning("[".concat(this._clientId, "] ").concat(e3.toString()));
          }
        this._statsCollector = new kI(this.store), this._statsCollector.onStatsException = (e3, t3, i3) => {
          OE.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e3, ", msg: ").concat(t3, ", uid: ").concat(i3)), this.safeEmit(yf.EXCEPTION, { code: e3, msg: t3, uid: i3 });
        }, this._statsCollector.onUploadPublishDuration = (e3, t3, i3, n2) => {
          const r2 = this._users.find((t4) => t4.uid === e3);
          r2 && Pg.peerPublishStatus(this._sessionId, { subscribeElapse: n2, audioPublishDuration: t3, videoPublishDuration: i3, peer: r2._uintid });
        }, this.store.useDataChannel = JS().supportDataChannel && GE("SIGNAL_CHANNEL"), this._gateway = new VC(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: e2.websocketRetryConfig || TE, httpRetryConfig: e2.httpRetryConfig || TE, forceWaitGatewayResponse: void 0 === e2.forceWaitGatewayResponse || e2.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: e2.role, clientRoleOptions: t2 }), this._configDistribute = new fv(), this._p2pChannel = new bb(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
      }
      async join(e2, t2, i3, n2, r2) {
        const o2 = ++this._numberOfJoinCount;
        this.store.joinStart(), n2 && (this.store.uid = n2);
        const s2 = Ub(), a2 = xb() ? window.isSecureContext : "Browser Not Support";
        if (!xb() && !s2 || !window.isSecureContext) {
          const e3 = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
          OE.warning(e3);
        }
        const c2 = $I();
        "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), OE.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
        const d2 = Pg.reportApiInvoke(c2, { name: _f.JOIN, options: [e2, t2, i3, n2], states: { isHttps: s2, isSecureContext: a2 }, tag: Ef.TRACER });
        Pg.setAppId(e2);
        try {
          if (!i3 && null !== i3)
            throw new SE(fE.INVALID_PARAMS, "Invalid token: ".concat(i3, ". If you don not use token, set it to null"));
          i3 && Xm(i3, "token", 1, 2047), Xm(e2, "appid", 1, 2047), Qm(t2), n2 && Zm(n2), r2 && Xm(r2, "optionalInfo", 1, 2047);
        } catch (e3) {
          throw d2.onError(e3), e3;
        }
        if (OE.info("[".concat(this._clientId, "] start join channel ").concat(t2, ", join number: ").concat(o2)), this._leaveMutex.isLocked) {
          OE.debug("[".concat(this._clientId, "] join: waiting leave operation"));
          (await this._leaveMutex.lock())(), OE.debug("[".concat(this._clientId, "] join: continue"));
        }
        if (this._joinAndNotLeaveYet = true, "DISCONNECTED" !== this.connectionState) {
          const e3 = new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
          throw d2.onError(e3), e3;
        }
        this._sessionId || (this._sessionId = c2, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
        const u2 = UD({ clientId: this._clientId, appId: e2, sid: this._sessionId, cname: t2, uid: "string" != typeof n2 ? n2 : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: i3 || e2, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r2, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint }, void 0 !== this._remoteDefaultVideoStreamType && { defaultVideoStream: this._remoteDefaultVideoStreamType });
        if (this._useLocalAccessPoint && (u2.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n2 && (u2.stringUid = n2, this._uintUid ? (u2.uid = this._uintUid, this._uintUid = void 0) : u2.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
          if (u2.aesmode = this._encryptionMode, u2.aespassword = await (async (e3) => {
            const t3 = pC("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"), i4 = await window.crypto.subtle.importKey("spki", t3, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), n3 = Ag(e3), r3 = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, i4, n3);
            return _C(new Uint8Array(r3));
          })(this._encryptionSecret), !this._joinAndNotLeaveYet)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
          this._encryptionSalt && (u2.aessalt = this._encryptionSalt);
        }
        this._startSession(this._sessionId, { channel: t2, appId: e2 });
        const l2 = this._sessionId;
        setTimeout(() => {
          "CONNECTING" === this.connectionState && l2 === this._sessionId && Pg.joinChannelTimeout(this._sessionId, 5);
        }, 5e3);
        try {
          let n3;
          const r3 = u2.cloudProxyServer;
          if (["proxy3", "proxy4", "proxy5"].includes(r3)) {
            const e3 = GE("PROXY_SERVER_TYPE3");
            Array.isArray(e3) ? u2.proxyServer = e3[0] : u2.proxyServer = e3;
          }
          if (Pg.setProxyServer(u2.proxyServer), OE.setProxyServer(u2.proxyServer), this.store.requestAPStart(), u2.stringUid && !u2.uid) {
            const e3 = await dv(u2.stringUid, u2, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, this.store);
            OE.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(u2.stringUid, " => ").concat(e3)), u2.uid = e3, n3 = await cv(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, true, this.store);
          } else
            n3 = await cv(u2, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, true, this.store);
          if (!this._joinAndNotLeaveYet)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
          this.store.requestAPEnd(), setTimeout(() => {
            this._configDistribute.startGetConfigDistribute(u2, this._axiosCancelSource.token), this._configDistribute.on(vS.UPDATE_BITRATE_LIMIT, (e3) => {
              this._p2pChannel.updateBitrateLimit(e3);
            });
          }, 0), this._key = i3 || e2;
          const o3 = n3.gatewayInfo;
          this._joinInfo = UD(UD({}, u2), {}, { cid: o3.cid, uid: u2.uid ? u2.uid : o3.uid, vid: o3.vid, apResponse: o3.res, uni_lbs_ip: o3.uni_lbs_ip, gatewayAddrs: o3.gatewayAddrs });
          const s3 = await this._joinGateway();
          if (!this._joinAndNotLeaveYet)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
          d2.onSuccess(s3), this._appId = e2, this._channelName = u2.cname, this._uid = s3, this.store.uid = s3, setTimeout(() => {
            this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Hh() ? "beforeunload" : "pagehide", this._handleBeforeUnload);
          }, 0);
          const a3 = u2.stringUid ? "string uid: ".concat(u2.stringUid, ",uid: ").concat(u2.uid) : "uid: ".concat(this._uid);
          return OE.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t2, ",").concat(a3)), setTimeout(() => {
            OE.startUpload();
          }, 5e3), this.store.joinEnd(), h3 = this, zE.includes(h3) || zE.push(h3), s3;
        } catch (e3) {
          const t3 = Array.isArray(e3) ? e3[0] : e3;
          throw t3 && t3.code === fE.OPERATION_ABORTED ? OE.warning("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3) : OE.error("[".concat(this._clientId, "] join number: ").concat(o2, ", Joining channel failed, rollback"), t3), t3.code !== fE.OPERATION_ABORTED && this._numberOfJoinCount === o2 && (this._gateway.state = "DISCONNECTED", this._reset()), d2.onError(t3), t3;
        }
        var h3;
      }
      _joinGateway() {
        if (!this._joinInfo || !this._key)
          throw new SE(fE.INVALID_OPERATION);
        return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !GE("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e2) => e2).catch((e2) => {
          if (e2.code === fE.INIT_WEBSOCKET_TIMEOUT)
            return this._gateway.leave(true, vf.FALLBACK), e2;
          if (e2.code === fE.INIT_DATACHANNEL_TIMEOUT)
            return this._gateway.leave(true, vf.FALLBACK), e2;
          throw e2;
        }).then((e2) => {
          if (e2 instanceof SE) {
            if (e2.code === fE.INIT_WEBSOCKET_TIMEOUT) {
              if (OE.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key)
                throw new SE(fE.INVALID_OPERATION);
              this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
              const e3 = GE("PROXY_SERVER_TYPE3");
              if (Array.isArray(e3))
                if (this._joinInfo.apUrl) {
                  const t3 = /^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."), i3 = t3.slice(t3.length - 2).join(".");
                  e3.forEach((e4) => {
                    this._joinInfo && e4.includes(i3) && (this._joinInfo.proxyServer = e4);
                  }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e3[0]);
                } else
                  this._joinInfo.proxyServer = e3[0];
              else
                this._joinInfo.proxyServer = e3;
              const t2 = GE("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);
              t2 && t2[1] && "443" !== t2[1] && OE.setProxyServer(this._joinInfo.proxyServer), "443" !== GE("STATS_COLLECTOR_PORT").toString() && Pg.setProxyServer(this._joinInfo.proxyServer);
              return Pg.reportApiInvoke(this._sessionId, { name: _f.JOIN_FALLBACK_TO_PROXY, options: [this._joinInfo.proxyServer], tag: Ef.TRACER }).onSuccess(), this.safeEmit(yf.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), GE("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && this._joinInfo.turnServer.servers.forEach((e4) => {
                "forceturn" in e4 && (e4.forceturn = true);
              }), this._gateway.join(this._joinInfo, this._key);
            }
            if (OE.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key)
              throw new SE(fE.INVALID_OPERATION);
            return Pg.reportApiInvoke(this._sessionId, { name: _f.DATACHANNEL_FAILBACK, options: [this.store.clientId], tag: Ef.TRACER }).onSuccess(), this._joinGateway();
          }
          return e2;
        }).then((e2) => e2);
      }
      async leave() {
        OE.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Hh() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e3) {
          const t2 = zE.indexOf(e3);
          -1 !== t2 && zE.splice(t2, 1);
        }(this);
        const e2 = await this._leaveMutex.lock();
        if ("DISCONNECTED" === this.connectionState)
          return OE.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e2();
        await this._gateway.leave("CONNECTED" !== this.connectionState), OE.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), e2();
      }
      async publish(e2) {
        let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (Array.isArray(e2) || (e2 = [e2]), 0 === e2.length)
          throw new SE(fE.INVALID_PARAMS, "track list is empty");
        if ("audience" === this._gateway.role)
          throw new SE(fE.INVALID_OPERATION, "audience can not publish stream");
        for (const i4 of e2) {
          if (!(i4 instanceof Vg))
            throw new SE(fE.INVALID_PARAMS, "parameter is not local track");
          if (!i4._enabled && t2)
            throw new SE(fE.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(i4.getTrackId()));
        }
        OE.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " "))));
        const i3 = await this._publishMutex.lock();
        await this._configDistribute.awaitConfigDistributeComplete(), t2 && e2.forEach((e3) => {
          const t3 = this._configDistribute.getBitrateLimit();
          e3 instanceof Cy && t3 && e3.setBitrateLimit(t3.uplink);
        });
        try {
          await this._publishHighStream(e2), OE.info("[".concat(this._clientId, "] Publish success, id ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " "))));
        } catch (e3) {
          throw OE.error("[".concat(this._clientId, "] publish error"), e3.toString()), e3;
        } finally {
          i3();
        }
      }
      async unpublish(e2) {
        if (!this._joinInfo || void 0 === this._uid)
          throw new SE(fE.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
        e2 ? Array.isArray(e2) || (e2 = [e2]) : e2 = this._p2pChannel.getAllTracks(true), OE.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e2.map((e3) => "".concat(e3.getTrackId(), " ")), " "));
        const t2 = await this._publishMutex.lock();
        try {
          const i3 = await this._p2pChannel.unpublish(e2);
          i3 && await this._gateway.unpublish(i3, this._uid), OE.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e2.map((e3) => "".concat(e3.getTrackId()))));
        } catch (e3) {
          throw OE.error("[".concat(this._clientId, "] unpublish error"), e3.toString()), e3;
        } finally {
          t2 && t2();
        }
      }
      async subscribe(e2, t2) {
        return this._subscribe(e2, t2);
      }
      async _subscribe(e2, t2, i3) {
        if (Ym(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream, not joined");
        if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
          throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
        if (!this._users.find((t3) => t3 === e2)) {
          const t3 = new SE(fE.INVALID_REMOTE_USER, "user is not in the channel");
          throw OE.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", this user is not in the channel")), t3;
        }
        if (!e2.hasAudio && !e2.hasVideo) {
          const t3 = new SE(fE.INVALID_REMOTE_USER, "user is not published");
          throw OE.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, ", user is not published")), t3;
        }
        if (!(i3 || ("audio" !== t2 || e2.hasAudio && void 0 !== e2._audioSSRC) && ("video" !== t2 || e2.hasVideo && void 0 !== e2._videoSSRC))) {
          const i4 = new SE(fE.REMOTE_USER_IS_NOT_PUBLISHED);
          throw OE.error("[".concat(this._clientId, "] can not subscribe ").concat(e2.uid, " with mediaType ").concat(t2, ", remote track is not published")), i4;
        }
        const n2 = "audio" === t2 ? e2._audioSSRC : e2._videoSSRC, r2 = "audio" === t2 ? e2._audioOrtc : e2._videoOrtc, o2 = "video" === t2 ? e2._rtxSsrcId : void 0, s2 = { stream_type: "audio" === t2 ? AS.AUDIO : AS.VIDEO, ssrcId: n2 }, a2 = await this._subscribeMutex.lock();
        OE.info("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, ", mediaType: ").concat(t2));
        try {
          if (await this._p2pChannel.hasRemoteMediaWithLock(e2, t2))
            await this._p2pChannel.unmuteRemote(e2, t2);
          else
            try {
              DI.markSubscribeStart(this.store.clientId, n2), this.store.subscribe(e2.uid, t2, Date.now()), await this._p2pChannel.subscribe(e2, t2, n2, o2, r2);
              try {
                await this._gateway.subscribe(e2.uid, s2, true);
              } catch (i5) {
                if ((null == i5 ? void 0 : i5.code) !== fE.WS_ABORT)
                  throw await this._p2pChannel.unsubscribe(e2, t2), i5;
                await this._p2pChannel.unsubscribe(e2, t2, true), this._p2pChannel.setPendingRemoteMedia(e2, t2);
              }
              this.store.subscribe(e2.uid, t2, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, e2, t2);
            } catch (i5) {
              throw this._p2pChannel.reportSubscribeEvent(false, null == i5 ? void 0 : i5.code, e2, t2), i5;
            }
          OE.info("[".concat(this._clientId, "] subscribe success user ").concat(e2.uid, ", mediaType: ").concat(t2)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e2.uid, this._defaultStreamFallbackType).catch((e3) => {
            OE.warning("[".concat(this._clientId, "] auto set fallback failed"), e3);
          });
          const i4 = "audio" === t2 ? e2._audioTrack : e2._videoTrack;
          if (!i4)
            throw new SE(fE.UNEXPECTED_ERROR, "can not find remote track in user object");
          return i4;
        } catch (t3) {
          throw OE.error("[".concat(this._clientId, "] subscribe user ").concat(e2.uid, " error"), t3), t3;
        } finally {
          a2();
        }
      }
      async massSubscribe(e2) {
        if (zm(e2, "subscribeList"), !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream, not joined");
        if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
          throw new SE(fE.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
        const t2 = Date.now(), i3 = /* @__PURE__ */ new Map(), n2 = await this._subscribeMutex.lock();
        OE.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e2.map((e3) => {
          let { user: t3, mediaType: i4 } = e3;
          return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i4);
        }).join("; ")));
        const r2 = (e2 = [...e2]).map((e3) => {
          let { user: t3, mediaType: i4 } = e3;
          return { user: t3, mediaType: i4 };
        }), o2 = await this._p2pChannel.globalLock();
        try {
          var s2;
          for (let t3 = e2.length - 1; t3 >= 0; t3--) {
            const n3 = e2[t3], { user: o3, mediaType: s3 } = n3;
            if (Ym(s3, "mediaType", ["audio", "video"]), !o3) {
              const e3 = new SE(fE.INVALID_PARAMS, "user property does not exist in subscribeList item");
              throw OE.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e3;
            }
            if (!this._users.find((e3) => e3 === o3)) {
              const i4 = new SE(fE.INVALID_REMOTE_USER, "user is not in the channel");
              OE.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o3.uid, ", this user is not in the channel")), r2[t3].error = i4, e2.splice(t3, 1);
              continue;
            }
            if ("audio" === s3 && (!o3.hasAudio || void 0 === o3._audioSSRC) || "video" === s3 && (!o3.hasVideo || void 0 === o3._videoSSRC)) {
              const i4 = new SE(fE.REMOTE_USER_IS_NOT_PUBLISHED);
              OE.error("[".concat(this._clientId, "] can not subscribe ").concat(o3.uid, " with mediaType ").concat(s3, ", remote user is not published")), r2[t3].error = i4, e2.splice(t3, 1);
              continue;
            }
            const a3 = cS.Video | cS.LwoVideo, c2 = i3.get(o3);
            if (c2) {
              if ("video" === s3 ? c2 & a3 : c2 & cS.Audio) {
                e2.splice(t3, 1), OE.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(o3.uid, ", mediaType:").concat(s3, " twice"));
                continue;
              }
              i3.set(o3, c2 | ("video" === s3 ? a3 : cS.Audio));
            } else
              i3.set(o3, "video" === s3 ? a3 : cS.Audio);
          }
          for (let t3 = e2.length - 1; t3 >= 0; t3--) {
            const n3 = e2[t3], { user: r3, mediaType: o3 } = n3, s3 = cS.Video | cS.LwoVideo;
            if (this._p2pChannel.hasRemoteMedia(r3, o3)) {
              await this._p2pChannel.unmuteRemoteNoLock(r3, o3);
              const n4 = i3.get(r3);
              i3.set(r3, "video" === o3 ? n4 ^ s3 : n4 ^ cS.Audio), e2.splice(t3, 1);
            }
          }
          this.store.massSubscribe(e2.map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), t2);
          const a2 = zi(s2 = Array.from(i3.entries())).call(s2, (e3, t3) => {
            let [i4, n3] = t3;
            if (0 === n3)
              return e3;
            const r3 = { stream_id: i4.uid, stream_type: n3 };
            return n3 & cS.Audio && (r3.audio_ssrc = i4._audioSSRC), n3 & cS.Video && (r3.video_ssrc = i4._videoSSRC), e3.push(r3), e3;
          }, []);
          try {
            e2.length > 0 && await this._p2pChannel.massSubscribeNoLock(e2.map((e3) => {
              let { user: t3, mediaType: i5 } = e3;
              return { user: t3, mediaType: i5, ssrcId: i5 === AS.VIDEO ? t3._videoSSRC : t3._audioSSRC, rtxSsrcId: i5 === AS.VIDEO ? t3._rtxSsrcId : void 0 };
            }));
            const i4 = /* @__PURE__ */ new Map();
            if (a2.length > 0) {
              const e3 = await this._gateway.subscribeAll(a2, true);
              ((null == e3 ? void 0 : e3.users) || []).forEach((e4) => {
                let { stream_id: t3, video_error_code: n3, audio_error_code: r3, error_code: o3 } = e4;
                (n3 || r3 || o3) && i4.set(t3, { video_error_code: n3, audio_error_code: r3, error_code: o3 });
              });
            }
            if (Array.from(i4.entries()).length > 0) {
              const e3 = Array.from(i4.entries()).map((e4) => {
                let t3, [i5, n3] = e4;
                n3.error_code || n3.video_error_code && n3.audio_error_code ? t3 = void 0 : n3.video_error_code ? t3 = AS.VIDEO : n3.audio_error_code && (t3 = AS.AUDIO);
                return { user: this.remoteUsers.find((e5) => e5.uid === i5), mediaType: t3 };
              });
              await this._p2pChannel.massUnsubscribeNoLock(e3);
            }
            for (const e3 of r2) {
              const t3 = i4.get(e3.user.uid);
              if (t3) {
                const i5 = t3.error_code || "audio" === e3.mediaType && t3.audio_error_code || "video" === e3.mediaType && t3.video_error_code;
                if (i5) {
                  const t4 = IC(i5);
                  OE.error("user:".concat(e3.user.uid, " mediaType:").concat(e3.mediaType, " has massSubscribe error ").concat(t4.desc)), e3.error = new SE(fE.SUBSCRIBE_FAILED, "code ".concat(i5, ": ").concat(t4.desc));
                }
              }
              e3.error || ("video" === e3.mediaType ? e3.track = e3.user.videoTrack : e3.track = e3.user.audioTrack);
            }
            return this.store.massSubscribe(r2.filter((e3) => !e3.error).map((e3) => ({ userId: e3.user.uid, type: e3.mediaType })), void 0, Date.now()), r2.forEach((e3) => {
              var i5;
              Pg.subscribe(this.store.sessionId, { succ: !!e3.error, ec: (null === (i5 = e3.error) || void 0 === i5 ? void 0 : i5.code) || null, video: e3.mediaType === AS.VIDEO, audio: e3.mediaType === AS.AUDIO, peerid: e3.user.uid, subscribeRequestid: e3.mediaType === AS.VIDEO ? e3.user._videoSSRC : e3.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - t2) }, true);
            }), OE.info("[".concat(this._clientId, "] massSubscribe success ").concat(e2.map((e3) => {
              let { user: t3, mediaType: i5 } = e3;
              return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i5);
            }).join("; "))), r2;
          } catch (t3) {
            throw await this._p2pChannel.massUnsubscribeNoLock(e2), t3;
          }
        } finally {
          o2(), n2();
        }
      }
      async unsubscribe(e2, t2) {
        if (t2 && Ym(t2, "mediaType", ["audio", "video"]), !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
        if (!this._users.find((t3) => t3 === e2)) {
          const t3 = new SE(fE.INVALID_REMOTE_USER, "user is not in the channel");
          throw OE.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e2.uid, ", user is not in the channel")), t3;
        }
        OE.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
        const i3 = await this._subscribeMutex.lock();
        try {
          const n2 = await this._p2pChannel.unsubscribe(e2, t2);
          n2 && await this._gateway.unsubscribe(n2, e2.uid), OE.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e2.uid, ", mediaType: ").concat(t2));
        } catch (t3) {
          if (t3.code === fE.DISCONNECT_P2P)
            return void OE.warning("disconnecting p2p, abort unsubscribe request.");
          throw OE.error("[".concat(this._clientId, "] unsubscribe user ").concat(e2.uid, " error"), t3.toString()), t3;
        } finally {
          i3();
        }
      }
      async massUnsubscribe(e2) {
        if (zm(e2, "unsubscribeList"), !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
        OE.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e2.map((e3) => {
          let { user: t3, mediaType: i3 } = e3;
          return "user: ".concat(null == t3 ? void 0 : t3.uid, ", mediaType: ").concat(i3, ";");
        }).join())), e2 = [...e2];
        const t2 = /* @__PURE__ */ new Map();
        for (let i3 = e2.length - 1; i3 >= 0; i3--) {
          const { user: n2, mediaType: r2 } = e2[i3];
          if (!n2) {
            const e3 = new SE(fE.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
            throw OE.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e3;
          }
          Ym(r2, "mediaType", ["video", "audio", void 0]);
          if (!this._users.find((e3) => e3 === n2)) {
            OE.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n2.uid, ", user is not in the channel")), e2.splice(i3, 1);
            continue;
          }
          const o2 = cS.Video | cS.LwoVideo;
          if (t2.has(n2)) {
            const s2 = t2.get(n2);
            let a2;
            switch (r2) {
              case "video":
                a2 = s2 & o2;
                break;
              case "audio":
                a2 = s2 & cS.Audio;
                break;
              default:
                a2 = s2 & (cS.Audio | o2);
            }
            if (a2) {
              OE.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(n2.uid, ",mediaType:").concat(r2, " twice.")), e2.splice(i3, 1);
              continue;
            }
            r2 ? "audio" === r2 ? t2.set(n2, s2 | cS.Audio) : "video" === r2 && t2.set(n2, s2 | o2) : t2.set(n2, s2 | cS.Audio | o2);
          } else
            r2 ? "audio" === r2 ? t2.set(n2, cS.Audio) : "video" === r2 && t2.set(n2, o2) : t2.set(n2, cS.Audio | o2);
        }
        try {
          const t3 = await this._p2pChannel.massUnsubscribe(e2);
          t3 && await this._gateway.massUnsubscribe(t3), OE.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e2.map((e3) => {
            let { user: t4, mediaType: i3 } = e3;
            return "user: ".concat(null == t4 ? void 0 : t4.uid, ", mediaType: ").concat(i3, ";");
          }).join()));
        } catch (e3) {
          if (e3.code === fE.DISCONNECT_P2P)
            return void OE.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
          throw OE.error("[".concat(this._clientId, "] massUnsubscribe error"), e3.toString()), e3;
        }
      }
      setLowStreamParameter(e2) {
        !function(e3) {
          if (!e3)
            throw new SE(fE.INVALID_PARAMS);
          $m(e3.width) || Jm(e3.width, "streamParameter.width"), $m(e3.height) || Jm(e3.height, "streamParameter.height"), $m(e3.framerate) || Jm(e3.framerate, "streamParameter.framerate"), $m(e3.bitrate) || qm(e3.bitrate, "streamParameter.bitrate");
        }(e2), (!e2.width && e2.height || e2.width && !e2.height) && OE.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), OE.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e2));
        const t2 = this._configDistribute.getLowStreamConfigDistribute();
        t2 && t2.bitrate && e2.bitrate && t2.bitrate < e2.bitrate && (e2.bitrate = t2.bitrate), this._lowStreamParameter = e2;
      }
      async enableDualStream() {
        if (!JS().supportDualStream)
          throw Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new SE(fE.NOT_SUPPORTED, "Your browser is not support dual stream");
        if (this._isDualStreamEnabled)
          throw new SE(fE.INVALID_OPERATION, "Dual stream is already enabled");
        if (this._p2pChannel.canPublishLowStream())
          try {
            await this._publishLowStream();
          } catch (e2) {
            throw Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), e2;
          }
        this._isDualStreamEnabled = true, Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), OE.info("[".concat(this._clientId, "] enable dual stream"));
      }
      async disableDualStream() {
        if (this._isDualStreamEnabled) {
          if (!this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
          if (this._p2pChannel.getLocalMedia(bS.LocalVideoLowTrack))
            try {
              const e2 = await this._p2pChannel.unpublishLowStream();
              e2 && await this._gateway.unpublish(e2, this._joinInfo.stringUid || this._joinInfo.uid);
            } catch (e2) {
              throw Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), e2;
            }
          this._isDualStreamEnabled = false, Pg.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), OE.info("[".concat(this._clientId, "] disable dual stream"));
        }
      }
      async setClientRole(e2, t2) {
        if (function(e3) {
          Ym(e3, "role", ["audience", "host"]);
        }(e2), t2 && Vf(t2), "rtc" === this.mode)
          throw OE.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), new SE(fE.INVALID_OPERATION, "rtc mode can not use setClientRole");
        if (t2 && t2.level && "host" === e2)
          throw new SE(fE.INVALID_OPERATION, "host mode can not set audience latency level");
        if ("audience" === e2 && this._p2pChannel.hasLocalMedia())
          throw new SE(fE.INVALID_OPERATION, "can not set client role to audience when publishing stream");
        await this._gateway.setClientRole(e2, t2), this._config.role = e2, OE.info("[".concat(this._clientId, "] set client role to ").concat(e2, ", level: ").concat(t2 && t2.level));
      }
      setProxyServer(e2, t2) {
        if (Xm(e2, "proxyServer"), !t2) {
          if ("DISCONNECTED" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "Set proxy server before join channel");
          if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
            throw new SE(fE.INVALID_OPERATION, "You have already set the proxy");
        }
        this._proxyServer = e2, Pg.setProxyServer(this._proxyServer), OE.setProxyServer(this._proxyServer), OE.info("[".concat(this._clientId, "] Set proxy server ").concat(t2 ? "by initialize call" : "", " success."));
      }
      setTurnServer(e2, t2) {
        if (Array.isArray(e2) || (e2 = [e2]), !t2) {
          if ("DISCONNECTED" !== this.connectionState)
            throw new SE(fE.INVALID_OPERATION, "Set turn server before join channel");
          if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint)
            throw new SE(fE.INVALID_OPERATION, "You have already set the proxy");
        }
        if (Uf(e2))
          return this._turnServer = { servers: e2, mode: "original-manual" }, void OE.info("[".concat(this._clientId, "] Set original turnserver ").concat(t2 ? "by initialize call" : "", " success: ").concat(e2.map((e3) => e3.urls).join(","), "."));
        e2.forEach((e3) => xf(e3)), this._turnServer = { servers: e2, mode: "manual" }, OE.info("[".concat(this._clientId, "] Set turnserver ").concat(t2 ? "by initialize call" : "", " success."));
      }
      setLicense(e2) {
        if ("DISCONNECTED" !== this.connectionState) {
          throw new SE(fE.INVALID_OPERATION, "you should set license before join channel");
        }
        if (Xm(e2, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e2))
          throw new SE(fE.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
        this._license = e2, OE.info("[".concat(this._clientId, "] set license success"), e2);
      }
      startProxyServer(e2) {
        if ("DISCONNECTED" !== this.connectionState)
          throw new SE(fE.INVALID_OPERATION, "Start proxy server before join channel");
        if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint)
          throw new SE(fE.INVALID_OPERATION, "You have already set the proxy");
        const t2 = [3, 4, 5];
        let i3;
        switch (void 0 === e2 && (e2 = 3), e2) {
          case 1:
          case 2:
            throw new SE(fE.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
          case 3:
            i3 = "proxy3";
            break;
          case 4:
            i3 = "proxy4";
            break;
          case 5:
            i3 = "proxy5";
            break;
          default:
            throw new SE(fE.INVALID_PARAMS, "proxy server mode must be ".concat(t2.join("|")));
        }
        this._cloudProxyServerMode = i3, this.store.cloudProxyServerMode = i3, OE.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
      }
      stopProxyServer() {
        if ("DISCONNECTED" !== this.connectionState)
          throw new SE(fE.INVALID_OPERATION, "Stop proxy server after leave channel");
        Pg.setProxyServer(), OE.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", OE.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
      }
      setLocalAccessPointsV2(e2) {
        if (!e2.accessPoints)
          throw new SE(fE.INVALID_PARAMS, "accessPoints is required.");
        zm(e2.accessPoints.serverList, "accessPoints.serverList"), Xm(e2.accessPoints.domain, "accessPoints.domain");
        const t2 = (e3, t3) => {
          qm(e3, t3, 0, 65535, true);
        };
        let i3 = 443;
        if (e2.accessPoints.port && (t2(e2.accessPoints.port, "accessPoints.port"), i3 = e2.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
          throw new SE(fE.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
        GE("CLOSE_AFB_FOR_LOCAL_AP") && (BE("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), BE("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
        const n2 = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r2 = e2.accessPoints.domain, o2 = e2.accessPoints.serverList.map((e3) => n2.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(r2) : e3), s2 = o2.map((e3) => "".concat(e3, ":").concat(i3));
        this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, BE("WEBCS_DOMAIN", s2), BE("WEBCS_DOMAIN_BACKUP_LIST", s2), BE("GATEWAY_DOMAINS", [r2]), e2.report && e2.report.hostname && Array.isArray(e2.report.hostname) && e2.report.hostname.length ? (zm(e2.report.hostname, "report.hostname"), BE("EVENT_REPORT_DOMAIN", e2.report.hostname[0]), BE("EVENT_REPORT_BACKUP_DOMAIN", e2.report.hostname[1] || e2.report.hostname[0])) : (BE("EVENT_REPORT_DOMAIN", o2[0]), BE("EVENT_REPORT_BACKUP_DOMAIN", o2[1] || o2[0]));
        let a2 = 6443;
        e2.report && e2.report.port && (t2(e2.report.port, "report.port"), a2 = e2.report.port), BE("STATS_COLLECTOR_PORT", a2), e2.report ? BE("ENABLE_EVENT_REPORT", true) : BE("ENABLE_EVENT_REPORT", false);
        let c2 = "";
        e2.log && e2.log.hostname && Array.isArray(e2.log.hostname) && e2.log.hostname.length ? (zm(e2.log.hostname, "log.hostname"), c2 = e2.log.hostname[0]) : c2 = o2[0];
        let d2 = 6444;
        e2.log && e2.log.port && (t2(e2.log.port, "log.port"), d2 = e2.log.port), BE("LOG_UPLOAD_SERVER", "".concat(c2, ":").concat(d2));
        let u2 = [];
        e2.cds && e2.cds.hostname && Array.isArray(e2.cds.hostname) && e2.cds.hostname.length ? (zm(e2.cds.hostname, "cds.hostname"), u2 = e2.cds.hostname) : u2 = o2;
        let l2 = 443;
        e2.cds && e2.cds.port && (t2(e2.cds.port, "cds.port"), l2 = e2.cds.port), BE("CDS_AP", u2.map((e3) => "".concat(e3, ":").concat(l2))), e2.cds ? BE("ENABLE_CONFIG_DISTRIBUTE", true) : BE("ENABLE_CONFIG_DISTRIBUTE", false), OE.info("set local access point v2 success");
      }
      setLocalAccessPoints(e2, t2) {
        if (zm(e2, "serverList"), Xm(t2, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode)
          throw new SE(fE.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
        const i3 = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
        e2 = e2.map((e3) => i3.test(e3) ? "".concat(e3.replace(/\./g, "-"), ".").concat(t2) : e3), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, BE("WEBCS_DOMAIN", e2), BE("WEBCS_DOMAIN_BACKUP_LIST", e2), BE("GATEWAY_DOMAINS", [t2]), BE("EVENT_REPORT_DOMAIN", e2[0]), BE("EVENT_REPORT_BACKUP_DOMAIN", e2[1] || e2[0]), BE("LOG_UPLOAD_SERVER", "".concat(e2[0], ":6444")), OE.info("[".concat(this._clientId, "] set local access point success"));
      }
      async setRemoteDefaultVideoStreamType(e2) {
        if (Ym(e2, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e2, this._joinInfo)
          try {
            await this._gateway.setDefaultRemoteVideoStreamType(e2), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
          } catch (e3) {
            throw OE.error("[".concat(this._clientId, "] set default remote video stream type error"), e3.toString()), e3;
          }
        else
          OE.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e2));
      }
      async setRemoteVideoStreamType(e2, t2) {
        Ym(t2, "streamType", [0, 1]);
        try {
          await this._gateway.setRemoteVideoStreamType(e2, t2), setTimeout(() => {
            const t3 = this._users.find((t4) => t4.uid === e2);
            t3 && t3.videoTrack && t3.videoTrack.updateMediaStreamTrackResolution();
          }, 2e3);
        } catch (e3) {
          throw OE.error("[".concat(this._clientId, "] set remote video stream type error"), e3.toString()), e3;
        }
        OE.info("[".concat(this._clientId, "] set remote ").concat(e2, " video stream type to ").concat(t2)), this._remoteStreamTypeCacheMap.set(e2, t2);
      }
      async setStreamFallbackOption(e2, t2) {
        Ym(t2, "fallbackType", [0, 1, 2]);
        try {
          await this._gateway.setStreamFallbackOption(e2, t2);
        } catch (e3) {
          throw OE.error("[".concat(this._clientId, "] set stream fallback option"), e3.toString()), e3;
        }
        OE.info("[".concat(this._clientId, "] set remote ").concat(e2, " stream fallback type to ").concat(t2)), this._streamFallbackTypeCacheMap.set(e2, t2);
      }
      setEncryptionConfig(e2, t2, i3) {
        !function(e3) {
          Ym(e3, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
        }(e2), Xm(t2, "secret");
        if (["aes-128-gcm2", "aes-256-gcm2"].includes(e2)) {
          if (!i3 || !(i3 instanceof Uint8Array && 32 === i3.length))
            throw new SE(fE.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
        } else if (i3)
          throw new SE(fE.INVALID_PARAMS, "current encrypt mode does not need salt");
        new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(t2) || OE.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e2, this._encryptionSecret = t2, i3 && (this._encryptionSalt = _C(i3));
      }
      async renewToken(e2) {
        if (Xm(e2, "token", 1, 2047), !this._key || !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "renewToken should not be called before user join");
        const t2 = this._key;
        this._key = e2, this._joinInfo && (this._joinInfo.token = e2);
        const i3 = await this._renewTokenMutex.lock();
        try {
          if (GE("USE_NEW_TOKEN")) {
            OE.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
            const t3 = await _v(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || TE);
            OE.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: e2, ticket: t3 });
          } else
            OE.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: e2 });
          OE.debug("[".concat(this._clientId, "] renewToken success"));
        } catch (e3) {
          throw this._key = t2, this._joinInfo.token = t2, OE.error("[".concat(this._clientId, "] renewToken failed"), e3.toString()), e3;
        } finally {
          i3();
        }
      }
      enableAudioVolumeIndicator() {
        this._audioVolumeIndicationInterval ? OE.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
          const e2 = this._p2pChannel.getAudioLevels();
          this.safeEmit(yf.VOLUME_INDICATOR, e2);
        }, GE("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
      }
      getRTCStats() {
        const e2 = this._statsCollector.getRTCStats(), t2 = this._gateway.getInChannelInfo();
        return e2.Duration = Math.round(t2.duration / 1e3), e2;
      }
      async startLiveStreaming(e2, t2) {
        if (!t2) {
          if ("h264" !== this.codec)
            throw new SE(fE.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
          if (!this._p2pChannel.hasLocalMedia())
            throw new SE(fE.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
        }
        if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e2) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e2))
          throw new SE(fE.LIVE_STREAMING_TASK_CONFLICT);
        const i3 = t2 ? Kf.TRANSCODE : Kf.RAW;
        return this._createLiveStreamingClient(i3).startLiveStreamingTask(e2, i3);
      }
      setLiveTranscoding(e2) {
        return this._createLiveStreamingClient(Kf.TRANSCODE).setTranscodingConfig(e2);
      }
      async stopLiveStreaming(e2) {
        const t2 = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((t3) => t3 && t3.hasUrl(e2));
        if (!t2.length)
          throw new SE(fE.INVALID_PARAMS, "can not find live streaming url to stop");
        await Sl.all(t2.map((t3) => t3 && t3.stopLiveStreamingTask(e2)));
      }
      async addInjectStreamUrl(e2, t2) {
        if (!this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
        const i3 = this._createLiveStreamingClient(Kf.INJECT);
        i3.setInjectStreamConfig(t2, 0), await i3.startLiveStreamingTask(e2, Kf.INJECT);
      }
      async removeInjectStreamUrl() {
        var e2;
        const t2 = this._createLiveStreamingClient(Kf.INJECT), i3 = Array.from(IR(e2 = t2.streamingTasks).call(e2)).find((e3) => e3.mode === Kf.INJECT);
        if (!this._joinInfo || !i3)
          throw new SE(fE.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
        await t2.stopLiveStreamingTask(i3.url);
      }
      async startChannelMediaRelay(e2) {
        yv(e2);
        const t2 = this._createChannelMediaRelayClient();
        await t2.startChannelMediaRelay(e2);
      }
      async updateChannelMediaRelay(e2) {
        yv(e2);
        const t2 = this._createChannelMediaRelayClient();
        await t2.updateChannelMediaRelay(e2);
      }
      async stopChannelMediaRelay() {
        const e2 = this._createChannelMediaRelayClient();
        await e2.stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
      }
      sendStreamMessage(e2) {
        let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (!this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "can not send data stream, not joined");
        if ("string" == typeof e2) {
          e2 = new TextEncoder().encode(e2);
        }
        if (new Blob([e2]).size > 1024)
          throw new SE(fE.INVALID_PARAMS, "stream message out of range.");
        return this._gateway.signal.request(bf.DATA_STREAM, { payload: _C(e2) }, !t2);
      }
      sendMetadata(e2) {
        if (!this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "can not send metadata, not joined");
        if (new Blob([e2]).size > 1024)
          throw new SE(fE.METADATA_OUT_OF_RANGE);
        return this._gateway.signal.request(bf.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: _C(e2) });
      }
      async sendCustomReportMessage(e2) {
        if (Array.isArray(e2) || (e2 = [e2]), e2.forEach(cf), !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "can not send custom report, not joined");
        await Pg.sendCustomReportMessage(this._joinInfo.sid, e2);
      }
      getLocalAudioStats() {
        return this._statsCollector.getLocalAudioTrackStats();
      }
      getRemoteAudioStats() {
        return this._statsCollector.getRemoteAudioTrackStats();
      }
      getLocalVideoStats() {
        return this._statsCollector.getLocalVideoTrackStats();
      }
      getRemoteVideoStats() {
        return this._statsCollector.getRemoteVideoTrackStats();
      }
      getRemoteNetworkQuality() {
        return this._statsCollector.getRemoteNetworkQualityStats();
      }
      async pickSVCLayer(e2, t2) {
        Ym(t2.spatialLayer, "spatialLayer", [0, 1, 2, 3]), Ym(t2.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
        try {
          await this._gateway.pickSVCLayer(e2, t2);
        } catch (e3) {
          throw OE.error("[".concat(this._clientId, "] pick SVC layer failed"), e3.toString()), e3;
        }
      }
      _reset() {
        if (OE.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = pE.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach((e2) => {
          e2._audioTrack && e2._audioTrack._destroy(), e2._videoTrack && e2._videoTrack._destroy();
        }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new Ug("client-publish"), this._subscribeMutex = new Ug("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect)
          try {
            this._inspect.close(), this._inspect = void 0;
          } catch (e2) {
          }
        if (this._moderation)
          try {
            this.setImageModeration(false);
          } catch (e2) {
          }
      }
      _startSession(e2, t2) {
        const i3 = e2 || $I();
        e2 ? OE.debug("[".concat(this._clientId, "] new Session ").concat(i3)) : OE.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(i3)), this._sessionId = i3, this.store.sessionId = i3, t2 ? Pg.sessionInit(this._sessionId, { lts: (/* @__PURE__ */ new Date()).getTime(), cname: t2.channel, appid: t2.appId, mode: this.mode }) : this._joinInfo ? Pg.sessionInit(this._sessionId, { lts: (/* @__PURE__ */ new Date()).getTime(), cname: this._joinInfo.cname, appid: this._joinInfo.appId, mode: this.mode }) : this._gateway.joinInfo && Pg.sessionInit(this._sessionId, { lts: (/* @__PURE__ */ new Date()).getTime(), cname: this._gateway.joinInfo.cname, appid: this._gateway.joinInfo.appId, mode: this.mode }), this._joinInfo && (this._joinInfo.sid = i3), this._gateway.joinInfo && (this._gateway.joinInfo.sid = i3);
      }
      async _publishHighStream(e2) {
        if (!this._joinInfo || void 0 === this._uid)
          throw new SE(fE.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
        if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
          throw new SE(fE.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
        if ("auto" === this._turnServer.mode && GE("FORCE_TURN") && !GE("TURN_ENABLE_TCP") && !GE("TURN_ENABLE_UDP"))
          throw new SE(fE.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
        OE.debug("[".concat(this._clientId, "] publish high stream"));
        try {
          const i3 = await this._p2pChannel.publish(e2, this._isDualStreamEnabled, this._lowStreamParameter), n2 = (await i3.next()).value;
          if (n2) {
            var t2;
            let e3;
            try {
              e3 = await this._gateway.publish(this._uid, n2, true);
            } catch (e4) {
              if (e4.code !== fE.DISCONNECT_P2P)
                throw i3.throw(e4), e4;
            }
            await i3.next((null === (t2 = e3) || void 0 === t2 ? void 0 : t2.ortc) || []);
          }
          this._p2pChannel.reportPublishEvent(true, null);
          for (const t3 of e2)
            t3 instanceof Cy && t3._encoderConfig && this._gateway.setVideoProfile(t3._encoderConfig), !t3.muted && t3.enabled || await this._p2pChannel.muteLocalTrack(t3);
        } catch (t3) {
          if (this._p2pChannel.reportPublishEvent(false, null == t3 ? void 0 : t3.code, e2), (null == t3 ? void 0 : t3.code) === fE.WS_ABORT)
            return;
          throw t3;
        }
      }
      async _publishLowStream() {
        if (!this._joinInfo || void 0 === this._uid)
          throw new SE(fE.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
        if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState)
          throw new SE(fE.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
        OE.debug("[".concat(this._clientId, "] publish low stream"));
        const e2 = this._configDistribute.getLowStreamConfigDistribute();
        e2 && e2.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e2.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e2.bitrate));
        try {
          const e3 = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i3 = (await e3.next()).value;
          if (i3) {
            var t2;
            let n2;
            try {
              n2 = await this._gateway.publish(this._uid, i3, true);
            } catch (t3) {
              if (t3.code !== fE.DISCONNECT_P2P)
                throw e3.throw(t3), t3;
            }
            e3.next((null === (t2 = n2) || void 0 === t2 ? void 0 : t2.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
          }
        } catch (e3) {
          if (this._p2pChannel.reportPublishEvent(false, null == e3 ? void 0 : e3.code, void 0, true), (null == e3 ? void 0 : e3.code) === fE.WS_ABORT)
            return;
          throw e3;
        }
      }
      _createLiveStreamingClient(e2) {
        if (!this._joinInfo || !this._appId) {
          return new SE(fE.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
        }
        const t2 = () => new Cv(this._joinInfo, this._config.websocketRetryConfig || TE, this._config.httpRetryConfig || TE), i3 = (e3) => {
          e3.onLiveStreamError = (e4, t3) => {
            Pg.reportApiInvoke(this._sessionId, { name: _f.ON_LIVE_STREAM_ERROR, options: [e4, t3], tag: Ef.TRACER }).onSuccess(), this.safeEmit(yf.LIVE_STREAMING_ERROR, e4, t3);
          }, e3.onLiveStreamWarning = (e4, t3) => {
            Pg.reportApiInvoke(this._sessionId, { name: _f.ON_LIVE_STREAM_WARNING, options: [e4, t3], tag: Ef.TRACER }).onSuccess(), this.safeEmit(yf.LIVE_STREAMING_WARNING, e4, t3);
          }, e3.on($f.REQUEST_WORKER_MANAGER_LIST, (e4, t3, i4) => {
            if (!this._joinInfo)
              return i4(new SE(fE.INVALID_OPERATION, "can not find join info to get worker manager"));
            hv(e4, this._joinInfo, this._axiosCancelSource.token, TE).then(t3).catch(i4);
          });
        };
        switch (e2) {
          case Kf.RAW:
            return this._liveRawStreamingClient || (this._liveRawStreamingClient = t2(), i3(this._liveRawStreamingClient)), this._liveRawStreamingClient;
          case Kf.TRANSCODE:
            return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t2(), i3(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
          case Kf.INJECT:
            return this._injectStreamingClient || (this._injectStreamingClient = t2(), this._injectStreamingClient.on($f.REQUEST_WORKER_MANAGER_LIST, (e3, t3, i4) => {
              if (!this._joinInfo)
                return i4(new SE(fE.INVALID_OPERATION, "can not find join info to get worker manager"));
              hv(e3, this._joinInfo, this._axiosCancelSource.token, TE).then(t3).catch(i4);
            }), this._injectStreamingClient.onInjectStatusChange = (e3, t3, i4) => {
              this.emit(yf.INJECT_STREAM_STATUS, e3, t3, i4);
            }), this._injectStreamingClient;
        }
      }
      _createChannelMediaRelayClient() {
        if (!this._joinInfo) {
          return new SE(fE.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
        }
        if (!this._channelMediaRelayClient) {
          const { sendResolutionWidth: e2, sendResolutionHeight: t2 } = this.getLocalVideoStats(), i3 = { width: e2, height: t2 };
          this._channelMediaRelayClient = new Ov(this._joinInfo, this._clientId, this._config.websocketRetryConfig || TE, this._config.httpRetryConfig || TE, i3), this._channelMediaRelayClient.on("state", (e3) => {
            e3 === rS.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.safeEmit(yf.CHANNEL_MEDIA_RELAY_STATE, e3);
          }), this._channelMediaRelayClient.on("event", (e3) => {
            this.safeEmit(yf.CHANNEL_MEDIA_RELAY_EVENT, e3);
          }), this._statsCollector.onStatsChanged = (e3, t3) => {
            var i4;
            "resolution" === e3 && (null === (i4 = this._channelMediaRelayClient) || void 0 === i4 || i4.setVideoProfile(t3));
          };
        }
        return this._channelMediaRelayClient;
      }
      _handleGatewayEvents() {
        this._gateway.on(aS.DISCONNECT_P2P, async () => {
          await this._p2pChannel.disconnectForReconnect();
        }), this._gateway.on(aS.CONNECTION_STATE_CHANGE, (e2, t2, i3) => {
          var n2;
          if (i3 === vf.FALLBACK)
            return;
          const r2 = () => {
            this.safeEmit(yf.CONNECTION_STATE_CHANGE, e2, t2, i3);
          };
          if (Pg.reportApiInvoke(this._sessionId || (null === (n2 = this._gateway.joinInfo) || void 0 === n2 ? void 0 : n2.sid) || null, { name: _f.CONNECTION_STATE_CHANGE, options: [e2, t2, i3], tag: Ef.TRACER }).onSuccess(JSON.stringify({ cur: e2, prev: t2, reason: i3 })), OE.info("[".concat(this._clientId, "] connection state change: ").concat(t2, " -> ").concat(e2)), "DISCONNECTED" === e2)
            return this._reset(), void r2();
          if ("RECONNECTING" === e2)
            this._users.forEach((e3) => {
              e3._trust_in_room_ = false, e3._trust_audio_enabled_state_ = false, e3._trust_video_enabled_state_ = false, e3._trust_audio_mute_state_ = false, e3._trust_video_mute_state_ = false, e3._trust_audio_stream_added_state_ = false, e3._trust_video_stream_added_state_ = false, e3._audioSSRC = void 0, e3._videoSSRC = void 0, e3._videoOrtc = void 0, e3._audioOrtc = void 0, e3._cname = void 0, e3._rtxSsrcId = void 0;
            }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
          else if ("CONNECTED" === e2) {
            var o2;
            this._streamFallbackTypeCacheMap.forEach((e3, t3) => {
              this._gateway.setStreamFallbackOption(t3, e3).catch((e4) => {
                OE.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e4);
              });
            }), this._remoteStreamTypeCacheMap.forEach((e3, t3) => {
              this._gateway.setRemoteVideoStreamType(t3, e3).catch((e4) => {
                OE.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e4);
              });
            }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
              OE.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
            }).catch((e3) => {
              OE.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e3));
            }), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
              if ("CONNECTED" !== this.connectionState)
                return;
              this._userOfflineTimeout = void 0;
              this._users.filter((e3) => !e3._trust_in_room_).forEach((e3) => {
                OE.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e3.uid)), this._handleUserOffline({ uid: e3.uid });
              });
            }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
              "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach((e3) => {
                e3._trust_audio_mute_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, "audio", false)), e3._trust_video_mute_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e3.uid)), this._handleMuteStream(e3.uid, "video", false)), e3._trust_audio_enabled_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e3.uid)), this._handleSetStreamLocalEnable("audio", e3.uid, true)), e3._trust_video_enabled_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e3.uid)), this._handleSetStreamLocalEnable("video", e3.uid, true)), e3._trust_video_stream_added_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "video")), e3._trust_audio_stream_added_state_ || (OE.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e3.uid)), this._handleResetAddStream(e3, "audio")), e3._video_added_ || e3._audio_added_ || (OE.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e3.uid)), this._handleRemoveStream({ uid: e3.uid, uint_id: e3._uintid }));
              }));
            }, 1e3);
          }
          r2();
        }), this._gateway.on(aS.REQUEST_NEW_GATEWAY_LIST, (e2, t2) => {
          if (!this._joinInfo)
            return t2(new SE(fE.UNEXPECTED_ERROR, "can not recover, no join info"));
          av(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || TE, this.store).then((t3) => {
            this._joinInfo && (this._joinInfo.apResponse = t3.gatewayInfo.res, this._joinInfo.gatewayAddrs = t3.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t3.gatewayInfo.uni_lbs_ip), e2(t3.gatewayInfo.gatewayAddrs.map((e3) => {
              if (this._joinInfo && this._joinInfo.proxyServer) {
                const t4 = e3.address.split(":");
                return "wss://".concat(this._joinInfo.proxyServer, "/ws/?h=").concat(t4[0], "&p=").concat(t4[1]);
              }
              return "wss://".concat(e3.address);
            }));
          }).catch(t2);
        }), this._gateway.on(aS.NETWORK_QUALITY, (e2) => {
          "normal" === this._networkQualitySensitivity && this.safeEmit(yf.NETWORK_QUALITY, e2);
        }), this._gateway.on(aS.STREAM_TYPE_CHANGE, (e2, t2) => {
          this.safeEmit(yf.STREAM_TYPE_CHANGED, e2, t2);
          Pg.reportApiInvoke(this._sessionId, { name: _f.STREAM_TYPE_CHANGE, options: [e2, t2], tag: Ef.TRACER }).onSuccess(JSON.stringify({ uid: e2, streamType: t2 }));
        }), this._gateway.on(aS.IS_P2P_DISCONNECTED, (e2) => {
          this._p2pChannel.isP2PDisconnected() ? e2(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e2(false) : e2(true);
        }), this._gateway.on(aS.NEED_RENEW_SESSION, () => {
          this._startSession();
        }), this._gateway.on(aS.REQUEST_P2P_CONNECTION_PARAMS, async (e2, t2, i3) => {
          try {
            t2(await this._p2pChannel.startP2PConnection(e2));
          } catch (e3) {
            i3(e3);
          }
        }), this._gateway.on(aS.JOIN_RESPONSE, (e2, t2) => {
          const { dtlsParameters: i3, iceParameters: n2, candidates: r2, rtpCapabilities: o2, setup: s2, cname: a2 } = GO(e2.ortc, t2);
          this._p2pChannel.connect(n2, i3, r2, o2, s2, a2);
        }), this._gateway.on(aS.REQUEST_DC_CONNECTION_PARAMS, (e2) => {
          e2(this._p2pChannel.getEstablishParams());
        }), this._gateway.on(aS.RESET_SIGNAL, (e2) => {
          this._p2pChannel.resetConnection(e2), this._handleGatewaySignalEvents();
        }), this._gateway.on(aS.DATACHANNEL_FAILBACK, () => {
          this._joinGateway();
        }), this._gateway.on(aS.DATACHANNEL_PRECONNECT, async (e2, t2, i3, n2) => {
          var r2, o2, s2, a2, c2, d2;
          await this._p2pChannel.startP2PConnection({ turnServer: null === (r2 = this._joinInfo) || void 0 === r2 ? void 0 : r2.turnServer }, true);
          const u2 = function(e3, t3) {
            let i4;
            return t3 && t3.ip && "number" == typeof t3.port ? (i4 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip, port: t3.port.toString(), type: "host", extension: {} }], OE.debug("Using remote candidate from AP ".concat(t3.ip, ":").concat(t3.port)), t3.ip6 && (i4.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t3.ip6, port: t3.port.toString(), type: "host", extension: {} }), OE.debug("Using IPV6 remote candidate from AP ".concat(t3.ip6, ":").concat(t3.port)))) : i4 = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: e3.ip, port: e3.port.toString(), type: "host", extension: {} }], i4;
          }(e2, t2);
          return this._p2pChannel.preConnect({ iceUfrag: "".concat(null === (o2 = this._joinInfo) || void 0 === o2 ? void 0 : o2.apResponse.cid, "_").concat(null === (s2 = this._joinInfo) || void 0 === s2 ? void 0 : s2.apResponse.cert), icePwd: "".concat(null === (a2 = this._joinInfo) || void 0 === a2 ? void 0 : a2.apResponse.cid, "_").concat(null === (c2 = this._joinInfo) || void 0 === c2 ? void 0 : c2.apResponse.cert) }, { fingerprints: [{ hashFunction: "sha-256", fingerprint: null !== (d2 = GE("FINGERPRINT")) && void 0 !== d2 ? d2 : e2.fingerprint }] }, u2, { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, "active", "o/i14u9pJrxRKAsu").then(i3).catch(n2);
        });
      }
      _handleGatewaySignalEvents() {
        this._gateway.signal.on(Df.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(Df.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(Df.ON_ADD_AUDIO_STREAM, (e2) => this._handleAddAudioOrVideoStream("audio", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc)), this._gateway.signal.on(Df.ON_ADD_VIDEO_STREAM, (e2) => this._handleAddAudioOrVideoStream("video", e2.uid, e2.ssrcId, e2.cname, e2.uint_id, e2.ortc, e2.rtxSsrcId)), this._gateway.signal.on(Df.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(Df.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(Df.MUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, "audio", true)), this._gateway.signal.on(Df.UNMUTE_AUDIO, (e2) => this._handleMuteStream(e2.uid, "audio", false)), this._gateway.signal.on(Df.MUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, "video", true)), this._gateway.signal.on(Df.UNMUTE_VIDEO, (e2) => this._handleMuteStream(e2.uid, "video", false)), this._gateway.signal.on(Df.RECEIVE_METADATA, (e2) => {
          const t2 = pC(e2.metadata);
          this.safeEmit(yf.RECEIVE_METADATA, e2.uid, t2);
        }), this._gateway.signal.on(Df.ON_DATA_STREAM, (e2) => {
          e2.seq && delete e2.seq, e2.payload = pC(e2.payload), this.safeEmit(yf.STREAM_MESSAGE, e2.uid, e2.payload), this.onStreamMessage && this.onStreamMessage(e2);
        }), this._gateway.signal.on(Df.ON_CRYPT_ERROR, () => {
          hC(() => {
            OE.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(yf.CRYPT_ERROR);
          }, this._sessionId);
        }), this._gateway.signal.on(Df.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
          OE.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true), this.safeEmit(yf.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
        }), this._gateway.signal.on(Df.ON_STREAM_FALLBACK_UPDATE, (e2) => {
          OE.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e2.stream_id, ", attr: ").concat(e2.stream_type)), this.safeEmit(yf.STREAM_FALLBACK, e2.stream_id, 1 === e2.stream_type ? "fallback" : "recover");
        }), this._gateway.signal.on(Df.ON_PUBLISH_STREAM, (e2) => {
          this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: e2.proxy })), OE.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e2))));
        }), this._gateway.signal.on(Df.ENABLE_LOCAL_VIDEO, (e2) => {
          this._handleSetStreamLocalEnable("video", e2.uid, true);
        }), this._gateway.signal.on(Df.DISABLE_LOCAL_VIDEO, (e2) => {
          this._handleSetStreamLocalEnable("video", e2.uid, false);
        }), this._gateway.signal.on(Nf.REQUEST_TIMEOUT, (e2, t2) => {
          if (this._joinInfo)
            switch (e2) {
              case bf.PUBLISH: {
                if (!t2)
                  return;
                const e3 = (t2 = t2).ortc;
                if (e3) {
                  var i3, n2, r2, o2;
                  const s2 = e3.some((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === sS.Audio;
                  }), a2 = e3.some((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 !== sS.Audio;
                  }), c2 = e3.some((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === sS.Screen || t3 === sS.ScreenLow;
                  });
                  "offer" === t2.state && Pg.publish(this._joinInfo.sid, { eventElapse: DI.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: fE.TIMEOUT, audio: s2, video: a2, p2pid: t2.p2p_id, publishRequestid: this.store.pubId, screenshare: c2, audioName: s2 ? null === (i3 = e3.find((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 === sS.Audio;
                  })) || void 0 === i3 || null === (n2 = i3.ssrcs[0]) || void 0 === n2 ? void 0 : n2.ssrcId.toString() : void 0, videoName: a2 ? null === (r2 = e3.find((e4) => {
                    let { stream_type: t3 } = e4;
                    return t3 !== sS.Audio;
                  })) || void 0 === r2 || null === (o2 = r2.ssrcs[0]) || void 0 === o2 ? void 0 : o2.ssrcId.toString() : void 0 });
                }
                break;
              }
              case bf.SUBSCRIBE:
                (t2 = t2) && Pg.subscribe(this._joinInfo.sid, { succ: false, ec: fE.TIMEOUT, audio: t2.stream_type === AS.AUDIO, video: t2.stream_type === AS.VIDEO, peerid: t2.stream_id, subscribeRequestid: t2.ssrcId, p2pid: this.store.p2pId, eventElapse: DI.measureFromSubscribeStart(this.store.clientId, t2.ssrcId) });
            }
        }), this._gateway.signal.on(Df.ON_P2P_OK, (e2) => {
          this.uid, this._uid;
        }), this._gateway.signal.on(Df.ON_PUBLISHED_USER_LIST, (e2) => {
          if (null == e2 || !e2.users)
            return;
          GE("BLOCK_LOCAL_CLIENT") && (e2.users = e2.users.filter((e3) => !ZE(e3.audio_ssrc, this.channelName)));
          const t2 = [], i3 = [];
          for (const n2 of e2.users) {
            let e3 = this._users.find((e4) => e4.uid === n2.stream_id);
            e3 ? e3._trust_in_room_ = true : (e3 = new yy(n2.stream_id, n2.stream_id), this._users.push(e3), 0 === this.getListeners(yf.PUBLISHED_USER_LIST).length && (OE.debug("[".concat(this._clientId, "] user online"), n2.stream_id), this.safeEmit(yf.USER_JOINED, e3)));
            const r2 = cS.Audio & n2.stream_type, o2 = (cS.Video | cS.LwoVideo) & n2.stream_type, s2 = r2 && e3.hasAudio, a2 = o2 && e3.hasVideo;
            o2 && (e3._trust_video_stream_added_state_ = true, e3._video_added_ = true, e3._videoSSRC = n2.video_ssrc, e3._rtxSsrcId = n2.video_rtx), r2 && (e3._trust_audio_stream_added_state_ = true, e3._audio_added_ = true, e3._audioSSRC = n2.audio_ssrc), r2 && !s2 && 0 === this.getListeners(yf.PUBLISHED_USER_LIST).length && (OE.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published audio")), this.safeEmit(yf.USER_PUBLISHED, e3, "audio")), o2 && !a2 && 0 === this.getListeners(yf.PUBLISHED_USER_LIST).length && (OE.info("[".concat(this._clientId, "] remote user ").concat(e3.uid, " published video")), this.safeEmit(yf.USER_PUBLISHED, e3, "video")), (r2 && !s2 || o2 && !a2) && t2.push(e3), o2 && this._p2pChannel.hasPendingRemoteMedia(e3, "video") && i3.push({ user: e3, mediaType: "video" }), r2 && this._p2pChannel.hasPendingRemoteMedia(e3, "audio") && i3.push({ user: e3, mediaType: "audio" });
          }
          i3.length > 0 && (OE.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(i3.map((e3) => "user: ".concat(e3.user.uid, ", mediaType: ").concat(e3.mediaType)).join("; "), " ")), this.massSubscribe(i3).catch((e3) => {
            OE.error("[".concat(this._clientId, "] mass resubscribe error"), e3.toString());
          })), this.getListeners(yf.PUBLISHED_USER_LIST).length > 0 ? (OE.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t2.map((e3) => e3.uid).join(", "))), this.safeEmit(yf.PUBLISHED_USER_LIST, t2)) : OE.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t2.map((e3) => e3.uid).join(", ")));
        });
      }
      _handleP2PChannelEvents() {
        this._p2pChannel.on(DS.RequestMuteLocal, async (e2, t2, i3) => {
          if (this._joinInfo)
            try {
              await this._gateway.muteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === fE.DISCONNECT_P2P ? t2() : i3(e3);
            }
          else
            t2();
        }), this._p2pChannel.on(DS.RequestUnmuteLocal, async (e2, t2, i3) => {
          if (this._joinInfo)
            try {
              await this._gateway.unmuteLocal(e2, this._joinInfo.stringUid || this._joinInfo.uid), t2();
            } catch (e3) {
              e3.code === fE.DISCONNECT_P2P ? t2() : i3(e3);
            }
          else
            t2();
        }), this._p2pChannel.on(DS.RequestRePublish, (e2, t2, i3) => {
          this.publish(e2, false).then(t2).catch(i3);
        }), this._p2pChannel.on(DS.RequestReSubscribe, async (e2, t2, i3) => {
          try {
            for (const { user: t3, kind: i4 } of e2)
              i4 === AS.VIDEO ? await this.subscribe(t3, "video") : await this.subscribe(t3, "audio");
            t2();
          } catch (e3) {
            i3(e3);
          }
        }), this._p2pChannel.on(DS.RequestUploadStats, (e2, t2) => {
          this._gateway.uploadStats(e2, t2);
        }), this._p2pChannel.on(DS.MediaReconnectStart, (e2) => {
          this.safeEmit(yf.MEDIA_RECONNECT_START, e2);
        }), this._p2pChannel.on(DS.MediaReconnectEnd, (e2) => {
          this.safeEmit(yf.MEDIA_RECONNECT_END, e2);
        }), this._p2pChannel.on(DS.NeedSignalRTT, (e2) => {
          e2(this._gateway.getSignalRTT());
        }), this._p2pChannel.on(DS.RequestRestartICE, async (e2) => {
          const t2 = await this._p2pChannel.restartICE(e2), i3 = await t2.next();
          if (i3.done)
            return;
          const n2 = i3.value;
          let r2;
          try {
            r2 = await this._gateway.restartICE({ iceParameters: n2 });
          } catch (e3) {
            return void t2.throw(e3);
          }
          const { iceParameters: o2 } = function(e3) {
            const t3 = e3.iceParameters;
            return { iceParameters: { iceUfrag: t3.iceUfrag, icePwd: t3.icePwd } };
          }(r2);
          await t2.next({ remoteIceParameters: o2 });
        }), this._p2pChannel.on(DS.RequestReconnect, async () => {
          this._gateway.reconnect();
        }), this._p2pChannel.on(DS.RequestReconnectPC, async () => {
          var e2;
          const { iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 } = await this._p2pChannel.startP2PConnection({ turnServer: null === (e2 = this._joinInfo) || void 0 === e2 ? void 0 : e2.turnServer }), { gatewayEstablishParams: r2, gatewayAddress: o2 } = await this._gateway.reconnectPC({ iceParameters: t2, dtlsParameters: i3, rtpCapabilities: n2 }), { dtlsParameters: s2, iceParameters: a2, candidates: c2, rtpCapabilities: d2, setup: u2, cname: l2 } = GO(r2, o2);
          await this._p2pChannel.connect(a2, s2, c2, d2, u2, l2), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
        }), this._p2pChannel.on(DS.RequestUnpublishForReconnectPC, async (e2, t2, i3) => {
          this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e2, this._uid), t2()) : i3();
        }), this._p2pChannel.on(DS.P2PLost, () => {
          this.safeEmit(yf.P2P_LOST, this.store.uid);
        }), this._p2pChannel.on(DS.UpdateVideoEncoder, (e2) => {
          e2._encoderConfig && this._gateway.setVideoProfile(e2._encoderConfig);
        }), this._p2pChannel.on(DS.ConnectionTypeChange, (e2) => {
          this.safeEmit(yf.IS_USING_CLOUD_PROXY, e2);
        }), this._p2pChannel.on(DS.RequestLowStreamParameter, (e2) => {
          e2(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
        }), this._p2pChannel.on(DS.QueryClientConnectionState, (e2) => {
          e2(this.connectionState);
        });
      }
      getKeyMetrics() {
        return this.store.keyMetrics;
      }
      async enableContentInspect(e2) {
        if ("CONNECTED" !== this.connectionState || !this._joinInfo)
          throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel"));
        if (this._inspect)
          throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
        if (!e2)
          throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary"));
        if (!e2.inspectType || !Array.isArray(e2.inspectType))
          throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array."));
        {
          const t2 = [...new Set(e2.inspectType)];
          t2.forEach((e3) => {
            if (!["supervise", "moderation"].includes(e3))
              throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e3, " is not a valid inspect type."));
          }), e2.inspectType = t2;
        }
        if (e2 && e2.extraInfo && e2.extraInfo.length > 1024)
          throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes"));
        try {
          const t2 = new Ew(e2);
          this._inspect = t2, this.handleVideoInspectEvents(this._inspect), await t2.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, TE);
        } catch (e3) {
          throw Array.isArray(e3) ? e3[0] : e3;
        }
      }
      async disableContentInspect() {
        if (!this._inspect)
          throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
        try {
          this._inspect.close(), this._inspect = void 0;
        } catch (e2) {
          throw Array.isArray(e2) ? e2[0] : e2;
        }
      }
      async setImageModeration(e2, t2) {
        if (Km(e2, "enabled"), e2) {
          if (!t2)
            throw new SE(fE.INVALID_PARAMS, "[".concat(this._clientId, "] config is necessary"));
          if (qm(t2.interval, "interval", 1e3, 1 / 0), "CONNECTED" !== this.connectionState || !this._joinInfo)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, '] can not enable image moderation, not joined"'));
          try {
            if (this._moderation)
              return void this._moderation.updateConfig(t2);
            const e3 = new Jw(t2);
            this._moderation = e3, this.handleImageModerationEvents(this._moderation), await e3.init({ appId: this._joinInfo.appId, areaCode: "", cname: this._joinInfo.cname, sid: this._joinInfo.sid, token: this._joinInfo.token, uid: this._joinInfo.uid, cid: this._joinInfo.cid, vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0 }, TE);
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
        } else {
          if (!this._moderation)
            throw new SE(fE.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
          try {
            this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
          } catch (e3) {
            throw Array.isArray(e3) ? e3[0] : e3;
          }
        }
      }
      handleImageModerationEvents(e2) {
        e2.on(HS.CONNECTION_STATE_CHANGE, (t2, i3) => {
          switch (this.emit(yf.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, t2, i3), t2) {
            case WS2.CONNECTED:
              if ("CONNECTED" !== this.connectionState)
                throw this.setImageModeration(false), new SE(fE.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
              e2.inspectImage();
          }
        }), e2.on(HS.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
          e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
        });
      }
      handleVideoInspectEvents(e2) {
        e2.on(VS.CONNECTION_STATE_CHANGE, (t2, i3) => {
          switch (this.emit(yf.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t2, i3), i3) {
            case US.CONNECTED:
              if ("CONNECTED" !== this.connectionState)
                return void this.emit(yf.CONTENT_INSPECT_ERROR, new SE(fE.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
              e2.inspectImage();
          }
        }), e2.on(VS.INSPECT_RESULT, (e3, t2) => {
          var i3;
          if ((null == t2 ? void 0 : t2.code) === fE.INVALID_OPERATION && "DISCONNECTED" === this.connectionState)
            return OE.debug("Stop inspect content because that has left channel"), null == this || null === (i3 = this._inspect) || void 0 === i3 || i3.close(), void (this._inspect = void 0);
          this.emit(yf.CONTENT_INSPECT_RESULT, e3, t2);
        }), e2.on(VS.CLIENT_LOCAL_VIDEO_TRACK, (e3) => {
          e3(this.localTracks.filter((e4) => "video" === e4.trackMediaType)[0]);
        });
      }
      getJoinChannelServiceRecords() {
        return OE.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
      }
      async setPublishAudioFilterEnabled(e2) {
        Km(e2, "enabled"), BE("ENABLE_PUBLISH_AUDIO_FILTER", e2), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e2);
      }
      _handleResetAddStream(e2, t2) {
        switch (t2) {
          case "audio":
            e2._audio_added_ = false, e2._trust_audio_stream_added_state_ = true;
            break;
          case "video":
            e2._video_added_ = false, e2._trust_video_stream_added_state_ = true;
        }
      }
    }).prototype, "leave", [Xw], Object.getOwnPropertyDescriptor(kD.prototype, "leave"), kD.prototype), ag(kD.prototype, "publish", [zw], Object.getOwnPropertyDescriptor(kD.prototype, "publish"), kD.prototype), ag(kD.prototype, "unpublish", [Qw], Object.getOwnPropertyDescriptor(kD.prototype, "unpublish"), kD.prototype), ag(kD.prototype, "subscribe", [Zw], Object.getOwnPropertyDescriptor(kD.prototype, "subscribe"), kD.prototype), ag(kD.prototype, "massSubscribe", [$w], Object.getOwnPropertyDescriptor(kD.prototype, "massSubscribe"), kD.prototype), ag(kD.prototype, "unsubscribe", [eD], Object.getOwnPropertyDescriptor(kD.prototype, "unsubscribe"), kD.prototype), ag(kD.prototype, "massUnsubscribe", [tD], Object.getOwnPropertyDescriptor(kD.prototype, "massUnsubscribe"), kD.prototype), ag(kD.prototype, "setLowStreamParameter", [iD], Object.getOwnPropertyDescriptor(kD.prototype, "setLowStreamParameter"), kD.prototype), ag(kD.prototype, "enableDualStream", [nD], Object.getOwnPropertyDescriptor(kD.prototype, "enableDualStream"), kD.prototype), ag(kD.prototype, "disableDualStream", [rD], Object.getOwnPropertyDescriptor(kD.prototype, "disableDualStream"), kD.prototype), ag(kD.prototype, "setClientRole", [oD], Object.getOwnPropertyDescriptor(kD.prototype, "setClientRole"), kD.prototype), ag(kD.prototype, "setProxyServer", [sD], Object.getOwnPropertyDescriptor(kD.prototype, "setProxyServer"), kD.prototype), ag(kD.prototype, "setTurnServer", [aD], Object.getOwnPropertyDescriptor(kD.prototype, "setTurnServer"), kD.prototype), ag(kD.prototype, "setLicense", [cD], Object.getOwnPropertyDescriptor(kD.prototype, "setLicense"), kD.prototype), ag(kD.prototype, "startProxyServer", [dD], Object.getOwnPropertyDescriptor(kD.prototype, "startProxyServer"), kD.prototype), ag(kD.prototype, "stopProxyServer", [uD], Object.getOwnPropertyDescriptor(kD.prototype, "stopProxyServer"), kD.prototype), ag(kD.prototype, "setLocalAccessPointsV2", [lD], Object.getOwnPropertyDescriptor(kD.prototype, "setLocalAccessPointsV2"), kD.prototype), ag(kD.prototype, "setLocalAccessPoints", [hD], Object.getOwnPropertyDescriptor(kD.prototype, "setLocalAccessPoints"), kD.prototype), ag(kD.prototype, "setRemoteDefaultVideoStreamType", [pD], Object.getOwnPropertyDescriptor(kD.prototype, "setRemoteDefaultVideoStreamType"), kD.prototype), ag(kD.prototype, "setRemoteVideoStreamType", [_D], Object.getOwnPropertyDescriptor(kD.prototype, "setRemoteVideoStreamType"), kD.prototype), ag(kD.prototype, "setStreamFallbackOption", [ED], Object.getOwnPropertyDescriptor(kD.prototype, "setStreamFallbackOption"), kD.prototype), ag(kD.prototype, "setEncryptionConfig", [mD], Object.getOwnPropertyDescriptor(kD.prototype, "setEncryptionConfig"), kD.prototype), ag(kD.prototype, "renewToken", [fD], Object.getOwnPropertyDescriptor(kD.prototype, "renewToken"), kD.prototype), ag(kD.prototype, "enableAudioVolumeIndicator", [SD], Object.getOwnPropertyDescriptor(kD.prototype, "enableAudioVolumeIndicator"), kD.prototype), ag(kD.prototype, "startLiveStreaming", [TD], Object.getOwnPropertyDescriptor(kD.prototype, "startLiveStreaming"), kD.prototype), ag(kD.prototype, "setLiveTranscoding", [gD], Object.getOwnPropertyDescriptor(kD.prototype, "setLiveTranscoding"), kD.prototype), ag(kD.prototype, "stopLiveStreaming", [RD], Object.getOwnPropertyDescriptor(kD.prototype, "stopLiveStreaming"), kD.prototype), ag(kD.prototype, "addInjectStreamUrl", [ID], Object.getOwnPropertyDescriptor(kD.prototype, "addInjectStreamUrl"), kD.prototype), ag(kD.prototype, "removeInjectStreamUrl", [CD], Object.getOwnPropertyDescriptor(kD.prototype, "removeInjectStreamUrl"), kD.prototype), ag(kD.prototype, "startChannelMediaRelay", [vD], Object.getOwnPropertyDescriptor(kD.prototype, "startChannelMediaRelay"), kD.prototype), ag(kD.prototype, "updateChannelMediaRelay", [yD], Object.getOwnPropertyDescriptor(kD.prototype, "updateChannelMediaRelay"), kD.prototype), ag(kD.prototype, "stopChannelMediaRelay", [AD], Object.getOwnPropertyDescriptor(kD.prototype, "stopChannelMediaRelay"), kD.prototype), ag(kD.prototype, "sendCustomReportMessage", [OD], Object.getOwnPropertyDescriptor(kD.prototype, "sendCustomReportMessage"), kD.prototype), ag(kD.prototype, "pickSVCLayer", [ND], Object.getOwnPropertyDescriptor(kD.prototype, "pickSVCLayer"), kD.prototype), ag(kD.prototype, "enableContentInspect", [bD], Object.getOwnPropertyDescriptor(kD.prototype, "enableContentInspect"), kD.prototype), ag(kD.prototype, "disableContentInspect", [wD], Object.getOwnPropertyDescriptor(kD.prototype, "disableContentInspect"), kD.prototype), ag(kD.prototype, "setImageModeration", [DD], Object.getOwnPropertyDescriptor(kD.prototype, "setImageModeration"), kD.prototype), ag(kD.prototype, "getJoinChannelServiceRecords", [PD], Object.getOwnPropertyDescriptor(kD.prototype, "getJoinChannelServiceRecords"), kD.prototype), ag(kD.prototype, "setPublishAudioFilterEnabled", [LD], Object.getOwnPropertyDescriptor(kD.prototype, "setPublishAudioFilterEnabled"), kD.prototype), kD);
    class VD extends zg {
      set currentState(e2) {
        e2 !== this._currentState && (this._currentState = e2, this.safeEmit(Lf.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
      }
      get currentState() {
        return this._currentState;
      }
      constructor(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        super(), _p(this, "audioBuffer", void 0), _p(this, "sourceNode", void 0), _p(this, "startPlayTime", 0), _p(this, "startPlayOffset", 0), _p(this, "pausePlayTime", 0), _p(this, "options", void 0), _p(this, "currentLoopCount", 0), _p(this, "currentPlaybackSpeed", 100), _p(this, "_currentState", "stopped"), this.audioBuffer = e2, this.options = t2, this.startPlayOffset = this.options.startPlayTime || 0;
      }
      createWebAudioDiagram() {
        return this.context.createGain();
      }
      get duration() {
        return this.audioBuffer.duration;
      }
      get playbackSpeed() {
        return this.currentPlaybackSpeed;
      }
      get currentTime() {
        return "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration;
      }
      updateOptions(e2) {
        "stopped" === this.currentState ? (this.options = e2, this.startPlayOffset = this.options.startPlayTime || 0) : OE.warning("can not set audio source options");
      }
      startProcessAudioBuffer() {
        this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
      }
      pauseProcessAudioBuffer() {
        this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
      }
      seekAudioBuffer(e2) {
        this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e2, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e2));
      }
      resumeProcessAudioBuffer() {
        "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
      }
      stopProcessAudioBuffer() {
        if (this.sourceNode) {
          this.sourceNode.onended = null;
          try {
            this.sourceNode.stop();
          } catch (e2) {
          }
          this.reset();
        }
      }
      setAudioBufferPlaybackSpeed(e2) {
        this.sourceNode && ("playing" === this.currentState && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e2 / 100), this.currentPlaybackSpeed = e2;
      }
      startSourceNode() {
        this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
      }
      createSourceNode() {
        const e2 = this.context.createBufferSource();
        return e2.buffer = this.audioBuffer, e2.loop = !!this.options.loop, e2.connect(this.outputNode), e2.playbackRate.value = this.currentPlaybackSpeed / 100, e2;
      }
      handleSourceNodeEnded() {
        if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount)
          return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
        this.reset();
      }
      reset() {
        this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
      }
    }
    const jD = /* @__PURE__ */ new Map();
    async function FD(e2, t2) {
      let i3 = null;
      if ("string" == typeof e2) {
        const t3 = jD.get(e2);
        if (t3)
          return OE.debug("use cached audio resource: ", e2), t3;
        try {
          i3 = (await RE(() => pE.get(e2, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
        } catch (e3) {
          throw new SE(fE.FETCH_AUDIO_FILE_FAILED, e3.toString());
        }
      } else {
        const t3 = new Sl((t4, i4) => {
          const n3 = new FileReader();
          n3.onload = (e3) => {
            e3.target ? t4(e3.target.result) : i4(new SE(fE.READ_LOCAL_AUDIO_FILE_ERROR));
          }, n3.onerror = () => {
            i4(new SE(fE.READ_LOCAL_AUDIO_FILE_ERROR));
          }, n3.readAsArrayBuffer(e2);
        });
        i3 = await t3;
      }
      const n2 = await function(e3) {
        const t3 = Hg();
        return new Sl((i4, n3) => {
          t3.decodeAudioData(e3, (e4) => {
            i4(e4);
          }, (e4) => {
            n3(new SE(fE.DECODE_AUDIO_FILE_FAILED, e4.toString()));
          });
        });
      }(i3);
      return "string" == typeof e2 && t2 && jD.set(e2, n2), n2;
    }
    function BD(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function GD(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? BD(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : BD(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    function WD(e2, t2, i3, n2) {
      i3.optimizationMode && (n2 && n2.width && n2.height ? (i3.encoderConfig = GD(GD({}, n2), {}, { bitrateMin: n2.bitrateMin, bitrateMax: n2.bitrateMax }), "motion" !== i3.optimizationMode && "detail" !== i3.optimizationMode || (t2.contentHint = i3.optimizationMode, t2.contentHint === i3.optimizationMode ? OE.debug("[".concat(e2, "] set content hint to"), i3.optimizationMode) : OE.debug("[".concat(e2, "] set content hint failed")))) : OE.warning("[".concat(e2, "] can not apply optimization mode bitrate config, no encoderConfig")));
    }
    const HD = xh().name;
    function KD(e2, t2, i3, n2) {
      let r2, o2 = 0, s2 = null;
      return new Sl((a2, c2) => {
        setTimeout(() => {
          r2 && (r2(), a2(o2));
        }, t2), r2 = Jg(() => {
          !function() {
            o2 > n2 && r2 && (r2(), a2(o2));
            const t3 = i3.getContext("2d");
            if (!t3) {
              const e3 = new SE(fE.UNEXPECTED_ERROR, "can not get canvas 2d context.");
              return OE.error(e3.toString()), void c2(e3);
            }
            t3.drawImage(e2, 0, 0, 160, 120);
            const d2 = t3.getImageData(0, 0, i3.width, i3.height), u2 = Math.floor(d2.data.length / 3);
            if (s2) {
              for (let e3 = 0; e3 < u2; e3 += 3)
                if (d2.data[e3] !== s2[e3])
                  return o2 += 1, void (s2 = d2.data);
              s2 = d2.data;
            } else
              s2 = d2.data;
          }();
        }, 30);
      });
    }
    class YD {
      constructor(e2, t2) {
        _p(this, "id", 0), _p(this, "element", void 0), _p(this, "peerPair", void 0), _p(this, "context", void 0), _p(this, "audioPlayerElement", void 0), _p(this, "audioTrack", void 0), YD.count += 1, this.id = YD.count, this.element = e2, this.context = t2;
      }
      initPeers() {
        this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e2) => {
          const t2 = document.createElement("audio");
          t2.srcObject = new MediaStream([e2.track]), t2.play(), this.audioPlayerElement = t2;
        };
      }
      async switchSdp() {
        if (!this.peerPair)
          return;
        const e2 = async (e3, t3) => {
          const i3 = "offer" === t3 ? await e3.createOffer() : await e3.createAnswer();
          return await e3.setLocalDescription(i3), "complete" === e3.iceGatheringState ? e3.localDescription : new Sl((t4) => {
            e3.onicegatheringstatechange = () => {
              "complete" === e3.iceGatheringState && t4(e3.localDescription);
            };
          });
        }, t2 = async (e3, t3) => await e3.setRemoteDescription(t3);
        try {
          const i3 = await e2(this.peerPair[0], "offer");
          await t2(this.peerPair[1], i3);
          const n2 = await e2(this.peerPair[1], "answer");
          await t2(this.peerPair[0], n2);
        } catch (e3) {
          throw new SE(fE.LOCAL_AEC_ERROR, e3.toString()).print();
        }
      }
      async getTracksFromMediaElement(e2) {
        if (this.audioTrack)
          return this.audioTrack;
        let t2;
        try {
          e2 instanceof HTMLVideoElement && (e2.captureStream ? e2.captureStream() : e2.mozCaptureStream()), t2 = this.context.createMediaStreamDestination();
          this.context.createMediaElementSource(e2).connect(t2);
        } catch (e3) {
          throw new SE(fE.LOCAL_AEC_ERROR, e3.toString()).print();
        }
        if (!t2) {
          throw new SE(fE.LOCAL_AEC_ERROR, "no dest node when local aec").print();
        }
        const i3 = t2.stream.getAudioTracks()[0];
        return this.audioTrack = i3, i3;
      }
      getElement() {
        return this.element;
      }
      async startEchoCancellation() {
        this.context.resume(), this.peerPair && this.close(), this.initPeers();
        const e2 = this.element, t2 = await this.getTracksFromMediaElement(e2);
        this.peerPair && this.peerPair[0].addTrack(t2), await this.switchSdp();
      }
      close() {
        OE.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e2) => {
          e2.close();
        }), this.peerPair = void 0, this.audioPlayerElement = void 0;
      }
    }
    var qD, JD;
    _p(YD, "count", 0);
    const XD = window.AudioContext || window.webkitAudioContext;
    const zD = new (qD = Dg({ report: Pg }), ag((JD = class {
      constructor() {
        _p(this, "units", []), _p(this, "context", void 0);
      }
      processExternalMediaAEC(e2) {
        if (!this._doesEnvironmentNeedAEC())
          return OE.debug("the system does not need to process local aec"), -1;
        this.context || (this.context = new XD());
        let t2 = this.units.find((t3) => t3 && t3.getElement() === e2);
        return t2 || (t2 = new YD(e2, this.context), this.units.push(t2)), t2.startEchoCancellation(), OE.debug("start processing local audio echo cancellation, id is", t2.id), t2.id;
      }
      _doesEnvironmentNeedAEC() {
        return xh().name !== wh.SAFARI;
      }
    }).prototype, "processExternalMediaAEC", [qD], Object.getOwnPropertyDescriptor(JD.prototype, "processExternalMediaAEC"), JD.prototype), JD)();
    function QD(e2, t2) {
      var i3 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(e2);
        t2 && (n2 = n2.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), i3.push.apply(i3, n2);
      }
      return i3;
    }
    function ZD(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var i3 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? QD(Object(i3), true).forEach(function(t3) {
          _p(e2, t3, i3[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i3)) : QD(Object(i3)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i3, t3));
        });
      }
      return e2;
    }
    const $D = window || document;
    function eP(e2) {
      let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      if (!$D)
        return;
      const i3 = tP._cspEventHandlerPointer;
      if (i3 && t2)
        return void console.error(i3, t2);
      const n2 = (e3) => {
        if (!(e3 && e3.blockedURI && (tP.onSecurityPolicyViolation || tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length > 0)))
          return;
        const t3 = e3.blockedURI;
        GE("CSP_DETECTED_HOSTNAME_LIST").some((e4) => t3.includes(e4)) && (tP.onSecurityPolicyViolation && "function" == typeof tP.onSecurityPolicyViolation && tP.onSecurityPolicyViolation(e3), tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length > 0 && tP.safeEmit(BS.SECURITY_POLICY_VIOLATION, e3));
      };
      i3 && $D.removeEventListener("securitypolicyviolation", i3), (t2 || e2 && "function" == typeof e2 || tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length > 0) && $D.addEventListener("securitypolicyviolation", n2), tP._cspEventHandlerPointer = n2;
    }
    BE("PROCESS_ID", "process-".concat(ZI(8, ""), "-").concat(ZI(4, ""), "-").concat(ZI(4, ""), "-").concat(ZI(4, ""), "-").concat(ZI(12, ""))), function() {
      const e2 = xh();
      qS.getDisplayMedia = function(e3) {
        if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia)
          return true;
        return false;
      }(), qS.getStreamFromExtension = e2.name === wh.CHROME && Number(e2.version) > 34, qS.supportUnifiedPlan = function() {
        if (!window.RTCRtpTransceiver)
          return false;
        if (!("currentDirection" in RTCRtpTransceiver.prototype))
          return false;
        const e3 = new RTCPeerConnection();
        let t2 = false;
        try {
          e3.addTransceiver("audio"), t2 = true;
        } catch (e4) {
        }
        return e3.close(), t2;
      }(), qS.supportMinBitrate = e2.name === wh.CHROME || e2.name === wh.EDGE, qS.supportSetRtpSenderParameters = function() {
        const e3 = xh();
        if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters)
          return false;
        return !!rp() || (!(!Hh() && !Fh()) || e3.name === wh.FIREFOX && Number(e3.version) >= 64);
      }(), e2.name === wh.SAFARI && (Number(e2.version) >= 14 ? qS.supportDualStream = true : qS.supportDualStream = false), qS.webAudioMediaStreamDest = function() {
        const e3 = xh();
        if (e3.name === wh.SAFARI && Number(e3.version) < 12)
          return false;
        return true;
      }(), qS.supportReplaceTrack = function() {
        if (!window.RTCRtpSender)
          return false;
        if ("function" == typeof RTCRtpSender.prototype.replaceTrack)
          return true;
        return false;
      }(), qS.supportWebGL = "undefined" != typeof WebGLRenderingContext, qS.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, rp() || (qS.webAudioWithAEC = true), qS.supportShareAudio = function() {
        const e3 = xh();
        if ((e3.os === bh.WIN_10 || e3.os === bh.WIN_81 || e3.os === bh.WIN_7 || e3.os === bh.LINUX || e3.os === bh.MAC_OS) && e3.name === wh.CHROME && Number(e3.version) >= 74)
          return true;
        return false;
      }(), qS.supportDualStreamEncoding = function() {
        const e3 = xh();
        if (GE("DISABLE_WEBAUDIO"))
          return true;
        return "Safari" === e3.name && Number(e3.version) >= 14 || !!("Chrome" === e3.name && /Windows/i.test(e3.os || "") && Number(e3.version) >= 100 && GE("CHROME_DUAL_STREAM_USE_ENCODING"));
      }(), qS.supportDataChannel = function() {
        if (qh(76) || function(e3) {
          const t2 = xh();
          return !(t2.name !== wh.FIREFOX || !t2.osVersion) && Number(t2.version) >= e3;
        }(68) || function(e3) {
          const t2 = xh();
          return !(t2.name !== wh.SAFARI || !t2.osVersion) && Number(t2.version) >= e3;
        }(14))
          return true;
        return false;
      }(), qS.supportPCSetConfiguration = function() {
        const e3 = window.RTCPeerConnection;
        return !Kh() && !!e3 && e3.prototype.setConfiguration instanceof Function;
      }(), qS.supportWebRTCEncodedTransform = function() {
        const e3 = xh();
        return "Chrome" === e3.name && Number(e3.version) >= 86;
      }(), OE.info("browser compatibility", JSON.stringify(qS), JSON.stringify(e2));
    }(), function() {
      let e2;
      try {
        e2 = window.localStorage.getItem("websdk_ng_global_parameter");
      } catch (e3) {
        return void OE.error("Error loading sdk config", e3.message);
      }
      if (e2)
        try {
          const t2 = JSON.parse(window.atob(e2)), i3 = Date.now();
          OE.debug("Loading global parameters from cache", t2), Object.keys(t2).forEach((e3) => {
            if (Object.prototype.hasOwnProperty.call(WE, e3)) {
              const { value: n2, expires: r2 } = t2[e3];
              if (r2 && r2 <= i3)
                return;
              HE[e3] = n2, WE[e3] = n2;
            }
          });
        } catch (t2) {
          OE.error("Error loading mutableParamsCache: ".concat(e2), t2.message);
        }
    }(), Array.isArray(HE.AREAS) && HE.AREAS.length > 0 && qC(HE.AREAS, true);
    const tP = function(e2) {
      const t2 = new EE(), i3 = e2, n2 = { getListeners: t2.getListeners.bind(t2), on: (e3, i4) => (function(e4, t3) {
        e4 === BS.SECURITY_POLICY_VIOLATION && eP(t3, true);
      }(e3, i4), t2.on.bind(t2)(e3, i4)), addListener: t2.addListener.bind(t2), once: t2.once.bind(t2), off: t2.off.bind(t2), removeAllListeners: t2.removeAllListeners.bind(t2), emit: t2.emit.bind(t2), safeEmit: t2.safeEmit.bind(t2) };
      return ZD(ZD({}, i3), n2);
    }({ __CLIENT_LIST__: zE, __TRACK_LIST__: QE, VERSION: bE, BUILD: NE, setParameter: (e2, t2, i3) => {
      OE.debug("setParameter key:".concat(e2, ", value:").concat(JSON.stringify(t2))), BE(e2, t2, i3);
    }, getParameter: GE, getSupportedCodec: async function() {
      let e2 = { audio: [], video: [] };
      try {
        let t2 = new RTCPeerConnection();
        t2.addTransceiver("video", { direction: "recvonly" }), t2.addTransceiver("audio", { direction: "recvonly" });
        const i3 = (await t2.createOffer()).sdp;
        if (!i3)
          return e2;
        t2.close(), t2 = null, e2 = function(e3) {
          const t3 = { video: [], audio: [] };
          return e3.match(/ VP8/i) && t3.video.push("VP8"), e3.match(/ VP9/i) && t3.video.push("VP9"), e3.match(/ AV1/i) && t3.video.push("AV1"), e3.match(/ H264/i) && t3.video.push("H264"), e3.match(/ H265/i) && t3.video.push("H265"), e3.match(/ opus/i) && t3.audio.push("OPUS"), e3.match(/ PCMU/i) && t3.audio.push("PCMU"), e3.match(/ PCMA/i) && t3.audio.push("PCMA"), e3.match(/ G722/i) && t3.audio.push("G722"), t3;
        }(i3);
      } catch (e3) {
        throw new SE(fE.CREATE_OFFER_FAILED, e3.toString && e3.toString()).print();
      }
      return e2;
    }, checkSystemRequirements: function() {
      const e2 = Pg.reportApiInvoke(null, { name: _f.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: Ef.TRACER });
      let t2 = false;
      try {
        const e3 = window.RTCPeerConnection, i4 = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, n3 = window.WebSocket;
        t2 = !!(e3 && i4 && n3);
      } catch (e3) {
        return OE.error("check system requirement failed: ", e3), false;
      }
      let i3 = false;
      const n2 = xh();
      n2.name === wh.CHROME && Number(n2.version) >= 58 && (!Gh() || Bh()) && (i3 = true), n2.name === wh.FIREFOX && Number(n2.version) >= 56 && (i3 = true), n2.name === wh.OPERA && Number(n2.version) >= 45 && (i3 = true), n2.name === wh.SAFARI && Number(n2.version) >= 11 && (i3 = true), (ip() || xh().name === wh.QQ) && (i3 = true), OE.debug("checkSystemRequirements, api:", t2, "browser", i3);
      const r2 = t2 && i3;
      return e2.onSuccess(r2), r2;
    }, getDevices: function(e2) {
      return lR.enumerateDevices(true, true, e2);
    }, getMicrophones: function(e2) {
      return lR.getRecordingDevices(e2);
    }, getCameras: function(e2) {
      return lR.getCamerasDevices(e2);
    }, getElectronScreenSources: eR, getPlaybackDevices: function(e2) {
      return lR.getSpeakers(e2);
    }, createClient: function() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" };
      const t2 = Pg.reportApiInvoke(null, { name: _f.CREATE_CLIENT, options: [e2], tag: Ef.TRACER });
      try {
        Mf(e2);
      } catch (e3) {
        throw t2.onError(e3), e3;
      }
      return void 0 === e2.audioCodec && (e2.audioCodec = "opus"), t2.onSuccess(), new xD(UD(UD({ forceWaitGatewayResponse: true }, e2), {}, { role: "rtc" === e2.mode ? "host" : e2.role || "audience" }));
    }, createCameraVideoTrack: async function() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_CAM_VIDEO_TRACK, options: [GD({}, e2)] }), i3 = Mv(e2), n2 = ZI(8, "track-cam-");
      let r2 = null;
      OE.info("start create camera video track with config", JSON.stringify(e2), "trackId", n2);
      try {
        r2 = (await aR({ video: i3 }, n2)).getVideoTracks()[0] || null;
      } catch (e3) {
        throw t2.onError(e3), e3;
      }
      if (!r2) {
        const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find track in media stream");
        return t2.onError(e3), e3.throw();
      }
      e2.optimizationMode && WD(n2, r2, e2, UE(e2.encoderConfig));
      const o2 = new vy(r2, e2, i3, e2.scalabiltyMode ? VE(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, n2);
      return t2.onSuccess(o2.getTrackId()), OE.info("create camera video success, trackId:", n2), o2;
    }, createCustomVideoTrack: function(e2) {
      const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_CUSTOM_VIDEO_TRACK, options: [e2] }), i3 = new Cy(e2.mediaStreamTrack, { width: e2.width, height: e2.height, frameRate: e2.frameRate, bitrateMax: e2.bitrateMax, bitrateMin: e2.bitrateMin }, e2.scalabiltyMode ? VE(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, ZI(8, "track-cus-"), [lS.CUSTOM_TRACK]);
      return t2.onSuccess(i3.getTrackId()), OE.info("create custom video track success with config", e2, "trackId", i3.getTrackId()), i3;
    }, createScreenVideoTrack: async function() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
      const i3 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_SCREEN_VIDEO_TRACK, options: [GD({}, e2), t2] });
      e2.encoderConfig ? "string" == typeof e2.encoderConfig || e2.encoderConfig.width && e2.encoderConfig.height || (e2.encoderConfig.width = { max: 1920 }, e2.encoderConfig.height = { max: 1080 }) : e2.encoderConfig = "1080p_2";
      const n2 = Uv(e2), r2 = ZI(8, "track-scr-v-");
      let o2 = null, s2 = null;
      const a2 = JS();
      if (!a2.supportShareAudio && "enable" === t2) {
        const e3 = new SE(fE.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
        return i3.onError(e3), e3.throw();
      }
      OE.info("start create screen video track with config", e2, "withAudio", t2, "trackId", r2);
      try {
        const e3 = await aR({ screen: n2, screenAudio: "auto" === t2 ? a2.supportShareAudio : "enable" === t2 }, r2);
        o2 = e3.getVideoTracks()[0] || null, s2 = e3.getAudioTracks()[0] || null;
      } catch (e3) {
        throw i3.onError(e3), e3;
      }
      if (!o2) {
        const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find track in media stream");
        return i3.onError(e3), e3.throw();
      }
      if (!s2 && "enable" === t2) {
        o2 && o2.stop();
        const e3 = new SE(fE.SHARE_AUDIO_NOT_ALLOWED);
        return i3.onError(e3), e3.throw();
      }
      e2.optimizationMode || (e2.optimizationMode = "detail"), e2.optimizationMode && (WD(r2, o2, e2, e2.encoderConfig && xE(e2.encoderConfig)), e2.encoderConfig && "string" != typeof e2.encoderConfig && (e2.encoderConfig.bitrateMin = e2.encoderConfig.bitrateMax));
      const c2 = new Cy(o2, e2.encoderConfig ? xE(e2.encoderConfig) : {}, e2.scalabiltyMode ? VE(e2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e2.optimizationMode, r2, [lS.SCREEN_TRACK]);
      if (!s2)
        return i3.onSuccess(c2.getTrackId()), OE.info("create screen video track success", "video:", c2.getTrackId()), c2;
      const d2 = new yI(s2, void 0, ZI(8, "track-scr-a-"), false, true);
      return i3.onSuccess([c2.getTrackId(), d2.getTrackId()]), OE.info("create screen video track success", "video:", c2.getTrackId(), "audio:", d2.getTrackId()), [c2, d2];
    }, createMicrophoneAndCameraTracks: async function() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const i3 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_MIC_AND_CAM_TRACKS, options: [e2, t2] }), n2 = Mv(t2), r2 = xv(e2), o2 = ZI(8, "track-mic-"), s2 = ZI(8, "track-cam-");
      let a2 = null, c2 = null;
      OE.info("start create camera video track(".concat(s2, ") and microphone audio track(").concat(o2, ") with config, audio: ").concat(JSON.stringify(e2), ", video: ").concat(JSON.stringify(t2)));
      try {
        const e3 = await aR({ audio: r2, video: n2 }, "".concat(o2, "-").concat(s2));
        a2 = e3.getAudioTracks()[0], c2 = e3.getVideoTracks()[0];
      } catch (e3) {
        throw i3.onError(e3), e3;
      }
      if (!a2 || !c2) {
        const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find tracks in media stream");
        return i3.onError(e3), e3.throw();
      }
      t2.optimizationMode && WD(s2, c2, t2, UE(t2.encoderConfig));
      const d2 = new AI(a2, e2, r2, o2), u2 = new vy(c2, t2, n2, t2.scalabiltyMode ? VE(t2.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t2.optimizationMode, s2);
      return i3.onSuccess([d2.getTrackId(), u2.getTrackId()]), OE.info("create camera video track(".concat(s2, ") and microphone audio track(").concat(o2, ") success")), [d2, u2];
    }, createMicrophoneAudioTrack: async function() {
      let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_MIC_AUDIO_TRACK, options: [e2] }), i3 = xv(e2), n2 = ZI(8, "track-mic-");
      let r2 = null;
      OE.info("start create microphone audio track with config", JSON.stringify(e2), "trackId", n2);
      try {
        r2 = (await aR({ audio: i3 }, n2)).getAudioTracks()[0] || null;
      } catch (e3) {
        throw t2.onError(e3), e3;
      }
      if (!r2) {
        const e3 = new SE(fE.UNEXPECTED_ERROR, "can not find track in media stream");
        return t2.onError(e3), e3.throw();
      }
      const o2 = new AI(r2, e2, i3, n2);
      return t2.onSuccess(o2.getTrackId()), OE.info("create microphone audio track success, trackId:", n2), o2;
    }, createCustomAudioTrack: function(e2) {
      const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_CUSTOM_AUDIO_TRACK, options: [e2] }), i3 = new yI(e2.mediaStreamTrack, e2.encoderConfig ? FE(e2.encoderConfig) : {}, ZI(8, "track-cus-"), false, true);
      return OE.info("create custom audio track success with config", e2, "trackId", i3.getTrackId()), t2.onSuccess(i3.getTrackId()), i3;
    }, createBufferSourceAudioTrack: async function(e2) {
      const t2 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CREATE_BUFFER_AUDIO_TRACK, options: [e2] });
      if (GE("DISABLE_WEBAUDIO"))
        throw new SE(fE.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
      const i3 = ZI(8, "track-buf-");
      OE.info("start create buffer source audio track with config", JSON.stringify(e2), "trackId", i3);
      const n2 = e2.source;
      if (!(e2.source instanceof AudioBuffer))
        try {
          e2.source = await FD(e2.source, e2.cacheOnlineFile);
        } catch (e3) {
          return t2.onError(e3), e3.throw();
        }
      const r2 = new VD(e2.source), o2 = new OI(n2, r2, e2.encoderConfig ? FE(e2.encoderConfig) : {}, i3);
      return OE.info("create buffer source audio track success, trackId:", i3), t2.onSuccess(o2.getTrackId()), o2;
    }, setAppType: function(e2) {
      if (OE.debug("setAppType: ".concat(e2)), !(Number.isInteger(e2) && e2 >= 0))
        throw OE.debug("Invalid appType"), new SE(fE.INVALID_PARAMS, "invalid app type", e2);
      BE("APP_TYPE", Math.floor(e2));
    }, setLogLevel: function(e2) {
      OE.setLogLevel(e2);
    }, enableLogUpload: function() {
      GE("USE_NEW_LOG") ? BE("UPLOAD_LOG", true) : OE.enableLogUpload();
    }, disableLogUpload: function() {
      GE("USE_NEW_LOG") ? BE("UPLOAD_LOG", false) : OE.disableLogUpload();
    }, createChannelMediaRelayConfiguration: function() {
      return new vv();
    }, checkAudioTrackIsActive: async function(e2) {
      let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
      const i3 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [t2] });
      if (!(e2 instanceof yI || e2 instanceof nb)) {
        const e3 = new SE(fE.INVALID_TRACK, "the parameter is not a audio track");
        return i3.onError(e3), e3.throw();
      }
      t2 && t2 < 1e3 && (t2 = 1e3);
      const n2 = e2 instanceof yI ? e2.getTrackLabel() : "remote_track", r2 = e2.getVolumeLevel();
      let o2 = r2, s2 = r2;
      const a2 = Date.now();
      return new Sl((r3) => {
        const c2 = setInterval(() => {
          const d2 = e2.getVolumeLevel();
          o2 = d2 > o2 ? d2 : o2, s2 = d2 < s2 ? d2 : s2;
          const u2 = o2 - s2 > 1e-4, l2 = Date.now() - a2;
          if (u2 || l2 > t2) {
            clearInterval(c2);
            const t3 = u2, s3 = { duration: l2, deviceLabel: n2, maxVolumeLevel: o2, result: t3 };
            OE.info("[track-".concat(e2.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s3))), i3.onSuccess(s3), r3(t3);
          }
        }, 200);
      });
    }, checkVideoTrackIsActive: async function(e2) {
      let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
      const i3 = Pg.reportApiInvoke(null, { tag: Ef.TRACER, name: _f.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [t2] });
      if (!(e2 instanceof Cy || e2 instanceof ib)) {
        const e3 = new SE(fE.INVALID_TRACK, "the parameter is not a video track");
        return i3.onError(e3), e3.throw();
      }
      const n2 = 4;
      t2 && t2 < 1e3 && (t2 = 1e3);
      const r2 = e2 instanceof Cy ? e2.getTrackLabel() : "remote_track", o2 = e2.getMediaStreamTrack(true), s2 = document.createElement("video");
      s2.style.width = "1px", s2.style.height = "1px", s2.setAttribute("muted", ""), s2.muted = true, s2.setAttribute("playsinline", ""), s2.controls = false, (Hh() || Fh()) && (s2.style.opacity = "0.01", s2.style.position = "fixed", s2.style.left = "0", s2.style.top = "0", document.body.appendChild(s2)), s2.srcObject = new MediaStream([o2]), s2.play();
      const a2 = document.createElement("canvas");
      a2.width = 160, a2.height = 120;
      let c2 = 0, d2 = 0;
      try {
        const e3 = Date.now();
        c2 = await KD(s2, t2, a2, n2), d2 = Date.now() - e3;
      } catch (e3) {
        throw i3.onError(e3), e3;
      }
      HD === wh.SAFARI && (s2.pause(), s2.remove()), s2.srcObject = null;
      const u2 = c2 > n2, l2 = { duration: d2, changedPicNum: c2, deviceLabel: r2, result: u2 };
      return OE.info("[track-".concat(e2.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l2))), i3.onSuccess(l2), u2;
    }, setArea: qC, audioElementPlayCenter: pR, processExternalMediaAEC: function(e2) {
      zD.processExternalMediaAEC(e2);
    }, registerExtensions: function(e2) {
      e2.forEach((e3) => {
        const t2 = e3;
        t2.__registered__ = true, t2.logger.hookLog = OE.extLog, t2.reporter.hookApiInvoke = Pg.extApiInvoke, t2.parameters && Object.keys(t2.parameters).forEach((e4) => {
          t2.parameters[e4] = GE(e4);
        });
      });
    }, ChannelMediaRelayError: oS, ChannelMediaRelayEvent: nS, ChannelMediaRelayState: rS, RemoteStreamFallbackType: _S, RemoteStreamType: pS, ConnectionDisconnectedReason: vf, AudienceLatencyLevelType: Cf, AREAS: SS });
    return Object.defineProperties(tP, { onAudioAutoplayFailed: { get: () => vg.onAudioAutoplayFailed, set: (e2) => {
      vg.onAudioAutoplayFailed = e2;
    } }, onAutoplayFailed: { get: () => vg.onAutoplayFailed, set: (e2) => {
      vg.onAutoplayFailed = e2;
    } }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => tP._onSecurityPolicyViolation, set(e2) {
      tP._onSecurityPolicyViolation = e2, eP(e2);
    } } }), lR.on(ff.CAMERA_DEVICE_CHANGED, (e2) => {
      OE.info("camera device changed", JSON.stringify(e2)), tP.onCameraChanged && tP.onCameraChanged(e2), tP.safeEmit(BS.CAMERA_CHANGED, e2);
    }), lR.on(ff.RECORDING_DEVICE_CHANGED, (e2) => {
      OE.info("microphone device changed", JSON.stringify(e2)), tP.onMicrophoneChanged && tP.onMicrophoneChanged(e2), tP.safeEmit(BS.MICROPHONE_CHANGED, e2);
    }), lR.on(ff.PLAYOUT_DEVICE_CHANGED, (e2) => {
      OE.debug("playout device changed", JSON.stringify(e2)), tP.onPlaybackDeviceChanged && tP.onPlaybackDeviceChanged(e2), tP.safeEmit(BS.PLAYBACK_DEVICE_CHANGED, e2);
    }), pR.onAutoplayFailed = () => {
      OE.info("detect audio element autoplay failed"), vg.onAudioAutoplayFailed && vg.onAudioAutoplayFailed();
    }, Gg.on("autoplay-failed", () => {
      OE.info("detect webaudio autoplay failed"), vg.onAudioAutoplayFailed && vg.onAudioAutoplayFailed(), tP.safeEmit(BS.AUTOPLAY_FAILED);
    }), window && (window.__ARTC__ = tP), tP;
  });
})(AgoraRTC_NProduction);
var AgoraRTC_NProductionExports = AgoraRTC_NProduction.exports;
const AgoraRTC = /* @__PURE__ */ getDefaultExportFromCjs(AgoraRTC_NProductionExports);
const sweetCustom = "";
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data: data2 }, supportsBinary, callback) => {
  if (withNativeBlob$1 && data2 instanceof Blob) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(data2, callback);
    }
  } else if (withNativeArrayBuffer$2 && (data2 instanceof ArrayBuffer || isView$1(data2))) {
    if (supportsBinary) {
      return callback(data2);
    } else {
      return encodeBlobAsBase64(new Blob([data2]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data2 || ""));
};
const encodeBlobAsBase64 = (data2, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data2);
};
function toArray(data2) {
  if (data2 instanceof Uint8Array) {
    return data2;
  } else if (data2 instanceof ArrayBuffer) {
    return new Uint8Array(data2);
  } else {
    return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup$1[chars.charCodeAt(i2)] = i2;
}
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i2)];
    encoded2 = lookup$1[base64.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data2, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data2);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data: data2 };
  }
};
const mapBinary = (data2, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data2 instanceof Blob) {
        return data2;
      } else {
        return new Blob([data2]);
      }
    case "arraybuffer":
    default:
      if (data2 instanceof ArrayBuffer) {
        return data2;
      } else {
        return data2.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback) => {
  const length2 = packets.length;
  const encodedPackets = new Array(length2);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length2) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk2) => acc + chunk2.length, 0);
}
function concatChunks(chunks, size2) {
  if (chunks[0].length === size2) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size2);
  let j2 = 0;
  for (let i2 = 0; i2 < size2; i2++) {
    buffer[i2] = chunks[0][j2++];
    if (j2 === chunks[0].length) {
      chunks.shift();
      j2 = 0;
    }
  }
  if (chunks.length && j2 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j2);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state2 = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk2, controller) {
      chunks.push(chunk2);
      while (true) {
        if (state2 === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state2 = 3;
          } else if (expectedLength === 126) {
            state2 = 1;
          } else {
            state2 = 2;
          }
        } else if (state2 === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state2 = 3;
        } else if (state2 === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state2 = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data2 = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data2 : TEXT_DECODER.decode(data2), binaryType));
          state2 = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb = callbacks[i2];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
function pick(obj, ...attr) {
  return attr.reduce((acc, k2) => {
    if (obj.hasOwnProperty(k2)) {
      acc[k2] = obj[k2];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length2 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c = str.charCodeAt(i2);
    if (c < 128) {
      length2 += 1;
    } else if (c < 2048) {
      length2 += 2;
    } else if (c < 55296 || c >= 57344) {
      length2 += 3;
    } else {
      i2++;
      length2 += 4;
    }
  }
  return length2;
}
function encode$1(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data2) {
    const packet = decodePacket(data2, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode$1(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i = 0, prev;
function encode(num) {
  let encoded = "";
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now2 = encode(+/* @__PURE__ */ new Date());
  if (now2 !== prev)
    return seed = 0, prev = now2;
  return now2 + "." + encode(seed++);
}
for (; i < length; i++)
  map[alphabet[i]] = i;
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
function createCookieJar() {
}
function empty() {
}
const hasXHR2 = function() {
  const xhr2 = new XHR({
    xdomain: false
  });
  return null != xhr2.responseType;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
    if (this.opts.withCredentials) {
      this.cookieJar = createCookieJar();
    }
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data2) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data2, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data2) => {
      this.doWrite(data2, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
    return new Request(this.uri(), opts);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data2, fn) {
    const req = this.request({
      method: "POST",
      data: data2
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var _a;
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    const xhr2 = this.xhr = new XHR(opts);
    try {
      xhr2.open(this.method, this.uri, true);
      try {
        if (this.opts.extraHeaders) {
          xhr2.setDisableHeaderCheck && xhr2.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr2.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr2.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr2.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr2);
      if ("withCredentials" in xhr2) {
        xhr2.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr2.timeout = this.opts.requestTimeout;
      }
      xhr2.onreadystatechange = () => {
        var _a2;
        if (xhr2.readyState === 3) {
          (_a2 = this.opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(xhr2);
        }
        if (4 !== xhr2.readyState)
          return;
        if (200 === xhr2.status || 1223 === xhr2.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr2.status === "number" ? xhr2.status : 0);
          }, 0);
        }
      };
      xhr2.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const data2 = this.xhr.responseText;
    if (data2 !== null) {
      this.emitReserved("data", data2);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const WebSocket$1 = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
const usingBrowserWebSocket = true;
const defaultBinaryType = "arraybuffer";
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket$1(uri, protocols) : new WebSocket$1(uri) : new WebSocket$1(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data2) => {
        const opts = {};
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data2);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket$1;
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    if (typeof WebTransport !== "function") {
      return;
    }
    this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    this.transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this.writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this.writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      this.writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data2 = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data2[$1] = $2;
    }
  });
  return data2;
}
let Socket$1 = class Socket extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts = {}) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || [
      "polling",
      "websocket",
      "webtransport"
    ];
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        this.beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this.beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$1;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new transports[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to2) {
      if (transport && to2.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade) {
      let i2 = 0;
      const l = this.upgrades.length;
      for (; i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      this.resetPingTimeout();
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data2) {
    this.emitReserved("handshake", data2);
    this.id = data2.sid;
    this.transport.query.sid = data2.sid;
    this.upgrades = this.filterUpgrades(data2.upgrades);
    this.pingInterval = data2.pingInterval;
    this.pingTimeout = data2.pingTimeout;
    this.maxPayload = data2.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data2 = this.writeBuffer[i2].data;
      if (data2) {
        payloadSize += byteLength(data2);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  send(msg, options, fn) {
    this.sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(type, data2, options, fn) {
    if ("function" === typeof data2) {
      fn = data2;
      data2 = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data: data2,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(err) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("beforeunload", this.beforeunloadEventListener, false);
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j2 = upgrades.length;
    for (; i2 < j2; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket$1.protocol = protocol$1;
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON3) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (isBinary(data2)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data2);
    return placeholder;
  } else if (Array.isArray(data2)) {
    const newData = new Array(data2.length);
    for (let i2 = 0; i2 < data2.length; i2++) {
      newData[i2] = _deconstructPacket(data2[i2], buffers);
    }
    return newData;
  } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
    const newData = {};
    for (const key in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key)) {
        newData[key] = _deconstructPacket(data2[key], buffers);
      }
    }
    return newData;
  }
  return data2;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data2, buffers) {
  if (!data2)
    return data2;
  if (data2 && data2._placeholder === true) {
    const isIndexValid = typeof data2.num === "number" && data2.num >= 0 && data2.num < buffers.length;
    if (isIndexValid) {
      return buffers[data2.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data2)) {
    for (let i2 = 0; i2 < data2.length; i2++) {
      data2[i2] = _reconstructPacket(data2[i2], buffers);
    }
  } else if (typeof data2 === "object") {
    for (const key in data2) {
      if (Object.prototype.hasOwnProperty.call(data2, key)) {
        data2[key] = _reconstructPacket(data2[key], buffers);
      }
    }
  }
  return data2;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer2) {
    this.replacer = replacer2;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject$1(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i2 = 0;
    const p2 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p2.type] === void 0) {
      throw new Error("unknown packet type " + p2.type);
    }
    if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p2.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if ("," === c)
          break;
        if (i2 === str.length)
          break;
      }
      p2.nsp = str.substring(start, i2);
    } else {
      p2.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c = str.charAt(i2);
        if (null == c || Number(c) != c) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p2.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder.isPayloadValid(p2.type, payload)) {
        p2.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p2;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject$1(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject$1(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket)
      ;
    else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((resolve2, reject) => {
      args.push((arg1, arg2) => {
        if (withErr) {
          return arg1 ? reject(arg1) : resolve2(arg2);
        } else {
          return resolve2(arg1);
        }
      });
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data2) => {
        this._sendConnectPacket(data2);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data2) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data2) : data2
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    }
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min2) {
  this.ms = min2;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket2 = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket2, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket2, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket2.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket2 = this.engine;
    this.subs.push(on(socket2, "ping", this.onping.bind(this)), on(socket2, "data", this.ondata.bind(this)), on(socket2, "error", this.onerror.bind(this)), on(socket2, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data2) {
    try {
      this.decoder.add(data2);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket2 = this.nsps[nsp];
    if (!socket2) {
      socket2 = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket2;
    } else if (this._autoConnect && !socket2.active) {
      socket2.connect();
    }
    return socket2;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket2) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket3 = this.nsps[nsp];
      if (socket3.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
const state$1 = reactive({
  connected: false
});
const URL$1 = "https://socketio.bitmec.com:8443";
const socket$1 = lookup(URL$1, { secure: true });
socket$1.on("connect", () => {
  state$1.connected = true;
});
socket$1.on("disconnect", () => {
  state$1.connected = false;
});
const audioUrl = "" + new URL("test-sound-ee71ba8f.mp3", import.meta.url).href;
const VIcon$1 = "";
const aliases = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar"
};
const mdi = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (props) => h(VClassIcon, {
    ...props,
    class: "mdi"
  })
};
const IconValue = [String, Function, Object, Array];
const IconSymbol = Symbol.for("vuetify:icons");
const makeIconProps = propsFactory({
  icon: {
    type: IconValue
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: true
  }
}, "icon");
const VComponentIcon = genericComponent()({
  name: "VComponentIcon",
  props: makeIconProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      const Icon = props.icon;
      return createVNode(props.tag, null, {
        default: () => [props.icon ? createVNode(Icon, null, null) : slots.default?.()]
      });
    };
  }
});
const VSvgIcon = defineComponent({
  name: "VSvgIcon",
  inheritAttrs: false,
  props: makeIconProps(),
  setup(props, _ref2) {
    let {
      attrs
    } = _ref2;
    return () => {
      return createVNode(props.tag, mergeProps(attrs, {
        "style": null
      }), {
        default: () => [createVNode("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [Array.isArray(props.icon) ? props.icon.map((path) => Array.isArray(path) ? createVNode("path", {
          "d": path[0],
          "fill-opacity": path[1]
        }, null) : createVNode("path", {
          "d": path
        }, null)) : createVNode("path", {
          "d": props.icon
        }, null)])]
      });
    };
  }
});
defineComponent({
  name: "VLigatureIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, null, {
        default: () => [props.icon]
      });
    };
  }
});
const VClassIcon = defineComponent({
  name: "VClassIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, {
        "class": props.icon
      }, null);
    };
  }
});
const defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
};
function createIcons(options) {
  return mergeDeep({
    defaultSet: "mdi",
    sets: {
      ...defaultSets,
      mdi
    },
    aliases: {
      ...aliases,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z"
      /* eslint-enable max-len */
    }
  }, options);
}
const useIcon = (props) => {
  const icons = inject$1(IconSymbol);
  if (!icons)
    throw new Error("Missing Vuetify Icons provide!");
  const iconData = computed(() => {
    const iconAlias = unref(props);
    if (!iconAlias)
      return {
        component: VComponentIcon
      };
    let icon = iconAlias;
    if (typeof icon === "string") {
      icon = icon.trim();
      if (icon.startsWith("$")) {
        icon = icons.aliases?.[icon.slice(1)];
      }
    }
    if (!icon)
      throw new Error(`Could not find aliased icon "${iconAlias}"`);
    if (Array.isArray(icon)) {
      return {
        component: VSvgIcon,
        icon
      };
    } else if (typeof icon !== "string") {
      return {
        component: VComponentIcon,
        icon
      };
    }
    const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
    const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
    const iconSet = icons.sets[iconSetName ?? icons.defaultSet];
    return {
      component: iconSet.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};
const predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
const makeSizeProps = propsFactory({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function useSize(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  return destructComputed(() => {
    let sizeClasses;
    let sizeStyles;
    if (includes(predefinedSizes, props.size)) {
      sizeClasses = `${name}--size-${props.size}`;
    } else if (props.size) {
      sizeStyles = {
        width: convertToUnit(props.size),
        height: convertToUnit(props.size)
      };
    }
    return {
      sizeClasses,
      sizeStyles
    };
  });
}
const makeVIconProps = propsFactory({
  color: String,
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  ...makeComponentProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "i"
  }),
  ...makeThemeProps()
}, "VIcon");
const VIcon = genericComponent()({
  name: "VIcon",
  props: makeVIconProps(),
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const slotIcon = ref();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      iconData
    } = useIcon(computed(() => slotIcon.value || props.icon));
    const {
      sizeClasses
    } = useSize(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    useRender(() => {
      const slotValue = slots.default?.();
      if (slotValue) {
        slotIcon.value = flattenFragments(slotValue).filter((node) => node.type === Text && node.children && typeof node.children === "string")[0]?.children;
      }
      return createVNode(iconData.value.component, {
        "tag": props.tag,
        "icon": iconData.value.icon,
        "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
          "v-icon--clickable": !!attrs.onClick,
          "v-icon--start": props.start,
          "v-icon--end": props.end
        }, props.class],
        "style": [!sizeClasses.value ? {
          fontSize: convertToUnit(props.size),
          height: convertToUnit(props.size),
          width: convertToUnit(props.size)
        } : void 0, textColorStyles.value, props.style],
        "role": attrs.onClick ? "button" : void 0,
        "aria-hidden": !attrs.onClick
      }, {
        default: () => [slotValue]
      });
    });
    return {};
  }
});
const VTooltip$1 = "";
const VOverlay$1 = "";
function elementToViewport(point, offset2) {
  return {
    x: point.x + offset2.x,
    y: point.y + offset2.y
  };
}
function getOffset(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function anchorToPoint(anchor, box) {
  if (anchor.side === "top" || anchor.side === "bottom") {
    const {
      side,
      align
    } = anchor;
    const x2 = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
    const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
    return elementToViewport({
      x: x2,
      y
    }, box);
  } else if (anchor.side === "left" || anchor.side === "right") {
    const {
      side,
      align
    } = anchor;
    const x2 = side === "left" ? 0 : side === "right" ? box.width : side;
    const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
    return elementToViewport({
      x: x2,
      y
    }, box);
  }
  return elementToViewport({
    x: box.width / 2,
    y: box.height / 2
  }, box);
}
const locationStrategies = {
  static: staticLocationStrategy,
  // specific viewport position, usually centered
  connected: connectedLocationStrategy
  // connected to a certain element
};
const makeLocationStrategyProps = propsFactory({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (val) => typeof val === "function" || val in locationStrategies
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function useLocationStrategies(props, data2) {
  const contentStyles = ref({});
  const updateLocation = ref();
  if (IN_BROWSER) {
    useToggleScope(() => !!(data2.isActive.value && props.locationStrategy), (reset) => {
      watch(() => props.locationStrategy, reset);
      onScopeDispose(() => {
        updateLocation.value = void 0;
      });
      if (typeof props.locationStrategy === "function") {
        updateLocation.value = props.locationStrategy(data2, props, contentStyles)?.updateLocation;
      } else {
        updateLocation.value = locationStrategies[props.locationStrategy](data2, props, contentStyles)?.updateLocation;
      }
    });
    window.addEventListener("resize", onResize, {
      passive: true
    });
    onScopeDispose(() => {
      window.removeEventListener("resize", onResize);
      updateLocation.value = void 0;
    });
  }
  function onResize(e) {
    updateLocation.value?.(e);
  }
  return {
    contentStyles,
    updateLocation
  };
}
function staticLocationStrategy() {
}
function getIntrinsicSize(el, isRtl) {
  if (isRtl) {
    el.style.removeProperty("left");
  } else {
    el.style.removeProperty("right");
  }
  const contentBox = nullifyTransforms(el);
  if (isRtl) {
    contentBox.x += parseFloat(el.style.right || 0);
  } else {
    contentBox.x -= parseFloat(el.style.left || 0);
  }
  contentBox.y -= parseFloat(el.style.top || 0);
  return contentBox;
}
function connectedLocationStrategy(data2, props, contentStyles) {
  const activatorFixed = isFixedPosition(data2.activatorEl.value);
  if (activatorFixed) {
    Object.assign(contentStyles.value, {
      position: "fixed",
      top: 0,
      [data2.isRtl.value ? "right" : "left"]: 0
    });
  }
  const {
    preferredAnchor,
    preferredOrigin
  } = destructComputed(() => {
    const parsedAnchor = parseAnchor(props.location, data2.isRtl.value);
    const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data2.isRtl.value);
    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
      return {
        preferredAnchor: flipCorner(parsedAnchor),
        preferredOrigin: flipCorner(parsedOrigin)
      };
    } else {
      return {
        preferredAnchor: parsedAnchor,
        preferredOrigin: parsedOrigin
      };
    }
  });
  const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
    return computed(() => {
      const val = parseFloat(props[key]);
      return isNaN(val) ? Infinity : val;
    });
  });
  const offset2 = computed(() => {
    if (Array.isArray(props.offset)) {
      return props.offset;
    }
    if (typeof props.offset === "string") {
      const offset3 = props.offset.split(" ").map(parseFloat);
      if (offset3.length < 2)
        offset3.push(0);
      return offset3;
    }
    return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
  });
  let observe = false;
  const observer = new ResizeObserver(() => {
    if (observe)
      updateLocation();
  });
  watch([data2.activatorEl, data2.contentEl], (_ref, _ref2) => {
    let [newActivatorEl, newContentEl] = _ref;
    let [oldActivatorEl, oldContentEl] = _ref2;
    if (oldActivatorEl)
      observer.unobserve(oldActivatorEl);
    if (newActivatorEl)
      observer.observe(newActivatorEl);
    if (oldContentEl)
      observer.unobserve(oldContentEl);
    if (newContentEl)
      observer.observe(newContentEl);
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    observer.disconnect();
  });
  function updateLocation() {
    observe = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => observe = true);
    });
    if (!data2.activatorEl.value || !data2.contentEl.value)
      return;
    const targetBox = data2.activatorEl.value.getBoundingClientRect();
    const contentBox = getIntrinsicSize(data2.contentEl.value, data2.isRtl.value);
    const scrollParents = getScrollParents(data2.contentEl.value);
    const viewportMargin = 12;
    if (!scrollParents.length) {
      scrollParents.push(document.documentElement);
      if (!(data2.contentEl.value.style.top && data2.contentEl.value.style.left)) {
        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
      }
    }
    const viewport = scrollParents.reduce((box, el) => {
      const rect = el.getBoundingClientRect();
      const scrollBox = new Box({
        x: el === document.documentElement ? 0 : rect.x,
        y: el === document.documentElement ? 0 : rect.y,
        width: el.clientWidth,
        height: el.clientHeight
      });
      if (box) {
        return new Box({
          x: Math.max(box.left, scrollBox.left),
          y: Math.max(box.top, scrollBox.top),
          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
        });
      }
      return scrollBox;
    }, void 0);
    viewport.x += viewportMargin;
    viewport.y += viewportMargin;
    viewport.width -= viewportMargin * 2;
    viewport.height -= viewportMargin * 2;
    let placement = {
      anchor: preferredAnchor.value,
      origin: preferredOrigin.value
    };
    function checkOverflow2(_placement) {
      const box = new Box(contentBox);
      const targetPoint = anchorToPoint(_placement.anchor, targetBox);
      const contentPoint = anchorToPoint(_placement.origin, box);
      let {
        x: x3,
        y: y2
      } = getOffset(targetPoint, contentPoint);
      switch (_placement.anchor.side) {
        case "top":
          y2 -= offset2.value[0];
          break;
        case "bottom":
          y2 += offset2.value[0];
          break;
        case "left":
          x3 -= offset2.value[0];
          break;
        case "right":
          x3 += offset2.value[0];
          break;
      }
      switch (_placement.anchor.align) {
        case "top":
          y2 -= offset2.value[1];
          break;
        case "bottom":
          y2 += offset2.value[1];
          break;
        case "left":
          x3 -= offset2.value[1];
          break;
        case "right":
          x3 += offset2.value[1];
          break;
      }
      box.x += x3;
      box.y += y2;
      box.width = Math.min(box.width, maxWidth.value);
      box.height = Math.min(box.height, maxHeight.value);
      const overflows = getOverflow(box, viewport);
      return {
        overflows,
        x: x3,
        y: y2
      };
    }
    let x2 = 0;
    let y = 0;
    const available = {
      x: 0,
      y: 0
    };
    const flipped = {
      x: false,
      y: false
    };
    let resets = -1;
    while (true) {
      if (resets++ > 10) {
        break;
      }
      const {
        x: _x,
        y: _y,
        overflows
      } = checkOverflow2(placement);
      x2 += _x;
      y += _y;
      contentBox.x += _x;
      contentBox.y += _y;
      {
        const axis2 = getAxis(placement.anchor);
        const hasOverflowX = overflows.x.before || overflows.x.after;
        const hasOverflowY = overflows.y.before || overflows.y.after;
        let reset = false;
        ["x", "y"].forEach((key) => {
          if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
            const newPlacement = {
              anchor: {
                ...placement.anchor
              },
              origin: {
                ...placement.origin
              }
            };
            const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
            newPlacement.anchor = flip(newPlacement.anchor);
            newPlacement.origin = flip(newPlacement.origin);
            const {
              overflows: newOverflows
            } = checkOverflow2(newPlacement);
            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
              placement = newPlacement;
              reset = flipped[key] = true;
            }
          }
        });
        if (reset)
          continue;
      }
      if (overflows.x.before) {
        x2 += overflows.x.before;
        contentBox.x += overflows.x.before;
      }
      if (overflows.x.after) {
        x2 -= overflows.x.after;
        contentBox.x -= overflows.x.after;
      }
      if (overflows.y.before) {
        y += overflows.y.before;
        contentBox.y += overflows.y.before;
      }
      if (overflows.y.after) {
        y -= overflows.y.after;
        contentBox.y -= overflows.y.after;
      }
      {
        const overflows2 = getOverflow(contentBox, viewport);
        available.x = viewport.width - overflows2.x.before - overflows2.x.after;
        available.y = viewport.height - overflows2.y.before - overflows2.y.after;
        x2 += overflows2.x.before;
        contentBox.x += overflows2.x.before;
        y += overflows2.y.before;
        contentBox.y += overflows2.y.before;
      }
      break;
    }
    const axis = getAxis(placement.anchor);
    Object.assign(contentStyles.value, {
      "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: convertToUnit(pixelRound(y)),
      left: data2.isRtl.value ? void 0 : convertToUnit(pixelRound(x2)),
      right: data2.isRtl.value ? convertToUnit(pixelRound(-x2)) : void 0,
      minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
    });
    return {
      available,
      contentBox
    };
  }
  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());
  nextTick$1(() => {
    const result = updateLocation();
    if (!result)
      return;
    const {
      available,
      contentBox
    } = result;
    if (contentBox.height > available.y) {
      requestAnimationFrame(() => {
        updateLocation();
        requestAnimationFrame(() => {
          updateLocation();
        });
      });
    }
  });
  return {
    updateLocation
  };
}
function pixelRound(val) {
  return Math.round(val * devicePixelRatio) / devicePixelRatio;
}
function pixelCeil(val) {
  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
}
let clean = true;
const frames = [];
function requestNewFrame(cb) {
  if (!clean || frames.length) {
    frames.push(cb);
    run();
  } else {
    clean = false;
    cb();
    run();
  }
}
let raf = -1;
function run() {
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => {
    const frame = frames.shift();
    if (frame)
      frame();
    if (frames.length)
      run();
    else
      clean = true;
  });
}
const scrollStrategies = {
  none: null,
  close: closeScrollStrategy,
  block: blockScrollStrategy,
  reposition: repositionScrollStrategy
};
const makeScrollStrategyProps = propsFactory({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (val) => typeof val === "function" || val in scrollStrategies
  }
}, "VOverlay-scroll-strategies");
function useScrollStrategies(props, data2) {
  if (!IN_BROWSER)
    return;
  let scope;
  watchEffect(async () => {
    scope?.stop();
    if (!(data2.isActive.value && props.scrollStrategy))
      return;
    scope = effectScope();
    await nextTick$1();
    scope.active && scope.run(() => {
      if (typeof props.scrollStrategy === "function") {
        props.scrollStrategy(data2, props, scope);
      } else {
        scrollStrategies[props.scrollStrategy]?.(data2, props, scope);
      }
    });
  });
  onScopeDispose(() => {
    scope?.stop();
  });
}
function closeScrollStrategy(data2) {
  function onScroll(e) {
    data2.isActive.value = false;
  }
  bindScroll(data2.activatorEl.value ?? data2.contentEl.value, onScroll);
}
function blockScrollStrategy(data2, props) {
  const offsetParent = data2.root.value?.offsetParent;
  const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data2.activatorEl.value, props.contained ? offsetParent : void 0), ...getScrollParents(data2.contentEl.value, props.contained ? offsetParent : void 0)])].filter((el) => !el.classList.contains("v-overlay-scroll-blocked"));
  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
  const scrollableParent = ((el) => hasScrollbar(el) && el)(offsetParent || document.documentElement);
  if (scrollableParent) {
    data2.root.value.classList.add("v-overlay--scroll-blocked");
  }
  scrollElements.forEach((el, i2) => {
    el.style.setProperty("--v-body-scroll-x", convertToUnit(-el.scrollLeft));
    el.style.setProperty("--v-body-scroll-y", convertToUnit(-el.scrollTop));
    if (el !== document.documentElement) {
      el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    }
    el.classList.add("v-overlay-scroll-blocked");
  });
  onScopeDispose(() => {
    scrollElements.forEach((el, i2) => {
      const x2 = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
      const y = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
      el.style.removeProperty("--v-body-scroll-x");
      el.style.removeProperty("--v-body-scroll-y");
      el.style.removeProperty("--v-scrollbar-offset");
      el.classList.remove("v-overlay-scroll-blocked");
      el.scrollLeft = -x2;
      el.scrollTop = -y;
    });
    if (scrollableParent) {
      data2.root.value.classList.remove("v-overlay--scroll-blocked");
    }
  });
}
function repositionScrollStrategy(data2, props, scope) {
  let slow = false;
  let raf2 = -1;
  let ric = -1;
  function update3(e) {
    requestNewFrame(() => {
      const start = performance.now();
      data2.updateLocation.value?.(e);
      const time = performance.now() - start;
      slow = time / (1e3 / 60) > 2;
    });
  }
  ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
    scope.run(() => {
      bindScroll(data2.activatorEl.value ?? data2.contentEl.value, (e) => {
        if (slow) {
          cancelAnimationFrame(raf2);
          raf2 = requestAnimationFrame(() => {
            raf2 = requestAnimationFrame(() => {
              update3(e);
            });
          });
        } else {
          update3(e);
        }
      });
    });
  });
  onScopeDispose(() => {
    typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
    cancelAnimationFrame(raf2);
  });
}
function bindScroll(el, onScroll) {
  const scrollElements = [document, ...getScrollParents(el)];
  scrollElements.forEach((el2) => {
    el2.addEventListener("scroll", onScroll, {
      passive: true
    });
  });
  onScopeDispose(() => {
    scrollElements.forEach((el2) => {
      el2.removeEventListener("scroll", onScroll);
    });
  });
}
const VMenuSymbol = Symbol.for("vuetify:v-menu");
const makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props, cb) {
  const delays = {};
  const runDelayFactory = (prop) => () => {
    if (!IN_BROWSER)
      return Promise.resolve(true);
    const active = prop === "openDelay";
    delays.closeDelay && window.clearTimeout(delays.closeDelay);
    delete delays.closeDelay;
    delays.openDelay && window.clearTimeout(delays.openDelay);
    delete delays.openDelay;
    return new Promise((resolve2) => {
      const delay = parseInt(props[prop] ?? 0, 10);
      delays[prop] = window.setTimeout(() => {
        cb?.(active);
        resolve2(active);
      }, delay);
    });
  };
  return {
    runCloseDelay: runDelayFactory("closeDelay"),
    runOpenDelay: runDelayFactory("openDelay")
  };
}
const makeActivatorProps = propsFactory({
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...makeDelayProps()
}, "VOverlay-activator");
function useActivator(props, _ref) {
  let {
    isActive,
    isTop
  } = _ref;
  const activatorEl = ref();
  let isHovered = false;
  let isFocused = false;
  let firstEnter = true;
  const openOnFocus = computed(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
  const openOnClick = computed(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
  const {
    runOpenDelay,
    runCloseDelay
  } = useDelay(props, (value2) => {
    if (value2 === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
      if (isActive.value !== value2) {
        firstEnter = true;
      }
      isActive.value = value2;
    }
  });
  const availableEvents = {
    onClick: (e) => {
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      isActive.value = !isActive.value;
    },
    onMouseenter: (e) => {
      if (e.sourceCapabilities?.firesTouchEvents)
        return;
      isHovered = true;
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    onMouseleave: (e) => {
      isHovered = false;
      runCloseDelay();
    },
    onFocus: (e) => {
      if (matchesSelector(e.target, ":focus-visible") === false)
        return;
      isFocused = true;
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    onBlur: (e) => {
      isFocused = false;
      e.stopPropagation();
      runCloseDelay();
    }
  };
  const activatorEvents = computed(() => {
    const events = {};
    if (openOnClick.value) {
      events.onClick = availableEvents.onClick;
    }
    if (props.openOnHover) {
      events.onMouseenter = availableEvents.onMouseenter;
      events.onMouseleave = availableEvents.onMouseleave;
    }
    if (openOnFocus.value) {
      events.onFocus = availableEvents.onFocus;
      events.onBlur = availableEvents.onBlur;
    }
    return events;
  });
  const contentEvents = computed(() => {
    const events = {};
    if (props.openOnHover) {
      events.onMouseenter = () => {
        isHovered = true;
        runOpenDelay();
      };
      events.onMouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    if (openOnFocus.value) {
      events.onFocusin = () => {
        isFocused = true;
        runOpenDelay();
      };
      events.onFocusout = () => {
        isFocused = false;
        runCloseDelay();
      };
    }
    if (props.closeOnContentClick) {
      const menu = inject$1(VMenuSymbol, null);
      events.onClick = () => {
        isActive.value = false;
        menu?.closeParents();
      };
    }
    return events;
  });
  const scrimEvents = computed(() => {
    const events = {};
    if (props.openOnHover) {
      events.onMouseenter = () => {
        if (firstEnter) {
          isHovered = true;
          firstEnter = false;
          runOpenDelay();
        }
      };
      events.onMouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    return events;
  });
  watch(isTop, (val) => {
    if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered))) {
      isActive.value = false;
    }
  });
  const activatorRef = ref();
  watchEffect(() => {
    if (!activatorRef.value)
      return;
    nextTick$1(() => {
      activatorEl.value = refElement(activatorRef.value);
    });
  });
  const vm = getCurrentInstance("useActivator");
  let scope;
  watch(() => !!props.activator, (val) => {
    if (val && IN_BROWSER) {
      scope = effectScope();
      scope.run(() => {
        _useActivator(props, vm, {
          activatorEl,
          activatorEvents
        });
      });
    } else if (scope) {
      scope.stop();
    }
  }, {
    flush: "post",
    immediate: true
  });
  onScopeDispose(() => {
    scope?.stop();
  });
  return {
    activatorEl,
    activatorRef,
    activatorEvents,
    contentEvents,
    scrimEvents
  };
}
function _useActivator(props, vm, _ref2) {
  let {
    activatorEl,
    activatorEvents
  } = _ref2;
  watch(() => props.activator, (val, oldVal) => {
    if (oldVal && val !== oldVal) {
      const activator = getActivator(oldVal);
      activator && unbindActivatorProps(activator);
    }
    if (val) {
      nextTick$1(() => bindActivatorProps());
    }
  }, {
    immediate: true
  });
  watch(() => props.activatorProps, () => {
    bindActivatorProps();
  });
  onScopeDispose(() => {
    unbindActivatorProps();
  });
  function bindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
    if (!el)
      return;
    bindProps(el, mergeProps(activatorEvents.value, _props));
  }
  function unbindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
    if (!el)
      return;
    unbindProps(el, mergeProps(activatorEvents.value, _props));
  }
  function getActivator() {
    let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
    let activator;
    if (selector) {
      if (selector === "parent") {
        let el = vm?.proxy?.$el?.parentNode;
        while (el?.hasAttribute("data-no-activator")) {
          el = el.parentNode;
        }
        activator = el;
      } else if (typeof selector === "string") {
        activator = document.querySelector(selector);
      } else if ("$el" in selector) {
        activator = selector.$el;
      } else {
        activator = selector;
      }
    }
    activatorEl.value = activator?.nodeType === Node.ELEMENT_NODE ? activator : null;
    return activatorEl.value;
  }
}
function useHydration() {
  if (!IN_BROWSER)
    return shallowRef(false);
  const {
    ssr
  } = useDisplay();
  if (ssr) {
    const isMounted = shallowRef(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return isMounted;
  } else {
    return shallowRef(true);
  }
}
const makeLazyProps = propsFactory({
  eager: Boolean
}, "lazy");
function useLazy(props, active) {
  const isBooted = shallowRef(false);
  const hasContent = computed(() => isBooted.value || props.eager || active.value);
  watch(active, () => isBooted.value = true);
  function onAfterLeave() {
    if (!props.eager)
      isBooted.value = false;
  }
  return {
    isBooted,
    hasContent,
    onAfterLeave
  };
}
function useRouter() {
  return getCurrentInstance("useRouter")?.proxy?.$router;
}
function useLink(props, attrs) {
  const RouterLink2 = resolveDynamicComponent("RouterLink");
  const isLink = computed(() => !!(props.href || props.to));
  const isClickable = computed(() => {
    return isLink?.value || hasEvent(attrs, "click") || hasEvent(props, "click");
  });
  if (typeof RouterLink2 === "string") {
    return {
      isLink,
      isClickable,
      href: toRef(props, "href")
    };
  }
  const link = props.to ? RouterLink2.useLink(props) : void 0;
  return {
    isLink,
    isClickable,
    route: link?.route,
    navigate: link?.navigate,
    isActive: link && computed(() => props.exact ? link.isExactActive?.value : link.isActive?.value),
    href: computed(() => props.to ? link?.route.value.href : props.href)
  };
}
const makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let inTransition = false;
function useBackButton(router2, cb) {
  let popped = false;
  let removeBefore;
  let removeAfter;
  if (IN_BROWSER) {
    nextTick$1(() => {
      window.addEventListener("popstate", onPopstate);
      removeBefore = router2?.beforeEach((to2, from2, next) => {
        if (!inTransition) {
          setTimeout(() => popped ? cb(next) : next());
        } else {
          popped ? cb(next) : next();
        }
        inTransition = true;
      });
      removeAfter = router2?.afterEach(() => {
        inTransition = false;
      });
    });
    onScopeDispose(() => {
      window.removeEventListener("popstate", onPopstate);
      removeBefore?.();
      removeAfter?.();
    });
  }
  function onPopstate(e) {
    if (e.state?.replaced)
      return;
    popped = true;
    setTimeout(() => popped = false);
  }
}
function useScopeId() {
  const vm = getCurrentInstance("useScopeId");
  const scopeId = vm.vnode.scopeId;
  return {
    scopeId: scopeId ? {
      [scopeId]: ""
    } : void 0
  };
}
const StackSymbol = Symbol.for("vuetify:stack");
const globalStack = reactive([]);
function useStack(isActive, zIndex, disableGlobalStack) {
  const vm = getCurrentInstance("useStack");
  const createStackEntry = !disableGlobalStack;
  const parent = inject$1(StackSymbol, void 0);
  const stack = reactive({
    activeChildren: /* @__PURE__ */ new Set()
  });
  provide(StackSymbol, stack);
  const _zIndex = shallowRef(+zIndex.value);
  useToggleScope(isActive, () => {
    const lastZIndex = globalStack.at(-1)?.[1];
    _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
    if (createStackEntry) {
      globalStack.push([vm.uid, _zIndex.value]);
    }
    parent?.activeChildren.add(vm.uid);
    onScopeDispose(() => {
      if (createStackEntry) {
        const idx = toRaw(globalStack).findIndex((v) => v[0] === vm.uid);
        globalStack.splice(idx, 1);
      }
      parent?.activeChildren.delete(vm.uid);
    });
  });
  const globalTop = shallowRef(true);
  if (createStackEntry) {
    watchEffect(() => {
      const _isTop = globalStack.at(-1)?.[0] === vm.uid;
      setTimeout(() => globalTop.value = _isTop);
    });
  }
  const localTop = computed(() => !stack.activeChildren.size);
  return {
    globalTop: readonly(globalTop),
    localTop,
    stackStyles: computed(() => ({
      zIndex: _zIndex.value
    }))
  };
}
function useTeleport(target) {
  const teleportTarget = computed(() => {
    const _target = target.value;
    if (_target === true || !IN_BROWSER)
      return void 0;
    const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
    if (targetElement == null) {
      return void 0;
    }
    let container = targetElement.querySelector(":scope > .v-overlay-container");
    if (!container) {
      container = document.createElement("div");
      container.className = "v-overlay-container";
      targetElement.appendChild(container);
    }
    return container;
  });
  return {
    teleportTarget
  };
}
function defaultConditional() {
  return true;
}
function checkEvent(e, el, binding) {
  if (!e || checkIsActive(e, binding) === false)
    return false;
  const root = attachedRoot(el);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
    return false;
  const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
  elements.push(el);
  return !elements.some((el2) => el2?.contains(e.target));
}
function checkIsActive(e, binding) {
  const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
  return isActive(e);
}
function directive(e, el, binding) {
  const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
  el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
    checkIsActive(e, binding) && handler && handler(e);
  }, 0);
}
function handleShadow(el, callback) {
  const root = attachedRoot(el);
  callback(document);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
    callback(root);
  }
}
const ClickOutside = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(el, binding) {
    const onClick = (e) => directive(e, el, binding);
    const onMousedown = (e) => {
      el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
    };
    handleShadow(el, (app2) => {
      app2.addEventListener("click", onClick, true);
      app2.addEventListener("mousedown", onMousedown, true);
    });
    if (!el._clickOutside) {
      el._clickOutside = {
        lastMousedownWasOutside: false
      };
    }
    el._clickOutside[binding.instance.$.uid] = {
      onClick,
      onMousedown
    };
  },
  unmounted(el, binding) {
    if (!el._clickOutside)
      return;
    handleShadow(el, (app2) => {
      if (!app2 || !el._clickOutside?.[binding.instance.$.uid])
        return;
      const {
        onClick,
        onMousedown
      } = el._clickOutside[binding.instance.$.uid];
      app2.removeEventListener("click", onClick, true);
      app2.removeEventListener("mousedown", onMousedown, true);
    });
    delete el._clickOutside[binding.instance.$.uid];
  }
};
function Scrim(props) {
  const {
    modelValue,
    color,
    ...rest
  } = props;
  return createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props.modelValue && createVNode("div", mergeProps({
      "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
      "style": props.color.backgroundColorStyles.value
    }, rest), null)]
  });
}
const makeVOverlayProps = propsFactory({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: true
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...makeActivatorProps(),
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeLazyProps(),
  ...makeLocationStrategyProps(),
  ...makeScrollStrategyProps(),
  ...makeThemeProps(),
  ...makeTransitionProps$1()
}, "VOverlay");
const VOverlay = genericComponent()({
  name: "VOverlay",
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: {
    _disableGlobalStack: Boolean,
    ...makeVOverlayProps()
  },
  emits: {
    "click:outside": (e) => true,
    "update:modelValue": (value2) => true,
    afterLeave: () => true
  },
  setup(props, _ref) {
    let {
      slots,
      attrs,
      emit: emit2
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const isActive = computed({
      get: () => model.value,
      set: (v) => {
        if (!(v && props.disabled))
          model.value = v;
      }
    });
    const {
      teleportTarget
    } = useTeleport(computed(() => props.attach || props.contained));
    const {
      themeClasses
    } = provideTheme(props);
    const {
      rtlClasses,
      isRtl
    } = useRtl();
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props, isActive);
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props.scrim === "string" ? props.scrim : null;
    }));
    const {
      globalTop,
      localTop,
      stackStyles
    } = useStack(isActive, toRef(props, "zIndex"), props._disableGlobalStack);
    const {
      activatorEl,
      activatorRef,
      activatorEvents,
      contentEvents,
      scrimEvents
    } = useActivator(props, {
      isActive,
      isTop: localTop
    });
    const {
      dimensionStyles
    } = useDimension(props);
    const isMounted = useHydration();
    const {
      scopeId
    } = useScopeId();
    watch(() => props.disabled, (v) => {
      if (v)
        isActive.value = false;
    });
    const root = ref();
    const contentEl = ref();
    const {
      contentStyles,
      updateLocation
    } = useLocationStrategies(props, {
      isRtl,
      contentEl,
      activatorEl,
      isActive
    });
    useScrollStrategies(props, {
      root,
      contentEl,
      activatorEl,
      isActive,
      updateLocation
    });
    function onClickOutside(e) {
      emit2("click:outside", e);
      if (!props.persistent)
        isActive.value = false;
      else
        animateClick();
    }
    function closeConditional() {
      return isActive.value && globalTop.value;
    }
    IN_BROWSER && watch(isActive, (val) => {
      if (val) {
        window.addEventListener("keydown", onKeydown);
      } else {
        window.removeEventListener("keydown", onKeydown);
      }
    }, {
      immediate: true
    });
    function onKeydown(e) {
      if (e.key === "Escape" && globalTop.value) {
        if (!props.persistent) {
          isActive.value = false;
          if (contentEl.value?.contains(document.activeElement)) {
            activatorEl.value?.focus();
          }
        } else
          animateClick();
      }
    }
    const router2 = useRouter();
    useToggleScope(() => props.closeOnBack, () => {
      useBackButton(router2, (next) => {
        if (globalTop.value && isActive.value) {
          next(false);
          if (!props.persistent)
            isActive.value = false;
          else
            animateClick();
        } else {
          next();
        }
      });
    });
    const top = ref();
    watch(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
      if (val) {
        const scrollParent = getScrollParent(root.value);
        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    });
    function animateClick() {
      if (props.noClickAnimation)
        return;
      contentEl.value && animate(contentEl.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: standardEasing
      });
    }
    useRender(() => createVNode(Fragment, null, [slots.activator?.({
      isActive: isActive.value,
      props: mergeProps({
        ref: activatorRef
      }, activatorEvents.value, props.activatorProps)
    }), isMounted.value && hasContent.value && createVNode(Teleport, {
      "disabled": !teleportTarget.value,
      "to": teleportTarget.value
    }, {
      default: () => [createVNode("div", mergeProps({
        "class": ["v-overlay", {
          "v-overlay--absolute": props.absolute || props.contained,
          "v-overlay--active": isActive.value,
          "v-overlay--contained": props.contained
        }, themeClasses.value, rtlClasses.value, props.class],
        "style": [stackStyles.value, {
          top: convertToUnit(top.value)
        }, props.style],
        "ref": root
      }, scopeId, attrs), [createVNode(Scrim, mergeProps({
        "color": scrimColor,
        "modelValue": isActive.value && !!props.scrim
      }, scrimEvents.value), null), createVNode(MaybeTransition, {
        "appear": true,
        "persisted": true,
        "transition": props.transition,
        "target": activatorEl.value,
        "onAfterLeave": () => {
          onAfterLeave();
          emit2("afterLeave");
        }
      }, {
        default: () => [withDirectives(createVNode("div", mergeProps({
          "ref": contentEl,
          "class": ["v-overlay__content", props.contentClass],
          "style": [dimensionStyles.value, contentStyles.value]
        }, contentEvents.value, props.contentProps), [slots.default?.({
          isActive
        })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
          handler: onClickOutside,
          closeConditional,
          include: () => [activatorEl.value]
        }]])]
      })])]
    })]));
    return {
      activatorEl,
      animateClick,
      contentEl,
      globalTop,
      localTop,
      updateLocation
    };
  }
});
const Refs = Symbol("Forwarded refs");
function getDescriptor(obj, key) {
  let currentObj = obj;
  while (currentObj) {
    const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
    if (descriptor)
      return descriptor;
    currentObj = Object.getPrototypeOf(currentObj);
  }
  return void 0;
}
function forwardRefs(target) {
  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    refs[_key - 1] = arguments[_key];
  }
  target[Refs] = refs;
  return new Proxy(target, {
    get(target2, key) {
      if (Reflect.has(target2, key)) {
        return Reflect.get(target2, key);
      }
      if (typeof key === "symbol" || key.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          const val = Reflect.get(ref2.value, key);
          return typeof val === "function" ? val.bind(ref2.value) : val;
        }
      }
    },
    has(target2, key) {
      if (Reflect.has(target2, key)) {
        return true;
      }
      if (typeof key === "symbol" || key.startsWith("__"))
        return false;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          return true;
        }
      }
      return false;
    },
    set(target2, key, value2) {
      if (Reflect.has(target2, key)) {
        return Reflect.set(target2, key, value2);
      }
      if (typeof key === "symbol" || key.startsWith("__"))
        return false;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          return Reflect.set(ref2.value, key, value2);
        }
      }
      return false;
    },
    getOwnPropertyDescriptor(target2, key) {
      const descriptor = Reflect.getOwnPropertyDescriptor(target2, key);
      if (descriptor)
        return descriptor;
      if (typeof key === "symbol" || key.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (!ref2.value)
          continue;
        const descriptor2 = getDescriptor(ref2.value, key) ?? ("_" in ref2.value ? getDescriptor(ref2.value._?.setupState, key) : void 0);
        if (descriptor2)
          return descriptor2;
      }
      for (const ref2 of refs) {
        const childRefs = ref2.value && ref2.value[Refs];
        if (!childRefs)
          continue;
        const queue2 = childRefs.slice();
        while (queue2.length) {
          const ref3 = queue2.shift();
          const descriptor2 = getDescriptor(ref3.value, key);
          if (descriptor2)
            return descriptor2;
          const childRefs2 = ref3.value && ref3.value[Refs];
          if (childRefs2)
            queue2.push(...childRefs2);
        }
      }
      return void 0;
    }
  });
}
const makeVTooltipProps = propsFactory({
  id: String,
  text: String,
  ...omit(makeVOverlayProps({
    closeOnBack: false,
    location: "end",
    locationStrategy: "connected",
    eager: true,
    minWidth: 0,
    offset: 10,
    openOnClick: false,
    openOnHover: true,
    origin: "auto",
    scrim: false,
    scrollStrategy: "reposition",
    transition: false
  }), ["absolute", "persistent"])
}, "VTooltip");
const VTooltip = genericComponent()({
  name: "VTooltip",
  props: makeVTooltipProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props.id || `v-tooltip-${uid2}`);
    const overlay = ref();
    const location2 = computed(() => {
      return props.location.split(" ").length > 1 ? props.location : props.location + " center";
    });
    const origin = computed(() => {
      return props.origin === "auto" || props.origin === "overlap" || props.origin.split(" ").length > 1 || props.location.split(" ").length > 1 ? props.origin : props.origin + " center";
    });
    const transition = computed(() => {
      if (props.transition)
        return props.transition;
      return isActive.value ? "scale-transition" : "fade-transition";
    });
    const activatorProps = computed(() => mergeProps({
      "aria-describedby": id.value
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-tooltip", props.class],
        "style": props.style,
        "id": id.value
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "transition": transition.value,
        "absolute": true,
        "location": location2.value,
        "origin": origin.value,
        "persistent": true,
        "role": "tooltip",
        "activatorProps": activatorProps.value,
        "_disableGlobalStack": true
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return slots.default?.(...args) ?? props.text;
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const _sfc_main$b = {
  data() {
    return {
      dialogVsInfo: false
    };
  },
  props: {
    // Dialog title
    vitalSignName: {
      type: String
    },
    // Vs indications for patient
    indications: {
      type: Array
    }
  }
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    createVNode(VTooltip, { location: "bottom" }, {
      activator: withCtx(({ props }) => [
        createVNode(VIcon, mergeProps({
          color: "blue-grey-lighten-2",
          dark: ""
        }, props), {
          default: withCtx(() => [
            createTextVNode(" mdi-help-circle ")
          ]),
          _: 2
        }, 1040)
      ]),
      default: withCtx(() => [
        createBaseVNode("ul", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.indications, (item) => {
            return openBlock(), createElementBlock("li", { key: item }, toDisplayString(item), 1);
          }), 128))
        ])
      ]),
      _: 1
    })
  ]);
}
const DialogWithVsIndication = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
const DiasSysComponent_vue_vue_type_style_index_0_lang = "";
const VBtn$1 = "";
const VBtnToggle$1 = "";
const VBtnGroup$1 = "";
const makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, "border");
function useBorder(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const borderClasses = computed(() => {
    const border = isRef(props) ? props.value : props.border;
    const classes = [];
    if (border === true || border === "") {
      classes.push(`${name}--border`);
    } else if (typeof border === "string" || border === 0) {
      for (const value2 of String(border).split(" ")) {
        classes.push(`border-${value2}`);
      }
    }
    return classes;
  });
  return {
    borderClasses
  };
}
const allowedDensities$1 = [null, "default", "comfortable", "compact"];
const makeDensityProps = propsFactory({
  density: {
    type: String,
    default: "default",
    validator: (v) => allowedDensities$1.includes(v)
  }
}, "density");
function useDensity(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const densityClasses = computed(() => {
    return `${name}--density-${props.density}`;
  });
  return {
    densityClasses
  };
}
const makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],
    validator(v) {
      const value2 = parseInt(v);
      return !isNaN(value2) && value2 >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      value2 <= 24;
    }
  }
}, "elevation");
function useElevation(props) {
  const elevationClasses = computed(() => {
    const elevation = isRef(props) ? props.value : props.elevation;
    const classes = [];
    if (elevation == null)
      return classes;
    classes.push(`elevation-${elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}
const allowedVariants$1 = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function genOverlays(isClickable, name) {
  return createVNode(Fragment, null, [isClickable && createVNode("span", {
    "key": "overlay",
    "class": `${name}__overlay`
  }, null), createVNode("span", {
    "key": "underlay",
    "class": `${name}__underlay`
  }, null)]);
}
const makeVariantProps = propsFactory({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (v) => allowedVariants$1.includes(v)
  }
}, "variant");
function useVariant(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const variantClasses = computed(() => {
    const {
      variant
    } = unref(props);
    return `${name}--variant-${variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor(computed(() => {
    const {
      variant,
      color
    } = unref(props);
    return {
      [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
    };
  }));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}
const makeVBtnGroupProps = propsFactory({
  divided: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps()
}, "VBtnGroup");
const VBtnGroup = genericComponent()({
  name: "VBtnGroup",
  props: makeVBtnGroupProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    provideDefaults({
      VBtn: {
        height: "auto",
        color: toRef(props, "color"),
        density: toRef(props, "density"),
        flat: true,
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      return createVNode(props.tag, {
        "class": ["v-btn-group", {
          "v-btn-group--divided": props.divided
        }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props.class],
        "style": props.style
      }, slots);
    });
  }
});
const makeGroupProps = propsFactory({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group");
const makeGroupItemProps = propsFactory({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function useGroupItem(props, injectKey) {
  let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const vm = getCurrentInstance("useGroupItem");
  if (!vm) {
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  }
  const id = getUid();
  provide(Symbol.for(`${injectKey.description}:id`), id);
  const group = inject$1(injectKey, null);
  if (!group) {
    if (!required)
      return group;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }
  const value2 = toRef(props, "value");
  const disabled = computed(() => !!(group.disabled.value || props.disabled));
  group.register({
    id,
    value: value2,
    disabled
  }, vm);
  onBeforeUnmount(() => {
    group.unregister(id);
  });
  const isSelected = computed(() => {
    return group.isSelected(id);
  });
  const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
  watch(isSelected, (value3) => {
    vm.emit("group:selected", {
      value: value3
    });
  });
  return {
    id,
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: (value3) => group.select(id, value3),
    selectedClass,
    value: value2,
    disabled,
    group
  };
}
function useGroup(props, injectKey) {
  let isUnmounted = false;
  const items = reactive([]);
  const selected = useProxiedModel(props, "modelValue", [], (v) => {
    if (v == null)
      return [];
    return getIds(items, wrapInArray(v));
  }, (v) => {
    const arr = getValues(items, v);
    return props.multiple ? arr : arr[0];
  });
  const groupVm = getCurrentInstance("useGroup");
  function register2(item, vm) {
    const unwrapped = item;
    const key = Symbol.for(`${injectKey.description}:id`);
    const children = findChildrenWithProvide(key, groupVm?.vnode);
    const index = children.indexOf(vm);
    if (index > -1) {
      items.splice(index, 0, unwrapped);
    } else {
      items.push(unwrapped);
    }
  }
  function unregister2(id) {
    if (isUnmounted)
      return;
    forceMandatoryValue();
    const index = items.findIndex((item) => item.id === id);
    items.splice(index, 1);
  }
  function forceMandatoryValue() {
    const item = items.find((item2) => !item2.disabled);
    if (item && props.mandatory === "force" && !selected.value.length) {
      selected.value = [item.id];
    }
  }
  onMounted(() => {
    forceMandatoryValue();
  });
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function select(id, value2) {
    const item = items.find((item2) => item2.id === id);
    if (value2 && item?.disabled)
      return;
    if (props.multiple) {
      const internalValue = selected.value.slice();
      const index = internalValue.findIndex((v) => v === id);
      const isSelected = ~index;
      value2 = value2 ?? !isSelected;
      if (isSelected && props.mandatory && internalValue.length <= 1)
        return;
      if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
        return;
      if (index < 0 && value2)
        internalValue.push(id);
      else if (index >= 0 && !value2)
        internalValue.splice(index, 1);
      selected.value = internalValue;
    } else {
      const isSelected = selected.value.includes(id);
      if (props.mandatory && isSelected)
        return;
      selected.value = value2 ?? !isSelected ? [id] : [];
    }
  }
  function step(offset2) {
    if (props.multiple)
      ;
    if (!selected.value.length) {
      const item = items.find((item2) => !item2.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex((i2) => i2.id === currentId);
      let newIndex = (currentIndex + offset2) % items.length;
      let newItem = items[newIndex];
      while (newItem.disabled && newIndex !== currentIndex) {
        newIndex = (newIndex + offset2) % items.length;
        newItem = items[newIndex];
      }
      if (newItem.disabled)
        return;
      selected.value = [items[newIndex].id];
    }
  }
  const state2 = {
    register: register2,
    unregister: unregister2,
    selected,
    select,
    disabled: toRef(props, "disabled"),
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: (id) => selected.value.includes(id),
    selectedClass: computed(() => props.selectedClass),
    items: computed(() => items),
    getItemIndex: (value2) => getItemIndex(items, value2)
  };
  provide(injectKey, state2);
  return state2;
}
function getItemIndex(items, value2) {
  const ids = getIds(items, [value2]);
  if (!ids.length)
    return -1;
  return items.findIndex((item) => item.id === ids[0]);
}
function getIds(items, modelValue) {
  const ids = [];
  modelValue.forEach((value2) => {
    const item = items.find((item2) => deepEqual(value2, item2.value));
    const itemByIndex = items[value2];
    if (item?.value != null) {
      ids.push(item.id);
    } else if (itemByIndex != null) {
      ids.push(itemByIndex.id);
    }
  });
  return ids;
}
function getValues(items, ids) {
  const values = [];
  ids.forEach((id) => {
    const itemIndex = items.findIndex((item) => item.id === id);
    if (~itemIndex) {
      const item = items[itemIndex];
      values.push(item.value != null ? item.value : itemIndex);
    }
  });
  return values;
}
const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
const makeVBtnToggleProps = propsFactory({
  ...makeVBtnGroupProps(),
  ...makeGroupProps()
}, "VBtnToggle");
const VBtnToggle = genericComponent()({
  name: "VBtnToggle",
  props: makeVBtnToggleProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      next,
      prev: prev2,
      select,
      selected
    } = useGroup(props, VBtnToggleSymbol);
    useRender(() => {
      const [btnGroupProps] = VBtnGroup.filterProps(props);
      return createVNode(VBtnGroup, mergeProps({
        "class": ["v-btn-toggle", props.class]
      }, btnGroupProps, {
        "style": props.style
      }), {
        default: () => [slots.default?.({
          isSelected,
          next,
          prev: prev2,
          select,
          selected
        })]
      });
    });
    return {
      next,
      prev: prev2,
      select
    };
  }
});
const makeVDefaultsProviderProps = propsFactory({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider");
const VDefaultsProvider = genericComponent(false)({
  name: "VDefaultsProvider",
  props: makeVDefaultsProviderProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      defaults: defaults2,
      disabled,
      reset,
      root,
      scoped
    } = toRefs(props);
    provideDefaults(defaults2, {
      reset,
      root,
      scoped,
      disabled
    });
    return () => slots.default?.();
  }
});
const VProgressCircular$1 = "";
const makeVProgressCircularProps = propsFactory({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...makeComponentProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "div"
  }),
  ...makeThemeProps()
}, "VProgressCircular");
const VProgressCircular = genericComponent()({
  name: "VProgressCircular",
  props: makeVProgressCircularProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const root = ref();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor(toRef(props, "bgColor"));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
    const width = computed(() => Number(props.width));
    const size2 = computed(() => {
      return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
    });
    const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
    const strokeWidth = computed(() => width.value / size2.value * diameter.value);
    const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    watchEffect(() => {
      intersectionRef.value = root.value;
      resizeRef.value = root.value;
    });
    useRender(() => createVNode(props.tag, {
      "ref": root,
      "class": ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!props.indeterminate,
        "v-progress-circular--visible": isIntersecting.value,
        "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
      }, themeClasses.value, sizeClasses.value, textColorClasses.value, props.class],
      "style": [sizeStyles.value, textColorStyles.value, props.style],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
    }, {
      default: () => [createVNode("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [createVNode("circle", {
        "class": ["v-progress-circular__underlay", underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null), createVNode("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null)]), slots.default && createVNode("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])]
    }));
    return {};
  }
});
const makeLoaderProps = propsFactory({
  loading: [Boolean, String]
}, "loader");
function useLoader(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const loaderClasses = computed(() => ({
    [`${name}--loading`]: props.loading
  }));
  return {
    loaderClasses
  };
}
function LoaderSlot(props, _ref) {
  let {
    slots
  } = _ref;
  return createVNode("div", {
    "class": `${props.name}__loader`
  }, [slots.default?.({
    color: props.color,
    isActive: props.active
  }) || createVNode(VProgressLinear, {
    "active": props.active,
    "color": props.color,
    "height": "2",
    "indeterminate": true
  }, null)]);
}
const positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
const makePositionProps = propsFactory({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (v) => positionValues.includes(v)
    )
  }
}, "position");
function usePosition(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const positionClasses = computed(() => {
    return props.position ? `${name}--${props.position}` : void 0;
  });
  return {
    positionClasses
  };
}
function useSelectLink(link, select) {
  watch(() => link.isActive?.value, (isActive) => {
    if (link.isLink.value && isActive && select) {
      nextTick$1(() => {
        select(true);
      });
    }
  }, {
    immediate: true
  });
}
const VRipple = "";
const stopSymbol = Symbol("rippleStop");
const DELAY_RIPPLE = 80;
function transform(el, value2) {
  el.style.transform = value2;
  el.style.webkitTransform = value2;
}
function isTouchEvent(e) {
  return e.constructor.name === "TouchEvent";
}
function isKeyboardEvent(e) {
  return e.constructor.name === "KeyboardEvent";
}
const calculate = function(e, el) {
  let value2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let localX = 0;
  let localY = 0;
  if (!isKeyboardEvent(e)) {
    const offset2 = el.getBoundingClientRect();
    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    localX = target.clientX - offset2.left;
    localY = target.clientY - offset2.top;
  }
  let radius = 0;
  let scale = 0.3;
  if (el._ripple?.circle) {
    scale = 0.15;
    radius = el.clientWidth / 2;
    radius = value2.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
  } else {
    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
  }
  const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
  const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
  const x2 = value2.center ? centerX : `${localX - radius}px`;
  const y = value2.center ? centerY : `${localY - radius}px`;
  return {
    radius,
    scale,
    x: x2,
    y,
    centerX,
    centerY
  };
};
const ripples = {
  /* eslint-disable max-statements */
  show(e, el) {
    let value2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!el?._ripple?.enabled) {
      return;
    }
    const container = document.createElement("span");
    const animation = document.createElement("span");
    container.appendChild(animation);
    container.className = "v-ripple__container";
    if (value2.class) {
      container.className += ` ${value2.class}`;
    }
    const {
      radius,
      scale,
      x: x2,
      y,
      centerX,
      centerY
    } = calculate(e, el, value2);
    const size2 = `${radius * 2}px`;
    animation.className = "v-ripple__animation";
    animation.style.width = size2;
    animation.style.height = size2;
    el.appendChild(container);
    const computed2 = window.getComputedStyle(el);
    if (computed2 && computed2.position === "static") {
      el.style.position = "relative";
      el.dataset.previousPosition = "static";
    }
    animation.classList.add("v-ripple__animation--enter");
    animation.classList.add("v-ripple__animation--visible");
    transform(animation, `translate(${x2}, ${y}) scale3d(${scale},${scale},${scale})`);
    animation.dataset.activated = String(performance.now());
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--in");
      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(el) {
    if (!el?._ripple?.enabled)
      return;
    const ripples2 = el.getElementsByClassName("v-ripple__animation");
    if (ripples2.length === 0)
      return;
    const animation = ripples2[ripples2.length - 1];
    if (animation.dataset.isHiding)
      return;
    else
      animation.dataset.isHiding = "true";
    const diff2 = performance.now() - Number(animation.dataset.activated);
    const delay = Math.max(250 - diff2, 0);
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--in");
      animation.classList.add("v-ripple__animation--out");
      setTimeout(() => {
        const ripples3 = el.getElementsByClassName("v-ripple__animation");
        if (ripples3.length === 1 && el.dataset.previousPosition) {
          el.style.position = el.dataset.previousPosition;
          delete el.dataset.previousPosition;
        }
        if (animation.parentNode?.parentNode === el)
          el.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }
};
function isRippleEnabled(value2) {
  return typeof value2 === "undefined" || !!value2;
}
function rippleShow(e) {
  const value2 = {};
  const element = e.currentTarget;
  if (!element?._ripple || element._ripple.touched || e[stopSymbol])
    return;
  e[stopSymbol] = true;
  if (isTouchEvent(e)) {
    element._ripple.touched = true;
    element._ripple.isTouch = true;
  } else {
    if (element._ripple.isTouch)
      return;
  }
  value2.center = element._ripple.centered || isKeyboardEvent(e);
  if (element._ripple.class) {
    value2.class = element._ripple.class;
  }
  if (isTouchEvent(e)) {
    if (element._ripple.showTimerCommit)
      return;
    element._ripple.showTimerCommit = () => {
      ripples.show(e, element, value2);
    };
    element._ripple.showTimer = window.setTimeout(() => {
      if (element?._ripple?.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
      }
    }, DELAY_RIPPLE);
  } else {
    ripples.show(e, element, value2);
  }
}
function rippleStop(e) {
  e[stopSymbol] = true;
}
function rippleHide(e) {
  const element = e.currentTarget;
  if (!element?._ripple)
    return;
  window.clearTimeout(element._ripple.showTimer);
  if (e.type === "touchend" && element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit();
    element._ripple.showTimerCommit = null;
    element._ripple.showTimer = window.setTimeout(() => {
      rippleHide(e);
    });
    return;
  }
  window.setTimeout(() => {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripples.hide(element);
}
function rippleCancelShow(e) {
  const element = e.currentTarget;
  if (!element?._ripple)
    return;
  if (element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit = null;
  }
  window.clearTimeout(element._ripple.showTimer);
}
let keyboardRipple = false;
function keyboardRippleShow(e) {
  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
    keyboardRipple = true;
    rippleShow(e);
  }
}
function keyboardRippleHide(e) {
  keyboardRipple = false;
  rippleHide(e);
}
function focusRippleHide(e) {
  if (keyboardRipple) {
    keyboardRipple = false;
    rippleHide(e);
  }
}
function updateRipple(el, binding, wasEnabled) {
  const {
    value: value2,
    modifiers
  } = binding;
  const enabled = isRippleEnabled(value2);
  if (!enabled) {
    ripples.hide(el);
  }
  el._ripple = el._ripple ?? {};
  el._ripple.enabled = enabled;
  el._ripple.centered = modifiers.center;
  el._ripple.circle = modifiers.circle;
  if (isObject$4(value2) && value2.class) {
    el._ripple.class = value2.class;
  }
  if (enabled && !wasEnabled) {
    if (modifiers.stop) {
      el.addEventListener("touchstart", rippleStop, {
        passive: true
      });
      el.addEventListener("mousedown", rippleStop);
      return;
    }
    el.addEventListener("touchstart", rippleShow, {
      passive: true
    });
    el.addEventListener("touchend", rippleHide, {
      passive: true
    });
    el.addEventListener("touchmove", rippleCancelShow, {
      passive: true
    });
    el.addEventListener("touchcancel", rippleHide);
    el.addEventListener("mousedown", rippleShow);
    el.addEventListener("mouseup", rippleHide);
    el.addEventListener("mouseleave", rippleHide);
    el.addEventListener("keydown", keyboardRippleShow);
    el.addEventListener("keyup", keyboardRippleHide);
    el.addEventListener("blur", focusRippleHide);
    el.addEventListener("dragstart", rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el);
  }
}
function removeListeners(el) {
  el.removeEventListener("mousedown", rippleShow);
  el.removeEventListener("touchstart", rippleShow);
  el.removeEventListener("touchend", rippleHide);
  el.removeEventListener("touchmove", rippleCancelShow);
  el.removeEventListener("touchcancel", rippleHide);
  el.removeEventListener("mouseup", rippleHide);
  el.removeEventListener("mouseleave", rippleHide);
  el.removeEventListener("keydown", keyboardRippleShow);
  el.removeEventListener("keyup", keyboardRippleHide);
  el.removeEventListener("dragstart", rippleHide);
  el.removeEventListener("blur", focusRippleHide);
}
function mounted$1(el, binding) {
  updateRipple(el, binding, false);
}
function unmounted$1(el) {
  delete el._ripple;
  removeListeners(el);
}
function updated(el, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }
  const wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el, binding, wasEnabled);
}
const Ripple = {
  mounted: mounted$1,
  unmounted: unmounted$1,
  updated
};
const makeVBtnProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  symbol: {
    type: null,
    default: VBtnToggleSymbol
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: IconValue,
  appendIcon: IconValue,
  block: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  text: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeLoaderProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "button"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "elevated"
  })
}, "VBtn");
const VBtn = genericComponent()({
  name: "VBtn",
  directives: {
    Ripple
  },
  props: makeVBtnProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    const group = useGroupItem(props, props.symbol, false);
    const link = useLink(props, attrs);
    const isActive = computed(() => {
      if (props.active !== void 0) {
        return props.active;
      }
      if (link.isLink.value) {
        return link.isActive?.value;
      }
      return group?.isSelected.value;
    });
    const isDisabled = computed(() => group?.disabled.value || props.disabled);
    const isElevated = computed(() => {
      return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
    });
    const valueAttr = computed(() => {
      if (props.value === void 0)
        return void 0;
      return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
    });
    function onClick(e) {
      if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
        return;
      link.navigate?.(e);
      group?.toggle();
    }
    useSelectLink(link, group?.select);
    useRender(() => {
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasPrepend = !!(props.prependIcon || slots.prepend);
      const hasAppend = !!(props.appendIcon || slots.append);
      const hasIcon = !!(props.icon && props.icon !== true);
      const hasColor = group?.isSelected.value && (!link.isLink.value || link.isActive?.value) || !group || link.isActive?.value;
      return withDirectives(createVNode(Tag, {
        "type": Tag === "a" ? void 0 : "button",
        "class": ["v-btn", group?.selectedClass.value, {
          "v-btn--active": isActive.value,
          "v-btn--block": props.block,
          "v-btn--disabled": isDisabled.value,
          "v-btn--elevated": isElevated.value,
          "v-btn--flat": props.flat,
          "v-btn--icon": !!props.icon,
          "v-btn--loading": props.loading,
          "v-btn--stacked": props.stacked
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, locationStyles.value, sizeStyles.value, props.style],
        "disabled": isDisabled.value || void 0,
        "href": link.href.value,
        "onClick": onClick,
        "value": valueAttr.value
      }, {
        default: () => [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createVNode("span", {
          "key": "prepend",
          "class": "v-btn__prepend"
        }, [!slots.prepend ? createVNode(VIcon, {
          "key": "prepend-icon",
          "icon": props.prependIcon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !props.prependIcon,
          "defaults": {
            VIcon: {
              icon: props.prependIcon
            }
          }
        }, slots.prepend)]), createVNode("span", {
          "class": "v-btn__content",
          "data-no-activator": ""
        }, [!slots.default && hasIcon ? createVNode(VIcon, {
          "key": "content-icon",
          "icon": props.icon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "content-defaults",
          "disabled": !hasIcon,
          "defaults": {
            VIcon: {
              icon: props.icon
            }
          }
        }, {
          default: () => [slots.default?.() ?? props.text]
        })]), !props.icon && hasAppend && createVNode("span", {
          "key": "append",
          "class": "v-btn__append"
        }, [!slots.append ? createVNode(VIcon, {
          "key": "append-icon",
          "icon": props.appendIcon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !props.appendIcon,
          "defaults": {
            VIcon: {
              icon: props.appendIcon
            }
          }
        }, slots.append)]), !!props.loading && createVNode("span", {
          "key": "loader",
          "class": "v-btn__loader"
        }, [slots.loader?.() ?? createVNode(VProgressCircular, {
          "color": typeof props.loading === "boolean" ? void 0 : props.loading,
          "indeterminate": true,
          "size": "23",
          "width": "2"
        }, null)])]
      }), [[resolveDirective("ripple"), !isDisabled.value && props.ripple, null]]);
    });
    return {};
  }
});
const VList$1 = "";
const makeTransitionProps = propsFactory({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function createCssTransition(name, origin, mode) {
  return genericComponent()({
    name,
    props: makeTransitionProps({
      mode,
      origin
    }),
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      const functions = {
        onBeforeEnter(el) {
          if (props.origin) {
            el.style.transformOrigin = props.origin;
          }
        },
        onLeave(el) {
          if (props.leaveAbsolute) {
            const {
              offsetTop,
              offsetLeft,
              offsetWidth,
              offsetHeight
            } = el;
            el._transitionInitialStyles = {
              position: el.style.position,
              top: el.style.top,
              left: el.style.left,
              width: el.style.width,
              height: el.style.height
            };
            el.style.position = "absolute";
            el.style.top = `${offsetTop}px`;
            el.style.left = `${offsetLeft}px`;
            el.style.width = `${offsetWidth}px`;
            el.style.height = `${offsetHeight}px`;
          }
          if (props.hideOnLeave) {
            el.style.setProperty("display", "none", "important");
          }
        },
        onAfterLeave(el) {
          if (props.leaveAbsolute && el?._transitionInitialStyles) {
            const {
              position,
              top,
              left,
              width,
              height
            } = el._transitionInitialStyles;
            delete el._transitionInitialStyles;
            el.style.position = position || "";
            el.style.top = top || "";
            el.style.left = left || "";
            el.style.width = width || "";
            el.style.height = height || "";
          }
        }
      };
      return () => {
        const tag = props.group ? TransitionGroup : Transition;
        return h(tag, {
          name: props.disabled ? "" : name,
          css: !props.disabled,
          ...props.group ? void 0 : {
            mode: props.mode
          },
          ...props.disabled ? {} : functions
        }, slots.default);
      };
    }
  });
}
function createJavascriptTransition(name, functions) {
  let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return genericComponent()({
    name,
    props: {
      mode: {
        type: String,
        default: mode
      },
      disabled: Boolean
    },
    setup(props, _ref2) {
      let {
        slots
      } = _ref2;
      return () => {
        return h(Transition, {
          name: props.disabled ? "" : name,
          css: !props.disabled,
          // mode: props.mode, // TODO: vuejs/vue-next#3104
          ...props.disabled ? {} : functions
        }, slots.default);
      };
    }
  });
}
function ExpandTransitionGenerator() {
  let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let x2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const sizeProperty = x2 ? "width" : "height";
  const offsetProperty = camelize(`offset-${sizeProperty}`);
  return {
    onBeforeEnter(el) {
      el._parent = el.parentNode;
      el._initialStyle = {
        transition: el.style.transition,
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
    },
    onEnter(el) {
      const initialStyle = el._initialStyle;
      el.style.setProperty("transition", "none", "important");
      el.style.overflow = "hidden";
      const offset2 = `${el[offsetProperty]}px`;
      el.style[sizeProperty] = "0";
      void el.offsetHeight;
      el.style.transition = initialStyle.transition;
      if (expandedParentClass && el._parent) {
        el._parent.classList.add(expandedParentClass);
      }
      requestAnimationFrame(() => {
        el.style[sizeProperty] = offset2;
      });
    },
    onAfterEnter: resetStyles,
    onEnterCancelled: resetStyles,
    onLeave(el) {
      el._initialStyle = {
        transition: "",
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
      el.style.overflow = "hidden";
      el.style[sizeProperty] = `${el[offsetProperty]}px`;
      void el.offsetHeight;
      requestAnimationFrame(() => el.style[sizeProperty] = "0");
    },
    onAfterLeave,
    onLeaveCancelled: onAfterLeave
  };
  function onAfterLeave(el) {
    if (expandedParentClass && el._parent) {
      el._parent.classList.remove(expandedParentClass);
    }
    resetStyles(el);
  }
  function resetStyles(el) {
    const size2 = el._initialStyle[sizeProperty];
    el.style.overflow = el._initialStyle.overflow;
    if (size2 != null)
      el.style[sizeProperty] = size2;
    delete el._initialStyle;
  }
}
const makeVDialogTransitionProps = propsFactory({
  target: Object
}, "v-dialog-transition");
const VDialogTransition = genericComponent()({
  name: "VDialogTransition",
  props: makeVDialogTransitionProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const functions = {
      onBeforeEnter(el) {
        el.style.pointerEvents = "none";
        el.style.visibility = "hidden";
      },
      async onEnter(el, done) {
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        el.style.visibility = "";
        const {
          x: x2,
          y,
          sx,
          sy,
          speed
        } = getDimensions(props.target, el);
        const animation = animate(el, [{
          transform: `translate(${x2}px, ${y}px) scale(${sx}, ${sy})`,
          opacity: 0
        }, {}], {
          duration: 225 * speed,
          easing: deceleratedEasing
        });
        getChildren(el)?.forEach((el2) => {
          animate(el2, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * speed,
            easing: standardEasing
          });
        });
        animation.finished.then(() => done());
      },
      onAfterEnter(el) {
        el.style.removeProperty("pointer-events");
      },
      onBeforeLeave(el) {
        el.style.pointerEvents = "none";
      },
      async onLeave(el, done) {
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        const {
          x: x2,
          y,
          sx,
          sy,
          speed
        } = getDimensions(props.target, el);
        const animation = animate(el, [{}, {
          transform: `translate(${x2}px, ${y}px) scale(${sx}, ${sy})`,
          opacity: 0
        }], {
          duration: 125 * speed,
          easing: acceleratedEasing
        });
        animation.finished.then(() => done());
        getChildren(el)?.forEach((el2) => {
          animate(el2, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * speed,
            easing: standardEasing
          });
        });
      },
      onAfterLeave(el) {
        el.style.removeProperty("pointer-events");
      }
    };
    return () => {
      return props.target ? createVNode(Transition, mergeProps({
        "name": "dialog-transition"
      }, functions, {
        "css": false
      }), slots) : createVNode(Transition, {
        "name": "dialog-transition"
      }, slots);
    };
  }
});
function getChildren(el) {
  const els = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")?.children;
  return els && [...els];
}
function getDimensions(target, el) {
  const targetBox = target.getBoundingClientRect();
  const elBox = nullifyTransforms(el);
  const [originX, originY] = getComputedStyle(el).transformOrigin.split(" ").map((v) => parseFloat(v));
  const [anchorSide, anchorOffset] = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let offsetX = targetBox.left + targetBox.width / 2;
  if (anchorSide === "left" || anchorOffset === "left") {
    offsetX -= targetBox.width / 2;
  } else if (anchorSide === "right" || anchorOffset === "right") {
    offsetX += targetBox.width / 2;
  }
  let offsetY = targetBox.top + targetBox.height / 2;
  if (anchorSide === "top" || anchorOffset === "top") {
    offsetY -= targetBox.height / 2;
  } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
    offsetY += targetBox.height / 2;
  }
  const tsx = targetBox.width / elBox.width;
  const tsy = targetBox.height / elBox.height;
  const maxs = Math.max(1, tsx, tsy);
  const sx = tsx / maxs || 0;
  const sy = tsy / maxs || 0;
  const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
  const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
  return {
    x: offsetX - (originX + elBox.left),
    y: offsetY - (originY + elBox.top),
    sx,
    sy,
    speed
  };
}
createCssTransition("fab-transition", "center center", "out-in");
createCssTransition("dialog-bottom-transition");
createCssTransition("dialog-top-transition");
const VFadeTransition = createCssTransition("fade-transition");
createCssTransition("scale-transition");
createCssTransition("scroll-x-transition");
createCssTransition("scroll-x-reverse-transition");
createCssTransition("scroll-y-transition");
createCssTransition("scroll-y-reverse-transition");
createCssTransition("slide-x-transition");
createCssTransition("slide-x-reverse-transition");
const VSlideYTransition = createCssTransition("slide-y-transition");
createCssTransition("slide-y-reverse-transition");
const VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
const VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
const ListKey = Symbol.for("vuetify:list");
function createList() {
  const parent = inject$1(ListKey, {
    hasPrepend: shallowRef(false),
    updateHasPrepend: () => null
  });
  const data2 = {
    hasPrepend: shallowRef(false),
    updateHasPrepend: (value2) => {
      if (value2)
        data2.hasPrepend.value = value2;
    }
  };
  provide(ListKey, data2);
  return parent;
}
function useList() {
  return inject$1(ListKey, null);
}
const singleOpenStrategy = {
  open: (_ref) => {
    let {
      id,
      value: value2,
      opened,
      parents
    } = _ref;
    if (value2) {
      const newOpened = /* @__PURE__ */ new Set();
      newOpened.add(id);
      let parent = parents.get(id);
      while (parent != null) {
        newOpened.add(parent);
        parent = parents.get(parent);
      }
      return newOpened;
    } else {
      opened.delete(id);
      return opened;
    }
  },
  select: () => null
};
const multipleOpenStrategy = {
  open: (_ref2) => {
    let {
      id,
      value: value2,
      opened,
      parents
    } = _ref2;
    if (value2) {
      let parent = parents.get(id);
      opened.add(id);
      while (parent != null && parent !== id) {
        opened.add(parent);
        parent = parents.get(parent);
      }
      return opened;
    } else {
      opened.delete(id);
    }
    return opened;
  },
  select: () => null
};
const listOpenStrategy = {
  open: multipleOpenStrategy.open,
  select: (_ref3) => {
    let {
      id,
      value: value2,
      opened,
      parents
    } = _ref3;
    if (!value2)
      return opened;
    const path = [];
    let parent = parents.get(id);
    while (parent != null) {
      path.push(parent);
      parent = parents.get(parent);
    }
    return new Set(path);
  }
};
const independentSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref) => {
      let {
        id,
        value: value2,
        selected
      } = _ref;
      id = toRaw(id);
      if (mandatory && !value2) {
        const on2 = Array.from(selected.entries()).reduce((arr, _ref2) => {
          let [key, value3] = _ref2;
          return value3 === "on" ? [...arr, key] : arr;
        }, []);
        if (on2.length === 1 && on2[0] === id)
          return selected;
      }
      selected.set(id, value2 ? "on" : "off");
      return selected;
    },
    in: (v, children, parents) => {
      let map2 = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map2 = strategy.select({
          id,
          value: true,
          selected: new Map(map2),
          children,
          parents
        });
      }
      return map2;
    },
    out: (v) => {
      const arr = [];
      for (const [key, value2] of v.entries()) {
        if (value2 === "on")
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
const independentSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref3) => {
      let {
        selected,
        id,
        ...rest
      } = _ref3;
      id = toRaw(id);
      const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
      return parentStrategy.select({
        ...rest,
        id,
        selected: singleSelected
      });
    },
    in: (v, children, parents) => {
      let map2 = /* @__PURE__ */ new Map();
      if (v?.length) {
        map2 = parentStrategy.in(v.slice(0, 1), children, parents);
      }
      return map2;
    },
    out: (v, children, parents) => {
      return parentStrategy.out(v, children, parents);
    }
  };
  return strategy;
};
const leafSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref4) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref4;
      id = toRaw(id);
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const leafSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSingleSelectStrategy(mandatory);
  const strategy = {
    select: (_ref5) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref5;
      id = toRaw(id);
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const classicSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref6) => {
      let {
        id,
        value: value2,
        selected,
        children,
        parents
      } = _ref6;
      id = toRaw(id);
      const original = new Map(selected);
      const items = [id];
      while (items.length) {
        const item = items.shift();
        selected.set(item, value2 ? "on" : "off");
        if (children.has(item)) {
          items.push(...children.get(item));
        }
      }
      let parent = parents.get(id);
      while (parent) {
        const childrenIds = children.get(parent);
        const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
        const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
        selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
        parent = parents.get(parent);
      }
      if (mandatory && !value2) {
        const on2 = Array.from(selected.entries()).reduce((arr, _ref7) => {
          let [key, value3] = _ref7;
          return value3 === "on" ? [...arr, key] : arr;
        }, []);
        if (on2.length === 0)
          return original;
      }
      return selected;
    },
    in: (v, children, parents) => {
      let map2 = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map2 = strategy.select({
          id,
          value: true,
          selected: new Map(map2),
          children,
          parents
        });
      }
      return map2;
    },
    out: (v, children) => {
      const arr = [];
      for (const [key, value2] of v.entries()) {
        if (value2 === "on" && !children.has(key))
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
const VNestedSymbol = Symbol.for("vuetify:nested");
const emptyNested = {
  id: shallowRef(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: ref(/* @__PURE__ */ new Map()),
    children: ref(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    select: () => null,
    opened: ref(/* @__PURE__ */ new Set()),
    selected: ref(/* @__PURE__ */ new Map()),
    selectedValues: ref([])
  }
};
const makeNestedProps = propsFactory({
  selectStrategy: [String, Function],
  openStrategy: [String, Object],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested");
const useNested = (props) => {
  let isUnmounted = false;
  const children = ref(/* @__PURE__ */ new Map());
  const parents = ref(/* @__PURE__ */ new Map());
  const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
  const selectStrategy = computed(() => {
    if (typeof props.selectStrategy === "object")
      return props.selectStrategy;
    switch (props.selectStrategy) {
      case "single-leaf":
        return leafSingleSelectStrategy(props.mandatory);
      case "leaf":
        return leafSelectStrategy(props.mandatory);
      case "independent":
        return independentSelectStrategy(props.mandatory);
      case "single-independent":
        return independentSingleSelectStrategy(props.mandatory);
      case "classic":
      default:
        return classicSelectStrategy(props.mandatory);
    }
  });
  const openStrategy = computed(() => {
    if (typeof props.openStrategy === "object")
      return props.openStrategy;
    switch (props.openStrategy) {
      case "list":
        return listOpenStrategy;
      case "single":
        return singleOpenStrategy;
      case "multiple":
      default:
        return multipleOpenStrategy;
    }
  });
  const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function getPath(id) {
    const path = [];
    let parent = id;
    while (parent != null) {
      path.unshift(parent);
      parent = parents.value.get(parent);
    }
    return path;
  }
  const vm = getCurrentInstance("nested");
  const nested = {
    id: shallowRef(),
    root: {
      opened,
      selected,
      selectedValues: computed(() => {
        const arr = [];
        for (const [key, value2] of selected.value.entries()) {
          if (value2 === "on")
            arr.push(key);
        }
        return arr;
      }),
      register: (id, parentId, isGroup) => {
        parentId && id !== parentId && parents.value.set(id, parentId);
        isGroup && children.value.set(id, []);
        if (parentId != null) {
          children.value.set(parentId, [...children.value.get(parentId) || [], id]);
        }
      },
      unregister: (id) => {
        if (isUnmounted)
          return;
        children.value.delete(id);
        const parent = parents.value.get(id);
        if (parent) {
          const list = children.value.get(parent) ?? [];
          children.value.set(parent, list.filter((child) => child !== id));
        }
        parents.value.delete(id);
        opened.value.delete(id);
      },
      open: (id, value2, event) => {
        vm.emit("click:open", {
          id,
          value: value2,
          path: getPath(id),
          event
        });
        const newOpened = openStrategy.value.open({
          id,
          value: value2,
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      openOnSelect: (id, value2, event) => {
        const newOpened = openStrategy.value.select({
          id,
          value: value2,
          selected: new Map(selected.value),
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      select: (id, value2, event) => {
        vm.emit("click:select", {
          id,
          value: value2,
          path: getPath(id),
          event
        });
        const newSelected = selectStrategy.value.select({
          id,
          value: value2,
          selected: new Map(selected.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newSelected && (selected.value = newSelected);
        nested.root.openOnSelect(id, value2, event);
      },
      children,
      parents
    }
  };
  provide(VNestedSymbol, nested);
  return nested.root;
};
const useNestedItem = (id, isGroup) => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  const uidSymbol = Symbol(getUid());
  const computedId = computed(() => id.value !== void 0 ? id.value : uidSymbol);
  const item = {
    ...parent,
    id: computedId,
    open: (open, e) => parent.root.open(computedId.value, open, e),
    openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
    parent: computed(() => parent.root.parents.value.get(computedId.value)),
    select: (selected, e) => parent.root.select(computedId.value, selected, e),
    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === "on"),
    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
    isGroupActivator: parent.isGroupActivator
  };
  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
  onBeforeUnmount(() => {
    !parent.isGroupActivator && parent.root.unregister(computedId.value);
  });
  isGroup && provide(VNestedSymbol, item);
  return item;
};
const useNestedGroupActivator = () => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  provide(VNestedSymbol, {
    ...parent,
    isGroupActivator: true
  });
};
function useSsrBoot() {
  const isBooted = shallowRef(false);
  onMounted(() => {
    window.requestAnimationFrame(() => {
      isBooted.value = true;
    });
  });
  const ssrBootStyles = computed(() => !isBooted.value ? {
    transition: "none !important"
  } : void 0);
  return {
    ssrBootStyles,
    isBooted: readonly(isBooted)
  };
}
const VListGroupActivator = defineComponent({
  name: "VListGroupActivator",
  setup(_, _ref) {
    let {
      slots
    } = _ref;
    useNestedGroupActivator();
    return () => slots.default?.();
  }
});
const makeVListGroupProps = propsFactory({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  prependIcon: IconValue,
  appendIcon: IconValue,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListGroup");
const VListGroup = genericComponent()({
  name: "VListGroup",
  props: makeVListGroupProps(),
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      isOpen,
      open,
      id: _id
    } = useNestedItem(toRef(props, "value"), true);
    const id = computed(() => `v-list-group--id-${String(_id.value)}`);
    const list = useList();
    const {
      isBooted
    } = useSsrBoot();
    function onClick(e) {
      open(!isOpen.value, e);
    }
    const activatorProps = computed(() => ({
      onClick,
      class: "v-list-group__header",
      id: id.value
    }));
    const toggleIcon = computed(() => isOpen.value ? props.collapseIcon : props.expandIcon);
    const activatorDefaults = computed(() => ({
      VListItem: {
        active: isOpen.value,
        activeColor: props.activeColor,
        baseColor: props.baseColor,
        color: props.color,
        prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
        appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
        title: props.title,
        value: props.value
      }
    }));
    useRender(() => createVNode(props.tag, {
      "class": ["v-list-group", {
        "v-list-group--prepend": list?.hasPrepend.value,
        "v-list-group--fluid": props.fluid,
        "v-list-group--subgroup": props.subgroup,
        "v-list-group--open": isOpen.value
      }, props.class],
      "style": props.style
    }, {
      default: () => [slots.activator && createVNode(VDefaultsProvider, {
        "defaults": activatorDefaults.value
      }, {
        default: () => [createVNode(VListGroupActivator, null, {
          default: () => [slots.activator({
            props: activatorProps.value,
            isOpen: isOpen.value
          })]
        })]
      }), createVNode(MaybeTransition, {
        "transition": {
          component: VExpandTransition
        },
        "disabled": !isBooted.value
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-list-group__items",
          "role": "group",
          "aria-labelledby": id.value
        }, [slots.default?.()]), [[vShow, isOpen.value]])]
      })]
    }));
    return {};
  }
});
const VListItem$1 = "";
const VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");
const VListItemTitle = createSimpleFunctional("v-list-item-title");
const VAvatar$1 = "";
const makeVAvatarProps = propsFactory({
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  image: String,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VAvatar");
const VAvatar = genericComponent()({
  name: "VAvatar",
  props: makeVAvatarProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    useRender(() => createVNode(props.tag, {
      "class": ["v-avatar", {
        "v-avatar--start": props.start,
        "v-avatar--end": props.end
      }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props.class],
      "style": [colorStyles.value, sizeStyles.value, props.style]
    }, {
      default: () => [props.image ? createVNode(VImg, {
        "key": "image",
        "src": props.image,
        "alt": "",
        "cover": true
      }, null) : props.icon ? createVNode(VIcon, {
        "key": "icon",
        "icon": props.icon
      }, null) : slots.default?.(), genOverlays(false, "v-avatar")]
    }));
    return {};
  }
});
const makeVListItemProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: IconValue,
  baseColor: String,
  disabled: Boolean,
  lines: String,
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  subtitle: [String, Number, Boolean],
  title: [String, Number, Boolean],
  value: null,
  onClick: EventProp(),
  onClickOnce: EventProp(),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VListItem");
const VListItem = genericComponent()({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: makeVListItemProps(),
  emits: {
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const link = useLink(props, attrs);
    const id = computed(() => props.value === void 0 ? link.href.value : props.value);
    const {
      select,
      isSelected,
      isIndeterminate,
      isGroupActivator,
      root,
      parent,
      openOnSelect
    } = useNestedItem(id, false);
    const list = useList();
    const isActive = computed(() => props.active !== false && (props.active || link.isActive?.value || isSelected.value));
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value || props.value != null && !!list));
    const roundedProps = computed(() => props.rounded || props.nav);
    const color = computed(() => props.color ?? props.activeColor);
    const variantProps = computed(() => ({
      color: isActive.value ? color.value ?? props.baseColor : props.baseColor,
      variant: props.variant
    }));
    watch(() => link.isActive?.value, (val) => {
      if (val && parent.value != null) {
        root.open(parent.value, true);
      }
      if (val) {
        openOnSelect(val);
      }
    }, {
      immediate: true
    });
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(roundedProps);
    const lineClasses = computed(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
    const slotProps = computed(() => ({
      isActive: isActive.value,
      select,
      isSelected: isSelected.value,
      isIndeterminate: isIndeterminate.value
    }));
    function onClick(e) {
      emit2("click", e);
      if (isGroupActivator || !isClickable.value)
        return;
      link.navigate?.(e);
      props.value != null && select(!isSelected.value, e);
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    useRender(() => {
      const Tag = isLink.value ? "a" : props.tag;
      const hasTitle = slots.title || props.title;
      const hasSubtitle = slots.subtitle || props.subtitle;
      const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      list?.updateHasPrepend(hasPrepend);
      if (props.activeColor) {
        deprecate$1("active-color", ["color", "base-color"]);
      }
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props.disabled,
          "v-list-item--link": isClickable.value,
          "v-list-item--nav": props.nav,
          "v-list-item--prepend": !hasPrepend && list?.hasPrepend.value,
          [`${props.activeClass}`]: props.activeClass && isActive.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props.class],
        "style": [colorStyles.value, dimensionStyles.value, props.style],
        "href": link.href.value,
        "tabindex": isClickable.value ? list ? -2 : 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-list-item__prepend"
        }, [!slots.prepend ? createVNode(Fragment, null, [props.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "density": props.density,
          "image": props.prependAvatar
        }, null), props.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props.density,
          "icon": props.prependIcon
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.prependAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.prependIcon
            },
            VListItemAction: {
              start: true
            }
          }
        }, {
          default: () => [slots.prepend?.(slotProps.value)]
        }), createVNode("div", {
          "class": "v-list-item__spacer"
        }, null)]), createVNode("div", {
          "class": "v-list-item__content",
          "data-no-activator": ""
        }, [hasTitle && createVNode(VListItemTitle, {
          "key": "title"
        }, {
          default: () => [slots.title?.({
            title: props.title
          }) ?? props.title]
        }), hasSubtitle && createVNode(VListItemSubtitle, {
          "key": "subtitle"
        }, {
          default: () => [slots.subtitle?.({
            subtitle: props.subtitle
          }) ?? props.subtitle]
        }), slots.default?.(slotProps.value)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-list-item__append"
        }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "density": props.density,
          "icon": props.appendIcon
        }, null), props.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "density": props.density,
          "image": props.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.appendAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.appendIcon
            },
            VListItemAction: {
              end: true
            }
          }
        }, {
          default: () => [slots.append?.(slotProps.value)]
        }), createVNode("div", {
          "class": "v-list-item__spacer"
        }, null)])]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
    });
    return {};
  }
});
const makeVListSubheaderProps = propsFactory({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListSubheader");
const VListSubheader = genericComponent()({
  name: "VListSubheader",
  props: makeVListSubheaderProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    useRender(() => {
      const hasText = !!(slots.default || props.title);
      return createVNode(props.tag, {
        "class": ["v-list-subheader", {
          "v-list-subheader--inset": props.inset,
          "v-list-subheader--sticky": props.sticky
        }, textColorClasses.value, props.class],
        "style": [{
          textColorStyles
        }, props.style]
      }, {
        default: () => [hasText && createVNode("div", {
          "class": "v-list-subheader__text"
        }, [slots.default?.() ?? props.title])]
      });
    });
    return {};
  }
});
const VDivider$1 = "";
const makeVDividerProps = propsFactory({
  color: String,
  inset: Boolean,
  length: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...makeComponentProps(),
  ...makeThemeProps()
}, "VDivider");
const VDivider = genericComponent()({
  name: "VDivider",
  props: makeVDividerProps(),
  setup(props, _ref) {
    let {
      attrs
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const dividerStyles = computed(() => {
      const styles = {};
      if (props.length) {
        styles[props.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props.length);
      }
      if (props.thickness) {
        styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
      }
      return styles;
    });
    useRender(() => createVNode("hr", {
      "class": [{
        "v-divider": true,
        "v-divider--inset": props.inset,
        "v-divider--vertical": props.vertical
      }, themeClasses.value, textColorClasses.value, props.class],
      "style": [dividerStyles.value, textColorStyles.value, props.style],
      "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
      "role": `${attrs.role || "separator"}`
    }, null));
    return {};
  }
});
const makeVListChildrenProps = propsFactory({
  items: Array
}, "VListChildren");
const VListChildren = genericComponent()({
  name: "VListChildren",
  props: makeVListChildrenProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    createList();
    return () => slots.default?.() ?? props.items?.map((_ref2) => {
      let {
        children,
        props: itemProps,
        type,
        raw: item
      } = _ref2;
      if (type === "divider") {
        return slots.divider?.({
          props: itemProps
        }) ?? createVNode(VDivider, itemProps, null);
      }
      if (type === "subheader") {
        return slots.subheader?.({
          props: itemProps
        }) ?? createVNode(VListSubheader, itemProps, null);
      }
      const slotsWithItem = {
        subtitle: slots.subtitle ? (slotProps) => slots.subtitle?.({
          ...slotProps,
          item
        }) : void 0,
        prepend: slots.prepend ? (slotProps) => slots.prepend?.({
          ...slotProps,
          item
        }) : void 0,
        append: slots.append ? (slotProps) => slots.append?.({
          ...slotProps,
          item
        }) : void 0,
        title: slots.title ? (slotProps) => slots.title?.({
          ...slotProps,
          item
        }) : void 0
      };
      const [listGroupProps, _1] = VListGroup.filterProps(itemProps);
      return children ? createVNode(VListGroup, mergeProps({
        "value": itemProps?.value
      }, listGroupProps), {
        activator: (_ref3) => {
          let {
            props: activatorProps
          } = _ref3;
          return slots.header ? slots.header({
            props: {
              ...itemProps,
              ...activatorProps
            }
          }) : createVNode(VListItem, mergeProps(itemProps, activatorProps), slotsWithItem);
        },
        default: () => createVNode(VListChildren, {
          "items": children
        }, slots)
      }) : slots.item ? slots.item({
        props: itemProps
      }) : createVNode(VListItem, itemProps, slotsWithItem);
    });
  }
});
const makeItemsProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  }
}, "list-items");
function transformItem$1(props, item) {
  const title = getPropertyFromItem(item, props.itemTitle, item);
  const value2 = getPropertyFromItem(item, props.itemValue, title);
  const children = getPropertyFromItem(item, props.itemChildren);
  const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? pick$1(item, ["children"])[1] : item : void 0 : getPropertyFromItem(item, props.itemProps);
  const _props = {
    title,
    value: value2,
    ...itemProps
  };
  return {
    title: String(_props.title ?? ""),
    value: _props.value,
    props: _props,
    children: Array.isArray(children) ? transformItems$1(props, children) : void 0,
    raw: item
  };
}
function transformItems$1(props, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem$1(props, item));
  }
  return array;
}
function useItems(props) {
  const items = computed(() => transformItems$1(props, props.items));
  const hasNullItem = computed(() => items.value.some((item) => item.value === null));
  function transformIn(value2) {
    if (!hasNullItem.value) {
      value2 = value2.filter((v) => v !== null);
    }
    return value2.map((v) => {
      if (props.returnObject && typeof v === "string") {
        return transformItem$1(props, v);
      }
      return items.value.find((item) => props.valueComparator(v, item.value)) || transformItem$1(props, v);
    });
  }
  function transformOut(value2) {
    return props.returnObject ? value2.map((_ref) => {
      let {
        raw
      } = _ref;
      return raw;
    }) : value2.map((_ref2) => {
      let {
        value: value3
      } = _ref2;
      return value3;
    });
  }
  return {
    items,
    transformIn,
    transformOut
  };
}
function isPrimitive(value2) {
  return typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean";
}
function transformItem(props, item) {
  const type = getPropertyFromItem(item, props.itemType, "item");
  const title = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
  const value2 = getPropertyFromItem(item, props.itemValue, void 0);
  const children = getPropertyFromItem(item, props.itemChildren);
  const itemProps = props.itemProps === true ? pick$1(item, ["children"])[1] : getPropertyFromItem(item, props.itemProps);
  const _props = {
    title,
    value: value2,
    ...itemProps
  };
  return {
    type,
    title: _props.title,
    value: _props.value,
    props: _props,
    children: type === "item" && children ? transformItems(props, children) : void 0,
    raw: item
  };
}
function transformItems(props, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem(props, item));
  }
  return array;
}
function useListItems(props) {
  const items = computed(() => transformItems(props, props.items));
  return {
    items
  };
}
const makeVListProps = propsFactory({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  nav: Boolean,
  ...makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  itemType: {
    type: String,
    default: "type"
  },
  ...makeItemsProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VList");
const VList = genericComponent()({
  name: "VList",
  props: makeVListProps(),
  emits: {
    "update:selected": (val) => true,
    "update:opened": (val) => true,
    "click:open": (value2) => true,
    "click:select": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props);
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      open,
      select
    } = useNested(props);
    const lineClasses = computed(() => props.lines ? `v-list--${props.lines}-line` : void 0);
    const activeColor = toRef(props, "activeColor");
    const baseColor = toRef(props, "baseColor");
    const color = toRef(props, "color");
    createList();
    provideDefaults({
      VListGroup: {
        activeColor,
        baseColor,
        color
      },
      VListItem: {
        activeClass: toRef(props, "activeClass"),
        activeColor,
        baseColor,
        color,
        density: toRef(props, "density"),
        disabled: toRef(props, "disabled"),
        lines: toRef(props, "lines"),
        nav: toRef(props, "nav"),
        variant: toRef(props, "variant")
      }
    });
    const isFocused = shallowRef(false);
    const contentRef = ref();
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget)))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (e.key === "ArrowDown") {
        focus("next");
      } else if (e.key === "ArrowUp") {
        focus("prev");
      } else if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      } else {
        return;
      }
      e.preventDefault();
    }
    function focus(location2) {
      if (contentRef.value) {
        return focusChild(contentRef.value, location2);
      }
    }
    useRender(() => {
      return createVNode(props.tag, {
        "ref": contentRef,
        "class": ["v-list", {
          "v-list--disabled": props.disabled,
          "v-list--nav": props.nav
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props.class],
        "style": [backgroundColorStyles.value, dimensionStyles.value, props.style],
        "tabindex": props.disabled || isFocused.value ? -1 : 0,
        "role": "listbox",
        "aria-activedescendant": void 0,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onFocus": onFocus,
        "onKeydown": onKeydown
      }, {
        default: () => [createVNode(VListChildren, {
          "items": items.value
        }, slots)]
      });
    });
    return {
      open,
      select,
      focus
    };
  }
});
const _sfc_main$a = {
  components: {
    DialogWithVsIndication
  },
  data() {
    return {
      vitalSignName: "Presión arterial",
      indications: [
        "Que el paciente tome el brazalete del esfigmomanómetro ubicado a su lado izquierdo.",
        "Que el paciente ubique la manguera de color gris para que quede apuntando a la muñeca.",
        "Que el paciente ingrese su mano a través del brazalete hasta llevarlo por arriba del codo.",
        "Que el paciente ajuste fuertemente el brazalete a su brazo.",
        "Pídale al paciente que permanezca inmóvil y no hable durante la medición.",
        "Habiendo obtenido el valor de la presión arterial, pídale que retire el brazalete."
      ],
      textSend: "Enviar",
      sendIcon: "mdi-send"
    };
  },
  // Vars that are parameters to use in component
  props: {
    // Chanel to send in redis
    cabin: {
      type: String
    },
    // Value of sistolic pressure
    sisValue: {
      type: String
    },
    // Value of diastolic pressure
    diasValue: {
      type: String
    },
    // Var to confirm value of vital signs and send to cabin
    confirmRequest: {
      type: String
    },
    // Function to request a vs to python
    requestVsFunction: {
      type: Function
    },
    // Key to know what vs value is received 
    sisKeyVsToSend: {
      type: String
    },
    // Key to know what vs value is received 
    diasKeyVsToSend: {
      type: String
    },
    // Key to know what vs ir requested
    vsNameToRequest: {
      type: String
    },
    // Function to send vs value to cabin
    sendDataCabin: {
      type: Function
    },
    // Key to know the doctor does a request for a vs
    requestVs: {
      type: String
    },
    // Var to know if there are 2 vs to send to cabin
    hasTwoVs: {
      type: Boolean
    },
    // Var to disabled button 
    disabledButton: {
      type: Boolean
    },
    value: Object
  },
  methods: {
    // Function that updates
    updateValueName() {
      this.$emit("input", {
        diastolic_pressure: this.$refs.diastolic_pressure.value,
        systolic_pressure: this.$refs.systolic_pressure.value
      });
    },
    // Request vital sign to python
    requestFunction() {
      if (this.requestVsFunction) {
        this.requestVsFunction(this.cabin, this.vsNameToRequest, this.requestVs);
        this.textSend = "Enviar";
        this.sendIcon = "mdi-send";
      }
    },
    // Send data to cabin when doctor confirms
    sendDataRedis() {
      if (this.sendDataCabin) {
        this.sendDataCabin({ cabin: this.cabin, hasTwo: this.hasTwoVs, value1: this.sisValue, value2: this.diasValue, confirmRequest: this.confirmRequest, key1: this.sisKeyVsToSend, key2: this.diasKeyVsToSend });
        this.textSend = "Enviado";
        this.sendIcon = "mdi-check-circle";
      }
    }
  }
};
const _hoisted_1$a = /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 mt-1 font-weight-bold" }, " Presión Arterial ", -1);
const _hoisted_2$9 = { class: "text-center ml-1 mt-1" };
const _hoisted_3$9 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1" }, " Sistólica ", -1);
const _hoisted_4$9 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1" }, " Diastólica ", -1);
const _hoisted_5$9 = ["id", "value"];
const _hoisted_6$7 = ["id", "value"];
const _hoisted_7$6 = /* @__PURE__ */ createBaseVNode("div", null, " Medir ", -1);
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DialogWithVsIndication = resolveComponent("DialogWithVsIndication");
  return openBlock(), createElementBlock("div", null, [
    createVNode(VRow, {
      class: "ml-3",
      "no-gutters": ""
    }, {
      default: withCtx(() => [
        _hoisted_1$a,
        createBaseVNode("div", _hoisted_2$9, [
          createVNode(_component_DialogWithVsIndication, {
            vitalSignName: $data.vitalSignName,
            indications: $data.indications
          }, null, 8, ["vitalSignName", "indications"])
        ])
      ]),
      _: 1
    }),
    createVNode(VRow, { "no-gutters": "" }, {
      default: withCtx(() => [
        createVNode(VCol, { cols: "12" }, {
          default: withCtx(() => [
            createVNode(VListItem, { lines: "three" }, {
              default: withCtx(() => [
                createVNode(VRow, { "no-gutters": "" }, {
                  default: withCtx(() => [
                    createVNode(VCol, {
                      cols: "12",
                      sm: "6",
                      md: "8"
                    }, {
                      default: withCtx(() => [
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                _hoisted_3$9
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                _hoisted_4$9
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "5" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    id: $props.value?.systolic_pressure >= 121 ? "systolic" : "",
                                    class: "form-field",
                                    type: "number",
                                    ref: "systolic_pressure",
                                    "prepend-icon": "mdi-phone",
                                    placeholder: "",
                                    value: $props.value?.systolic_pressure,
                                    onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_5$9)
                                ])
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, {
                              cols: "5",
                              class: "ml-5"
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    id: $props.value?.diastolic_pressure >= 85 ? "diastolic" : "",
                                    class: "form-field",
                                    type: "number",
                                    ref: "diastolic_pressure",
                                    placeholder: "",
                                    value: $props.value?.diastolic_pressure,
                                    onInput: _cache[1] || (_cache[1] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_6$7)
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(VRow, {
                  "no-gutters": "",
                  class: "mt-4"
                }, {
                  default: withCtx(() => [
                    createVNode(VBtn, {
                      class: "mr-4",
                      color: "#00afb9",
                      variant: "outlined",
                      onClick: $options.requestFunction,
                      disabled: $props.disabledButton
                    }, {
                      default: withCtx(() => [
                        _hoisted_7$6
                      ]),
                      _: 1
                    }, 8, ["onClick", "disabled"]),
                    createVNode(VBtn, {
                      onClick: $options.sendDataRedis,
                      color: "#00afb9",
                      dark: "",
                      elevation: "0"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString($data.textSend) + " ", 1),
                        createVNode(VIcon, { end: "" }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($data.sendIcon), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const DiasSysComponent = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
const HeartRateComponent_vue_vue_type_style_index_0_lang = "";
const _sfc_main$9 = {
  components: {
    DialogWithVsIndication
  },
  data() {
    return {
      vitalSignName: "Pulso-oximetría",
      indications: [
        "Limpie sus manos con el gel desinfectante",
        "Inserte su dedo índice derecho en el sensor ubicado en el descansa brazo derecho.",
        "Pídale al paciente que no mueva el dedo durante la medición."
      ],
      textSend: "Enviar",
      sendIcon: "mdi-send"
    };
  },
  // Vars that are parameters to use in component
  props: {
    // Chanel to send in redis
    cabin: {
      type: String
    },
    // Value of sistolic pressure
    bpmValue: {
      type: String
    },
    // Value of diastolic pressure
    spo2Value: {
      type: String
    },
    // Var to confirm value of vital signs and send to cabin
    confirmRequest: {
      type: String
    },
    // Function to request a vs to python
    requestVsFunction: {
      type: Function
    },
    // Key to know what vs value is received 
    bpmKeyVsToSend: {
      type: String
    },
    // Key to know what vs value is received 
    spo2KeyVsToSend: {
      type: String
    },
    // Key to know what vs ir requested
    vsNameToRequest: {
      type: String
    },
    // Function to send vs value to cabin
    sendDataCabin: {
      type: Function
    },
    // Key to know when doctor makes a request for a vs
    requestVs: {
      type: String
    },
    // Var to know if there are 2 vs to send to cabin
    hasTwoVs: {
      type: Boolean
    },
    // Var to disabled button 
    disabledButton: {
      type: Boolean
    },
    value: Object
  },
  methods: {
    // Function that updates
    updateValueName() {
      this.$emit("input", {
        oxygen: this.$refs.oxygen.value,
        heart_rate: this.$refs.heart_rate.value
      });
    },
    // Request vital sign to python
    requestFunction() {
      if (this.requestVsFunction) {
        this.requestVsFunction(this.cabin, this.vsNameToRequest, this.requestVs);
        this.textSend = "Enviar";
        this.sendIcon = "mdi-send";
      }
    },
    // Send data to cabin when doctor confirms
    sendDataRedis() {
      if (this.sendDataCabin) {
        this.sendDataCabin({ cabin: this.cabin, hasTwo: this.hasTwoVs, value1: this.bpmValue, value2: this.spo2Value, confirmRequest: this.confirmRequest, key1: this.bpmKeyVsToSend, key2: this.spo2KeyVsToSend });
        this.textSend = "Enviado";
        this.sendIcon = "mdi-check-circle";
      }
    }
  }
};
const _hoisted_1$9 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-1 text-h6 font-weight-bold" }, " Oximetría ", -1);
const _hoisted_2$8 = { class: "text-center ml-1 mt-1" };
const _hoisted_3$8 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1" }, " Frecuencia cardíaca ", -1);
const _hoisted_4$8 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1" }, " Saturación de oxígeno ", -1);
const _hoisted_5$8 = ["id", "value"];
const _hoisted_6$6 = ["id", "value"];
const _hoisted_7$5 = /* @__PURE__ */ createBaseVNode("div", null, " Medir ", -1);
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DialogWithVsIndication = resolveComponent("DialogWithVsIndication");
  return openBlock(), createElementBlock("div", null, [
    createVNode(VRow, {
      class: "ml-3",
      "no-gutters": ""
    }, {
      default: withCtx(() => [
        _hoisted_1$9,
        createBaseVNode("div", _hoisted_2$8, [
          createVNode(_component_DialogWithVsIndication, {
            vitalSignName: $data.vitalSignName,
            indications: $data.indications
          }, null, 8, ["vitalSignName", "indications"])
        ])
      ]),
      _: 1
    }),
    createVNode(VRow, { "no-gutters": "" }, {
      default: withCtx(() => [
        createVNode(VCol, { cols: "12" }, {
          default: withCtx(() => [
            createVNode(VListItem, { lines: "three" }, {
              default: withCtx(() => [
                createVNode(VRow, { "no-gutters": "" }, {
                  default: withCtx(() => [
                    createVNode(VCol, {
                      cols: "12",
                      sm: "6",
                      md: "8"
                    }, {
                      default: withCtx(() => [
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                _hoisted_3$8
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                _hoisted_4$8
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "5" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    id: $props.value?.heart_rate >= 60 && $props.value?.heart_rate <= 100 ? "" : "oxygen",
                                    class: "form-field",
                                    type: "number",
                                    ref: "heart_rate",
                                    placeholder: "",
                                    value: $props.value?.heart_rate,
                                    onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_5$8)
                                ])
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, {
                              cols: "5",
                              class: "ml-6"
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    id: $props.value?.oxygen <= 92 ? "oxygen" : "",
                                    class: "form-field",
                                    type: "number",
                                    ref: "oxygen",
                                    placeholder: "",
                                    value: $props.value?.oxygen,
                                    onInput: _cache[1] || (_cache[1] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_6$6)
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(VRow, {
                  "no-gutters": "",
                  class: "mt-4"
                }, {
                  default: withCtx(() => [
                    createVNode(VBtn, {
                      class: "mr-4",
                      color: "#00afb9",
                      variant: "outlined",
                      onClick: $options.requestFunction,
                      disabled: $props.disabledButton
                    }, {
                      default: withCtx(() => [
                        _hoisted_7$5
                      ]),
                      _: 1
                    }, 8, ["onClick", "disabled"]),
                    createVNode(VBtn, {
                      onClick: $options.sendDataRedis,
                      color: "#00afb9",
                      dark: "",
                      elevation: "0"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString($data.textSend) + " ", 1),
                        createVNode(VIcon, { end: "" }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($data.sendIcon), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const HeartRateComponent = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
const WeightComponent_vue_vue_type_style_index_0_lang = "";
const _sfc_main$8 = {
  components: {
    DialogWithVsIndication
  },
  data() {
    return {
      vitalSignName: "Peso",
      indications: [
        "Pídale al paciente que ubique las huellas en el suelo de la cabina.",
        "Indiquele al paciente que se ponga de pie y se pare sobre las huellas.",
        "Que el paciente permanezca inmóvil durante la medición.",
        "Pídale que permanezca de pie en el mismo sitio, al obtener el dato del peso."
      ],
      textSend: "Enviar",
      sendIcon: "mdi-send",
      weightType: "lbs"
    };
  },
  // Vars that are parameters to use in component
  props: {
    // Chanel to send in redis
    cabin: {
      type: String
    },
    // Value of height
    weightValue: {
      type: String
    },
    // Var to confirm value of vital signs and send to cabin
    confirmRequest: {
      type: String
    },
    // Function to request a vs to python
    requestVsFunction: {
      type: Function
    },
    // Key to know what vs value is received 
    weightKeyVsToSend: {
      type: String
    },
    // Key to know what vs ir requested
    vsNameToRequest: {
      type: String
    },
    // Function to send vs value to cabin
    sendDataCabin: {
      type: Function
    },
    // Key to know when doctor makes a request for a vs
    requestVs: {
      type: String
    },
    // Var to know if there are 2 vs to send to cabin
    hasTwoVs: {
      type: Boolean
    },
    // Var to disabled button 
    disabledButton: {
      type: Boolean
    },
    // Value of Weight
    value: Object
  },
  methods: {
    changeSelect() {
      var $select = document.getElementById("weight");
      if (this.$refs.weight.value != "") {
        if ($select.value == "kg") {
          this.weightType = "kg";
          this.$refs.weight.value /= 2.20462;
        } else {
          this.weightType = "lbs";
          this.$refs.weight.value *= 2.20462;
        }
      }
    },
    // Function that updates
    updateValueName() {
      this.$emit("input", {
        weight: this.$refs.weight.value
      });
    },
    // Request vital sign to python
    requestFunction() {
      if (this.requestVsFunction) {
        this.requestVsFunction(this.cabin, this.vsNameToRequest, this.requestVs);
        this.textSend = "Enviar";
        this.sendIcon = "mdi-send";
      }
    },
    // Send data to cabin when doctor confirms
    sendDataRedis() {
      if (this.sendDataCabin) {
        this.sendDataCabin({ cabin: this.cabin, hasTwo: this.hasTwoVs, value1: this.weightValue, value2: "", confirmRequest: this.confirmRequest, key1: this.weightKeyVsToSend, key2: "" });
        this.textSend = "Enviado";
        this.sendIcon = "mdi-check-circle";
      }
    }
  }
};
const _hoisted_1$8 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-1 text-h6 font-weight-bold" }, " Antropometría ", -1);
const _hoisted_2$7 = { class: "text-center ml-1 mt-1" };
const _hoisted_3$7 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1" }, " Peso ", -1);
const _hoisted_4$7 = ["value"];
const _hoisted_5$7 = /* @__PURE__ */ createBaseVNode("option", { value: "lb" }, "lb", -1);
const _hoisted_6$5 = /* @__PURE__ */ createBaseVNode("option", { value: "kg" }, "kg", -1);
const _hoisted_7$4 = [
  _hoisted_5$7,
  _hoisted_6$5
];
const _hoisted_8$4 = /* @__PURE__ */ createBaseVNode("div", null, " Medir ", -1);
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DialogWithVsIndication = resolveComponent("DialogWithVsIndication");
  return openBlock(), createElementBlock("div", null, [
    createVNode(VRow, {
      class: "ml-3",
      "no-gutters": ""
    }, {
      default: withCtx(() => [
        _hoisted_1$8,
        createBaseVNode("div", _hoisted_2$7, [
          createVNode(_component_DialogWithVsIndication, {
            vitalSignName: $data.vitalSignName,
            indications: $data.indications
          }, null, 8, ["vitalSignName", "indications"])
        ])
      ]),
      _: 1
    }),
    createVNode(VRow, { "no-gutters": "" }, {
      default: withCtx(() => [
        createVNode(VCol, { cols: "12" }, {
          default: withCtx(() => [
            createVNode(VListItem, { lines: "three" }, {
              default: withCtx(() => [
                createVNode(VRow, { "no-gutters": "" }, {
                  default: withCtx(() => [
                    createVNode(VCol, {
                      cols: "12",
                      sm: "6",
                      md: "8"
                    }, {
                      default: withCtx(() => [
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                _hoisted_3$7
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    class: "form-field",
                                    type: "number",
                                    ref: "weight",
                                    placeholder: "",
                                    value: $props.value?.weight,
                                    onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_4$7)
                                ])
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, {
                              cols: "3",
                              class: "ml-2"
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("select", {
                                    onChange: _cache[1] || (_cache[1] = ($event) => $options.changeSelect()),
                                    id: "weight",
                                    name: "weight",
                                    class: "form-field",
                                    style: { "min-width": "70px" }
                                  }, _hoisted_7$4, 32)
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(VRow, {
                  "no-gutters": "",
                  class: "mt-4"
                }, {
                  default: withCtx(() => [
                    createVNode(VBtn, {
                      class: "mr-4",
                      color: "#00afb9",
                      variant: "outlined",
                      onClick: $options.requestFunction,
                      disabled: $props.disabledButton
                    }, {
                      default: withCtx(() => [
                        _hoisted_8$4
                      ]),
                      _: 1
                    }, 8, ["onClick", "disabled"]),
                    createVNode(VBtn, {
                      onClick: $options.sendDataRedis,
                      color: "#00afb9",
                      dark: "",
                      elevation: "0"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString($data.textSend) + " ", 1),
                        createVNode(VIcon, { end: "" }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($data.sendIcon), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const WeightComponent = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
const HeightComponent_vue_vue_type_style_index_0_lang = "";
const _sfc_main$7 = {
  components: {
    DialogWithVsIndication
  },
  data() {
    return {
      vitalSignName: "Altura",
      indications: [
        "Pídale que se pare de forma erguido y vea al frente a un punto fijo.",
        "Que el paciente permanezca inmóvil durante la medición.",
        "Pídale que permanezca de pie al obtener el valor de la altura."
      ],
      textSend: "Enviar",
      sendIcon: "mdi-send"
    };
  },
  // Vars that are parameters to use in component
  props: {
    // Chanel to send in redis
    cabin: {
      type: String
    },
    // Value of height
    heightValue: {
      type: String
    },
    // Var to confirm value of vital signs and send to cabin
    confirmRequest: {
      type: String
    },
    // Function to request a vs to python
    requestVsFunction: {
      type: Function
    },
    // Key to know what vs value is received 
    heightKeyVsToSend: {
      type: String
    },
    // Key to know what vs ir requested
    vsNameToRequest: {
      type: String
    },
    // Function to send vs value to cabin
    sendDataCabin: {
      type: Function
    },
    // Key to know when doctor makes a request for a vs
    requestVs: {
      type: String
    },
    // Var to know if there are 2 vs to send to cabin
    hasTwoVs: {
      type: Boolean
    },
    // Var to disabled button 
    disabledButton: {
      type: Boolean
    },
    value: Object
  },
  methods: {
    // Function that updates
    updateValueName() {
      this.$emit("input", {
        height: this.$refs.height.value
      });
      console.log(this.$refs.height.value);
    },
    // Request vital sign to python
    requestFunction() {
      if (this.requestVsFunction) {
        this.requestVsFunction(this.cabin, this.vsNameToRequest, this.requestVs);
        this.textSend = "Enviar";
        this.sendIcon = "mdi-send";
      }
    },
    // Send data to cabin when doctor confirms
    sendDataRedis() {
      if (this.sendDataCabin) {
        this.sendDataCabin({ cabin: this.cabin, hasTwo: this.hasTwoVs, value1: this.heightValue, value2: "", confirmRequest: this.confirmRequest, key1: this.heightKeyVsToSend, key2: "" });
        this.textSend = "Enviado";
        this.sendIcon = "mdi-check-circle";
      }
    }
  }
};
const _hoisted_1$7 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-1 text-h6 font-weight-bold" }, " Antropometría ", -1);
const _hoisted_2$6 = { class: "text-center ml-1 mt-1" };
const _hoisted_3$6 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1" }, " Altura ", -1);
const _hoisted_4$6 = ["value"];
const _hoisted_5$6 = /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 text-grey ml-2" }, " m ", -1);
const _hoisted_6$4 = /* @__PURE__ */ createBaseVNode("div", null, " Medir ", -1);
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DialogWithVsIndication = resolveComponent("DialogWithVsIndication");
  return openBlock(), createElementBlock("div", null, [
    createVNode(VRow, {
      class: "ml-3",
      "no-gutters": ""
    }, {
      default: withCtx(() => [
        _hoisted_1$7,
        createBaseVNode("div", _hoisted_2$6, [
          createVNode(_component_DialogWithVsIndication, {
            vitalSignName: $data.vitalSignName,
            indications: $data.indications
          }, null, 8, ["vitalSignName", "indications"])
        ])
      ]),
      _: 1
    }),
    createVNode(VRow, { "no-gutters": "" }, {
      default: withCtx(() => [
        createVNode(VCol, { cols: "12" }, {
          default: withCtx(() => [
            createVNode(VListItem, { lines: "three" }, {
              default: withCtx(() => [
                createVNode(VRow, { "no-gutters": "" }, {
                  default: withCtx(() => [
                    createVNode(VCol, {
                      cols: "12",
                      sm: "6",
                      md: "8"
                    }, {
                      default: withCtx(() => [
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                _hoisted_3$6
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    class: "form-field",
                                    type: "text",
                                    ref: "height",
                                    placeholder: "",
                                    value: $props.value?.height,
                                    onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_4$6)
                                ])
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, null, {
                              default: withCtx(() => [
                                _hoisted_5$6
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(VRow, {
                  "no-gutters": "",
                  class: "mt-4"
                }, {
                  default: withCtx(() => [
                    createVNode(VBtn, {
                      class: "mr-4",
                      color: "#00afb9",
                      variant: "outlined",
                      onClick: $options.requestFunction,
                      disabled: $props.disabledButton
                    }, {
                      default: withCtx(() => [
                        _hoisted_6$4
                      ]),
                      _: 1
                    }, 8, ["onClick", "disabled"]),
                    createVNode(VBtn, {
                      onClick: $options.sendDataRedis,
                      color: "#00afb9",
                      dark: "",
                      elevation: "0"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString($data.textSend) + " ", 1),
                        createVNode(VIcon, { end: "" }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($data.sendIcon), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const HeightComponent = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const TemperatureComponent_vue_vue_type_style_index_0_lang = "";
const _sfc_main$6 = {
  components: {
    DialogWithVsIndication
  },
  data() {
    return {
      vitalSignName: "Temperatura",
      indications: [
        "Pidale que ubique el dispositivo de color blanco al lado derecho de la pantalla o monitor frente a ellos.",
        "Indíquele que acerque su frente a una distancia de dos dedos del sensor y que permanezca de pie. Ud le indicará cuando se pueda sentar.",
        "Pídale al paciente que tome asiento al obtener el resultado."
      ],
      textSend: "Enviar",
      sendIcon: "mdi-send"
    };
  },
  // Vars that are parameters to use in component
  props: {
    // Chanel to send in redis
    cabin: {
      type: String
    },
    // Value of temperature
    tmpValue: {
      type: String
    },
    // Var to confirm value of vital signs and send to cabin
    confirmRequest: {
      type: String
    },
    // Function to request a vs to python
    requestVsFunction: {
      type: Function
    },
    // Key to know what vs value is received 
    tmpKeyVsToSend: {
      type: String
    },
    // Key to know what vs ir requested
    vsNameToRequest: {
      type: String
    },
    // Function to send vs value to cabin
    sendDataCabin: {
      type: Function
    },
    // Key to know when doctor makes a request for a vs
    requestVs: {
      type: String
    },
    // Var to know if there are 2 vs to send to cabin
    hasTwoVs: {
      type: Boolean
    },
    // Var to disabled button 
    disabledButton: {
      type: Boolean
    },
    value: Object
  },
  methods: {
    // Function that updates
    updateValueName() {
      this.$emit("input", {
        temperature: this.$refs.temperature.value
      });
    },
    // Request vital sign to python
    requestFunction() {
      if (this.requestVsFunction) {
        this.requestVsFunction(this.cabin, this.vsNameToRequest, this.requestVs);
        this.textSend = "Enviar";
        this.sendIcon = "mdi-send";
      }
    },
    // Send data to cabin when doctor confirms
    sendDataRedis() {
      if (this.sendDataCabin) {
        this.sendDataCabin({ cabin: this.cabin, hasTwo: this.hasTwoVs, value1: this.tmpValue, value2: "", confirmRequest: this.confirmRequest, key1: this.tmpKeyVsToSend, key2: "" });
        this.textSend = "Enviado";
        this.sendIcon = "mdi-check-circle";
      }
    }
  }
};
const _hoisted_1$6 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-1 text-h6 font-weight-bold" }, " Temperatura ", -1);
const _hoisted_2$5 = { class: "text-center" };
const _hoisted_3$5 = ["id", "value"];
const _hoisted_4$5 = /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 text-grey ml-2" }, " °C ", -1);
const _hoisted_5$5 = /* @__PURE__ */ createBaseVNode("div", null, " Medir ", -1);
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DialogWithVsIndication = resolveComponent("DialogWithVsIndication");
  return openBlock(), createElementBlock("div", null, [
    createVNode(VRow, {
      class: "ml-3",
      "no-gutters": ""
    }, {
      default: withCtx(() => [
        _hoisted_1$6,
        createBaseVNode("div", _hoisted_2$5, [
          createVNode(_component_DialogWithVsIndication, {
            vitalSignName: $data.vitalSignName,
            indications: $data.indications
          }, null, 8, ["vitalSignName", "indications"])
        ])
      ]),
      _: 1
    }),
    createVNode(VRow, { "no-gutters": "" }, {
      default: withCtx(() => [
        createVNode(VCol, { cols: "12" }, {
          default: withCtx(() => [
            createVNode(VListItem, { lines: "three" }, {
              default: withCtx(() => [
                createVNode(VRow, { "no-gutters": "" }, {
                  default: withCtx(() => [
                    createVNode(VCol, {
                      cols: "12",
                      sm: "6",
                      md: "8"
                    }, {
                      default: withCtx(() => [
                        createVNode(VRow, {
                          "no-gutters": "",
                          class: "mt-2"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCol, { cols: "6" }, {
                              default: withCtx(() => [
                                createBaseVNode("div", null, [
                                  createBaseVNode("input", {
                                    id: $props.value?.temperature > 37.99 ? "temperature" : "",
                                    class: "form-field",
                                    type: "number",
                                    ref: "temperature",
                                    placeholder: "",
                                    prefix: "$",
                                    value: $props.value?.temperature,
                                    onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValueName())
                                  }, null, 40, _hoisted_3$5)
                                ])
                              ]),
                              _: 1
                            }),
                            createVNode(VCol, null, {
                              default: withCtx(() => [
                                _hoisted_4$5
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                createVNode(VRow, {
                  "no-gutters": "",
                  class: "mt-4"
                }, {
                  default: withCtx(() => [
                    createVNode(VBtn, {
                      class: "mr-4",
                      color: "#00afb9",
                      variant: "outlined",
                      onClick: $options.requestFunction,
                      disabled: $props.disabledButton
                    }, {
                      default: withCtx(() => [
                        _hoisted_5$5
                      ]),
                      _: 1
                    }, 8, ["onClick", "disabled"]),
                    createVNode(VBtn, {
                      onClick: $options.sendDataRedis,
                      color: "#00afb9",
                      dark: "",
                      elevation: "0"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString($data.textSend) + " ", 1),
                        createVNode(VIcon, { end: "" }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($data.sendIcon), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const TemperatureComponent = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _imports_5 = "" + new URL("esfi-2a5d9c21.png", import.meta.url).href;
const _imports_6 = "" + new URL("lungs-33fe5331.png", import.meta.url).href;
const VitalSignsResults_vue_vue_type_style_index_0_lang = "";
const VChip$1 = "";
const VChipGroup = "";
const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
const makeVChipGroupProps = propsFactory({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeComponentProps(),
  ...makeGroupProps({
    selectedClass: "v-chip--selected"
  }),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "tonal"
  })
}, "VChipGroup");
genericComponent()({
  name: "VChipGroup",
  props: makeVChipGroupProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isSelected,
      select,
      next,
      prev: prev2,
      selected
    } = useGroup(props, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        filter: toRef(props, "filter"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => createVNode(props.tag, {
      "class": ["v-chip-group", {
        "v-chip-group--column": props.column
      }, themeClasses.value, props.class],
      "style": props.style
    }, {
      default: () => [slots.default?.({
        isSelected,
        select,
        next,
        prev: prev2,
        selected: selected.value
      })]
    }));
    return {};
  }
});
const makeVChipProps = propsFactory({
  activeClass: String,
  appendAvatar: String,
  appendIcon: IconValue,
  closable: Boolean,
  closeIcon: {
    type: IconValue,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: true
  },
  onClick: EventProp(),
  onClickOnce: EventProp(),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "span"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "tonal"
  })
}, "VChip");
const VChip = genericComponent()({
  name: "VChip",
  directives: {
    Ripple
  },
  props: makeVChipProps(),
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value2) => true,
    "group:selected": (val) => true,
    click: (e) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses
    } = useSize(props);
    const {
      themeClasses
    } = provideTheme(props);
    const isActive = useProxiedModel(props, "modelValue");
    const group = useGroupItem(props, VChipGroupSymbol, false);
    const link = useLink(props, attrs);
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
    const closeProps = computed(() => ({
      "aria-label": t(props.closeLabel),
      onClick(e) {
        e.stopPropagation();
        isActive.value = false;
        emit2("click:close", e);
      }
    }));
    function onClick(e) {
      emit2("click", e);
      if (!isClickable.value)
        return;
      link.navigate?.(e);
      group?.toggle();
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    return () => {
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasAppendMedia = !!(props.appendIcon || props.appendAvatar);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasClose = !!(slots.close || props.closable);
      const hasFilter = !!(slots.filter || props.filter) && group;
      const hasPrependMedia = !!(props.prependIcon || props.prependAvatar);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      const hasColor = !group || group.isSelected.value;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props.disabled,
          "v-chip--label": props.label,
          "v-chip--link": isClickable.value,
          "v-chip--filter": hasFilter,
          "v-chip--pill": props.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group?.selectedClass.value, props.class],
        "style": [hasColor ? colorStyles.value : void 0, props.style],
        "disabled": props.disabled || void 0,
        "draggable": props.draggable,
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
          "key": "filter"
        }, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-chip__filter"
          }, [!slots.filter ? createVNode(VIcon, {
            "key": "filter-icon",
            "icon": props.filterIcon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "filter-defaults",
            "disabled": !props.filterIcon,
            "defaults": {
              VIcon: {
                icon: props.filterIcon
              }
            }
          }, slots.filter)]), [[vShow, group.isSelected.value]])]
        }), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-chip__prepend"
        }, [!slots.prepend ? createVNode(Fragment, null, [props.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "icon": props.prependIcon,
          "start": true
        }, null), props.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "image": props.prependAvatar,
          "start": true
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              image: props.prependAvatar,
              start: true
            },
            VIcon: {
              icon: props.prependIcon,
              start: true
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-chip__content"
        }, [slots.default?.({
          isSelected: group?.isSelected.value,
          selectedClass: group?.selectedClass.value,
          select: group?.select,
          toggle: group?.toggle,
          value: group?.value.value,
          disabled: props.disabled
        }) ?? props.text]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-chip__append"
        }, [!slots.append ? createVNode(Fragment, null, [props.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "end": true,
          "icon": props.appendIcon
        }, null), props.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "end": true,
          "image": props.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              end: true,
              image: props.appendAvatar
            },
            VIcon: {
              end: true,
              icon: props.appendIcon
            }
          }
        }, slots.append)]), hasClose && createVNode("div", mergeProps({
          "key": "close",
          "class": "v-chip__close"
        }, closeProps.value), [!slots.close ? createVNode(VIcon, {
          "key": "close-icon",
          "icon": props.closeIcon,
          "size": "x-small"
        }, null) : createVNode(VDefaultsProvider, {
          "key": "close-defaults",
          "defaults": {
            VIcon: {
              icon: props.closeIcon,
              size: "x-small"
            }
          }
        }, slots.close)])]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
    };
  }
});
const _sfc_main$5 = {
  data() {
    return {};
  },
  props: {
    weight: {
      type: String
    },
    height: {
      type: String
    },
    oxygen: {
      type: String
    },
    bpmF: {
      type: String
    },
    temperature: {
      type: String
    },
    systolicPressure: {
      type: String
    },
    diastolicPressure: {
      type: String
    },
    esfigmoAvailable: {
      type: Boolean
    },
    imc: {
      type: String
    }
  }
};
const _hoisted_1$5 = { class: "text-center" };
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("img", {
  style: { "max-height": "20px", "max-width": "20px" },
  src: _imports_5
}, null, -1);
const _hoisted_3$4 = ["id"];
const _hoisted_4$4 = /* @__PURE__ */ createBaseVNode("span", { class: "mr-1 ml-1" }, "/", -1);
const _hoisted_5$4 = ["id"];
const _hoisted_6$3 = /* @__PURE__ */ createBaseVNode("img", {
  style: { "max-height": "25px", "max-width": "25px" },
  src: _imports_6
}, null, -1);
const _hoisted_7$3 = ["id"];
const _hoisted_8$3 = /* @__PURE__ */ createBaseVNode("span", { class: "mr-1 ml-1" }, "-", -1);
const _hoisted_9$3 = ["id"];
const _hoisted_10$3 = ["id"];
const _hoisted_11$3 = ["id"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createVNode(VRow, {
      "no-gutters": "",
      justify: "start"
    }, {
      default: withCtx(() => [
        createVNode(VChip, {
          class: "ma-2",
          label: ""
        }, {
          default: withCtx(() => [
            _hoisted_2$4,
            createBaseVNode("span", {
              id: $props.systolicPressure >= 121 ? "orange-text" : "",
              class: "mr-1 ml-2"
            }, toDisplayString($props.systolicPressure), 9, _hoisted_3$4),
            _hoisted_4$4,
            createBaseVNode("span", {
              id: $props.diastolicPressure >= 85 ? "orange-text" : "",
              class: "mr-1"
            }, toDisplayString($props.diastolicPressure), 9, _hoisted_5$4)
          ]),
          _: 1
        }),
        createVNode(VChip, {
          class: "ma-2",
          label: ""
        }, {
          default: withCtx(() => [
            _hoisted_6$3,
            createBaseVNode("span", {
              id: $props.bpmF >= 60 && $props.bpmF <= 100 ? "" : "orange-text",
              class: "mr-1 ml-1"
            }, toDisplayString($props.bpmF), 9, _hoisted_7$3),
            createTextVNode(" lpm "),
            _hoisted_8$3,
            createBaseVNode("span", {
              id: $props.oxygen <= 92 ? "orange-text" : "",
              class: "mr-1"
            }, toDisplayString($props.oxygen), 9, _hoisted_9$3),
            createTextVNode("% ")
          ]),
          _: 1
        }),
        createVNode(VChip, {
          class: "ma-2",
          label: ""
        }, {
          default: withCtx(() => [
            createVNode(VIcon, { start: "" }, {
              default: withCtx(() => [
                createTextVNode(" mdi-weight-pound ")
              ]),
              _: 1
            }),
            createTextVNode(" " + toDisplayString(parseFloat($props.weight ?? 0).toFixed(2).toString() || $props.weight), 1)
          ]),
          _: 1
        }),
        createVNode(VChip, {
          class: "ma-2",
          label: ""
        }, {
          default: withCtx(() => [
            createVNode(VIcon, { start: "" }, {
              default: withCtx(() => [
                createTextVNode(" mdi-human-male-height ")
              ]),
              _: 1
            }),
            createTextVNode(" " + toDisplayString($props.height), 1)
          ]),
          _: 1
        }),
        createVNode(VChip, {
          class: "ma-2",
          label: ""
        }, {
          default: withCtx(() => [
            createVNode(VIcon, { start: "" }, {
              default: withCtx(() => [
                createTextVNode(" mdi-thermometer-lines ")
              ]),
              _: 1
            }),
            createBaseVNode("span", {
              id: $props.temperature > 37.99 ? "orange-text" : ""
            }, toDisplayString($props.temperature), 9, _hoisted_10$3)
          ]),
          _: 1
        }),
        createVNode(VChip, {
          class: "ma-2",
          label: ""
        }, {
          default: withCtx(() => [
            createVNode(VIcon, { start: "" }, {
              default: withCtx(() => [
                createTextVNode(" mdi-human-handsdown ")
              ]),
              _: 1
            }),
            createBaseVNode("span", {
              id: $props.imc < 19 || $props.imc > 24.99 ? "orange-text" : ""
            }, "IMC " + toDisplayString($props.imc), 9, _hoisted_11$3)
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const VitalSignsResults = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const VCard$1 = "";
const VCardActions = genericComponent()({
  name: "VCardActions",
  props: makeComponentProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        variant: "text"
      }
    });
    useRender(() => createVNode("div", {
      "class": ["v-card-actions", props.class],
      "style": props.style
    }, [slots.default?.()]));
    return {};
  }
});
const VCardSubtitle = createSimpleFunctional("v-card-subtitle");
const VCardTitle = createSimpleFunctional("v-card-title");
const makeCardItemProps = propsFactory({
  appendAvatar: String,
  appendIcon: IconValue,
  prependAvatar: String,
  prependIcon: IconValue,
  subtitle: String,
  title: String,
  ...makeComponentProps(),
  ...makeDensityProps()
}, "VCardItem");
const VCardItem = genericComponent()({
  name: "VCardItem",
  props: makeCardItemProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      const hasPrependMedia = !!(props.prependAvatar || props.prependIcon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      const hasAppendMedia = !!(props.appendAvatar || props.appendIcon);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasTitle = !!(props.title || slots.title);
      const hasSubtitle = !!(props.subtitle || slots.subtitle);
      return createVNode("div", {
        "class": ["v-card-item", props.class],
        "style": props.style
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-card-item__prepend"
      }, [!slots.prepend ? hasPrependMedia && createVNode(VAvatar, {
        "key": "prepend-avatar",
        "density": props.density,
        "icon": props.prependIcon,
        "image": props.prependAvatar
      }, null) : createVNode(VDefaultsProvider, {
        "key": "prepend-defaults",
        "disabled": !hasPrependMedia,
        "defaults": {
          VAvatar: {
            density: props.density,
            icon: props.prependIcon,
            image: props.prependAvatar
          }
        }
      }, slots.prepend)]), createVNode("div", {
        "class": "v-card-item__content"
      }, [hasTitle && createVNode(VCardTitle, {
        "key": "title"
      }, {
        default: () => [slots.title?.() ?? props.title]
      }), hasSubtitle && createVNode(VCardSubtitle, {
        "key": "subtitle"
      }, {
        default: () => [slots.subtitle?.() ?? props.subtitle]
      }), slots.default?.()]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-card-item__append"
      }, [!slots.append ? hasAppendMedia && createVNode(VAvatar, {
        "key": "append-avatar",
        "density": props.density,
        "icon": props.appendIcon,
        "image": props.appendAvatar
      }, null) : createVNode(VDefaultsProvider, {
        "key": "append-defaults",
        "disabled": !hasAppendMedia,
        "defaults": {
          VAvatar: {
            density: props.density,
            icon: props.appendIcon,
            image: props.appendAvatar
          }
        }
      }, slots.append)])]);
    });
    return {};
  }
});
const VCardText = createSimpleFunctional("v-card-text");
const makeVCardProps = propsFactory({
  appendAvatar: String,
  appendIcon: IconValue,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  subtitle: String,
  text: String,
  title: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLoaderProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "elevated"
  })
}, "VCard");
const VCard = genericComponent()({
  name: "VCard",
  directives: {
    Ripple
  },
  props: makeVCardProps(),
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const link = useLink(props, attrs);
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value));
    useRender(() => {
      const Tag = isLink.value ? "a" : props.tag;
      const hasTitle = !!(slots.title || props.title);
      const hasSubtitle = !!(slots.subtitle || props.subtitle);
      const hasHeader = hasTitle || hasSubtitle;
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      const hasImage = !!(slots.image || props.image);
      const hasCardItem = hasHeader || hasPrepend || hasAppend;
      const hasText = !!(slots.text || props.text);
      return withDirectives(createVNode(Tag, {
        "class": ["v-card", {
          "v-card--disabled": props.disabled,
          "v-card--flat": props.flat,
          "v-card--hover": props.hover && !(props.disabled || props.flat),
          "v-card--link": isClickable.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
        "href": link.href.value,
        "onClick": isClickable.value && link.navigate,
        "tabindex": props.disabled ? -1 : void 0
      }, {
        default: () => [hasImage && createVNode("div", {
          "key": "image",
          "class": "v-card__image"
        }, [!slots.image ? createVNode(VImg, {
          "key": "image-img",
          "cover": true,
          "src": props.image
        }, null) : createVNode(VDefaultsProvider, {
          "key": "image-defaults",
          "disabled": !props.image,
          "defaults": {
            VImg: {
              cover: true,
              src: props.image
            }
          }
        }, slots.image)]), createVNode(LoaderSlot, {
          "name": "v-card",
          "active": !!props.loading,
          "color": typeof props.loading === "boolean" ? void 0 : props.loading
        }, {
          default: slots.loader
        }), hasCardItem && createVNode(VCardItem, {
          "key": "item",
          "prependAvatar": props.prependAvatar,
          "prependIcon": props.prependIcon,
          "title": props.title,
          "subtitle": props.subtitle,
          "appendAvatar": props.appendAvatar,
          "appendIcon": props.appendIcon
        }, {
          default: slots.item,
          prepend: slots.prepend,
          title: slots.title,
          subtitle: slots.subtitle,
          append: slots.append
        }), hasText && createVNode(VCardText, {
          "key": "text"
        }, {
          default: () => [slots.text?.() ?? props.text]
        }), slots.default?.(), slots.actions && createVNode(VCardActions, null, {
          default: slots.actions
        }), genOverlays(isClickable.value, "v-card")]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
    });
    return {};
  }
});
const VCarousel$1 = "";
const VWindow$1 = "";
const handleGesture = (wrapper) => {
  const {
    touchstartX,
    touchendX,
    touchstartY,
    touchendY
  } = wrapper;
  const dirRatio = 0.5;
  const minDistance = 16;
  wrapper.offsetX = touchendX - touchstartX;
  wrapper.offsetY = touchendY - touchstartY;
  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {
    wrapper.left && touchendX < touchstartX - minDistance && wrapper.left(wrapper);
    wrapper.right && touchendX > touchstartX + minDistance && wrapper.right(wrapper);
  }
  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {
    wrapper.up && touchendY < touchstartY - minDistance && wrapper.up(wrapper);
    wrapper.down && touchendY > touchstartY + minDistance && wrapper.down(wrapper);
  }
};
function touchstart(event, wrapper) {
  const touch = event.changedTouches[0];
  wrapper.touchstartX = touch.clientX;
  wrapper.touchstartY = touch.clientY;
  wrapper.start?.({
    originalEvent: event,
    ...wrapper
  });
}
function touchend(event, wrapper) {
  const touch = event.changedTouches[0];
  wrapper.touchendX = touch.clientX;
  wrapper.touchendY = touch.clientY;
  wrapper.end?.({
    originalEvent: event,
    ...wrapper
  });
  handleGesture(wrapper);
}
function touchmove(event, wrapper) {
  const touch = event.changedTouches[0];
  wrapper.touchmoveX = touch.clientX;
  wrapper.touchmoveY = touch.clientY;
  wrapper.move?.({
    originalEvent: event,
    ...wrapper
  });
}
function createHandlers() {
  let value2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const wrapper = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: value2.left,
    right: value2.right,
    up: value2.up,
    down: value2.down,
    start: value2.start,
    move: value2.move,
    end: value2.end
  };
  return {
    touchstart: (e) => touchstart(e, wrapper),
    touchend: (e) => touchend(e, wrapper),
    touchmove: (e) => touchmove(e, wrapper)
  };
}
function mounted(el, binding) {
  const value2 = binding.value;
  const target = value2?.parent ? el.parentElement : el;
  const options = value2?.options ?? {
    passive: true
  };
  const uid2 = binding.instance?.$.uid;
  if (!target || !uid2)
    return;
  const handlers2 = createHandlers(binding.value);
  target._touchHandlers = target._touchHandlers ?? /* @__PURE__ */ Object.create(null);
  target._touchHandlers[uid2] = handlers2;
  keys$1(handlers2).forEach((eventName2) => {
    target.addEventListener(eventName2, handlers2[eventName2], options);
  });
}
function unmounted(el, binding) {
  const target = binding.value?.parent ? el.parentElement : el;
  const uid2 = binding.instance?.$.uid;
  if (!target?._touchHandlers || !uid2)
    return;
  const handlers2 = target._touchHandlers[uid2];
  keys$1(handlers2).forEach((eventName2) => {
    target.removeEventListener(eventName2, handlers2[eventName2]);
  });
  delete target._touchHandlers[uid2];
}
const Touch = {
  mounted,
  unmounted
};
const Touch$1 = Touch;
const VWindowSymbol = Symbol.for("vuetify:v-window");
const VWindowGroupSymbol = Symbol.for("vuetify:v-window-group");
const makeVWindowProps = propsFactory({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (v) => typeof v === "boolean" || v === "hover"
  },
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  ...makeComponentProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VWindow");
const VWindow = genericComponent()({
  name: "VWindow",
  directives: {
    Touch
  },
  props: makeVWindowProps(),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isRtl
    } = useRtl();
    const {
      t
    } = useLocale();
    const group = useGroup(props, VWindowGroupSymbol);
    const rootRef = ref();
    const isRtlReverse = computed(() => isRtl.value ? !props.reverse : props.reverse);
    const isReversed = shallowRef(false);
    const transition = computed(() => {
      const axis = props.direction === "vertical" ? "y" : "x";
      const reverse = isRtlReverse.value ? !isReversed.value : isReversed.value;
      const direction = reverse ? "-reverse" : "";
      return `v-window-${axis}${direction}-transition`;
    });
    const transitionCount = shallowRef(0);
    const transitionHeight = ref(void 0);
    const activeIndex = computed(() => {
      return group.items.value.findIndex((item) => group.selected.value.includes(item.id));
    });
    watch(activeIndex, (newVal, oldVal) => {
      const itemsLength = group.items.value.length;
      const lastIndex = itemsLength - 1;
      if (itemsLength <= 2) {
        isReversed.value = newVal < oldVal;
      } else if (newVal === lastIndex && oldVal === 0) {
        isReversed.value = true;
      } else if (newVal === 0 && oldVal === lastIndex) {
        isReversed.value = false;
      } else {
        isReversed.value = newVal < oldVal;
      }
    });
    provide(VWindowSymbol, {
      transition,
      isReversed,
      transitionCount,
      transitionHeight,
      rootRef
    });
    const canMoveBack = computed(() => props.continuous || activeIndex.value !== 0);
    const canMoveForward = computed(() => props.continuous || activeIndex.value !== group.items.value.length - 1);
    function prev2() {
      canMoveBack.value && group.prev();
    }
    function next() {
      canMoveForward.value && group.next();
    }
    const arrows = computed(() => {
      const arrows2 = [];
      const prevProps = {
        icon: isRtl.value ? props.nextIcon : props.prevIcon,
        class: `v-window__${isRtlReverse.value ? "right" : "left"}`,
        onClick: group.prev,
        ariaLabel: t("$vuetify.carousel.prev")
      };
      arrows2.push(canMoveBack.value ? slots.prev ? slots.prev({
        props: prevProps
      }) : createVNode(VBtn, prevProps, null) : createVNode("div", null, null));
      const nextProps = {
        icon: isRtl.value ? props.prevIcon : props.nextIcon,
        class: `v-window__${isRtlReverse.value ? "left" : "right"}`,
        onClick: group.next,
        ariaLabel: t("$vuetify.carousel.next")
      };
      arrows2.push(canMoveForward.value ? slots.next ? slots.next({
        props: nextProps
      }) : createVNode(VBtn, nextProps, null) : createVNode("div", null, null));
      return arrows2;
    });
    const touchOptions = computed(() => {
      if (props.touch === false)
        return props.touch;
      const options = {
        left: () => {
          isRtlReverse.value ? prev2() : next();
        },
        right: () => {
          isRtlReverse.value ? next() : prev2();
        },
        start: (_ref2) => {
          let {
            originalEvent
          } = _ref2;
          originalEvent.stopPropagation();
        }
      };
      return {
        ...options,
        ...props.touch === true ? {} : props.touch
      };
    });
    useRender(() => withDirectives(createVNode(props.tag, {
      "ref": rootRef,
      "class": ["v-window", {
        "v-window--show-arrows-on-hover": props.showArrows === "hover"
      }, themeClasses.value, props.class],
      "style": props.style
    }, {
      default: () => [createVNode("div", {
        "class": "v-window__container",
        "style": {
          height: transitionHeight.value
        }
      }, [slots.default?.({
        group
      }), props.showArrows !== false && createVNode("div", {
        "class": "v-window__controls"
      }, [arrows.value])]), slots.additional?.({
        group
      })]
    }), [[resolveDirective("touch"), touchOptions.value]]));
    return {
      group
    };
  }
});
const makeVCarouselProps = propsFactory({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: IconValue,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (value2) => Number(value2) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...makeVWindowProps({
    continuous: true,
    mandatory: "force",
    showArrows: true
  })
}, "VCarousel");
const VCarousel = genericComponent()({
  name: "VCarousel",
  props: makeVCarouselProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const {
      t
    } = useLocale();
    const windowRef = ref();
    let slideTimeout = -1;
    watch(model, restartTimeout);
    watch(() => props.interval, restartTimeout);
    watch(() => props.cycle, (val) => {
      if (val)
        restartTimeout();
      else
        window.clearTimeout(slideTimeout);
    });
    onMounted(startTimeout);
    function startTimeout() {
      if (!props.cycle || !windowRef.value)
        return;
      slideTimeout = window.setTimeout(windowRef.value.group.next, +props.interval > 0 ? +props.interval : 6e3);
    }
    function restartTimeout() {
      window.clearTimeout(slideTimeout);
      window.requestAnimationFrame(startTimeout);
    }
    useRender(() => {
      const [windowProps] = VWindow.filterProps(props);
      return createVNode(VWindow, mergeProps({
        "ref": windowRef
      }, windowProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-carousel", {
          "v-carousel--hide-delimiter-background": props.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": props.verticalDelimiters
        }, props.class],
        "style": [{
          height: convertToUnit(props.height)
        }, props.style]
      }), {
        default: slots.default,
        additional: (_ref2) => {
          let {
            group
          } = _ref2;
          return createVNode(Fragment, null, [!props.hideDelimiters && createVNode("div", {
            "class": "v-carousel__controls",
            "style": {
              left: props.verticalDelimiters === "left" && props.verticalDelimiters ? 0 : "auto",
              right: props.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [group.items.value.length > 0 && createVNode(VDefaultsProvider, {
            "defaults": {
              VBtn: {
                color: props.color,
                icon: props.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            "scoped": true
          }, {
            default: () => [group.items.value.map((item, index) => {
              const props2 = {
                id: `carousel-item-${item.id}`,
                "aria-label": t("$vuetify.carousel.ariaLabel.delimiter", index + 1, group.items.value.length),
                class: [group.isSelected(item.id) && "v-btn--active"],
                onClick: () => group.select(item.id, true)
              };
              return slots.item ? slots.item({
                props: props2,
                item
              }) : createVNode(VBtn, mergeProps(item, props2), null);
            })]
          })]), props.progress && createVNode(VProgressLinear, {
            "class": "v-carousel__progress",
            "color": typeof props.progress === "string" ? props.progress : void 0,
            "modelValue": (group.getItemIndex(model.value) + 1) / group.items.value.length * 100
          }, null)]);
        },
        prev: slots.prev,
        next: slots.next
      });
    });
    return {};
  }
});
const makeVWindowItemProps = propsFactory({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...makeComponentProps(),
  ...makeGroupItemProps(),
  ...makeLazyProps()
}, "VWindowItem");
const VWindowItem = genericComponent()({
  name: "VWindowItem",
  directives: {
    Touch: Touch$1
  },
  props: makeVWindowItemProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const window2 = inject$1(VWindowSymbol);
    const groupItem = useGroupItem(props, VWindowGroupSymbol);
    const {
      isBooted
    } = useSsrBoot();
    if (!window2 || !groupItem)
      throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const isTransitioning = shallowRef(false);
    const hasTransition = computed(() => isBooted.value && (window2.isReversed.value ? props.reverseTransition !== false : props.transition !== false));
    function onAfterTransition() {
      if (!isTransitioning.value || !window2) {
        return;
      }
      isTransitioning.value = false;
      if (window2.transitionCount.value > 0) {
        window2.transitionCount.value -= 1;
        if (window2.transitionCount.value === 0) {
          window2.transitionHeight.value = void 0;
        }
      }
    }
    function onBeforeTransition() {
      if (isTransitioning.value || !window2) {
        return;
      }
      isTransitioning.value = true;
      if (window2.transitionCount.value === 0) {
        window2.transitionHeight.value = convertToUnit(window2.rootRef.value?.clientHeight);
      }
      window2.transitionCount.value += 1;
    }
    function onTransitionCancelled() {
      onAfterTransition();
    }
    function onEnterTransition(el) {
      if (!isTransitioning.value) {
        return;
      }
      nextTick$1(() => {
        if (!hasTransition.value || !isTransitioning.value || !window2) {
          return;
        }
        window2.transitionHeight.value = convertToUnit(el.clientHeight);
      });
    }
    const transition = computed(() => {
      const name = window2.isReversed.value ? props.reverseTransition : props.transition;
      return !hasTransition.value ? false : {
        name: typeof name !== "string" ? window2.transition.value : name,
        onBeforeEnter: onBeforeTransition,
        onAfterEnter: onAfterTransition,
        onEnterCancelled: onTransitionCancelled,
        onBeforeLeave: onBeforeTransition,
        onAfterLeave: onAfterTransition,
        onLeaveCancelled: onTransitionCancelled,
        onEnter: onEnterTransition
      };
    });
    const {
      hasContent
    } = useLazy(props, groupItem.isSelected);
    useRender(() => createVNode(MaybeTransition, {
      "transition": transition.value,
      "disabled": !isBooted.value
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": ["v-window-item", groupItem.selectedClass.value, props.class],
        "style": props.style
      }, [hasContent.value && slots.default?.()]), [[vShow, groupItem.isSelected.value]])]
    }));
    return {
      groupItem
    };
  }
});
const makeVCarouselItemProps = propsFactory({
  ...makeVImgProps(),
  ...makeVWindowItemProps()
}, "VCarouselItem");
const VCarouselItem = genericComponent()({
  name: "VCarouselItem",
  inheritAttrs: false,
  props: makeVCarouselItemProps(),
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    useRender(() => {
      const [imgProps] = VImg.filterProps(props);
      const [windowItemProps] = VWindowItem.filterProps(props);
      return createVNode(VWindowItem, mergeProps({
        "class": "v-carousel-item"
      }, windowItemProps), {
        default: () => [createVNode(VImg, mergeProps(attrs, imgProps), slots)]
      });
    });
  }
});
const FormKey = Symbol.for("vuetify:form");
const makeFormProps = propsFactory({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function createForm(props) {
  const model = useProxiedModel(props, "modelValue");
  const isDisabled = computed(() => props.disabled);
  const isReadonly2 = computed(() => props.readonly);
  const isValidating = shallowRef(false);
  const items = ref([]);
  const errors = ref([]);
  async function validate() {
    const results = [];
    let valid = true;
    errors.value = [];
    isValidating.value = true;
    for (const item of items.value) {
      const itemErrorMessages = await item.validate();
      if (itemErrorMessages.length > 0) {
        valid = false;
        results.push({
          id: item.id,
          errorMessages: itemErrorMessages
        });
      }
      if (!valid && props.fastFail)
        break;
    }
    errors.value = results;
    isValidating.value = false;
    return {
      valid,
      errors: errors.value
    };
  }
  function reset() {
    items.value.forEach((item) => item.reset());
  }
  function resetValidation() {
    items.value.forEach((item) => item.resetValidation());
  }
  watch(items, () => {
    let valid = 0;
    let invalid = 0;
    const results = [];
    for (const item of items.value) {
      if (item.isValid === false) {
        invalid++;
        results.push({
          id: item.id,
          errorMessages: item.errorMessages
        });
      } else if (item.isValid === true)
        valid++;
    }
    errors.value = results;
    model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
  }, {
    deep: true
  });
  provide(FormKey, {
    register: (_ref) => {
      let {
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2
      } = _ref;
      if (items.value.some((item) => item.id === id))
        ;
      items.value.push({
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2,
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (id) => {
      items.value = items.value.filter((item) => {
        return item.id !== id;
      });
    },
    update: (id, isValid2, errorMessages) => {
      const found = items.value.find((item) => item.id === id);
      if (!found)
        return;
      found.isValid = isValid2;
      found.errorMessages = errorMessages;
    },
    isDisabled,
    isReadonly: isReadonly2,
    isValidating,
    isValid: model,
    items,
    validateOn: toRef(props, "validateOn")
  });
  return {
    errors,
    isDisabled,
    isReadonly: isReadonly2,
    isValidating,
    isValid: model,
    items,
    validate,
    reset,
    resetValidation
  };
}
function useForm() {
  return inject$1(FormKey, null);
}
const makeVFormProps = propsFactory({
  ...makeComponentProps(),
  ...makeFormProps()
}, "VForm");
const VForm = genericComponent()({
  name: "VForm",
  props: makeVFormProps(),
  emits: {
    "update:modelValue": (val) => true,
    submit: (e) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const form = createForm(props);
    const formRef = ref();
    function onReset(e) {
      e.preventDefault();
      form.reset();
    }
    function onSubmit(_e) {
      const e = _e;
      const ready = form.validate();
      e.then = ready.then.bind(ready);
      e.catch = ready.catch.bind(ready);
      e.finally = ready.finally.bind(ready);
      emit2("submit", e);
      if (!e.defaultPrevented) {
        ready.then((_ref2) => {
          let {
            valid
          } = _ref2;
          if (valid) {
            formRef.value?.submit();
          }
        });
      }
      e.preventDefault();
    }
    useRender(() => createVNode("form", {
      "ref": formRef,
      "class": ["v-form", props.class],
      "style": props.style,
      "novalidate": true,
      "onReset": onReset,
      "onSubmit": onSubmit
    }, [slots.default?.(form)]));
    return forwardRefs(form, formRef);
  }
});
const VSheet$1 = "";
const makeVSheetProps = propsFactory({
  color: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VSheet");
const VSheet = genericComponent()({
  name: "VSheet",
  props: makeVSheetProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    useRender(() => createVNode(props.tag, {
      "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props.class],
      "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props.style]
    }, slots));
    return {};
  }
});
const _sfc_main$4 = {
  data() {
    return {
      loader: null,
      loading: false,
      valid: true,
      colors: [
        "green",
        "secondary",
        "yellow darken-4",
        "red lighten-2",
        "orange darken-1"
      ],
      cycle: false,
      slides: [
        "First",
        "Second",
        "Third",
        "Fourth",
        "Fifth"
      ]
    };
  },
  watch: {
    loader() {
      const l = this.loader;
      this[l] = !this[l];
      setTimeout(() => this[l] = false, 3e3);
      this.loader = null;
    }
  },
  // Vars that are used parameters to use in component
  props: {
    // Patient's Historical Prescription
    prescriptions: Array,
    // JSON that has the value of keys
    value: Object,
    // Function to send data of prescription
    action: {
      type: Function
    },
    // Doctor info
    assistant: {
      type: String
    },
    // Cabin id to know the channel
    cabin: {
      type: String
    },
    // Patient info.
    patientFirstName: {
      type: String
    },
    patientLastName: {
      type: String
    },
    patientProfilePicture: {
      type: String
    },
    // Doctor Id
    assistantId: {
      type: String
    },
    consultation: {
      type: String
    },
    requestVsFunction: {
      type: Function
    }
  },
  methods: {
    // Validate form
    // Parse timestamp of prescription
    fixDateAndHour(date2) {
      let result = new Date(date2).toLocaleString();
      return result + " hrs";
    },
    // Updating value of texts
    updateValueName() {
      this.$emit("input", {
        drug: this.$refs.drug.value,
        presentation: this.$refs.presentation.value,
        dose: this.$refs.dose.value,
        frequency: this.$refs.frequency.value,
        prescription_start_date: this.$refs.prescription_start_date.value,
        prescription_end_date: this.$refs.prescription_end_date.value,
        comments: this.$refs.comments.value
      });
    },
    // API call
    executeRequestFunction() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/consultations/send-prescription/`;
      if (this.$refs.formprescription.validate()) {
        this.loader = "loading", axios$1.post(path, {
          "drug": this.$refs.drug.value,
          "presentation": this.$refs.presentation.value,
          "dose": this.$refs.dose.value,
          "frequency": this.$refs.frequency.value,
          "comments": this.$refs.comments.value,
          "assistant_info": this.assistant,
          "cabin": this.cabin,
          "assistantId": this.assistantId,
          "consultation": this.consultation.toString(),
          "prescription_start_date": this.$refs.prescription_start_date.value,
          "prescription_end_date": this.$refs.prescription_end_date.value
        }, { headers }).then((r) => {
          if (this.requestVsFunction) {
            this.requestVsFunction();
          }
          let timerInterval;
          this.$swal({
            icon: "success",
            title: "Receta enviada.",
            timer: 4e3,
            timerProgressBar: true,
            didOpen: () => {
              this.$swal.showLoading();
            },
            willClose: () => {
              clearInterval(timerInterval);
            }
          }).then((result) => {
            return result;
          });
          return r.data;
        }).catch(
          (e) => {
            let timerInterval;
            this.$swal({
              icon: "error",
              title: "No se ha podido enviar la receta, intente de nuevo.",
              timer: 4e3,
              timerProgressBar: true,
              didOpen: () => {
                this.$swal.showLoading();
              },
              willClose: () => {
                clearInterval(timerInterval);
              }
            }).then((result) => {
              return result;
            });
            console.log(e, "error");
          }
        );
      }
    }
  }
};
const _hoisted_1$4 = /* @__PURE__ */ createBaseVNode("div", { class: "text-h5" }, "Receta Médica", -1);
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " *Campos obligatorios ", -1);
const _hoisted_3$3 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Medicina* ", -1);
const _hoisted_4$3 = ["value"];
const _hoisted_5$3 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Presentación* ", -1);
const _hoisted_6$2 = ["value"];
const _hoisted_7$2 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Dosis* ", -1);
const _hoisted_8$2 = ["value"];
const _hoisted_9$2 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Frecuencia* ", -1);
const _hoisted_10$2 = ["value"];
const _hoisted_11$2 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Fecha inicio* ", -1);
const _hoisted_12$2 = ["value"];
const _hoisted_13$2 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Fecha fin* ", -1);
const _hoisted_14$2 = ["value"];
const _hoisted_15$2 = /* @__PURE__ */ createBaseVNode("div", { class: "text-grey text-body-1 mb-1" }, " Observaciones* ", -1);
const _hoisted_16$2 = ["value"];
const _hoisted_17$2 = /* @__PURE__ */ createBaseVNode("span", { class: "text-h5" }, "Historial", -1);
const _hoisted_18$2 = /* @__PURE__ */ createBaseVNode("div", null, [
  /* @__PURE__ */ createBaseVNode("p", { class: "pa-5 text-h6 text-grey text-center" }, "El paciente no ha tenidos recetas en los últimos 7 días.")
], -1);
const _hoisted_19$2 = { class: "mt-3 ml-3 text-h5 text-grey text-decoration-underline text-uppercase" };
const _hoisted_20$2 = { class: "ml-3 text-subtitle-1 text-grey" };
const _hoisted_21$2 = { class: "ml-3 text-subtitle-1 text-grey" };
const _hoisted_22$2 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-3 font-weight-medium text-black text-h6" }, " Presentación ", -1);
const _hoisted_23$2 = { class: "text-subtitle-1 font-weight-medium" };
const _hoisted_24$2 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-2 font-weight-medium text-black text-h6" }, " Dosis ", -1);
const _hoisted_25$2 = { class: "text-subtitle-1 font-weight-medium" };
const _hoisted_26$2 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-2 font-weight-medium text-black text-h6" }, " Frecuencia ", -1);
const _hoisted_27$2 = { class: "text-subtitle-1 font-weight-medium" };
const _hoisted_28$2 = /* @__PURE__ */ createBaseVNode("div", { class: "mt-2 font-weight-medium text-black text-h6" }, " Observaciones ", -1);
const _hoisted_29$2 = { class: "text-subtitle-1 font-weight-medium" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    createVNode(VRow, {
      "no-gutters": "",
      justify: "space-between",
      style: { "background-color": "white" }
    }, {
      default: withCtx(() => [
        createVNode(VCol, { cols: "6" }, {
          default: withCtx(() => [
            createVNode(VCard, { elevation: "0" }, {
              default: withCtx(() => [
                createVNode(VCardTitle, null, {
                  default: withCtx(() => [
                    _hoisted_1$4
                  ]),
                  _: 1
                }),
                createVNode(VCardSubtitle, null, {
                  default: withCtx(() => [
                    _hoisted_2$3
                  ]),
                  _: 1
                }),
                createVNode(VForm, {
                  ref: "formprescription",
                  "lazy-validation": "",
                  modelValue: $data.valid,
                  "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.valid = $event),
                  class: "pl-5"
                }, {
                  default: withCtx(() => [
                    _hoisted_3$3,
                    createBaseVNode("input", {
                      class: "form-field mb-5",
                      type: "text",
                      ref: "drug",
                      value: $props.value?.drug,
                      required: "",
                      onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValueName())
                    }, null, 40, _hoisted_4$3),
                    _hoisted_5$3,
                    createBaseVNode("input", {
                      class: "form-field mb-5",
                      type: "text",
                      ref: "presentation",
                      required: "",
                      value: $props.value?.presentation,
                      onInput: _cache[1] || (_cache[1] = ($event) => $options.updateValueName())
                    }, null, 40, _hoisted_6$2),
                    _hoisted_7$2,
                    createBaseVNode("input", {
                      class: "form-field mb-5",
                      type: "text",
                      ref: "dose",
                      required: "",
                      value: $props.value?.dose,
                      onInput: _cache[2] || (_cache[2] = ($event) => $options.updateValueName())
                    }, null, 40, _hoisted_8$2),
                    _hoisted_9$2,
                    createBaseVNode("input", {
                      class: "form-field mb-5",
                      type: "text",
                      ref: "frequency",
                      required: "",
                      value: $props.value?.frequency,
                      onInput: _cache[3] || (_cache[3] = ($event) => $options.updateValueName())
                    }, null, 40, _hoisted_10$2),
                    createVNode(VRow, null, {
                      default: withCtx(() => [
                        createVNode(VCol, {
                          cols: "6",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            _hoisted_11$2,
                            createBaseVNode("input", {
                              class: "form-field mb-5",
                              type: "date",
                              ref: "prescription_start_date",
                              required: "",
                              value: $props.value?.prescription_start_date,
                              onInput: _cache[4] || (_cache[4] = ($event) => $options.updateValueName())
                            }, null, 40, _hoisted_12$2)
                          ]),
                          _: 1
                        }),
                        createVNode(VCol, {
                          cols: "6",
                          sm: "6"
                        }, {
                          default: withCtx(() => [
                            _hoisted_13$2,
                            createBaseVNode("input", {
                              class: "form-field mb-5",
                              type: "date",
                              ref: "prescription_end_date",
                              required: "",
                              value: $props.value?.prescription_end_date,
                              onInput: _cache[5] || (_cache[5] = ($event) => $options.updateValueName())
                            }, null, 40, _hoisted_14$2)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    _hoisted_15$2,
                    createBaseVNode("textarea", {
                      class: "form-field mb-5",
                      type: "area",
                      ref: "comments",
                      required: "",
                      value: $props.value?.comments,
                      onInput: _cache[6] || (_cache[6] = ($event) => $options.updateValueName())
                    }, null, 40, _hoisted_16$2),
                    createVNode(VBtn, {
                      onClick: _cache[7] || (_cache[7] = ($event) => $options.executeRequestFunction()),
                      color: "#00afb9",
                      block: "",
                      elevation: "0",
                      loading: $data.loading,
                      disabled: $data.loading,
                      class: "mr-5 ml-5 mb-10 text-white button"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Guardar ")
                      ]),
                      _: 1
                    }, 8, ["loading", "disabled"])
                  ]),
                  _: 1
                }, 8, ["modelValue"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        createVNode(VCol, { cols: "5" }, {
          default: withCtx(() => [
            createVNode(VCardTitle, null, {
              default: withCtx(() => [
                _hoisted_17$2
              ]),
              _: 1
            }),
            createVNode(VCard, {
              elevation: "0",
              "max-width": "300",
              variant: "outlined"
            }, {
              default: withCtx(() => [
                createVNode(VCarousel, {
                  cycle: $data.cycle,
                  "hide-delimiter-background": "",
                  "show-arrows": $props.prescriptions.length > 0,
                  "delimiter-icon": "mdi-minus",
                  height: "490",
                  "reverse-transition": "fade-transition",
                  transition: "fade-transition"
                }, {
                  default: withCtx(() => [
                    $props.prescriptions.length == 0 ? (openBlock(), createBlock(VRow, {
                      key: 0,
                      align: "center",
                      justify: "center"
                    }, {
                      default: withCtx(() => [
                        _hoisted_18$2
                      ]),
                      _: 1
                    })) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($props.prescriptions, (prescription, i2) => {
                      return openBlock(), createBlock(VCarouselItem, { key: i2 }, {
                        default: withCtx(() => [
                          createVNode(VSheet, {
                            height: "100%",
                            tile: ""
                          }, {
                            default: withCtx(() => [
                              createVNode(VRow, { class: "fill-height" }, {
                                default: withCtx(() => [
                                  createVNode(VCard, {
                                    class: "ml-3 mr-3 pt-5",
                                    flat: "",
                                    width: "300"
                                  }, {
                                    default: withCtx(() => [
                                      createBaseVNode("div", _hoisted_19$2, toDisplayString(prescription["drug"]), 1),
                                      createBaseVNode("div", _hoisted_20$2, "Dr. " + toDisplayString(prescription["assistant"]["first_name"] || "  " + prescription["assistant"]["last_name"] || " "), 1),
                                      createBaseVNode("div", _hoisted_21$2, "Fecha: " + toDisplayString($options.fixDateAndHour(prescription["timestamp"])), 1),
                                      createVNode(VCardText, null, {
                                        default: withCtx(() => [
                                          _hoisted_22$2,
                                          createBaseVNode("div", _hoisted_23$2, toDisplayString(prescription["presentation"]), 1),
                                          _hoisted_24$2,
                                          createBaseVNode("div", _hoisted_25$2, toDisplayString(prescription["dose"]), 1),
                                          _hoisted_26$2,
                                          createBaseVNode("div", _hoisted_27$2, toDisplayString(prescription["frequency"]), 1),
                                          _hoisted_28$2,
                                          createBaseVNode("div", _hoisted_29$2, toDisplayString(prescription["comments"] || "No hay observaciones"), 1)
                                        ]),
                                        _: 2
                                      }, 1024)
                                    ]),
                                    _: 2
                                  }, 1024)
                                ]),
                                _: 2
                              }, 1024)
                            ]),
                            _: 2
                          }, 1024)
                        ]),
                        _: 2
                      }, 1024);
                    }), 128))
                  ]),
                  _: 1
                }, 8, ["cycle", "show-arrows"]),
                createVNode(VDivider, { class: "mx-2" }),
                createVNode(VList, null, {
                  default: withCtx(() => [
                    createVNode(VListItem, null, {
                      default: withCtx(() => [
                        createVNode(VAvatar, null, {
                          default: withCtx(() => [
                            createVNode(VImg, {
                              src: $props.patientProfilePicture || "https://cdn.vuetifyjs.com/images/john.png",
                              height: "100"
                            }, null, 8, ["src"])
                          ]),
                          _: 1
                        }),
                        createVNode(VListItemTitle, null, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($props.patientFirstName ?? ""), 1)
                          ]),
                          _: 1
                        }),
                        createVNode(VListItemSubtitle, null, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString($props.patientLastName ?? ""), 1)
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    })
  ]);
}
const PrescriptionsComponent = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const _imports_0 = "" + new URL("bitmec-fd3a3a8c.png", import.meta.url).href;
const _imports_1 = "" + new URL("scanner-106e0a61.png", import.meta.url).href;
const _imports_2 = "" + new URL("scann-50b08199.png", import.meta.url).href;
const _imports_3 = "" + new URL("search-bc170c95.png", import.meta.url).href;
const _imports_4 = "" + new URL("document-92f1dc13.png", import.meta.url).href;
const CallCenterInformation_vue_vue_type_style_index_0_scoped_507f268c_lang = "";
const VAlert$1 = "";
const VAlertTitle = createSimpleFunctional("v-alert-title");
const allowedTypes = ["success", "info", "warning", "error"];
const makeVAlertProps = propsFactory({
  border: {
    type: [Boolean, String],
    validator: (val) => {
      return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
    }
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: IconValue,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: true
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (val) => allowedTypes.includes(val)
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VAlert");
const VAlert = genericComponent()({
  name: "VAlert",
  props: makeVAlertProps(),
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const icon = computed(() => {
      if (props.icon === false)
        return void 0;
      if (!props.type)
        return props.icon;
      return props.icon ?? `$${props.type}`;
    });
    const variantProps = computed(() => ({
      color: props.color ?? props.type,
      variant: props.variant
    }));
    const {
      themeClasses
    } = provideTheme(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "borderColor"));
    const {
      t
    } = useLocale();
    const closeProps = computed(() => ({
      "aria-label": t(props.closeLabel),
      onClick(e) {
        isActive.value = false;
        emit2("click:close", e);
      }
    }));
    return () => {
      const hasPrepend = !!(slots.prepend || icon.value);
      const hasTitle = !!(slots.title || props.title);
      const hasClose = !!(slots.close || props.closable);
      return isActive.value && createVNode(props.tag, {
        "class": ["v-alert", props.border && {
          "v-alert--border": !!props.border,
          [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
        }, {
          "v-alert--prominent": props.prominent
        }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props.class],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props.style],
        "role": "alert"
      }, {
        default: () => [genOverlays(false, "v-alert"), props.border && createVNode("div", {
          "key": "border",
          "class": ["v-alert__border", textColorClasses.value],
          "style": textColorStyles.value
        }, null), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-alert__prepend"
        }, [!slots.prepend ? createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props.density,
          "icon": icon.value,
          "size": props.prominent ? 44 : 28
        }, null) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !icon.value,
          "defaults": {
            VIcon: {
              density: props.density,
              icon: icon.value,
              size: props.prominent ? 44 : 28
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-alert__content"
        }, [hasTitle && createVNode(VAlertTitle, {
          "key": "title"
        }, {
          default: () => [slots.title?.() ?? props.title]
        }), slots.text?.() ?? props.text, slots.default?.()]), slots.append && createVNode("div", {
          "key": "append",
          "class": "v-alert__append"
        }, [slots.append()]), hasClose && createVNode("div", {
          "key": "close",
          "class": "v-alert__close"
        }, [!slots.close ? createVNode(VBtn, mergeProps({
          "key": "close-btn",
          "icon": props.closeIcon,
          "size": "x-small",
          "variant": "text"
        }, closeProps.value), null) : createVNode(VDefaultsProvider, {
          "key": "close-defaults",
          "defaults": {
            VBtn: {
              icon: props.closeIcon,
              size: "x-small",
              variant: "text"
            }
          }
        }, {
          default: () => [slots.close?.({
            props: closeProps.value
          })]
        })])]
      });
    };
  }
});
const VDialog$1 = "";
const makeVDialogProps = propsFactory({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: true
  },
  scrollable: Boolean,
  ...makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })
}, "VDialog");
const VDialog = genericComponent()({
  name: "VDialog",
  props: makeVDialogProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const overlay = ref();
    function onFocusin(e) {
      const before = e.relatedTarget;
      const after = e.target;
      if (before !== after && overlay.value?.contentEl && // We're the topmost dialog
      overlay.value?.globalTop && // It isn't the document or the dialog body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the dialog body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        if (!focusable.length)
          return;
        const firstElement = focusable[0];
        const lastElement = focusable[focusable.length - 1];
        if (before === firstElement) {
          lastElement.focus();
        } else {
          firstElement.focus();
        }
      }
    }
    if (IN_BROWSER) {
      watch(() => isActive.value && props.retainFocus, (val) => {
        val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
      }, {
        immediate: true
      });
    }
    watch(isActive, async (val) => {
      await nextTick$1();
      if (val) {
        overlay.value.contentEl?.focus({
          preventScroll: true
        });
      } else {
        overlay.value.activatorEl?.focus({
          preventScroll: true
        });
      }
    });
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "dialog",
      "aria-expanded": String(isActive.value)
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props.fullscreen,
          "v-dialog--scrollable": props.scrollable
        }, props.class],
        "style": props.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "aria-modal": "true",
        "activatorProps": activatorProps.value,
        "role": "dialog"
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VDialog"
          }, {
            default: () => [slots.default?.(...args)]
          });
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const VSelect$1 = "";
const VSelectionControl$1 = "";
const VLabel$1 = "";
const makeVLabelProps = propsFactory({
  text: String,
  clickable: Boolean,
  ...makeComponentProps(),
  ...makeThemeProps()
}, "VLabel");
const VLabel = genericComponent()({
  name: "VLabel",
  props: makeVLabelProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode("label", {
      "class": ["v-label", {
        "v-label--clickable": props.clickable
      }, props.class],
      "style": props.style
    }, [props.text, slots.default?.()]));
    return {};
  }
});
const VSelectionControlGroup = "";
const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
const makeSelectionControlGroupProps = propsFactory({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: IconValue,
  trueIcon: IconValue,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeThemeProps()
}, "SelectionControlGroup");
const makeVSelectionControlGroupProps = propsFactory({
  ...makeSelectionControlGroupProps({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup");
genericComponent()({
  name: "VSelectionControlGroup",
  props: makeVSelectionControlGroupProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props, "modelValue");
    const uid2 = getUid();
    const id = computed(() => props.id || `v-selection-control-group-${uid2}`);
    const name = computed(() => props.name || id.value);
    const updateHandlers = /* @__PURE__ */ new Set();
    provide(VSelectionControlGroupSymbol, {
      modelValue,
      forceUpdate: () => {
        updateHandlers.forEach((fn) => fn());
      },
      onForceUpdate: (cb) => {
        updateHandlers.add(cb);
        onScopeDispose(() => {
          updateHandlers.delete(cb);
        });
      }
    });
    provideDefaults({
      [props.defaultsTarget]: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        density: toRef(props, "density"),
        error: toRef(props, "error"),
        inline: toRef(props, "inline"),
        modelValue,
        multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
        name,
        falseIcon: toRef(props, "falseIcon"),
        trueIcon: toRef(props, "trueIcon"),
        readonly: toRef(props, "readonly"),
        ripple: toRef(props, "ripple"),
        type: toRef(props, "type"),
        valueComparator: toRef(props, "valueComparator")
      }
    });
    useRender(() => createVNode("div", {
      "class": ["v-selection-control-group", {
        "v-selection-control-group--inline": props.inline
      }, props.class],
      "style": props.style,
      "role": props.type === "radio" ? "radiogroup" : void 0
    }, [slots.default?.()]));
    return {};
  }
});
const makeVSelectionControlProps = propsFactory({
  label: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...makeComponentProps(),
  ...makeSelectionControlGroupProps()
}, "VSelectionControl");
function useSelectionControl(props) {
  const group = inject$1(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props);
  const modelValue = useProxiedModel(props, "modelValue");
  const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
  const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
  const isMultiple = computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
    },
    set(val) {
      if (props.readonly)
        return;
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const {
    backgroundColorClasses,
    backgroundColorStyles
  } = useBackgroundColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const icon = computed(() => model.value ? props.trueIcon : props.falseIcon);
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    backgroundColorClasses,
    backgroundColorStyles,
    icon
  };
}
const VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeVSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      group,
      densityClasses,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      backgroundColorClasses,
      backgroundColorStyles,
      trueValue
    } = useSelectionControl(props);
    const uid2 = getUid();
    const id = computed(() => props.id || `input-${uid2}`);
    const isFocused = shallowRef(false);
    const isFocusVisible = shallowRef(false);
    const input = ref();
    group?.onForceUpdate(() => {
      if (input.value) {
        input.value.checked = model.value;
      }
    });
    function onFocus(e) {
      isFocused.value = true;
      if (matchesSelector(e.target, ":focus-visible") !== false) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    function onInput(e) {
      if (props.readonly && group) {
        nextTick$1(() => group.forceUpdate());
      }
      model.value = e.target.checked;
    }
    useRender(() => {
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const inputNode = createVNode("input", mergeProps({
        "ref": input,
        "checked": model.value,
        "disabled": !!(props.readonly || props.disabled),
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "aria-disabled": !!(props.readonly || props.disabled),
        "type": props.type,
        "value": trueValue.value,
        "name": props.name,
        "aria-checked": props.type === "checkbox" ? model.value : void 0
      }, inputAttrs), null);
      return createVNode("div", mergeProps({
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props.disabled,
          "v-selection-control--error": props.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": props.inline
        }, densityClasses.value, props.class]
      }, rootAttrs, {
        "style": props.style
      }), [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value],
        "style": textColorStyles.value
      }, [slots.default?.({
        backgroundColorClasses,
        backgroundColorStyles
      }), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"]
      }, [slots.input?.({
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        inputNode,
        icon: icon.value,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      }) ?? createVNode(Fragment, null, [icon.value && createVNode(VIcon, {
        "key": "icon",
        "icon": icon.value
      }, null), inputNode])]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
        "for": id.value,
        "clickable": true,
        "onClick": (e) => e.stopPropagation()
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});
const makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeVSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn");
const VCheckboxBtn = genericComponent()({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value2) => true,
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const model = useProxiedModel(props, "modelValue");
    function onChange(v) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    const falseIcon = computed(() => {
      return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
    });
    useRender(() => {
      const controlProps = omit(VSelectionControl.filterProps(props)[0], ["modelValue"]);
      return createVNode(VSelectionControl, mergeProps(controlProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": [($event) => model.value = $event, onChange],
        "class": ["v-checkbox-btn", props.class],
        "style": props.style,
        "type": "checkbox",
        "falseIcon": falseIcon.value,
        "trueIcon": trueIcon.value,
        "aria-checked": indeterminate.value ? "mixed" : void 0
      }), slots);
    });
    return {};
  }
});
const VInput$1 = "";
function useInputIcon(props) {
  const {
    t
  } = useLocale();
  function InputIcon(_ref) {
    let {
      name
    } = _ref;
    const localeKey = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[name];
    const listener = props[`onClick:${name}`];
    const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, props.label ?? "") : void 0;
    return createVNode(VIcon, {
      "icon": props[`${name}Icon`],
      "aria-label": label,
      "onClick": listener
    }, null);
  }
  return {
    InputIcon
  };
}
const VMessages$1 = "";
const makeVMessagesProps = propsFactory({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...makeComponentProps(),
  ...makeTransitionProps$1({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })
}, "VMessages");
const VMessages = genericComponent()({
  name: "VMessages",
  props: makeVMessagesProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const messages = computed(() => wrapInArray(props.messages));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props.color));
    useRender(() => createVNode(MaybeTransition, {
      "transition": props.transition,
      "tag": "div",
      "class": ["v-messages", textColorClasses.value, props.class],
      "style": [textColorStyles.value, props.style],
      "role": "alert",
      "aria-live": "polite"
    }, {
      default: () => [props.active && messages.value.map((message, i2) => createVNode("div", {
        "class": "v-messages__message",
        "key": `${i2}-${messages.value}`
      }, [slots.message ? slots.message({
        message
      }) : message]))]
    }));
    return {};
  }
});
const makeFocusProps = propsFactory({
  focused: Boolean,
  "onUpdate:focused": EventProp()
}, "focus");
function useFocus(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const isFocused = useProxiedModel(props, "focused");
  const focusClasses = computed(() => {
    return {
      [`${name}--focused`]: isFocused.value
    };
  });
  function focus() {
    isFocused.value = true;
  }
  function blur() {
    isFocused.value = false;
  }
  return {
    focusClasses,
    isFocused,
    focus,
    blur
  };
}
const makeValidationProps = propsFactory({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...makeFocusProps()
}, "validation");
function useValidation(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
  const model = useProxiedModel(props, "modelValue");
  const validationModel = computed(() => props.validationValue === void 0 ? model.value : props.validationValue);
  const form = useForm();
  const internalErrorMessages = ref([]);
  const isPristine = shallowRef(true);
  const isDirty = computed(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
  const isDisabled = computed(() => !!(props.disabled ?? form?.isDisabled.value));
  const isReadonly2 = computed(() => !!(props.readonly ?? form?.isReadonly.value));
  const errorMessages = computed(() => {
    return props.errorMessages.length ? wrapInArray(props.errorMessages).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
  });
  const validateOn = computed(() => {
    let value2 = (props.validateOn ?? form?.validateOn.value) || "input";
    if (value2 === "lazy")
      value2 = "input lazy";
    const set2 = new Set(value2?.split(" ") ?? []);
    return {
      blur: set2.has("blur") || set2.has("input"),
      input: set2.has("input"),
      submit: set2.has("submit"),
      lazy: set2.has("lazy")
    };
  });
  const isValid2 = computed(() => {
    if (props.error || props.errorMessages.length)
      return false;
    if (!props.rules.length)
      return true;
    if (isPristine.value) {
      return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
    } else {
      return !internalErrorMessages.value.length;
    }
  });
  const isValidating = shallowRef(false);
  const validationClasses = computed(() => {
    return {
      [`${name}--error`]: isValid2.value === false,
      [`${name}--dirty`]: isDirty.value,
      [`${name}--disabled`]: isDisabled.value,
      [`${name}--readonly`]: isReadonly2.value
    };
  });
  const uid2 = computed(() => props.name ?? unref(id));
  onBeforeMount(() => {
    form?.register({
      id: uid2.value,
      validate,
      reset,
      resetValidation
    });
  });
  onBeforeUnmount(() => {
    form?.unregister(uid2.value);
  });
  onMounted(async () => {
    if (!validateOn.value.lazy) {
      await validate(true);
    }
    form?.update(uid2.value, isValid2.value, errorMessages.value);
  });
  useToggleScope(() => validateOn.value.input, () => {
    watch(validationModel, () => {
      if (validationModel.value != null) {
        validate();
      } else if (props.focused) {
        const unwatch = watch(() => props.focused, (val) => {
          if (!val)
            validate();
          unwatch();
        });
      }
    });
  });
  useToggleScope(() => validateOn.value.blur, () => {
    watch(() => props.focused, (val) => {
      if (!val)
        validate();
    });
  });
  watch(isValid2, () => {
    form?.update(uid2.value, isValid2.value, errorMessages.value);
  });
  function reset() {
    model.value = null;
    nextTick$1(resetValidation);
  }
  function resetValidation() {
    isPristine.value = true;
    if (!validateOn.value.lazy) {
      validate(true);
    } else {
      internalErrorMessages.value = [];
    }
  }
  async function validate() {
    let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const results = [];
    isValidating.value = true;
    for (const rule of props.rules) {
      if (results.length >= +(props.maxErrors ?? 1)) {
        break;
      }
      const handler = typeof rule === "function" ? rule : () => rule;
      const result = await handler(validationModel.value);
      if (result === true)
        continue;
      if (result !== false && typeof result !== "string") {
        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
        continue;
      }
      results.push(result || "");
    }
    internalErrorMessages.value = results;
    isValidating.value = false;
    isPristine.value = silent;
    return internalErrorMessages.value;
  }
  return {
    errorMessages,
    isDirty,
    isDisabled,
    isReadonly: isReadonly2,
    isPristine,
    isValid: isValid2,
    isValidating,
    reset,
    resetValidation,
    validate,
    validationClasses
  };
}
const makeVInputProps = propsFactory({
  id: String,
  appendIcon: IconValue,
  centerAffix: {
    type: Boolean,
    default: true
  },
  prependIcon: IconValue,
  hideDetails: [Boolean, String],
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v) => ["horizontal", "vertical"].includes(v)
  },
  "onClick:prepend": EventProp(),
  "onClick:append": EventProp(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeValidationProps()
}, "VInput");
const VInput = genericComponent()({
  name: "VInput",
  props: {
    ...makeVInputProps()
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const {
      densityClasses
    } = useDensity(props);
    const {
      rtlClasses
    } = useRtl();
    const {
      InputIcon
    } = useInputIcon(props);
    const uid2 = getUid();
    const id = computed(() => props.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    } = useValidation(props, "v-input", id);
    const slotProps = computed(() => ({
      id,
      messagesId,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate
    }));
    const messages = computed(() => {
      if (props.errorMessages?.length || !isPristine.value && errorMessages.value.length) {
        return errorMessages.value;
      } else if (props.hint && (props.persistentHint || props.focused)) {
        return props.hint;
      } else {
        return props.messages;
      }
    });
    useRender(() => {
      const hasPrepend = !!(slots.prepend || props.prependIcon);
      const hasAppend = !!(slots.append || props.appendIcon);
      const hasMessages = messages.value.length > 0;
      const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
      return createVNode("div", {
        "class": ["v-input", `v-input--${props.direction}`, {
          "v-input--center-affix": props.centerAffix
        }, densityClasses.value, rtlClasses.value, validationClasses.value, props.class],
        "style": props.style
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-input__prepend"
      }, [slots.prepend?.(slotProps.value), props.prependIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prepend"
      }, null)]), slots.default && createVNode("div", {
        "class": "v-input__control"
      }, [slots.default?.(slotProps.value)]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-input__append"
      }, [props.appendIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "append"
      }, null), slots.append?.(slotProps.value)]), hasDetails && createVNode("div", {
        "class": "v-input__details"
      }, [createVNode(VMessages, {
        "id": messagesId.value,
        "active": hasMessages,
        "messages": messages.value
      }, {
        message: slots.message
      }), slots.details?.(slotProps.value)])]);
    });
    return {
      reset,
      resetValidation,
      validate
    };
  }
});
const VMenu$1 = "";
const makeVMenuProps = propsFactory({
  // TODO
  // disableKeys: Boolean,
  id: String,
  ...omit(makeVOverlayProps({
    closeDelay: 250,
    closeOnContentClick: true,
    locationStrategy: "connected",
    openDelay: 300,
    scrim: false,
    scrollStrategy: "reposition",
    transition: {
      component: VDialogTransition
    }
  }), ["absolute"])
}, "VMenu");
const VMenu = genericComponent()({
  name: "VMenu",
  props: makeVMenuProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props.id || `v-menu-${uid2}`);
    const overlay = ref();
    const parent = inject$1(VMenuSymbol, null);
    const openChildren = shallowRef(0);
    provide(VMenuSymbol, {
      register() {
        ++openChildren.value;
      },
      unregister() {
        --openChildren.value;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren.value) {
            isActive.value = false;
            parent?.closeParents();
          }
        }, 40);
      }
    });
    async function onFocusIn(e) {
      const before = e.relatedTarget;
      const after = e.target;
      await nextTick$1();
      if (isActive.value && before !== after && overlay.value?.contentEl && // We're the topmost menu
      overlay.value?.globalTop && // It isn't the document or the menu body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the menu body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        focusable[0]?.focus();
      }
    }
    watch(isActive, (val) => {
      if (val) {
        parent?.register();
        document.addEventListener("focusin", onFocusIn, {
          once: true
        });
      } else {
        parent?.unregister();
        document.removeEventListener("focusin", onFocusIn);
      }
    });
    function onClickOutside() {
      parent?.closeParents();
    }
    function onKeydown(e) {
      if (props.disabled)
        return;
      if (e.key === "Tab") {
        const nextElement = getNextElement(focusableChildren(overlay.value?.contentEl, false), e.shiftKey ? "prev" : "next", (el) => el.tabIndex >= 0);
        if (!nextElement) {
          isActive.value = false;
          overlay.value?.activatorEl?.focus();
        }
      }
    }
    function onActivatorKeydown(e) {
      if (props.disabled)
        return;
      const el = overlay.value?.contentEl;
      if (el && isActive.value) {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          focusChild(el, "next");
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          focusChild(el, "prev");
        }
      } else if (["ArrowDown", "ArrowUp"].includes(e.key)) {
        isActive.value = true;
        e.preventDefault();
        setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
      }
    }
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "menu",
      "aria-expanded": String(isActive.value),
      "aria-owns": id.value,
      onKeydown: onActivatorKeydown
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-menu", props.class],
        "style": props.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": activatorProps.value,
        "onClick:outside": onClickOutside,
        "onKeydown": onKeydown
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VMenu"
          }, {
            default: () => [slots.default?.(...args)]
          });
        }
      });
    });
    return forwardRefs({
      id,
      ΨopenChildren: openChildren
    }, overlay);
  }
});
const VTextField$1 = "";
const VCounter$1 = "";
const makeVCounterProps = propsFactory({
  active: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...makeComponentProps(),
  ...makeTransitionProps$1({
    transition: {
      component: VSlideYTransition
    }
  })
}, "VCounter");
const VCounter = genericComponent()({
  name: "VCounter",
  functional: true,
  props: makeVCounterProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const counter = computed(() => {
      return props.max ? `${props.value} / ${props.max}` : String(props.value);
    });
    useRender(() => createVNode(MaybeTransition, {
      "transition": props.transition
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": ["v-counter", props.class],
        "style": props.style
      }, [slots.default ? slots.default({
        counter: counter.value,
        max: props.max,
        value: props.value
      }) : counter.value]), [[vShow, props.active]])]
    }));
    return {};
  }
});
const VField$1 = "";
const makeVFieldLabelProps = propsFactory({
  floating: Boolean,
  ...makeComponentProps()
}, "VFieldLabel");
const VFieldLabel = genericComponent()({
  name: "VFieldLabel",
  props: makeVFieldLabelProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VLabel, {
      "class": ["v-field-label", {
        "v-field-label--floating": props.floating
      }, props.class],
      "style": props.style,
      "aria-hidden": props.floating || void 0
    }, slots));
    return {};
  }
});
const allowedVariants = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
const makeVFieldProps = propsFactory({
  appendInnerIcon: IconValue,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: IconValue,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: IconValue,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (v) => allowedVariants.includes(v)
  },
  "onClick:clear": EventProp(),
  "onClick:appendInner": EventProp(),
  "onClick:prependInner": EventProp(),
  ...makeComponentProps(),
  ...makeLoaderProps(),
  ...makeRoundedProps(),
  ...makeThemeProps()
}, "VField");
const VField = genericComponent()({
  name: "VField",
  inheritAttrs: false,
  props: {
    id: String,
    ...makeFocusProps(),
    ...makeVFieldProps()
  },
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      focusClasses,
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const {
      InputIcon
    } = useInputIcon(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      rtlClasses
    } = useRtl();
    const isActive = computed(() => props.dirty || props.active);
    const hasLabel = computed(() => !props.singleLine && !!(props.label || slots.label));
    const uid2 = getUid();
    const id = computed(() => props.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return props.error || props.disabled ? void 0 : isActive.value && isFocused.value ? props.color : props.baseColor;
    }));
    watch(isActive, (val) => {
      if (hasLabel.value) {
        const el = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        requestAnimationFrame(() => {
          const rect = nullifyTransforms(el);
          const targetRect = targetEl.getBoundingClientRect();
          const x2 = targetRect.x - rect.x;
          const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
          const targetWidth = targetRect.width / 0.75;
          const width = Math.abs(targetWidth - rect.width) > 1 ? {
            maxWidth: convertToUnit(targetWidth)
          } : void 0;
          const style = getComputedStyle(el);
          const targetStyle = getComputedStyle(targetEl);
          const duration = parseFloat(style.transitionDuration) * 1e3 || 150;
          const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
          const color = targetStyle.getPropertyValue("color");
          el.style.visibility = "visible";
          targetEl.style.visibility = "hidden";
          animate(el, {
            transform: `translate(${x2}px, ${y}px) scale(${scale})`,
            color,
            ...width
          }, {
            duration,
            easing: standardEasing,
            direction: val ? "normal" : "reverse"
          }).finished.then(() => {
            el.style.removeProperty("visibility");
            targetEl.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const slotProps = computed(() => ({
      isActive,
      isFocused,
      controlRef,
      blur,
      focus
    }));
    function onClick(e) {
      if (e.target !== document.activeElement) {
        e.preventDefault();
      }
    }
    useRender(() => {
      const isOutlined = props.variant === "outlined";
      const hasPrepend = slots["prepend-inner"] || props.prependInnerIcon;
      const hasClear = !!(props.clearable || slots.clear);
      const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
      const label = slots.label ? slots.label({
        ...slotProps.value,
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      return createVNode("div", mergeProps({
        "class": ["v-field", {
          "v-field--active": isActive.value,
          "v-field--appended": hasAppend,
          "v-field--center-affix": props.centerAffix ?? !isPlainOrUnderlined.value,
          "v-field--disabled": props.disabled,
          "v-field--dirty": props.dirty,
          "v-field--error": props.error,
          "v-field--flat": props.flat,
          "v-field--has-background": !!props.bgColor,
          "v-field--persistent-clear": props.persistentClear,
          "v-field--prepended": hasPrepend,
          "v-field--reverse": props.reverse,
          "v-field--single-line": props.singleLine,
          "v-field--no-label": !label,
          [`v-field--variant-${props.variant}`]: true
        }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props.class],
        "style": [backgroundColorStyles.value, props.style],
        "onClick": onClick
      }, attrs), [createVNode("div", {
        "class": "v-field__overlay"
      }, null), createVNode(LoaderSlot, {
        "name": "v-field",
        "active": !!props.loading,
        "color": props.error ? "error" : typeof props.loading === "string" ? props.loading : props.color
      }, {
        default: slots.loader
      }), hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-field__prepend-inner"
      }, [props.prependInnerIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prependInner"
      }, null), slots["prepend-inner"]?.(slotProps.value)]), createVNode("div", {
        "class": "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "key": "floating-label",
        "ref": floatingLabelRef,
        "class": [textColorClasses.value],
        "floating": true,
        "for": id.value,
        "style": textColorStyles.value
      }, {
        default: () => [label]
      }), createVNode(VFieldLabel, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label]
      }), slots.default?.({
        ...slotProps.value,
        props: {
          id: id.value,
          class: "v-field__input",
          "aria-describedby": messagesId.value
        },
        focus,
        blur
      })]), hasClear && createVNode(VExpandXTransition, {
        "key": "clear"
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-field__clearable",
          "onMousedown": (e) => {
            e.preventDefault();
            e.stopPropagation();
          }
        }, [slots.clear ? slots.clear() : createVNode(InputIcon, {
          "name": "clear"
        }, null)]), [[vShow, props.dirty]])]
      }), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-field__append-inner"
      }, [slots["append-inner"]?.(slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "appendInner"
      }, null)]), createVNode("div", {
        "class": ["v-field__outline", textColorClasses.value],
        "style": textColorStyles.value
      }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
        "class": "v-field__outline__start"
      }, null), hasLabel.value && createVNode("div", {
        "class": "v-field__outline__notch"
      }, [createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      })]), createVNode("div", {
        "class": "v-field__outline__end"
      }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      })])]);
    });
    return {
      controlRef
    };
  }
});
function filterFieldProps(attrs) {
  const keys2 = Object.keys(VField.props).filter((k2) => !isOn(k2) && k2 !== "class" && k2 !== "style");
  return pick$1(attrs, keys2);
}
const activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
const makeVTextFieldProps = propsFactory({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...makeVInputProps(),
  ...makeVFieldProps()
}, "VTextField");
const VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: Intersect$1
  },
  inheritAttrs: false,
  props: makeVTextFieldProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const counterValue = computed(() => {
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : (model.value ?? "").toString().length;
    });
    const max2 = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
        return void 0;
      return props.counter;
    });
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props.variant));
    function onIntersect(isIntersecting, entries) {
      if (!props.autofocus || !isIntersecting)
        return;
      entries[0].target?.focus?.();
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value || props.active);
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        inputRef.value?.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
      if (e.target === inputRef.value)
        return;
      onFocus();
      e.preventDefault();
    }
    function onControlClick(e) {
      onFocus();
      emit2("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick$1(() => {
        model.value = null;
        callEvent(props["onClick:clear"], e);
      });
    }
    function onInput(e) {
      const el = e.target;
      model.value = el.value;
      if (props.modelModifiers?.trim && ["text", "search", "password", "tel", "url"].includes(props.type)) {
        const caretPosition = [el.selectionStart, el.selectionEnd];
        nextTick$1(() => {
          el.selectionStart = caretPosition[0];
          el.selectionEnd = caretPosition[1];
        });
      }
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props.counter || props.counterValue);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [{
        modelValue: _,
        ...inputProps
      }] = VInput.filterProps(props);
      const [fieldProps] = filterFieldProps(props);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--prefixed": props.prefix,
          "v-text-field--suffixed": props.suffix,
          "v-text-field--plain-underlined": ["plain", "underlined"].includes(props.variant)
        }, props.class],
        "style": props.style
      }, rootAttrs, inputProps, {
        "centerAffix": !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": onControlMousedown,
            "onClick": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": props["onClick:prependInner"],
            "onClick:appendInner": props["onClick:appendInner"],
            "role": props.role
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props.dirty,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref3;
              const inputNode = withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "value": model.value,
                "onInput": onInput,
                "autofocus": props.autofocus,
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "name": props.name,
                "placeholder": props.placeholder,
                "size": 1,
                "type": props.type,
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]]);
              return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [createVNode("span", {
                "class": "v-text-field__prefix__text"
              }, [props.prefix])]), slots.default ? createVNode("div", {
                "class": fieldClass,
                "data-no-activator": ""
              }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                class: fieldClass
              }), props.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [createVNode("span", {
                "class": "v-text-field__suffix__text"
              }, [props.suffix])])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => createVNode(Fragment, null, [slots.details?.(slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": props.persistentCounter || isFocused.value,
          "value": counterValue.value,
          "max": max2.value
        }, slots.counter)])]) : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, inputRef);
  }
});
const VVirtualScroll$1 = "";
const makeVVirtualScrollItemProps = propsFactory({
  renderless: Boolean,
  ...makeComponentProps()
}, "VVirtualScrollItem");
const VVirtualScrollItem = genericComponent()({
  name: "VVirtualScrollItem",
  inheritAttrs: false,
  props: makeVVirtualScrollItemProps(),
  emits: {
    "update:height": (height) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver(void 0, "border");
    watch(() => contentRect.value?.height, (height) => {
      if (height != null)
        emit2("update:height", height);
    });
    useRender(() => props.renderless ? createVNode(Fragment, null, [slots.default?.({
      itemRef: resizeRef
    })]) : createVNode("div", mergeProps({
      "ref": resizeRef,
      "class": ["v-virtual-scroll__item", props.class],
      "style": props.style
    }, attrs), [slots.default?.()]));
  }
});
const UP = -1;
const DOWN = 1;
const makeVirtualProps = propsFactory({
  itemHeight: {
    type: [Number, String],
    default: 48
  }
}, "virtual");
function useVirtual(props, items, offset2) {
  const first = shallowRef(0);
  const baseItemHeight = shallowRef(props.itemHeight);
  const itemHeight = computed({
    get: () => parseInt(baseItemHeight.value ?? 0, 10),
    set(val) {
      baseItemHeight.value = val;
    }
  });
  const containerRef = ref();
  const {
    resizeRef,
    contentRect
  } = useResizeObserver();
  watchEffect(() => {
    resizeRef.value = containerRef.value;
  });
  const display = useDisplay();
  const sizeMap = /* @__PURE__ */ new Map();
  let sizes = Array.from({
    length: items.value.length
  });
  const visibleItems = computed(() => {
    const height = (!contentRect.value || containerRef.value === document.documentElement ? display.height.value : contentRect.value.height) - (offset2?.value ?? 0);
    return Math.ceil(height / itemHeight.value * 1.7 + 1);
  });
  function handleItemResize(index, height) {
    itemHeight.value = Math.max(itemHeight.value, height);
    sizes[index] = height;
    sizeMap.set(items.value[index], height);
  }
  function calculateOffset2(index) {
    return sizes.slice(0, index).reduce((acc, val) => acc + (val || itemHeight.value), 0);
  }
  function calculateMidPointIndex(scrollTop) {
    const end = items.value.length;
    let middle = 0;
    let middleOffset = 0;
    while (middleOffset < scrollTop && middle < end) {
      middleOffset += sizes[middle++] || itemHeight.value;
    }
    return middle - 1;
  }
  let lastScrollTop = 0;
  function handleScroll() {
    if (!containerRef.value || !contentRect.value)
      return;
    const height = contentRect.value.height - 56;
    const scrollTop = containerRef.value.scrollTop;
    const direction = scrollTop < lastScrollTop ? UP : DOWN;
    const midPointIndex = calculateMidPointIndex(scrollTop + height / 2);
    const buffer = Math.round(visibleItems.value / 3);
    const firstIndex = midPointIndex - buffer;
    const lastIndex = first.value + buffer * 2 - 1;
    if (direction === UP && midPointIndex <= lastIndex) {
      first.value = clamp(firstIndex, 0, items.value.length);
    } else if (direction === DOWN && midPointIndex >= lastIndex) {
      first.value = clamp(firstIndex, 0, items.value.length - visibleItems.value);
    }
    lastScrollTop = scrollTop;
  }
  function scrollToIndex(index) {
    if (!containerRef.value)
      return;
    const offset3 = calculateOffset2(index);
    containerRef.value.scrollTop = offset3;
  }
  const last = computed(() => Math.min(items.value.length, first.value + visibleItems.value));
  const computedItems = computed(() => {
    return items.value.slice(first.value, last.value).map((item, index) => ({
      raw: item,
      index: index + first.value
    }));
  });
  const paddingTop = computed(() => calculateOffset2(first.value));
  const paddingBottom = computed(() => calculateOffset2(items.value.length) - calculateOffset2(last.value));
  watch(() => items.value.length, () => {
    sizes = createRange(items.value.length).map(() => itemHeight.value);
    sizeMap.forEach((height, item) => {
      const index = items.value.indexOf(item);
      if (index === -1) {
        sizeMap.delete(item);
      } else {
        sizes[index] = height;
      }
    });
  });
  return {
    containerRef,
    computedItems,
    itemHeight,
    paddingTop,
    paddingBottom,
    scrollToIndex,
    handleScroll,
    handleItemResize
  };
}
const makeVVirtualScrollProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...makeVirtualProps(),
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VVirtualScroll");
const VVirtualScroll = genericComponent()({
  name: "VVirtualScroll",
  props: makeVVirtualScrollProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const vm = getCurrentInstance("VVirtualScroll");
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      containerRef,
      handleScroll,
      handleItemResize,
      scrollToIndex,
      paddingTop,
      paddingBottom,
      computedItems
    } = useVirtual(props, toRef(props, "items"));
    useToggleScope(() => props.renderless, () => {
      onMounted(() => {
        containerRef.value = getScrollParent(vm.vnode.el, true);
        containerRef.value?.addEventListener("scroll", handleScroll);
      });
      onScopeDispose(() => {
        containerRef.value?.removeEventListener("scroll", handleScroll);
      });
    });
    useRender(() => {
      const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
        "key": item.index,
        "renderless": props.renderless,
        "onUpdate:height": (height) => handleItemResize(item.index, height)
      }, {
        default: (slotProps) => slots.default?.({
          item: item.raw,
          index: item.index,
          ...slotProps
        })
      }));
      return props.renderless ? createVNode(Fragment, null, [createVNode("div", {
        "class": "v-virtual-scroll__spacer",
        "style": {
          paddingTop: convertToUnit(paddingTop.value)
        }
      }, null), children, createVNode("div", {
        "class": "v-virtual-scroll__spacer",
        "style": {
          paddingBottom: convertToUnit(paddingBottom.value)
        }
      }, null)]) : createVNode("div", {
        "ref": containerRef,
        "class": ["v-virtual-scroll", props.class],
        "onScroll": handleScroll,
        "style": [dimensionStyles.value, props.style]
      }, [createVNode("div", {
        "class": "v-virtual-scroll__container",
        "style": {
          paddingTop: convertToUnit(paddingTop.value),
          paddingBottom: convertToUnit(paddingBottom.value)
        }
      }, [children])]);
    });
    return {
      scrollToIndex
    };
  }
});
function useScrolling(listRef, textFieldRef) {
  const isScrolling = shallowRef(false);
  let scrollTimeout;
  function onListScroll(e) {
    cancelAnimationFrame(scrollTimeout);
    isScrolling.value = true;
    scrollTimeout = requestAnimationFrame(() => {
      scrollTimeout = requestAnimationFrame(() => {
        isScrolling.value = false;
      });
    });
  }
  async function finishScrolling() {
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => {
      if (isScrolling.value) {
        const stop = watch(isScrolling, () => {
          stop();
          resolve2();
        });
      } else
        resolve2();
    });
  }
  async function onListKeydown(e) {
    if (e.key === "Tab") {
      textFieldRef.value?.focus();
    }
    if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
      return;
    const el = listRef.value?.$el;
    if (!el)
      return;
    if (e.key === "Home" || e.key === "End") {
      el.scrollTo({
        top: e.key === "Home" ? 0 : el.scrollHeight,
        behavior: "smooth"
      });
    }
    await finishScrolling();
    const children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (e.key === "PageDown" || e.key === "Home") {
      const top = el.getBoundingClientRect().top;
      for (const child of children) {
        if (child.getBoundingClientRect().top >= top) {
          child.focus();
          break;
        }
      }
    } else {
      const bottom = el.getBoundingClientRect().bottom;
      for (const child of [...children].reverse()) {
        if (child.getBoundingClientRect().bottom <= bottom) {
          child.focus();
          break;
        }
      }
    }
  }
  return {
    onListScroll,
    onListKeydown
  };
}
const makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ...makeItemsProps({
    itemChildren: false
  })
}, "Select");
const makeVSelectProps = propsFactory({
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "button"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps$1({
    transition: {
      component: VDialogTransition
    }
  })
}, "VSelect");
const VSelect = genericComponent()({
  name: "VSelect",
  props: makeVSelectProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        if (_menu.value && !v && vMenuRef.value?.ΨopenChildren)
          return;
        _menu.value = v;
      }
    });
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const selectedValues = computed(() => model.value.map((selection) => selection.value));
    const isFocused = shallowRef(false);
    const label = computed(() => menu.value ? props.closeText : props.openText);
    let keyboardLookupPrefix = "";
    let keyboardLookupLastTime;
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return items.value.filter((item) => !model.value.some((s) => s === item));
      }
      return items.value;
    });
    const menuDisabled = computed(() => props.hideNoData && !items.value.length || props.readonly || form?.isReadonly.value);
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (!e.key || props.readonly || form?.isReadonly.value)
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "Home") {
        listRef.value?.focus("first");
      } else if (e.key === "End") {
        listRef.value?.focus("last");
      }
      const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
      function checkPrintable(e2) {
        const isPrintableChar = e2.key.length === 1;
        const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
        return isPrintableChar && noModifier;
      }
      if (props.multiple || !checkPrintable(e))
        return;
      const now2 = performance.now();
      if (now2 - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
        keyboardLookupPrefix = "";
      }
      keyboardLookupPrefix += e.key.toLowerCase();
      keyboardLookupLastTime = now2;
      const item = items.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
      if (item !== void 0) {
        model.value = [item];
      }
    }
    function select(item) {
      if (props.multiple) {
        const index = model.value.findIndex((selection) => props.valueComparator(selection.value, item.value));
        if (index === -1) {
          model.value = [...model.value, item];
        } else {
          const value2 = [...model.value];
          value2.splice(index, 1);
          model.value = value2;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      if (!listRef.value?.$el.contains(e.relatedTarget)) {
        menu.value = false;
      }
    }
    function onAfterLeave() {
      if (isFocused.value) {
        vTextFieldRef.value?.focus();
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onModelUpdate(v) {
      if (v == null)
        model.value = [];
      else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
        const item = items.value.find((item2) => item2.title === v);
        if (item) {
          select(item);
        }
      } else if (vTextFieldRef.value) {
        vTextFieldRef.value.value = "";
      }
    }
    watch(menu, () => {
      if (!props.hideSelected && menu.value && model.value.length) {
        const index = displayItems.value.findIndex((item) => model.value.some((s) => props.valueComparator(s.value, item.value)));
        IN_BROWSER && window.requestAnimationFrame(() => {
          index >= 0 && vVirtualScrollRef.value?.scrollToIndex(index);
        });
      }
    });
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const [textFieldProps] = VTextField.filterProps(props);
      const placeholder = isDirty || !isFocused.value && props.label && !props.persistentPlaceholder ? void 0 : props.placeholder;
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": onModelUpdate,
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "dirty": isDirty,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length,
          "v-select--selection-slot": !!slots.selection
        }, props.class],
        "style": props.style,
        "inputmode": "none",
        "placeholder": placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown,
        "aria-label": t(label.value),
        "title": t(label.value)
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-select__content",
          "disabled": menuDisabled.value,
          "eager": props.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props.transition,
          "onAfterLeave": onAfterLeave
        }, props.menuProps), {
          default: () => [hasList && createVNode(VList, {
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "color": props.itemColor ?? props.color
          }, {
            default: () => [slots["prepend-item"]?.(), !displayItems.value.length && !props.hideNoData && (slots["no-data"]?.() ?? createVNode(VListItem, {
              "title": t(props.noDataText)
            }, null)), createVNode(VVirtualScroll, {
              "ref": vVirtualScrollRef,
              "renderless": true,
              "items": displayItems.value
            }, {
              default: (_ref2) => {
                let {
                  item,
                  index,
                  itemRef
                } = _ref2;
                const itemProps = mergeProps(item.props, {
                  ref: itemRef,
                  key: index,
                  onClick: () => select(item)
                });
                return slots.item?.({
                  item,
                  index,
                  props: itemProps
                }) ?? createVNode(VListItem, itemProps, {
                  prepend: (_ref3) => {
                    let {
                      isSelected
                    } = _ref3;
                    return createVNode(Fragment, null, [props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                      "key": item.value,
                      "modelValue": isSelected,
                      "ripple": false,
                      "tabindex": "-1"
                    }, null) : void 0, item.props.prependIcon && createVNode(VIcon, {
                      "icon": item.props.prependIcon
                    }, null)]);
                  }
                });
              }
            }), slots["append-item"]?.()]
          })]
        }), model.value.map((item, index) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          return createVNode("div", {
            "key": item.value,
            "class": "v-select__selection"
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props.closableChips,
            "size": "small",
            "text": item.title
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => [slots.chip?.({
              item,
              index,
              props: slotProps
            })]
          }) : slots.selection?.({
            item,
            index
          }) ?? createVNode("span", {
            "class": "v-select__selection-text"
          }, [item.title, props.multiple && index < model.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [slots["append-inner"]?.(...args), props.menuIcon ? createVNode(VIcon, {
            "class": "v-select__menu-icon",
            "icon": props.menuIcon
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      menu,
      select
    }, vTextFieldRef);
  }
});
const VSnackbar$1 = "";
const makeVSnackbarProps = propsFactory({
  multiLine: Boolean,
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ...makeLocationProps({
    location: "bottom"
  }),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeVariantProps(),
  ...makeThemeProps(),
  ...omit(makeVOverlayProps({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar");
const VSnackbar = genericComponent()({
  name: "VSnackbar",
  props: makeVSnackbarProps(),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      scopeId
    } = useScopeId();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      roundedClasses
    } = useRounded(props);
    const overlay = ref();
    watch(isActive, startTimeout);
    watch(() => props.timeout, startTimeout);
    onMounted(() => {
      if (isActive.value)
        startTimeout();
    });
    let activeTimeout = -1;
    function startTimeout() {
      window.clearTimeout(activeTimeout);
      const timeout = Number(props.timeout);
      if (!isActive.value || timeout === -1)
        return;
      activeTimeout = window.setTimeout(() => {
        isActive.value = false;
      }, timeout);
    }
    function onPointerenter() {
      window.clearTimeout(activeTimeout);
    }
    useRender(() => {
      const [overlayProps] = VOverlay.filterProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-snackbar", {
          "v-snackbar--active": isActive.value,
          "v-snackbar--multi-line": props.multiLine && !props.vertical,
          "v-snackbar--vertical": props.vertical
        }, positionClasses.value, props.class],
        "style": props.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "contentProps": mergeProps({
          class: ["v-snackbar__wrapper", themeClasses.value, colorClasses.value, roundedClasses.value, variantClasses.value],
          style: [locationStyles.value, colorStyles.value],
          onPointerenter,
          onPointerleave: startTimeout
        }, overlayProps.contentProps),
        "persistent": true,
        "noClickAnimation": true,
        "scrim": false,
        "scrollStrategy": "none",
        "_disableGlobalStack": true
      }, scopeId), {
        default: () => [genOverlays(false, "v-snackbar"), slots.default && createVNode("div", {
          "class": "v-snackbar__content",
          "role": "status",
          "aria-live": "polite"
        }, [slots.default()]), slots.actions && createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              variant: "text",
              ripple: false
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-snackbar__actions"
          }, [slots.actions()])]
        })],
        activator: slots.activator
      });
    });
    return forwardRefs({}, overlay);
  }
});
const VSystemBar$1 = "";
const makeVSystemBarProps = propsFactory({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeLayoutItemProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VSystemBar");
const VSystemBar = genericComponent()({
  name: "VSystemBar",
  props: makeVSystemBarProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      ssrBootStyles
    } = useSsrBoot();
    const height = computed(() => props.height ?? (props.window ? 32 : 24));
    const {
      layoutItemStyles
    } = useLayoutItem({
      id: props.name,
      order: computed(() => parseInt(props.order, 10)),
      position: shallowRef("top"),
      layoutSize: height,
      elementSize: height,
      active: computed(() => true),
      absolute: toRef(props, "absolute")
    });
    useRender(() => createVNode(props.tag, {
      "class": ["v-system-bar", {
        "v-system-bar--window": props.window
      }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value, roundedClasses.value, props.class],
      "style": [backgroundColorStyles.value, layoutItemStyles.value, ssrBootStyles.value, props.style]
    }, slots));
    return {};
  }
});
const VTabs$1 = "";
const VTab$1 = "";
const VTabsSymbol = Symbol.for("vuetify:v-tabs");
const makeVTabProps = propsFactory({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...omit(makeVBtnProps({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab");
const VTab = genericComponent()({
  name: "VTab",
  props: makeVTabProps(),
  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      textColorClasses: sliderColorClasses,
      textColorStyles: sliderColorStyles
    } = useTextColor(props, "sliderColor");
    const isHorizontal = computed(() => props.direction === "horizontal");
    const isSelected = shallowRef(false);
    const rootEl = ref();
    const sliderEl = ref();
    function updateSlider(_ref2) {
      let {
        value: value2
      } = _ref2;
      isSelected.value = value2;
      if (value2) {
        const prevEl = rootEl.value?.$el.parentElement?.querySelector(".v-tab--selected .v-tab__slider");
        const nextEl = sliderEl.value;
        if (!prevEl || !nextEl)
          return;
        const color = getComputedStyle(prevEl).color;
        const prevBox = prevEl.getBoundingClientRect();
        const nextBox = nextEl.getBoundingClientRect();
        const xy = isHorizontal.value ? "x" : "y";
        const XY = isHorizontal.value ? "X" : "Y";
        const rightBottom = isHorizontal.value ? "right" : "bottom";
        const widthHeight = isHorizontal.value ? "width" : "height";
        const prevPos = prevBox[xy];
        const nextPos = nextBox[xy];
        const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
        const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
        const size2 = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
        const scale = size2 / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
        const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
        const sigma = 1.5;
        animate(nextEl, {
          backgroundColor: [color, "currentcolor"],
          transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`, "none"],
          transformOrigin: Array(3).fill(origin)
        }, {
          duration: 225,
          easing: standardEasing
        });
      }
    }
    useRender(() => {
      const [btnProps] = VBtn.filterProps(props);
      return createVNode(VBtn, mergeProps({
        "symbol": VTabsSymbol,
        "ref": rootEl,
        "class": ["v-tab", props.class],
        "style": props.style,
        "tabindex": isSelected.value ? 0 : -1,
        "role": "tab",
        "aria-selected": String(isSelected.value),
        "active": false
      }, btnProps, attrs, {
        "block": props.fixed,
        "maxWidth": props.fixed ? 300 : void 0,
        "onGroup:selected": updateSlider
      }), {
        default: () => [slots.default?.() ?? props.text, !props.hideSlider && createVNode("div", {
          "ref": sliderEl,
          "class": ["v-tab__slider", sliderColorClasses.value],
          "style": sliderColorStyles.value
        }, null)]
      });
    });
    return {};
  }
});
const VSlideGroup$1 = "";
function bias(val) {
  const c = 0.501;
  const x2 = Math.abs(val);
  return Math.sign(val) * (x2 / ((1 / c - 2) * (1 - x2) + 1));
}
function calculateUpdatedOffset(_ref) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    currentScrollOffset,
    isHorizontal
  } = _ref;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const adjustedOffsetStart = isRtl && isHorizontal ? contentSize - offsetStart - clientSize : offsetStart;
  const totalSize = containerSize + currentScrollOffset;
  const itemOffset = clientSize + adjustedOffsetStart;
  const additionalOffset = clientSize * 0.4;
  if (adjustedOffsetStart <= currentScrollOffset) {
    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
  } else if (totalSize <= itemOffset) {
    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
  }
  return currentScrollOffset;
}
function calculateCenteredOffset(_ref2) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    isHorizontal
  } = _ref2;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const offsetCentered = isRtl && isHorizontal ? contentSize - offsetStart - clientSize / 2 - containerSize / 2 : offsetStart + clientSize / 2 - containerSize / 2;
  return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
}
const VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
const makeVSlideGroupProps = propsFactory({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: VSlideGroupSymbol
  },
  nextIcon: {
    type: IconValue,
    default: "$next"
  },
  prevIcon: {
    type: IconValue,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
  },
  ...makeComponentProps(),
  ...makeTagProps(),
  ...makeGroupProps({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup");
const VSlideGroup = genericComponent()({
  name: "VSlideGroup",
  props: makeVSlideGroupProps(),
  emits: {
    "update:modelValue": (value2) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const {
      mobile
    } = useDisplay();
    const group = useGroup(props, props.symbol);
    const isOverflowing = shallowRef(false);
    const scrollOffset = shallowRef(0);
    const containerSize = shallowRef(0);
    const contentSize = shallowRef(0);
    const isHorizontal = computed(() => props.direction === "horizontal");
    const {
      resizeRef: containerRef,
      contentRect: containerRect
    } = useResizeObserver();
    const {
      resizeRef: contentRef,
      contentRect
    } = useResizeObserver();
    const firstSelectedIndex = computed(() => {
      if (!group.selected.value.length)
        return -1;
      return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
    });
    const lastSelectedIndex = computed(() => {
      if (!group.selected.value.length)
        return -1;
      return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
    });
    if (IN_BROWSER) {
      let frame = -1;
      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => {
          if (containerRect.value && contentRect.value) {
            const sizeProperty = isHorizontal.value ? "width" : "height";
            containerSize.value = containerRect.value[sizeProperty];
            contentSize.value = contentRect.value[sizeProperty];
            isOverflowing.value = containerSize.value + 1 < contentSize.value;
          }
          if (firstSelectedIndex.value >= 0 && contentRef.value) {
            const selectedElement = contentRef.value.children[lastSelectedIndex.value];
            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {
              scrollOffset.value = 0;
            } else if (props.centerActive) {
              scrollOffset.value = calculateCenteredOffset({
                selectedElement,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                isHorizontal: isHorizontal.value
              });
            } else if (isOverflowing.value) {
              scrollOffset.value = calculateUpdatedOffset({
                selectedElement,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                currentScrollOffset: scrollOffset.value,
                isHorizontal: isHorizontal.value
              });
            }
          }
        });
      });
    }
    const disableTransition = shallowRef(false);
    let startTouch = 0;
    let startOffset = 0;
    function onTouchstart(e) {
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      const sign2 = isRtl.value && isHorizontal.value ? -1 : 1;
      startOffset = sign2 * scrollOffset.value;
      startTouch = e.touches[0][sizeProperty];
      disableTransition.value = true;
    }
    function onTouchmove(e) {
      if (!isOverflowing.value)
        return;
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      const sign2 = isRtl.value && isHorizontal.value ? -1 : 1;
      scrollOffset.value = sign2 * (startOffset + startTouch - e.touches[0][sizeProperty]);
    }
    function onTouchend(e) {
      const maxScrollOffset = contentSize.value - containerSize.value;
      if (scrollOffset.value < 0 || !isOverflowing.value) {
        scrollOffset.value = 0;
      } else if (scrollOffset.value >= maxScrollOffset) {
        scrollOffset.value = maxScrollOffset;
      }
      disableTransition.value = false;
    }
    function onScroll() {
      if (!containerRef.value)
        return;
      containerRef.value[isHorizontal.value ? "scrollLeft" : "scrollTop"] = 0;
    }
    const isFocused = shallowRef(false);
    function onFocusin(e) {
      isFocused.value = true;
      if (!isOverflowing.value || !contentRef.value)
        return;
      for (const el of e.composedPath()) {
        for (const item of contentRef.value.children) {
          if (item === el) {
            scrollOffset.value = calculateUpdatedOffset({
              selectedElement: item,
              containerSize: containerSize.value,
              contentSize: contentSize.value,
              isRtl: isRtl.value,
              currentScrollOffset: scrollOffset.value,
              isHorizontal: isHorizontal.value
            });
            return;
          }
        }
      }
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget)))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (isHorizontal.value) {
        if (e.key === "ArrowRight") {
          focus(isRtl.value ? "prev" : "next");
        } else if (e.key === "ArrowLeft") {
          focus(isRtl.value ? "next" : "prev");
        }
      } else {
        if (e.key === "ArrowDown") {
          focus("next");
        } else if (e.key === "ArrowUp") {
          focus("prev");
        }
      }
      if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      }
    }
    function focus(location2) {
      if (!contentRef.value)
        return;
      if (!location2) {
        const focusable = focusableChildren(contentRef.value);
        focusable[0]?.focus();
      } else if (location2 === "next") {
        const el = contentRef.value.querySelector(":focus")?.nextElementSibling;
        if (el)
          el.focus();
        else
          focus("first");
      } else if (location2 === "prev") {
        const el = contentRef.value.querySelector(":focus")?.previousElementSibling;
        if (el)
          el.focus();
        else
          focus("last");
      } else if (location2 === "first") {
        contentRef.value.firstElementChild?.focus();
      } else if (location2 === "last") {
        contentRef.value.lastElementChild?.focus();
      }
    }
    function scrollTo(location2) {
      const newAbsoluteOffset = scrollOffset.value + (location2 === "prev" ? -1 : 1) * containerSize.value;
      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);
    }
    const contentStyles = computed(() => {
      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
      if (scrollOffset.value <= 0) {
        scrollAmount = bias(-scrollOffset.value);
      }
      const sign2 = isRtl.value && isHorizontal.value ? -1 : 1;
      return {
        transform: `translate${isHorizontal.value ? "X" : "Y"}(${sign2 * scrollAmount}px)`,
        transition: disableTransition.value ? "none" : "",
        willChange: disableTransition.value ? "transform" : ""
      };
    });
    const slotProps = computed(() => ({
      next: group.next,
      prev: group.prev,
      select: group.select,
      isSelected: group.isSelected
    }));
    const hasAffixes = computed(() => {
      switch (props.showArrows) {
        case "always":
          return true;
        case "desktop":
          return !mobile.value;
        case true:
          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        case "mobile":
          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        default:
          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
      }
    });
    const hasPrev = computed(() => {
      return Math.abs(scrollOffset.value) > 0;
    });
    const hasNext = computed(() => {
      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
    });
    useRender(() => createVNode(props.tag, {
      "class": ["v-slide-group", {
        "v-slide-group--vertical": !isHorizontal.value,
        "v-slide-group--has-affixes": hasAffixes.value,
        "v-slide-group--is-overflowing": isOverflowing.value
      }, props.class],
      "style": props.style,
      "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
      "onFocus": onFocus
    }, {
      default: () => [hasAffixes.value && createVNode("div", {
        "key": "prev",
        "class": ["v-slide-group__prev", {
          "v-slide-group__prev--disabled": !hasPrev.value
        }],
        "onClick": () => scrollTo("prev")
      }, [slots.prev?.(slotProps.value) ?? createVNode(VFadeTransition, null, {
        default: () => [createVNode(VIcon, {
          "icon": isRtl.value ? props.nextIcon : props.prevIcon
        }, null)]
      })]), createVNode("div", {
        "key": "container",
        "ref": containerRef,
        "class": "v-slide-group__container",
        "onScroll": onScroll
      }, [createVNode("div", {
        "ref": contentRef,
        "class": "v-slide-group__content",
        "style": contentStyles.value,
        "onTouchstartPassive": onTouchstart,
        "onTouchmovePassive": onTouchmove,
        "onTouchendPassive": onTouchend,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onKeydown": onKeydown
      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && createVNode("div", {
        "key": "next",
        "class": ["v-slide-group__next", {
          "v-slide-group__next--disabled": !hasNext.value
        }],
        "onClick": () => scrollTo("next")
      }, [slots.next?.(slotProps.value) ?? createVNode(VFadeTransition, null, {
        default: () => [createVNode(VIcon, {
          "icon": isRtl.value ? props.prevIcon : props.nextIcon
        }, null)]
      })])]
    }));
    return {
      selected: group.selected,
      scrollTo,
      scrollOffset,
      focus
    };
  }
});
function parseItems(items) {
  if (!items)
    return [];
  return items.map((item) => {
    if (!isObject$4(item))
      return {
        text: item,
        value: item
      };
    return item;
  });
}
const makeVTabsProps = propsFactory({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...makeVSlideGroupProps({
    mandatory: "force"
  }),
  ...makeDensityProps(),
  ...makeTagProps()
}, "VTabs");
const VTabs = genericComponent()({
  name: "VTabs",
  props: makeVTabsProps(),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const parsedItems = computed(() => parseItems(props.items));
    const {
      densityClasses
    } = useDensity(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    provideDefaults({
      VTab: {
        color: toRef(props, "color"),
        direction: toRef(props, "direction"),
        stacked: toRef(props, "stacked"),
        fixed: toRef(props, "fixedTabs"),
        sliderColor: toRef(props, "sliderColor"),
        hideSlider: toRef(props, "hideSlider")
      }
    });
    useRender(() => {
      const [slideGroupProps] = VSlideGroup.filterProps(props);
      return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-tabs", `v-tabs--${props.direction}`, `v-tabs--align-tabs-${props.alignTabs}`, {
          "v-tabs--fixed-tabs": props.fixedTabs,
          "v-tabs--grow": props.grow,
          "v-tabs--stacked": props.stacked
        }, densityClasses.value, backgroundColorClasses.value, props.class],
        "style": [{
          "--v-tabs-height": convertToUnit(props.height)
        }, backgroundColorStyles.value, props.style],
        "role": "tablist",
        "symbol": VTabsSymbol
      }), {
        default: () => [slots.default ? slots.default() : parsedItems.value.map((item) => createVNode(VTab, mergeProps(item, {
          "key": item.text
        }), null))]
      });
    });
    return {};
  }
});
const VToolbar$1 = "";
const makeVToolbarTitleProps = propsFactory({
  text: String,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VToolbarTitle");
const VToolbarTitle = genericComponent()({
  name: "VToolbarTitle",
  props: makeVToolbarTitleProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      const hasText = !!(slots.default || slots.text || props.text);
      return createVNode(props.tag, {
        "class": ["v-toolbar-title", props.class],
        "style": props.style
      }, {
        default: () => [hasText && createVNode("div", {
          "class": "v-toolbar-title__placeholder"
        }, [slots.text ? slots.text() : props.text, slots.default?.()])]
      });
    });
    return {};
  }
});
const allowedDensities = [null, "prominent", "default", "comfortable", "compact"];
const makeVToolbarProps = propsFactory({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (v) => allowedDensities.includes(v)
  },
  extended: Boolean,
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "header"
  }),
  ...makeThemeProps()
}, "VToolbar");
const VToolbar = genericComponent()({
  name: "VToolbar",
  props: makeVToolbarProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      themeClasses
    } = provideTheme(props);
    const {
      rtlClasses
    } = useRtl();
    const isExtended = shallowRef(!!(props.extended || slots.extension?.()));
    const contentHeight = computed(() => parseInt(Number(props.height) + (props.density === "prominent" ? Number(props.height) : 0) - (props.density === "comfortable" ? 8 : 0) - (props.density === "compact" ? 16 : 0), 10));
    const extensionHeight = computed(() => isExtended.value ? parseInt(Number(props.extensionHeight) + (props.density === "prominent" ? Number(props.extensionHeight) : 0) - (props.density === "comfortable" ? 4 : 0) - (props.density === "compact" ? 8 : 0), 10) : 0);
    provideDefaults({
      VBtn: {
        variant: "text"
      }
    });
    useRender(() => {
      const hasTitle = !!(props.title || slots.title);
      const hasImage = !!(slots.image || props.image);
      const extension = slots.extension?.();
      isExtended.value = !!(props.extended || extension);
      return createVNode(props.tag, {
        "class": ["v-toolbar", {
          "v-toolbar--absolute": props.absolute,
          "v-toolbar--collapse": props.collapse,
          "v-toolbar--flat": props.flat,
          "v-toolbar--floating": props.floating,
          [`v-toolbar--density-${props.density}`]: true
        }, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, roundedClasses.value, themeClasses.value, rtlClasses.value, props.class],
        "style": [backgroundColorStyles.value, props.style]
      }, {
        default: () => [hasImage && createVNode("div", {
          "key": "image",
          "class": "v-toolbar__image"
        }, [!slots.image ? createVNode(VImg, {
          "key": "image-img",
          "cover": true,
          "src": props.image
        }, null) : createVNode(VDefaultsProvider, {
          "key": "image-defaults",
          "disabled": !props.image,
          "defaults": {
            VImg: {
              cover: true,
              src: props.image
            }
          }
        }, slots.image)]), createVNode(VDefaultsProvider, {
          "defaults": {
            VTabs: {
              height: convertToUnit(contentHeight.value)
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-toolbar__content",
            "style": {
              height: convertToUnit(contentHeight.value)
            }
          }, [slots.prepend && createVNode("div", {
            "class": "v-toolbar__prepend"
          }, [slots.prepend?.()]), hasTitle && createVNode(VToolbarTitle, {
            "key": "title",
            "text": props.title
          }, {
            text: slots.title
          }), slots.default?.(), slots.append && createVNode("div", {
            "class": "v-toolbar__append"
          }, [slots.append?.()])])]
        }), createVNode(VDefaultsProvider, {
          "defaults": {
            VTabs: {
              height: convertToUnit(extensionHeight.value)
            }
          }
        }, {
          default: () => [createVNode(VExpandTransition, null, {
            default: () => [isExtended.value && createVNode("div", {
              "class": "v-toolbar__extension",
              "style": {
                height: convertToUnit(extensionHeight.value)
              }
            }, [extension])]
          })]
        })]
      });
    });
    return {
      contentHeight,
      extensionHeight
    };
  }
});
reactive({
  connected: false
});
const agoraEngine = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });
const _sfc_main$3 = {
  components: {
    // VuePdfApp, 
    TimeComponent,
    ProgressLinearComponent,
    DiasSysComponent,
    HeartRateComponent,
    WeightComponent,
    HeightComponent,
    TemperatureComponent,
    VitalSignsResults,
    PrescriptionsComponent
    //VitalSignComponent
  },
  data() {
    return {
      localVideoPlayer: "",
      videoTrack: null,
      audioTrack: null,
      videodiv: "",
      text: "",
      downlinkNetworkQuality: 0,
      downlinkNetworkQualityRemote: 0,
      remotePlayerContainer: "",
      localPlayerContainer: "",
      options: {
        appId: "10d5ec86b71f43da879117c0e5c2b6e1",
        // Set the channel name.
        channel: "",
        // Pass your temp token here.
        token: "",
        // Set the user ID.
        uid: 0
      },
      channelParameters: {
        localAudioTrack: null,
        // A variable to hold a local video track.
        localVideoTrack: null,
        // A variable to hold a remote audio track.
        remoteAudioTrack: null,
        // A variable to hold a remote video track.
        remoteVideoTrack: null,
        // A variable to hold the remote user id.s
        remoteUid: null
      },
      minutes: "--",
      seconds: "--",
      videoBlocked: false,
      disabledButtonEndCall: true,
      disabledButtonVolUp: false,
      disabledButtonVolMin: false,
      //cronometro
      time: "00:00",
      timeBegan: null,
      timeStopped: null,
      stoppedDuration: 0,
      started: null,
      running: false,
      isStop: false,
      //buscador de tipo de laboratorios
      searchLab: "",
      genderLocal: "",
      dialogSearch: false,
      scanSave: true,
      e6: 1,
      step: 1,
      snackbar: false,
      consultations: [],
      filteredConsultations: [],
      consultationName: "",
      //variable utilizada al momento de crear consulta y asignarle fecha
      consultation_form: {
        name: "",
        active: true,
        patient: "",
        cabin: ""
      },
      e1: 1,
      callId: this.$route.params.callId,
      gid: "",
      cabinId: this.$route.params.cabinId,
      patientId: null,
      consultationId: "",
      dialog20: false,
      dialog21: false,
      dialog: false,
      first_name: "",
      dialog3: false,
      videoProfile: "360p_1",
      channel: "",
      transcode: js_cookieExports.get("transcode") || "interop",
      codec: js_cookieExports.get("codec") || "h264",
      attendeeMode: js_cookieExports.get("attendeeMode") || "video",
      baseMode: js_cookieExports.get("baseMode") || "avc",
      uid: void 0,
      form1: {
        id: "",
        cabin: null,
        state: "",
        alive: true,
        active: true,
        entity: null,
        profile_picture: null,
        first_name: "",
        last_name: "",
        birth_date: (/* @__PURE__ */ new Date()).toISOString().substring(0, 10),
        gender: null,
        government_id: "",
        phone_number: "",
        country: "Guatemala",
        email: "",
        city: "",
        address: ""
      },
      url: null,
      //personal information vars
      firstName: null,
      message: null,
      // consultations data
      dialogAskingVitalSigns: false,
      vitalSignDescription: "",
      dialog14: false,
      dialogLoadingVitalSign: false,
      dialogLoading: false,
      dialogLoadingAppointment: false,
      snackbar2: false,
      dialogSaveVS: false,
      symptom: "",
      type2: null,
      e7: 1,
      navigationType: void 0,
      dialogSend: false,
      dialogValidate: false,
      selectDisabled: false,
      form: {
        consultation: "",
        type: null,
        location: null,
        severity: null,
        onset: (/* @__PURE__ */ new Date()).toISOString().substring(0, 10),
        reported: "N/A",
        timestamp: ""
      },
      formvitalsign: {
        consultation: null,
        weight: null,
        height: null,
        systolic_pressure: null,
        diastolic_pressure: null,
        heart_rate: null,
        temperature: null,
        glucose: null,
        oxygen: null,
        timestamp: (/* @__PURE__ */ new Date()).toISOString().substring(0, 10)
      },
      idScan: "",
      imageScan: "",
      appointmentForm: {
        consultation: null,
        appointment_type: null,
        scheduled: (/* @__PURE__ */ new Date()).toISOString(),
        start: null,
        end: null,
        patient: null,
        ambassador: 13
      },
      channelCmd: "",
      patiId: "",
      idAssistnt: "",
      isDemoChannel: false,
      isInstallerChannel: false,
      isTestingChannel: false,
      isOperationsChannel: false,
      cabinChannel: "",
      showScanResult: false,
      statusDoor: false,
      doorClosed: false,
      doorOpened: false,
      scanDone: false,
      scanError: false,
      endingCall: false,
      emergencyDoor: true,
      dialogDoor: false,
      volumeMute: false,
      //CallCenterDoctors
      dialogDoc: false,
      dialogReload: false,
      listScans: [],
      //Vars para activar/desactivar botones de signos vitales
      disabledButton: false,
      //patient details for seguimiento
      isSeguimiento: null,
      proflePicP: "",
      nameP: "",
      apellidoP: "",
      genderP: null,
      ageP: "",
      newCabinIdChannel: "",
      //snackbars volume
      volDone: false,
      volError: false,
      muteDone: false,
      unmuteDone: false,
      overlay: false,
      laser: false,
      //button scan
      newScan: false,
      //new vars
      waitingScanVar: false,
      turnOnScanVar: true,
      buttonsScan: true,
      waitingMessage: "",
      parsedSVHeight: "",
      scanOnDone: false,
      scanOnError: false,
      snackbarVar: false,
      textVol: "",
      scanAg: false,
      nscanAg: true,
      sendButton: true,
      validateSaveButton: false,
      attempts: 3,
      activateCallInfo: false,
      //var patient dpi
      snackBarWait: false,
      timeout: -1,
      bottom: true,
      right: true,
      callStarted: false,
      callStartedAgora: false,
      waitingCall: true,
      keyDiv: 0,
      noteMedicalButton: true,
      record: false,
      textSteto: "Grabar",
      estetoR: false,
      cardBlocked: false,
      //Vars to get country information
      sthetoAvailable: false,
      esfigmoAvailable: false,
      transition: "slide-y-reverse-transition",
      fab: false,
      patient: "",
      canva: "",
      remot: "",
      camerasAvailables: [],
      microphonesAvailables: [],
      dialogDevice: false,
      videoT: null,
      audioT: null,
      tab: null,
      miniScan: false,
      miniVs: true,
      vitalSigns: {
        esfigmo: "esfigmo",
        oxygen: "oxygen",
        weight: "weight",
        height: "height",
        temperature: "temperature"
      },
      typeRequest: {
        requestSv: "request-sv",
        confirmSv: "confirm-sv"
      },
      keyVsToSend: {
        weight: "Weight-c",
        height: "height-c",
        bpm: "bpm-c",
        spo2: "SpO2-c",
        sis: "sis-c",
        dias: "dias-c",
        tmp: "tmp-c"
      },
      sendRequestText: "Enviando solicitud...",
      showVsCard: false,
      showScanCard: false,
      scanSize: "",
      imc: null,
      titleVideoEnded: "Video terminado",
      textVideoEnded: "¡Puedes seguir llenando la información del paciente!",
      stethoText: "Activar esteto",
      tab2: null,
      tab3: null,
      turnOnScanText: "Encender escaner",
      turningOnScan: false,
      recordStethoText: "Grabar",
      recordStethoIcon: "mdi-play",
      sthetoUpVol: false,
      sthetoMinVol: false,
      sthetoSaveVol: false,
      internetQualityLabel: "",
      internetQuality: 0,
      calls: [],
      patientDpiInfo: [],
      cameraNotReadable: false,
      componentKey: 0,
      cabinLocation: "",
      download_speed: 0,
      assistant: "",
      patientPrescriptions: [],
      pfname: "",
      plname: "",
      patientProfilePicture: "",
      assistantId: "",
      dialogFormPatient: true,
      gender: [
        { name: " Femenino", value: false },
        { name: "Masculino", value: true }
      ],
      modal0: false,
      isGenericPatient: false,
      buttonsBlocked: true,
      listVitalSigns: []
    };
  },
  created() {
    if (localStorage.getItem("dpi")) {
      this.gid = localStorage.getItem("dpi");
    }
    this.assistant = localStorage.getItem("doctor");
    this.assistantId = localStorage.getItem("doctorId");
    this.getDevices();
    this.formvitalsign.weight = localStorage.getItem("weight");
    this.formvitalsign.heart_rate = localStorage.getItem("heart_rate");
    this.formvitalsign.oxygen = localStorage.getItem("oxygen");
    this.formvitalsign.temperature = localStorage.getItem("temperature");
    this.formvitalsign.systolic_pressure = localStorage.getItem("systolic_pressure");
    this.formvitalsign.diastolic_pressure = localStorage.getItem("diastolic_pressure");
    this.formvitalsign.height = localStorage.getItem("height");
    this.imc = localStorage.getItem("imc");
    this.esfigmoAvailable = JSON.parse(localStorage.getItem("esfigmoAvailable")) == true;
    this.sthetoAvailable = JSON.parse(localStorage.getItem("estetoAvailable")) == true;
    this.isDemoChannel = localStorage.getItem("is_demo");
    this.isInstallerChannel = localStorage.getItem("is_installer");
    this.isTestingChannel = localStorage.getItem("is_testing");
    this.isOperationsChannel = localStorage.getItem("is_operations");
    this.cabinChannel = `cabin-${this.cabinId}`;
    this.idAssistnt = localStorage.getItem("idAssistant");
    this.form1.cabin = this.cabinId;
    this.consultation_form.cabin = this.cabinId;
    this.channel = `cabin-${this.cabinId}`;
    this.options.channel = this.channel;
    this.channelCmd = `${this.channel}-cmd`;
    this.appId = AGORA_APP_ID;
    this.download_speed = localStorage.getItem("download_speed");
    this.newCabinIdChannel = localStorage.getItem("cabinId");
    this.callStarted = JSON.parse(localStorage.getItem("callStarted")) === true, this.callStartedAgora = JSON.parse(localStorage.getItem("callStartedAgora")) === true;
    this.activateCallInfo = JSON.parse(localStorage.getItem("activateCallInfo")) === true;
    this.form1.government_id = this.gid;
    this.cardBlocked = JSON.parse(localStorage.getItem("cardBlocked")) === true;
    this.waitingCall = JSON.parse(localStorage.getItem("waitCall") === true);
    if (localStorage.getItem("waitCall") == null) {
      this.waitingCall = true;
    }
    if (!this.appId) {
      return alert("Get App ID first!");
    }
    this.patchCall();
    this.getCabin();
    this.getConsultations();
    this.getConsultation();
    this.loadInformation();
    this.reload();
    this.getPatientByDPI();
    try {
      const ws = new WebSocket("ws://3.143.233.51:3000/");
      ws.addEventListener("open", () => {
        ws.send(this.cabinChannel);
      });
    } catch (error) {
      return error;
    }
    setTimeout(() => {
      this.start();
    }, 5e3);
    if (this.waitingCall == false) {
      this.buttonsBlocked = false;
      this.startCall();
    }
    this.consultation_form.name = hooks(/* @__PURE__ */ new Date()).format(
      "YYYY/MM/DD h:mm a"
    );
    if (localStorage.getItem("consultation_Id")) {
      this.consultationId = localStorage.getItem("consultation_Id");
    }
    console.log(localStorage.getItem("dpi"), " getting dpi");
    if (localStorage.getItem("dpi")) {
      console.log(localStorage.getItem("dpi"), " getting dpi here");
      this.gid = localStorage.getItem("dpi");
      this.createOrSearchPatient();
    }
  },
  watch: {
    e7(newValue) {
      localStorage.setItem("step", newValue);
    },
    overlay(val) {
      val && setTimeout(() => {
        this.overlay = false;
      }, 3e3);
    },
    dialog14(val) {
      if (!val)
        return;
      setTimeout(() => this.dialogLoadingAppointment = false, 4e3);
    },
    dialogDoor(val) {
      if (!val)
        return;
    }
  },
  mounted() {
    this.$nextTick(() => {
      let canvas = document.querySelector("#card-outlined");
      return canvas;
    });
    this.isReload();
    if (localStorage.getItem("reloaded")) {
      localStorage.removeItem("reloaded");
    } else {
      localStorage.setItem("reloaded", "1");
      window.location.reload();
    }
  },
  beforeUpdate() {
    let canvas = document.querySelector("#card-outlined");
    let videos = document.querySelector("#localVideoPlayerTest");
    this.canva = canvas;
    this.videodiv = videos;
    if (videos != null) {
      this.videodiv.appendChild(this.localVideoPlayer);
    }
    if (canvas != null) {
      this.canva.appendChild(this.localPlayerContainer);
      this.canva.appendChild(this.remotePlayerContainer);
    }
  },
  methods: {
    isGender(g) {
      this.form1.gender = g.value;
    },
    async toggleDeviceTest() {
      try {
        this.videoTrack = AgoraRTC.createCameraVideoTrack({ cameraId: this.videoT });
        this.audioTrack = AgoraRTC.createMicrophoneAudioTrack({ microphoneId: this.audioT });
        this.localVideoPlayer = document.createElement("div");
        this.localVideoPlayer.style.height = "25%";
        this.localVideoPlayer.style.width = "15%";
        this.localVideoPlayer.style.position = "absolute";
        this.localVideoPlayer.style.border = "2px #00afb9 solid";
        (await this.videoTrack).play(this.localVideoPlayer);
      } catch (error) {
        console.error(error);
      }
    },
    playAudio() {
      this.$refs.audioPlayer.src = audioUrl;
      this.$refs.audioPlayer.play();
    },
    async testAudio() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        this.mediaRecorder = new MediaRecorder(stream);
        const chunks = [];
        this.mediaRecorder.ondataavailable = (e) => {
          chunks.push(e.data);
        };
        this.mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: "audio/wav" });
          const audioUrl2 = URL.createObjectURL(blob);
          this.$refs.audioPlayer.src = audioUrl2;
          this.$refs.audioPlayer.play();
          console.log("Audio del micrófono reproducido correctamente.");
        };
        this.mediaRecorder.start();
        const recordingDuration = 3e3;
        setTimeout(() => {
          this.mediaRecorder.stop();
        }, recordingDuration);
      } catch (error) {
        console.error("No se puede acceder al micrófono o reproducir el audio:", error);
      }
    },
    createOrSearchPatient() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let pathPatients = `${API_URL}api/patients/`;
      axios$1.get(`${pathPatients}get-patient-by-dpi/?government_id=${this.gid}`, { headers }).then((response) => {
        this.patientDpiInfo = response.data;
        if (this.patientDpiInfo.length == 0) {
          this.dialogFormPatient = true;
        } else {
          this.isGenericPatient = true;
          this.dialogFormPatient = false;
          this.buttonsBlocked = false;
          this.patientPrescriptions = this.patientDpiInfo[0]["prescriptions_patient"];
          this.listVitalSigns = response.data[0]["vital_signs_patient"];
          this.pfname = this.patientDpiInfo[0]["first_name"];
          this.plname = this.patientDpiInfo[0]["last_name"];
          this.form1.id = this.patientDpiInfo[0]["id"];
          this.form1.first_name = this.pfname;
          this.form1.last_name = this.plname;
          this.form1.phone_number = this.patientDpiInfo[0]["phone_number"];
          this.patientProfilePicture = this.patientDpiInfo[0]["profile_picture"];
          this.form1.birth_date = this.patientDpiInfo[0]["birth_date"];
          this.form1.gender = this.patientDpiInfo[0]["gender"];
          if (this.pfname.includes("Usuario-")) {
            this.isGenericPatient = true;
            this.dialogFormPatient = false;
            this.form1.first_name = this.patientDpiInfo[0]["first_name"];
            this.form1.last_name = this.patientDpiInfo[0]["last_name"];
            this.form1.phone_number = this.patientDpiInfo[0]["phone_number"];
            this.form1.id = this.patientDpiInfo[0]["id"];
          }
          if (response.data[0].cabin != this.cabinId) {
            axios$1.patch(`${pathPatients}${response.data[0].id}/`, {
              "cabin": this.cabinId,
              "entity": this.form1.entity
            }, { headers }).then((res) => {
              this.patient = res.data.id;
              this.createConsultation();
            }).catch((e) => {
              console.log(e, "error");
              return e;
            });
          } else {
            this.patient = response.data[0].id;
            this.createConsultation();
          }
        }
      }).catch((e) => {
        return e;
      });
    },
    getPatientDpi(dpi) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let pathPatients = `${API_URL}api/patients/`;
      axios$1.get(`${pathPatients}get-patient-by-dpi/?government_id=${dpi}`, { headers }).then((r) => {
        this.patientDpiInfo = r.data;
        this.patientPrescriptions = this.patientDpiInfo[0]["prescriptions_patient"];
        this.pfname = this.patientDpiInfo[0]["first_name"];
        this.plname = this.patientDpiInfo[0]["last_name"];
        this.patientProfilePicture = this.patientDpiInfo[0]["profile_picture"];
        return r.data;
      });
    },
    createPatient() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let pathPatients = `${API_URL}api/patients/`;
      if (this.isGenericPatient) {
        axios$1.patch(`${API_URL}api/patients/${this.form1.id}/`, {
          "first_name": this.form1.first_name,
          "last_name": this.form1.last_name,
          "birth_date": this.form1.birth_date,
          "gender": this.form1.gender,
          "government_id": this.form1.government_id
        }, { headers }).then((response) => {
          this.dialog = false;
          this.genericAlert("success", " ", "Información guardada.");
          this.dialogFormPatient = false;
          this.getPatientDpi(response.data["government_id"]);
          localStorage.setItem("dpi", response.data["government_id"]);
          this.gid = response.data["government_id"];
          return response.data;
        }).catch((e) => {
          console.log(e, "errore");
          this.genericAlert("error", " ", "No se ha podido guardar la información del paciente");
          this.dialog = false;
          this.loading = false;
          return e;
        });
      } else {
        axios$1.post(pathPatients, {
          "cabin": this.cabinId,
          "entity": this.form1.entity,
          "first_name": this.form1.first_name,
          "last_name": this.form1.last_name,
          "birth_date": this.form1.birth_date,
          "gender": this.form1.gender,
          "government_id": this.gid,
          "phone_number": this.form1.phone_number,
          "country": "GT",
          "city": "GT",
          "address": "GT",
          "email": "na",
          "state": "GT",
          "alive": false,
          "active": true
        }, { headers }).then((r) => {
          this.dialog = false;
          this.patient = r.data.id;
          this.getPatientDpi(r.data["government_id"]);
          this.genericAlert("success", " ", "Paciente registrado");
          this.dialogFormPatient = false;
          this.createConsultation();
        }).catch((e) => {
          this.dialog = false;
          this.genericAlert("error", " ", "No se ha podido registrar al paciente");
          return e;
        });
      }
    },
    alertToSaveOrNotSaveScan(title, saveScan) {
      let timerInterval;
      this.$swal({
        title,
        timer: 5e3,
        timerProgressBar: true,
        didOpen: () => {
          this.$swal.showLoading();
        },
        willClose: () => {
          clearInterval(timerInterval);
        }
      }).then((result) => {
        if (saveScan) {
          this.genericAlert("success", " ", "Documento guardado");
        } else {
          this.deleteScan();
        }
        this.newScan = true;
        this.showScanResult = false;
        return result;
      });
    },
    deleteScan() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/upload/scans/${this.idScan}/`;
      axios$1.delete(path, { headers }).then((response) => {
        this.genericAlert("success", " ", "Documento eliminado");
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    changeVsPathGif(vs) {
      this.formvitalsign.weight = localStorage.getItem("weight");
      console.log(this.formvitalsign.weight, "weight");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/switch-gif/`;
      axios$1.post(path, {
        "vs": vs,
        "cabin": this.cabinId
      }, { headers }).then((response) => {
        return response;
      }).catch((e) => {
        return e;
      });
    },
    switchVsOrScan(type) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/switch-vs-scan/`;
      switch (true) {
        case this.showVsCard:
          this.showScanCard = false;
          break;
        case this.showScanCard:
          this.showVsCard = false;
          break;
      }
      axios$1.post(path, {
        "cabin": this.cabinId,
        "type": type
      }, { headers }).then((response) => {
        return response;
      }).catch((e) => {
        return e;
      });
    },
    requestSvFunction(cabin, vsName, typeRequest) {
      this.sendRequestText = "Enviando solicitud...";
      this.snackBarWait = true;
      this.dialogAskingVitalSigns = true;
      this.disabledButton = true;
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/send-vs-request-confirm/`;
      axios$1.post(path, {
        "cabin": cabin,
        "vs": vsName,
        "type-request": typeRequest
      }, { headers }).then((response) => {
        setTimeout(() => this.dialogAskingVitalSigns = false, 4e3);
        return response;
      }).catch((e) => {
        this.genericAlert("error", "Enviar", "¡Algo ha salido mal, intenta de nuevo!");
        this.snackBarWait = false;
        this.dialogAskingVitalSigns = false;
        setTimeout(() => this.disabledButton = false, 5e3);
        return e;
      });
    },
    sendVsDataCabin({ cabin, hasTwo: has2Vs, value1, value2, confirmRequest: typeRequest, key1, key2 }) {
      this.sendRequestText = "Enviando...";
      this.dialogAskingVitalSigns = true;
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/send-vs-request-confirm/`;
      var body;
      if (has2Vs) {
        body = {
          "cabin": cabin,
          "value-1": value1,
          "value-2": value2,
          "type-request": typeRequest,
          "key-1": key1,
          "key-2": key2,
          "hasTwoSv": has2Vs
        };
      } else {
        body = {
          "cabin": cabin,
          "value": value1,
          "type-request": typeRequest,
          "key": key1,
          "hasTwoSv": has2Vs
        };
      }
      axios$1.post(path, body, { headers }).then((response) => {
        setTimeout(() => this.dialogAskingVitalSigns = false, 2e3);
        this.genericAlert("success", "Enviar", "¡Se ha enviado la información a la cabina!");
        return response;
      }).catch((e) => {
        this.genericAlert("error", "Enviar", "¡Algo ha salido mal, intenta de nuevo!");
        this.snackBarWait = false;
        this.dialogAskingVitalSigns = false;
        return e;
      });
    },
    getDevices() {
      AgoraRTC.getCameras().then((device) => {
        this.camerasAvailables = device;
        this.videoT = this.camerasAvailables[0].deviceId;
      });
      AgoraRTC.getMicrophones().then((device) => {
        this.microphonesAvailables = device.filter((d) => d.deviceId != "default" && d.deviceId != "communications");
        this.audioT = this.microphonesAvailables[0].deviceId;
      });
    },
    forceRerender() {
      this.componentKey += 1;
    },
    async isVideoDevice(g) {
      await this.channelParameters.localVideoTrack.setDevice(g.deviceId);
      this.videoT = g.deviceId;
    },
    async isAudioDevice(g) {
      await this.channelParameters.localAudioTrack.setDevice(g.deviceId);
      this.audioT = g.deviceId;
    },
    async startCall() {
      this.remotePlayerContainer = document.createElement("div");
      this.localPlayerContainer = document.createElement("div");
      this.localPlayerContainer.id = this.options.uid;
      this.localPlayerContainer.style.height = "30%";
      this.localPlayerContainer.style.width = "30%";
      this.localPlayerContainer.style.position = "absolute";
      this.localPlayerContainer.style.top = "10px";
      this.localPlayerContainer.style.zIndex = "10";
      this.localPlayerContainer.style.left = "10px";
      this.localPlayerContainer.style.border = "2px #00b6ed solid";
      this.remotePlayerContainer.style.width = "100%";
      this.remotePlayerContainer.style.height = "100%";
      this.remotePlayerContainer.style.top = "0px";
      this.remotePlayerContainer.style.left = "0px";
      this.remotePlayerContainer.style.position = "absolute";
      this.remotePlayerContainer.style.border = "2px #00b6ed solid";
      agoraEngine.on("network-quality", (quality) => {
        try {
          this.downlinkNetworkQuality = quality.downlinkNetworkQuality;
        } catch (error) {
          console.error("Error al obtener la calidad de red LOCAL");
        }
      });
      agoraEngine.on("network-quality", () => {
        try {
          const remoteNetwork = agoraEngine.getRemoteNetworkQuality();
          const networkQuality = Object.values(remoteNetwork);
          this.downlinkNetworkQualityRemote = networkQuality[0].downlinkNetworkQuality;
        } catch (error) {
          console.error("Error al obtener la calidad de red REMOTA");
        }
      });
      agoraEngine.on("user-published", async (user, mediaType) => {
        await agoraEngine.subscribe(user, mediaType);
        if (mediaType == "video") {
          this.channelParameters.remoteVideoTrack = user.videoTrack;
          this.channelParameters.remoteAudioTrack = user.audioTrack;
          this.channelParameters.remoteUid = user.uid.toString();
          this.remotePlayerContainer.id = user.uid.toString();
          this.channelParameters.remoteUid = user.uid.toString();
          this.channelParameters.remoteVideoTrack.play(this.remotePlayerContainer);
        }
        if (mediaType == "audio") {
          this.channelParameters.remoteAudioTrack = user.audioTrack;
          this.channelParameters.remoteAudioTrack.play();
        }
        agoraEngine.on("user-unpublished", (user2) => {
          console.log(user2.uid + "has left the channel");
        });
      });
      AgoraRTC.enableLogUpload();
      AgoraRTC.setLogLevel(1);
      agoraEngine.enableDualStream();
      await agoraEngine.join(this.options.appId, this.options.channel, null, this.options.uid);
      this.channelParameters.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack(
        {
          "AEC": true,
          "AGC": true,
          "ANS": true,
          encoderConfig: "high_quality_stereo"
        }
      );
      try {
        this.channelParameters.localVideoTrack = await AgoraRTC.createCameraVideoTrack(
          {
            optimizationMode: "motion",
            encoderConfig: {
              width: 640,
              // Specify a value range and an ideal value
              height: { ideal: 360, min: 280, max: 480 },
              frameRate: 15,
              bitrateMin: 490,
              bitrateMax: 800
            }
          }
        );
      } catch (error) {
        let err = JSON.stringify(error);
        let errContent = JSON.parse(err);
        if (errContent["code"] == "NOT_READABLE") {
          this.cameraNotReadable = true;
        }
      }
      await agoraEngine.publish([this.channelParameters.localAudioTrack, this.channelParameters.localVideoTrack]);
      this.channelParameters.localVideoTrack.play(this.localPlayerContainer);
      this.channelParameters.localVideoTrack.setOptimizationMode("motion");
    },
    async leaveCall() {
      this.channelParameters.localAudioTrack.close();
      this.channelParameters.localVideoTrack.close();
      await agoraEngine.leave();
      this.removeVideoDiv(this.remotePlayerContainer.id);
      this.removeVideoDiv(this.localPlayerContainer.id);
    },
    createVideoTrack() {
      if (this.cameraNotReadable) {
        let timerInterval;
        this.$swal({
          icon: "info",
          title: "Reconectando",
          timer: 4e3,
          timerProgressBar: true,
          didOpen: () => {
            this.$swal.showLoading();
          },
          willClose: () => {
            clearInterval(timerInterval);
          }
        }).then((result) => {
          window.location.reload();
          return result;
        });
      }
    },
    removeVideoDiv(elementId) {
      let Div = document.getElementById(elementId);
      if (Div) {
        Div.remove();
      }
    },
    genericAlert(icon, title, text) {
      let timerInterval;
      this.$swal({
        icon,
        title,
        text,
        timer: 4e3,
        timerProgressBar: true,
        didOpen: () => {
          this.$swal.showLoading();
        },
        willClose: () => {
          clearInterval(timerInterval);
        }
      }).then((result) => {
        return result;
      });
    },
    //CallCenterDoctor
    isReload() {
      const navigation = window.performance.getEntriesByType("navigation");
      if (navigation) {
        this.navigationType = navigation[0].type;
        if (localStorage.getItem("keep-step") != null && this.navigationType === "reload" && localStorage.getItem("step") == 1) {
          this.step = 2;
          this.e7 = 1;
        } else if (this.e7 > 1 && this.navigationType === "reload" && localStorage.getItem("step") == 1) {
          this.step = 2;
          this.e7 = 1;
        } else if (localStorage.getItem("step") == 2) {
          this.step = 2;
          this.e7 = 2;
        }
      }
    },
    getPatientByDPI() {
      this.genericAlert("", "Cargando...", "Por favor, espere.");
    },
    reload() {
      this.dialogReload = true;
      setTimeout(() => this.dialogReload = false, 5e3);
      window.onload = function() {
        if (!window.location.hash) {
          window.location = window.location + "#loaded";
          window.location.reload();
        }
      };
    },
    async openCabin() {
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/doctor/open-cabin-end-consultation/${this.callId}/`;
      await axios$1.patch(
        path,
        {
          patient: this.patientId,
          consultation: consultaId,
          scheduled: /* @__PURE__ */ new Date(),
          start: null,
          ambassador: 13,
          doctor: 1,
          started: null,
          end: null
        },
        { headers }
      ).then((res) => {
        localStorage.setItem("videoBlocked", true);
        this.videoBlocked = JSON.parse(localStorage.getItem("videoBlocked")) === true;
        this.waitingCall = false;
        if (this.cardBlocked == false) {
          this.titleVideoEnded = "Consulta terminada";
          this.textVideoEnded = "";
        }
        this.videoBlocked = true;
        localStorage.removeItem("callStarted");
        this.callStartedAgora = false;
        this.noteMedicalButton = false;
        this.callStarted = false;
        localStorage.removeItem("waitCall");
        localStorage.removeItem("cardBlocked");
        this.cardBlocked = false;
        this.disabledButtonEndCall = false;
        localStorage.removeItem("esfigmoAvailable");
        localStorage.removeItem("estetoAvailable");
        localStorage.removeItem("call_id");
        localStorage.removeItem("cabin_t_id");
        localStorage.removeItem("cabin_location");
        localStorage.removeItem("call_timestamp");
        this.genericAlert("success", "Abrir cabina", "¡Se ha abierto la cabina!");
        return res.data;
      }).catch((err) => {
        return err;
      });
    },
    async activateReceipt() {
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/doctor/activate-receipt/${this.callId}/`;
      await axios$1.patch(
        path,
        {
          patient: this.patientId,
          consultation: consultaId,
          scheduled: /* @__PURE__ */ new Date(),
          start: null,
          ambassador: 13,
          doctor: 1,
          started: null,
          end: null
        },
        { headers }
      ).then((res) => {
        return res;
      }).catch((err) => {
        return err;
      });
    },
    async getScans() {
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      var path = `${API_URL}api/consultations/consultation_scans/${consultaId}/`;
      axios$1.get(path, { headers }).then((response) => {
        this.listScans = response.data["consultation_scans"];
      }).catch((e) => {
        return e;
      });
    },
    async emergencyDoorActivate() {
      this.dialogDoor = true;
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/emergency-door/${this.cabinId}/`;
      axios$1.patch(
        path,
        {
          nit: "CF"
        },
        { headers }
      ).then((response) => {
        this.emergencyDoor = !this.emergencyDoor;
        this.dialogDoor = false;
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    async emergencyDoorDeactivate() {
      this.dialogDoor = true;
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/emergency-door-deactivate/${this.cabinId}/`;
      axios$1.patch(
        path,
        {
          nit: "CF"
        },
        { headers }
      ).then((response) => {
        this.emergencyDoor = !this.emergencyDoor;
        this.dialogDoor = false;
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    async pushCall() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/push-call/`;
      axios$1.post(
        path,
        {
          "cabin": this.cabinId
        },
        { headers }
      ).then((response) => {
        this.genericAlert("success", "Enviar", "¡Se ha enviado la solicitud a la cabina!");
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    async settingVolume(action) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/pos/setting-volume/`;
      axios$1.post(
        path,
        {
          "cabin": this.cabinId,
          "action": action
        },
        { headers }
      ).then((response) => {
        switch (action) {
          case "call-min":
            this.disabledButtonVolMin = true;
            break;
          case "call-unmute":
            this.volumeMute = !this.volumeMute;
            break;
          case "call-mute":
            this.volumeMute = !this.volumeMute;
            break;
          case "call-up":
            this.disabledButtonVolUp = true;
            break;
          case "stheto-min":
            this.sthetoMinVol = true;
            break;
          case "stheto-up":
            this.sthetoUpVol = true;
            break;
          case "stheto-save":
            this.sthetoSaveVol = true;
            break;
        }
        return response.data;
      }).catch((e) => {
        this.disabledButtonVolMin = false;
        return e;
      });
    },
    async recordStetho() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/pos/record-stetho/${this.cabinId}/`;
      axios$1.patch(
        path,
        { nit: "CF" },
        { headers }
      ).then((response) => {
        this.record = !this.record;
        this.recordStethoText = this.record ? "Grabando..." : "Grabar";
        this.recordStethoIcon = this.record ? "mdi-stop" : "mdi-play";
        this.genericAlert("success", "Estetoscopio", "¡Se ha enviado la solicitud!");
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    async switchMic() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/pos/switch-mic/${this.cabinId}/`;
      axios$1.patch(
        path,
        {
          nit: "CF"
        },
        { headers }
      ).then((response) => {
        this.estetoR = !this.estetoR;
        this.stethoText = this.estetoR ? "Desactivar esteto" : "Activar esteto";
        this.genericAlert("success", "Micrófono", "¡Se ha enviado la solicitud!");
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    start() {
      if (this.running)
        return;
      if (this.timeBegan === null) {
        this.timeBegan = /* @__PURE__ */ new Date();
      }
      if (this.timeStopped !== null) {
        this.stoppedDuration += /* @__PURE__ */ new Date() - this.timeStopped;
      }
      this.started = setInterval(this.clockRunning, 10);
      this.running = true;
      this.isStop = true;
    },
    clockRunning() {
      var currentTime = /* @__PURE__ */ new Date(), timeElapsed = new Date(
        currentTime - this.timeBegan - this.stoppedDuration
      ), min2 = timeElapsed.getUTCMinutes(), sec = timeElapsed.getUTCSeconds();
      this.time = this.zeroPrefix(min2, 2) + ":" + this.zeroPrefix(sec, 2);
    },
    zeroPrefix(num, digit) {
      var zero = "";
      for (var i2 = 0; i2 < digit; i2++) {
        zero += "0";
      }
      return (zero + num).slice(-digit);
    },
    patchCall() {
      this.patchTimerCall();
      setInterval(this.patchTimerCall, 1e3 * 61);
    },
    patchTimerCall(s) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/pos/call-timer/${this.callId}/`;
      var time_to_parse = this.time.substring(0, 2);
      var timer_parsed = parseInt(time_to_parse);
      axios$1.patch(
        path,
        {
          duration: this.time,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          status: s,
          cabin: this.cabinId,
          minutes: timer_parsed,
          assistant: this.idAssistnt
        },
        { headers }
      ).then((response) => {
        return response.data;
      }).catch((error) => {
        return error;
      });
    },
    getCall() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/pos/call/${this.callId}/`;
      axios$1.patch(path, { "status": 1 }, { headers }).then((response) => {
        return response.data;
      });
    },
    loadInformation() {
      try {
        const ws = new WebSocket("ws://3.143.233.51:3000/");
        ws.onmessage = ({ data: data2 }) => {
          this.message = data2;
          let content = JSON.parse(this.message);
          if ("message" in content && "channel" in content) {
            if (!(content.channel === this.cabinChannel || content.channel === this.channel))
              return;
            content = content.message;
          }
          switch (content["call"]) {
            case "start-call":
              this.getCall();
              this.startCall();
              if (this.videoBlocked) {
                this.videoBlocked = false;
              }
              localStorage.setItem("callStarted", true);
              localStorage.setItem("waitCall", false);
              localStorage.setItem("cardBlocked", true);
              this.callStarted = JSON.parse(localStorage.getItem("callStarted")) === true;
              this.waitingCall = JSON.parse(localStorage.getItem("waitCall")) === true;
              this.cardBlocked = JSON.parse(localStorage.getItem("cardBlocked")) === true;
              this.createOrSearchPatient();
              break;
          }
          switch (content["vs"]) {
            case "Weight":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.genericAlert("error", "Peso", "¡Algo ha salido mal, intenta de nuevo!");
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Peso";
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("weight", content["valor"]);
                    this.formvitalsign.weight = localStorage.getItem("weight");
                    if (typeof this.formvitalsign.height === "string") {
                      let conversion = (this.formvitalsign.weight / 2.20462262).toFixed(2);
                      this.imc = (conversion / Math.pow(this.formvitalsign.height, 2)).toFixed(2);
                      localStorage.setItem("imc", this.imc);
                      this.imc = localStorage.getItem("imc");
                    }
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "bpm":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    break;
                  case "Mal":
                    break;
                  case "Obj":
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("heart_rate", content["valor"]);
                    this.formvitalsign.heart_rate = localStorage.getItem("heart_rate");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "SpO2":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Oximetría", "¡Algo ha salido mal, intenta de nuevo! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Oximetría", "¡Algo ha salido mal, intenta de nuevo! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Oximetría", "¡Algo ha salido mal, ya no te quedan intentos! Por favor, continúa.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        this.attempts = 3;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.snackBarWait = false;
                    this.attempts = 3;
                    this.vitalSignDescription = "Frecuencia cardiaca y Oxígeno";
                    localStorage.setItem("oxygen", content["valor"]);
                    this.formvitalsign.oxygen = localStorage.getItem("oxygen");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "tmp":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Temperatura", "¡Algo ha salido mal, intenta de nuevo! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Temperatura", "¡Algo ha salido mal, intenta de nuevo! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Temperatura", "¡Algo ha salido mal, ya no te quedan intentos! Por favor, continúa.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        this.attempts = 3;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Temperatura";
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("temperature", content["valor"]);
                    this.formvitalsign.temperature = localStorage.getItem("temperature");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "sis":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "b":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    break;
                  default:
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("systolic_pressure", content["valor"]);
                    this.formvitalsign.systolic_pressure = localStorage.getItem("systolic_pressure");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "dias":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "b":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Presión arterial", "¡Brazalete mal colocado, asegúrate de que esté debidamente ajustado! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Presión arterial", "¡Brazalete mal colocado, asegúrate de que esté debidamente ajustado! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Presión arterial", "¡Brazalete mal colocado, asegúrate de que esté debidamente ajustado! Por favor, continúa.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        this.attempts = 3;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Presión Sistólica y Diastólica";
                    localStorage.setItem("diastolic_pressure", content["valor"]);
                    this.formvitalsign.diastolic_pressure = localStorage.getItem("diastolic_pressure");
                    this.snackBarWait = false;
                    this.attempts = 3;
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "height":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Altura", "¡Algo ha salido mal, intenta de nuevo! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Altura", "¡Algo ha salido mal, intenta de nuevo! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Altura", "¡Algo ha salido mal, ya no te quedan intentos! Por favor, continúa");
                        this.snackBarWait = false;
                        this.attempts = 3;
                        setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Altura";
                    if (content["valor"] > 100) {
                      content["valor"] = content["valor"] / 100;
                      this.formvitalsign.height = content["valor"];
                      this.formvitalsign.height = this.formvitalsign.height.toFixed(2).toString();
                      this.parsedSVHeight = content["valor"].toFixed(2) + " m";
                      localStorage.setItem("height", content["valor"].toFixed(2));
                      this.formvitalsign.height = localStorage.getItem("height");
                      this.snackBarWait = false;
                      this.attempts = 3;
                      if (typeof this.formvitalsign.weight === "string") {
                        let conversion = (this.formvitalsign.weight / 2.20462262).toFixed(2);
                        this.imc = (conversion / Math.pow(this.formvitalsign.height, 2)).toFixed(2);
                        localStorage.setItem("imc", this.imc);
                        this.imc = localStorage.getItem("imc");
                      }
                      setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    } else {
                      this.formvitalsign.height = content["valor"];
                      localStorage.setItem("height", content["valor"]);
                      this.formvitalsign.height = localStorage.getItem("height");
                      this.parsedSVHeight = content["valor"];
                      this.snackBarWait = false;
                      this.attempts = 3;
                      if (typeof this.formvitalsign.weight === "string") {
                        let conversion = (this.formvitalsign.weight / 2.20462262).toFixed(2);
                        this.imc = (conversion / Math.pow(this.formvitalsign.height, 2)).toFixed(2);
                        localStorage.setItem("imc", this.imc);
                        this.imc = localStorage.getItem("imc");
                      }
                      setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    }
                    break;
                }
              }
              break;
            default:
              break;
          }
          switch (content["type"]) {
            case "dpi":
              this.gid = content["dpi_info"];
              this.buttonsBlocked = false;
              localStorage.setItem("dpi", this.gid);
              this.createOrSearchPatient();
              this.form1.government_id = this.gid;
              break;
            case "alarm":
              if (content["outOfservice-ev"] == "on") {
                let timerInterval;
                this.$swal({
                  icon: "warning",
                  title: "Cabina",
                  text: "La cabina experimentó un error en el sistema. La llamada no conectará y se finalizará automáticamente.",
                  timer: 15e3,
                  timerProgressBar: true,
                  didOpen: () => {
                    this.$swal.showLoading();
                  },
                  willClose: () => {
                    clearInterval(timerInterval);
                  }
                }).then((result) => {
                  this.openCabin();
                  this.activateReceipt();
                  this.finishCallPatient();
                  this.changeStatusOfCall();
                  return result;
                });
              }
              if ("volEst" in content) {
                this.snackbarVar = true;
                this.textVol = content["volEst"];
                this.sthetoMinVol = false;
                this.sthetoUpVol = false;
                this.sthetoSaveVol = false;
              }
              switch (content["esteto"]) {
                case "EstetoAvailable":
                  this.sthetoAvailable = true;
                  localStorage.setItem("estetoAvailable", true);
                  this.sthetoAvailable = JSON.parse(localStorage.getItem("estetoAvailable")) == true;
                  break;
                case "START":
                  this.genericAlert("success", "Estetoscopio", "¡Se ha iniciado la grabación!");
                  break;
                case "done":
                  this.genericAlert("success", "Estetoscopio", "¡Audio grabado correctamente!");
                  this.textSteto = "Grabar";
                  this.recordStethoText = "Grabar";
                  this.recordStethoIcon = "mdi-play";
                  this.record = !this.record;
                  break;
                case "error":
                  this.genericAlert("error", "Estetoscopio", "¡No se ha podido grabar el audio!");
                  this.textSteto = "Grabar";
                  this.recordStethoText = "Grabar";
                  this.recordStethoIcon = "mdi-play";
                  this.record = !this.record;
                  break;
                default:
                  break;
              }
              switch (content["esfigmo"]) {
                case "EsfigmoAvailable":
                  this.esfigmoAvailable = true;
                  localStorage.setItem("esfigmoAvailable", true);
                  this.esfigmoAvailable = JSON.parse(localStorage.getItem("esfigmoAvailable")) == true;
                  break;
                default:
                  break;
              }
              switch (content["mic"]) {
                case "esteto":
                  this.genericAlert("success", "Micrófono", "¡Se ha cambiado al estetoscopio!");
                  break;
                case "cámara":
                  this.genericAlert("success", "Micrófono", "¡Se ha cambiado al audio de cabina!");
                  break;
                case "error":
                  this.genericAlert("error", "Micrófono", "¡No se ha podido cambiar el micrófono!");
                  this.estetoR = !this.estetoR;
                  break;
                default:
                  break;
              }
              switch (content["door"]) {
                case "open":
                  this.statusDoor = true;
                  this.doorOpened = true;
                  this.doorClosed = false;
                  break;
                case "close":
                  this.statusDoor = true;
                  this.doorOpened = false;
                  this.doorClosed = true;
                  break;
                default:
                  break;
              }
              switch (content["scan"]) {
                case "done":
                  this.scanDone = true;
                  this.scanAg = true;
                  this.turnOnScanVar = false;
                  this.newScan = false;
                  this.buttonsScan = true;
                  this.waitingScanVar = false;
                  break;
                case "error":
                  this.scanError = true;
                  this.turnOnScanVar = false;
                  this.newScan = false;
                  this.buttonsScan = true;
                  if (this.nscanAg) {
                    this.newScan = true;
                  } else {
                    this.scanAg = true;
                  }
                  this.waitingScanVar = false;
                  break;
                case "saved":
                  this.scanDone = false;
                  this.waitingScanVar = false;
                  this.buttonsScan = true;
                  this.showScanResult = true;
                  this.scanAg = false;
                  break;
                case "413":
                  this.scanSize = content["scan_size"];
                  this.genericAlert("error", "Escaner", `El archivo ha superado el límite de tamaño ${this.scanSize} MB`);
                  this.waitingScanVar = false;
                  this.buttonsScan = true;
                  this.scanAg = false;
                  this.newScan = true;
                  this.showScanResult = false;
                  break;
                case "400":
                case "http":
                  this.genericAlert("error", "Escaner", "Error en los servidores");
                  this.waitingScanVar = false;
                  this.newScan = true;
                  this.showScanResult = false;
                  break;
                default:
                  break;
              }
              switch (content["scanOn"]) {
                case "done":
                  this.scanOnDone = true;
                  this.turnOnScanVar = false;
                  this.newScan = true;
                  this.turningOnScan = false;
                  break;
                case "error":
                  this.turnOnScanVar = true;
                  break;
                default:
                  break;
              }
              if (content["vol"]) {
                this.snackbarVar = true;
                this.textVol = content["vol"];
                this.disabledButtonVolMin = false;
                this.disabledButtonVolUp = false;
              }
              break;
            default:
              break;
          }
        };
      } catch (error) {
        return error;
      }
    },
    loadInformationSocket() {
      try {
        socket$1.on("message", (data2) => {
          let content = data2;
          if ("message" in content && "senderId" in content) {
            if (data2.senderId !== socket$1.id)
              return;
            content = JSON.parse(content["message"]);
          }
          switch (content["call"]) {
            case "start-call":
              this.getCall();
              this.startCall();
              if (this.videoBlocked) {
                this.videoBlocked = false;
              }
              localStorage.setItem("callStarted", true);
              localStorage.setItem("waitCall", false);
              localStorage.setItem("cardBlocked", true);
              this.callStarted = JSON.parse(localStorage.getItem("callStarted")) === true;
              this.waitingCall = JSON.parse(localStorage.getItem("waitCall")) === true;
              this.cardBlocked = JSON.parse(localStorage.getItem("cardBlocked")) === true;
              this.createOrSearchPatient();
              break;
          }
          switch (content["vs"]) {
            case "Weight":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.genericAlert("error", "Peso", "¡Algo ha salido mal, intenta de nuevo!");
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Peso";
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("weight", content["valor"]);
                    this.formvitalsign.weight = localStorage.getItem("weight");
                    if (typeof this.formvitalsign.height === "string") {
                      let conversion = (this.formvitalsign.weight / 2.20462262).toFixed(2);
                      this.imc = (conversion / Math.pow(this.formvitalsign.height, 2)).toFixed(2);
                      localStorage.setItem("imc", this.imc);
                      this.imc = localStorage.getItem("imc");
                    }
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "bpm":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    break;
                  case "Mal":
                    break;
                  case "Obj":
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("heart_rate", content["valor"]);
                    this.formvitalsign.heart_rate = localStorage.getItem("heart_rate");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "SpO2":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Oximetría", "¡Algo ha salido mal, intenta de nuevo! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Oximetría", "¡Algo ha salido mal, intenta de nuevo! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Oximetría", "¡Algo ha salido mal, ya no te quedan intentos! Por favor, continúa.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        this.attempts = 3;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.snackBarWait = false;
                    this.attempts = 3;
                    this.vitalSignDescription = "Frecuencia cardiaca y Oxígeno";
                    localStorage.setItem("oxygen", content["valor"]);
                    this.formvitalsign.oxygen = localStorage.getItem("oxygen");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "tmp":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Temperatura", "¡Algo ha salido mal, intenta de nuevo! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Temperatura", "¡Algo ha salido mal, intenta de nuevo! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Temperatura", "¡Algo ha salido mal, ya no te quedan intentos! Por favor, continúa.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        this.attempts = 3;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Temperatura";
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("temperature", content["valor"]);
                    this.formvitalsign.temperature = localStorage.getItem("temperature");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "sis":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "b":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    break;
                  default:
                    this.snackBarWait = false;
                    this.attempts = 3;
                    localStorage.setItem("systolic_pressure", content["valor"]);
                    this.formvitalsign.systolic_pressure = localStorage.getItem("systolic_pressure");
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "dias":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "b":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Presión arterial", "¡Brazalete mal colocado, asegúrate de que esté debidamente ajustado! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Presión arterial", "¡Brazalete mal colocado, asegúrate de que esté debidamente ajustado! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Presión arterial", "¡Brazalete mal colocado, asegúrate de que esté debidamente ajustado! Por favor, continúa.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        this.attempts = 3;
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Presión Sistólica y Diastólica";
                    localStorage.setItem("diastolic_pressure", content["valor"]);
                    this.formvitalsign.diastolic_pressure = localStorage.getItem("diastolic_pressure");
                    this.snackBarWait = false;
                    this.attempts = 3;
                    setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    break;
                }
              }
              break;
            case "height":
              if (content["valor"] != "") {
                switch (content["valor"]) {
                  case "error":
                    this.disabledButton = false;
                    this.snackBarWait = false;
                    this.attempts -= 1;
                    switch (this.attempts) {
                      case 2:
                        this.genericAlert("error", "Altura", "¡Algo ha salido mal, intenta de nuevo! Te quedan 2 intentos.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 1:
                        this.genericAlert("error", "Altura", "¡Algo ha salido mal, intenta de nuevo! Te queda 1 intento.");
                        this.disabledButton = false;
                        this.snackBarWait = false;
                        break;
                      case 0:
                        this.genericAlert("error", "Altura", "¡Algo ha salido mal, ya no te quedan intentos! Por favor, continúa");
                        this.snackBarWait = false;
                        this.attempts = 3;
                        setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                        break;
                      default:
                        break;
                    }
                    break;
                  default:
                    this.dialogLoadingVitalSign = true;
                    this.vitalSignDescription = "Altura";
                    if (content["valor"] > 100) {
                      content["valor"] = content["valor"] / 100;
                      this.formvitalsign.height = content["valor"];
                      this.formvitalsign.height = this.formvitalsign.height.toFixed(2).toString();
                      this.parsedSVHeight = content["valor"].toFixed(2) + " m";
                      localStorage.setItem("height", content["valor"].toFixed(2));
                      this.formvitalsign.height = localStorage.getItem("height");
                      this.snackBarWait = false;
                      this.attempts = 3;
                      if (typeof this.formvitalsign.weight === "string") {
                        let conversion = (this.formvitalsign.weight / 2.20462262).toFixed(2);
                        this.imc = (conversion / Math.pow(this.formvitalsign.height, 2)).toFixed(2);
                        localStorage.setItem("imc", this.imc);
                        this.imc = localStorage.getItem("imc");
                      }
                      setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    } else {
                      this.formvitalsign.height = content["valor"];
                      localStorage.setItem("height", content["valor"]);
                      this.formvitalsign.height = localStorage.getItem("height");
                      this.parsedSVHeight = content["valor"];
                      this.snackBarWait = false;
                      this.attempts = 3;
                      if (typeof this.formvitalsign.weight === "string") {
                        let conversion = (this.formvitalsign.weight / 2.20462262).toFixed(2);
                        this.imc = (conversion / Math.pow(this.formvitalsign.height, 2)).toFixed(2);
                        localStorage.setItem("imc", this.imc);
                        this.imc = localStorage.getItem("imc");
                      }
                      setTimeout(() => (this.dialogLoadingVitalSign = false, this.disabledButton = false), 4e3);
                    }
                    break;
                }
              }
              break;
            default:
              break;
          }
          switch (content["type"]) {
            case "dpi":
              this.gid = content["dpi_info"];
              localStorage.setItem("dpi", this.gid);
              this.createOrSearchPatient();
              break;
            case "alarm":
              if (content["outOfservice-ev"] == "on") {
                let timerInterval;
                this.$swal({
                  icon: "warning",
                  title: "Cabina",
                  text: "La cabina experimentó un error en el sistema. La llamada no conectará y se finalizará automáticamente.",
                  timer: 15e3,
                  timerProgressBar: true,
                  didOpen: () => {
                    this.$swal.showLoading();
                  },
                  willClose: () => {
                    clearInterval(timerInterval);
                  }
                }).then((result) => {
                  this.openCabin();
                  this.activateReceipt();
                  this.finishCallPatient();
                  this.changeStatusOfCall();
                  return result;
                });
              }
              if ("volEst" in content) {
                this.snackbarVar = true;
                this.textVol = content["volEst"];
                this.sthetoMinVol = false;
                this.sthetoUpVol = false;
                this.sthetoSaveVol = false;
              }
              switch (content["esteto"]) {
                case "EstetoAvailable":
                  this.sthetoAvailable = true;
                  localStorage.setItem("estetoAvailable", true);
                  this.sthetoAvailable = JSON.parse(localStorage.getItem("estetoAvailable")) == true;
                  break;
                case "START":
                  this.genericAlert("success", "Estetoscopio", "¡Se ha iniciado la grabación!");
                  break;
                case "done":
                  this.genericAlert("success", "Estetoscopio", "¡Audio grabado correctamente!");
                  this.textSteto = "Grabar";
                  this.recordStethoText = "Grabar";
                  this.recordStethoIcon = "mdi-play";
                  this.record = !this.record;
                  break;
                case "error":
                  this.genericAlert("error", "Estetoscopio", "¡No se ha podido grabar el audio!");
                  this.textSteto = "Grabar";
                  this.recordStethoText = "Grabar";
                  this.recordStethoIcon = "mdi-play";
                  this.record = !this.record;
                  break;
                default:
                  break;
              }
              switch (content["esfigmo"]) {
                case "EsfigmoAvailable":
                  this.esfigmoAvailable = true;
                  localStorage.setItem("esfigmoAvailable", true);
                  this.esfigmoAvailable = JSON.parse(localStorage.getItem("esfigmoAvailable")) == true;
                  break;
                default:
                  break;
              }
              switch (content["mic"]) {
                case "esteto":
                  this.genericAlert("success", "Micrófono", "¡Se ha cambiado al estetoscopio!");
                  break;
                case "cámara":
                  this.genericAlert("success", "Micrófono", "¡Se ha cambiado al audio de cabina!");
                  break;
                case "error":
                  this.genericAlert("error", "Micrófono", "¡No se ha podido cambiar el micrófono!");
                  this.estetoR = !this.estetoR;
                  break;
                default:
                  break;
              }
              switch (content["door"]) {
                case "open":
                  this.statusDoor = true;
                  this.doorOpened = true;
                  this.doorClosed = false;
                  break;
                case "close":
                  this.statusDoor = true;
                  this.doorOpened = false;
                  this.doorClosed = true;
                  break;
                default:
                  break;
              }
              switch (content["scan"]) {
                case "done":
                  this.scanDone = true;
                  this.scanAg = true;
                  this.turnOnScanVar = false;
                  this.newScan = false;
                  this.buttonsScan = true;
                  this.waitingScanVar = false;
                  break;
                case "error":
                  this.scanError = true;
                  this.turnOnScanVar = false;
                  this.newScan = false;
                  this.buttonsScan = true;
                  if (this.nscanAg) {
                    this.newScan = true;
                  } else {
                    this.scanAg = true;
                  }
                  this.waitingScanVar = false;
                  break;
                case "saved":
                  this.scanDone = false;
                  this.waitingScanVar = false;
                  this.buttonsScan = true;
                  this.showScanResult = true;
                  this.scanAg = false;
                  break;
                case "413":
                  this.scanSize = content["scan_size"];
                  this.genericAlert("error", "Escaner", `El archivo ha superado el límite de tamaño ${this.scanSize} MB`);
                  this.waitingScanVar = false;
                  this.buttonsScan = true;
                  this.scanAg = false;
                  this.newScan = true;
                  this.showScanResult = false;
                  break;
                case "400":
                case "http":
                  this.genericAlert("error", "Escaner", "Error en los servidores");
                  this.waitingScanVar = false;
                  this.newScan = true;
                  this.showScanResult = false;
                  break;
                default:
                  break;
              }
              switch (content["scanOn"]) {
                case "done":
                  this.scanOnDone = true;
                  this.turnOnScanVar = false;
                  this.newScan = true;
                  this.turningOnScan = false;
                  break;
                case "error":
                  this.turnOnScanVar = true;
                  break;
                default:
                  break;
              }
              if (content["vol"]) {
                this.snackbarVar = true;
                this.textVol = content["vol"];
                this.disabledButtonVolMin = false;
                this.disabledButtonVolUp = false;
              }
              break;
            default:
              break;
          }
        });
      } catch (error) {
        return error;
      }
    },
    createConsultation() {
      this.getConsultations();
      this.consultation_form.patient = localStorage.getItem("id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/consultations/`;
      axios$1.post(path, {
        name: hooks(/* @__PURE__ */ new Date()).format("YYYY/MM/DD h:mm a"),
        active: true,
        patient: this.patient,
        cabin: this.cabinId
      }, { headers }).then((response) => {
        axios$1.patch(`${API_URL}api/cabin/pos/call-timer/${this.callId}/`, {
          "consultation": response.data.id
        }, { headers }).then((responseCall) => {
          return responseCall.data;
        }).catch((error) => {
          return error;
        });
        localStorage.setItem("consultation_Id", response.data.id);
        localStorage.setItem("consul_name", response.data.name);
        localStorage.setItem("step", 1);
        var consultation = localStorage.getItem("consultation_Id");
        this.form.consultation = consultation;
        this.consultationId = localStorage.getItem("consultation_Id");
        this.consultationName = response.data.name, this.showSnackbar();
        setTimeout(
          () => this.redirectConsult(response.data.id, response.data.name),
          1e3
        );
        setTimeout(() => this.snackbar = false, 3e3);
        this.overlay = !this.overlay;
        this.dialog21 = false;
        this.e7 = 1;
        localStorage.setItem("keep-step", "keep-s");
        this.sendConsultId(response.data.id);
        return response.data;
      }).catch((err) => {
        return err;
      });
    },
    sendConsultId(consultId) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/upload/send-consult-id/`;
      axios$1.post(path, {
        "cabin": this.cabinId,
        "consult_id": consultId
      }, { headers }).then((response) => {
        return response.data;
      }).catch((e) => {
        return e;
      });
    },
    async getConsultation() {
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/consultations/consultations/${consultaId}/`;
      await axios$1.get(path, { headers }).then((response) => {
        this.form.consultation = response.data.id;
        this.formvitalsign.consultation = response.data.id;
        this.appointmentForm.consultation = response.data.id;
        this.appointmentForm.patient = response.data.patient;
      }).catch((error) => {
        return error;
      });
    },
    showSnackbar2() {
      this.snackbar2 = true;
    },
    async changeStatus() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/staff/assistant/${this.idAssistnt}/`;
      await axios$1.patch(path, { "is_busy": false, "online": true }, { headers }).then((res) => {
        window.location.reload();
        return res.data;
      }).catch((err) => {
        return err;
      });
    },
    async changeStatusOfCall() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path2 = `${API_URL}api/cabin/pos/call-timer/${this.callId}/`;
      var time_to_parse = this.time.substring(0, 2);
      var timer_parsed = parseInt(time_to_parse);
      await axios$1.patch(
        path2,
        {
          duration: this.time,
          timestamp: Date(),
          status: 2,
          cabin: this.cabinId,
          minutes: timer_parsed,
          assistant: this.idAssistnt
        },
        { headers }
      ).then((response) => {
        localStorage.removeItem("callStartedAgora");
        localStorage.removeItem("activateCallInfo");
        localStorage.removeItem("callStarted");
        localStorage.removeItem("weight");
        localStorage.removeItem("oxygen");
        localStorage.removeItem("heart_rate");
        localStorage.removeItem("temperature");
        localStorage.removeItem("systolic_pressure");
        localStorage.removeItem("diastolic_pressure");
        localStorage.removeItem("height");
        localStorage.removeItem("imc");
        this.endingCall = true;
        this.isSeguimiento = null;
        this.proflePicP = "";
        this.nameP = "";
        this.apellidoP = "";
        this.genderP = null;
        this.ageP = "";
        this.changeStatus();
        this.$router.push(
          `/dashboard/assistant-${this.idAssistnt}/ent-${this.form1.entity}`
        );
        return response.data;
      }).catch((error) => {
        return error;
      });
    },
    async turnOnScan() {
      let consultaId = localStorage.getItem("consultation_Id");
      this.turnOnScanText = "Encendiendo escaner...";
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/consultations/turn-on-scan/${consultaId}/`;
      if (this.turningOnScan == false) {
        await axios$1.patch(
          path,
          {
            consultation: consultaId
          },
          { headers }
        ).then((response) => {
          if (response.status == 200) {
            this.genericAlert("success", "Escanner", "¡Se ha enviado la solicitud!");
          }
          this.turningOnScan = true;
        }).catch((error) => {
          this.genericAlert("error", "Escanner", "¡No se ha podido enviar la solicitud!");
          return error;
        });
      }
    },
    scan() {
      this.waitingMessage = "Escaneando...";
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/upload/scans/`;
      axios$1.post(
        path,
        {
          image: null,
          created_at: (/* @__PURE__ */ new Date()).toISOString().concat("T00:00:00Z"),
          updated_at: (/* @__PURE__ */ new Date()).toISOString().concat("T00:00:00Z"),
          consultation: consultaId
        },
        { headers }
      ).then((response) => {
        this.dialogValidate = false;
        this.idScan = response.data.id;
        this.newScan = false;
        this.waitingScanVar = true;
        this.turnOnScanVar = false;
        this.genericAlert("success", "Escanner", "¡Se envió la solicitud para escanear!");
        return response.data;
      }).catch((error) => {
        this.newScan = true;
        return error;
      });
    },
    scanAgain() {
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/upload/scans-again/${this.idScan}/`;
      axios$1.patch(
        path,
        {
          image: null,
          created_at: (/* @__PURE__ */ new Date()).toISOString().concat("T00:00:00Z"),
          updated_at: (/* @__PURE__ */ new Date()).toISOString().concat("T00:00:00Z"),
          consultation: consultaId
        },
        { headers }
      ).then((response) => {
        this.dialogValidate = false;
        this.buttonsScan = false;
        this.scanAg = false;
        this.waitingScanVar = true;
        this.nscanAg = false;
        this.genericAlert("success", "Escanner", "¡Se envió la solicitud para escanear!");
        return response.data;
      }).catch((error) => {
        return error;
      });
    },
    saveScan() {
      this.waitingMessage = "Guardando...";
      let consultaId = localStorage.getItem("consultation_Id");
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/upload/scans/${this.idScan}/`;
      axios$1.patch(
        path,
        {
          image: null,
          created_at: (/* @__PURE__ */ new Date()).toISOString().concat("T00:00:00Z"),
          updated_at: (/* @__PURE__ */ new Date()).toISOString().concat("T00:00:00Z"),
          consultation: consultaId
        },
        { headers }
      ).then((response) => {
        this.dialogValidate = false;
        this.waitingScanVar = true;
        this.buttonsScan = false;
        this.genericAlert("success", "Escanner", "¡Se envió la solicitud!");
        return response.data;
      }).catch((error) => {
        return error;
      });
    },
    showScan() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/upload/scans/${this.idScan}/`;
      axios$1.get(path, { headers }).then((response) => {
        this.imageScan = response.data.image;
        window.open(this.imageScan, "_blank");
        return response.data;
      }).catch((err) => {
        return err;
      });
    },
    async getConsultations() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/consultations/consultations/`;
      await axios$1.get(path, { headers }).then((response) => {
        this.consultations = response.data;
        this.filteredConsultations = this.consultations.filter(
          (consultation) => consultation.patient == this.patientId
        );
      }).catch((error) => {
        return error;
      });
    },
    showSnackbar() {
      this.snackbar = true;
    },
    getCabin() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/cabin/${this.cabinId}/`;
      axios$1.get(path, { headers }).then((response) => {
        this.form1.cabin = response.data.id;
        this.form1.entity = response.data.entity;
        this.cabinLocation = response.data.location;
        return response.data;
      }).catch((error) => {
        return error;
      });
    },
    async finishCallPatient() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/pos/finish-call/${this.cabinId}/`;
      let formData = new FormData();
      formData.append("receipt_nit", "CF");
      await axios$1.patch(path, formData, { headers }).then((response) => {
        localStorage.removeItem("step");
        localStorage.removeItem("e1");
        localStorage.removeItem("e6");
        localStorage.removeItem("e7");
        localStorage.removeItem("consultation_Id");
        localStorage.removeItem("dpi");
        return response.data;
      }).catch((error) => {
        return error;
      });
    },
    showLoading() {
      setTimeout(
        function() {
          this.dialog3 = !this.dialog3;
        }.bind(this),
        4e3
      );
      this.dialog3 = !this.dialog3;
    },
    async redirectConsult(id, name) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/consultations/tracing/${id}/`;
      await axios$1.patch(
        path,
        {
          name
        },
        { headers }
      ).then((res) => {
        this.consultationId = id;
        this.consultationName = name;
        localStorage.setItem("consultation_Id", id);
        localStorage.setItem("consul_name", name);
        this.dialog21 = false;
        this.step = 2;
        this.e7 = 1;
        localStorage.setItem("keep-step", "keep-s");
        localStorage.setItem("step", 1);
        return res.data;
      }).catch((err) => {
        return err;
      });
    }
  }
};
const _withScopeId$2 = (n) => (pushScopeId("data-v-507f268c"), n = n(), popScopeId(), n);
const _hoisted_1$3 = { class: "d-flex justify-end" };
const _hoisted_2$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-h6" }, " ¡Registro creado correctamente! ", -1));
const _hoisted_3$2 = { class: "d-flex justify-end" };
const _hoisted_4$2 = { class: "text-subtitle-1" };
const _hoisted_5$2 = { class: "text-subtitle-1" };
const _hoisted_6$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-subtitle-1" }, " Midiendo signo vital, espere... ", -1));
const _hoisted_7$1 = { class: "d-flex justify-end" };
const _hoisted_8$1 = { class: "text-subtitle-1" };
const _hoisted_9$1 = { class: "d-flex justify-end" };
const _hoisted_10$1 = { class: "text-subtitle-1" };
const _hoisted_11$1 = { class: "d-flex justify-end" };
const _hoisted_12$1 = { class: "text-subtitle-1" };
const _hoisted_13$1 = { class: "d-flex justify-end" };
const _hoisted_14$1 = { class: "text-subtitle-1" };
const _hoisted_15$1 = { class: "d-flex justify-end" };
const _hoisted_16$1 = { class: "text-subtitle-1" };
const _hoisted_17$1 = { class: "d-flex justify-end" };
const _hoisted_18$1 = { class: "text-subtitle-1" };
const _hoisted_19$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-grey font-weight-medium text-h5 text-center mb-5" }, "Cargando información", -1));
const _hoisted_20$1 = { class: "text-center" };
const _hoisted_21$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("h1", { class: "font-weight-black text-h5 pt-3 text-white" }, " Obteniendo signo vital... ", -1));
const _hoisted_22$1 = { class: "font-weight-black text-h6 mb-3 text-white" };
const _hoisted_23$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "wrapper meeting" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "ag-header" }, [
    /* @__PURE__ */ createBaseVNode("div", { class: "ag-header-lead" }, [
      /* @__PURE__ */ createBaseVNode("img", {
        class: "header-logo",
        src: _imports_0,
        alt: ""
      })
    ])
  ])
], -1));
const _hoisted_24$1 = { class: "" };
const _hoisted_25$1 = {
  class: "ag-main",
  id: "container"
};
const _hoisted_26$1 = { class: "ag-container" };
const _hoisted_27$1 = { key: 0 };
const _hoisted_28$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "mt-10" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    class: "header-logo",
    src: _imports_0,
    alt: ""
  })
], -1));
const _hoisted_29$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_30$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "mr-1 button text-white font-weight-bold" }, "Médico", -1));
const _hoisted_31$1 = { class: "mr-1 ml-2 button text-white font-weight-bold" };
const _hoisted_32$1 = { class: "ml-2" };
const _hoisted_33$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "ml-1" }, "Reconectar", -1));
const _hoisted_34$1 = { class: "ml-2" };
const _hoisted_35$1 = { class: "" };
const _hoisted_36$1 = { class: "mr-1" };
const _hoisted_37$1 = { class: "mr-1" };
const _hoisted_38 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "" }, "Salida de paciente", -1));
const _hoisted_39 = {
  id: "clock",
  class: "pa-3"
};
const _hoisted_40 = {
  class: "time mr-2",
  style: { "color": "black", "font-size": "20px" }
};
const _hoisted_41 = { class: "" };
const _hoisted_42 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "" }, "Audio/video", -1));
const _hoisted_43 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
  class: "text-h6",
  align: "start"
}, " Dispositivos de video ", -1));
const _hoisted_44 = { key: 0 };
const _hoisted_45 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6" }, " La cámara falló. ", -1));
const _hoisted_46 = {
  key: 1,
  class: "ml-15",
  id: "localVideoPlayerTest"
};
const _hoisted_47 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
  class: "text-h6",
  align: "start"
}, " Dispositivos de audio ", -1));
const _hoisted_48 = {
  ref: "audioPlayer",
  style: { "width": "inherit" },
  controls: ""
};
const _hoisted_49 = { class: "mr-1" };
const _hoisted_50 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "" }, "Emergencia", -1));
const _hoisted_51 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h5" }, "Documentos escaneados", -1));
const _hoisted_52 = {
  key: 0,
  class: "text-h5 pa-6"
};
const _hoisted_53 = {
  key: 1,
  class: "text-h5 pa-5"
};
const _hoisted_54 = ["href"];
const _hoisted_55 = { class: "ml-2" };
const _hoisted_56 = { class: "ml-8 text-h6 text-grey font-weight-bold" };
const _hoisted_57 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "text-subtitle-1" }, " Midiendo signo vital, espere... ", -1));
const _hoisted_58 = { class: "mt-6 mr-9" };
const _hoisted_59 = { class: "pt-5 mb-2 text-h6 text-black mt-2" };
const _hoisted_60 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h5" }, "Información del paciente", -1));
const _hoisted_61 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-subtitle-1" }, "Por favor llene la información del paciente en el siguiente formulario para poder continuar.", -1));
const _hoisted_62 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-medium text-grey text-h6" }, " Nombres: ", -1));
const _hoisted_63 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-medium text-grey text-h6" }, " Apellidos: ", -1));
const _hoisted_64 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-medium text-grey text-h6" }, " Fecha de nacimiento: ", -1));
const _hoisted_65 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-medium text-grey text-h6" }, " Género: ", -1));
const _hoisted_66 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-medium text-grey text-h6" }, " Número de Identificación", -1));
const _hoisted_67 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", { class: "font-weight-medium text-grey text-h6" }, " Teléfono: ", -1));
const _hoisted_68 = { class: "text-center" };
const _hoisted_69 = { class: "text-h5" };
const _hoisted_70 = { class: "text-grey" };
const _hoisted_71 = { class: "text-grey" };
const _hoisted_72 = { key: 0 };
const _hoisted_73 = {
  class: "mt-2",
  style: { "font-size": "15px" }
};
const _hoisted_74 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_75 = {
  key: 1,
  class: "text-center"
};
const _hoisted_76 = { key: 0 };
const _hoisted_77 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", null, [
  /* @__PURE__ */ createBaseVNode("img", {
    style: { "max-height": "35px", "max-width": "35px" },
    src: _imports_1
  })
], -1));
const _hoisted_78 = {
  class: "mt-4 text-black",
  style: { "font-size": "15px" }
};
const _hoisted_79 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_80 = { key: 1 };
const _hoisted_81 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "mt-2" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    style: { "max-height": "35px", "max-width": "35px" },
    src: _imports_2
  })
], -1));
const _hoisted_82 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
  class: "mt-4 text-black",
  style: { "font-size": "15px" }
}, " Escanear ", -1));
const _hoisted_83 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_84 = { key: 0 };
const _hoisted_85 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "mt-2" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    style: { "max-height": "35px", "max-width": "35px" },
    src: _imports_2
  })
], -1));
const _hoisted_86 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
  class: "mt-2 text-black",
  style: { "font-size": "15px" }
}, " Escanear ", -1));
const _hoisted_87 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_88 = { key: 0 };
const _hoisted_89 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "mt-2" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    style: { "max-height": "35px", "max-width": "35px" },
    src: _imports_3
  })
], -1));
const _hoisted_90 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
  class: "mt-2 text-black",
  style: { "font-size": "15px" }
}, " Vista previa ", -1));
const _hoisted_91 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_92 = { key: 2 };
const _hoisted_93 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "mt-2" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    style: { "max-height": "35px", "max-width": "35px" },
    src: _imports_4
  })
], -1));
const _hoisted_94 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", {
  class: "mt-2 text-black",
  style: { "font-size": "15px" }
}, " Ver documentos ", -1));
const _hoisted_95 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_96 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "mt-4 mb-4" }, "¿Desea guardar este documento?", -1));
const _hoisted_97 = { class: "d-flex flex-row" };
const _hoisted_98 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("img", {
  style: { "max-height": "30px", "max-width": "30px" },
  src: _imports_5
}, null, -1));
const _hoisted_99 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("img", {
  style: { "max-height": "40px", "max-width": "40px" },
  src: _imports_6
}, null, -1));
const _hoisted_100 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 text-grey" }, "Resultados", -1));
const _hoisted_101 = { class: "d-flex flex-row align-center" };
const _hoisted_102 = { key: 0 };
const _hoisted_103 = { class: "" };
const _hoisted_104 = { class: "" };
const _hoisted_105 = { class: "mr-1" };
const _hoisted_106 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 ml-2" }, " No se ha podido conectar con su cámara. ", -1));
const _hoisted_107 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("ul", null, [
  /* @__PURE__ */ createBaseVNode("li", { class: "text-subtitle-1" }, " Revise si hay otra aplicación usándola y ciérrela. "),
  /* @__PURE__ */ createBaseVNode("li", { class: "text-subtitle-1" }, " Seleccione su cámara en la sección AUDIO/VIDEO. ")
], -1));
const _hoisted_108 = { class: "text-center" };
const _hoisted_109 = { key: 0 };
const _hoisted_110 = { key: 1 };
const _hoisted_111 = { key: 2 };
const _hoisted_112 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_113 = { key: 3 };
const _hoisted_114 = { key: 0 };
const _hoisted_115 = { key: 1 };
const _hoisted_116 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6" }, "Volumen", -1));
const _hoisted_117 = { class: "font-weight-medium text-pink text-h6" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ProgressLinearComponent = resolveComponent("ProgressLinearComponent");
  const _component_TimeComponent = resolveComponent("TimeComponent");
  const _component_v_date_picker = resolveComponent("v-date-picker");
  const _component_DiasSysComponent = resolveComponent("DiasSysComponent");
  const _component_HeartRateComponent = resolveComponent("HeartRateComponent");
  const _component_WeightComponent = resolveComponent("WeightComponent");
  const _component_HeightComponent = resolveComponent("HeightComponent");
  const _component_TemperatureComponent = resolveComponent("TemperatureComponent");
  const _component_VitalSignsResults = resolveComponent("VitalSignsResults");
  const _component_PrescriptionsComponent = resolveComponent("PrescriptionsComponent");
  const _component_notifications = resolveComponent("notifications");
  return openBlock(), createBlock(VApp, { style: { "background-color": "#fafafa" } }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$3, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "success",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.snackbar2,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.snackbar2 = $event)
        }, {
          default: withCtx(() => [
            _hoisted_2$2,
            createVNode(VIcon, {
              dark: "",
              end: ""
            }, {
              default: withCtx(() => [
                createTextVNode("mdi-checkbox-marked-circle")
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createBaseVNode("div", _hoisted_3$2, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "warning",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.scanError,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.scanError = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_4$2, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡No se escaneó, intente de nuevo! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "success",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.scanOnDone,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.scanOnDone = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_5$2, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡Se ha encendido el scan! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "#00afb9",
          timeout: $data.timeout,
          bottom: $data.bottom,
          right: $data.right,
          class: "elevation-24",
          modelValue: $data.snackBarWait,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.snackBarWait = $event)
        }, {
          default: withCtx(() => [
            createVNode(VRow, { justify: "center" }, {
              default: withCtx(() => [
                _hoisted_6$1,
                createVNode(VProgressCircular, {
                  class: "ml-3",
                  width: 3,
                  size: "20",
                  color: "white",
                  indeterminate: ""
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["timeout", "bottom", "right", "modelValue"])
      ]),
      createBaseVNode("div", _hoisted_7$1, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "success",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.scanOnDone,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.scanOnDone = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_8$1, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡Se ha encendido el scan! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createBaseVNode("div", _hoisted_9$1, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "warning",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.scanOnError,
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.scanOnError = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_10$1, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡No se ha encendido el scan! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createBaseVNode("div", _hoisted_11$1, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "warning",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.volError,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.volError = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_12$1, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡Error, intente de nuevo! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createBaseVNode("div", _hoisted_13$1, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "primary",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.volDone,
          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.volDone = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_14$1, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡Se actualizó el volumen! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createBaseVNode("div", _hoisted_15$1, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "primary",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.muteDone,
          "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.muteDone = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_16$1, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡Mute activado! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createBaseVNode("div", _hoisted_17$1, [
        createVNode(VSnackbar, {
          "max-width": "100",
          color: "primary",
          location: "right bottom",
          class: "elevation-24",
          modelValue: $data.unmuteDone,
          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.unmuteDone = $event)
        }, {
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_18$1, [
              createVNode(VIcon, {
                dark: "",
                end: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(" mdi-alert-circle ")
                ]),
                _: 1
              }),
              createTextVNode(" ¡Mute desactivado! ")
            ])
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createVNode(VDialog, {
        modelValue: $data.dialogAskingVitalSigns,
        "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.dialogAskingVitalSigns = $event),
        scrim: false,
        persistent: "",
        width: "300"
      }, {
        default: withCtx(() => [
          createVNode(VCard, {
            color: "#00afb9",
            dark: ""
          }, {
            default: withCtx(() => [
              createVNode(VCardText, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($data.sendRequestText) + " ", 1),
                  createVNode(_component_ProgressLinearComponent)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]),
      createVNode(VDialog, {
        modelValue: $data.dialog3,
        "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $data.dialog3 = $event),
        "max-width": "500px"
      }, {
        default: withCtx(() => [
          createVNode(VCard, { class: "pa-8" }, {
            default: withCtx(() => [
              createVNode(VCardTitle, null, {
                default: withCtx(() => [
                  _hoisted_19$1,
                  createVNode(VSpacer)
                ]),
                _: 1
              }),
              createBaseVNode("div", _hoisted_20$1, [
                createVNode(VProgressCircular, {
                  size: 50,
                  color: "#8DDAFC",
                  indeterminate: ""
                })
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue"]),
      createBaseVNode("div", null, [
        createVNode(VDialog, {
          modelValue: $data.dialogLoadingVitalSign,
          "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.dialogLoadingVitalSign = $event),
          scrim: false,
          persistent: "",
          width: "350"
        }, {
          default: withCtx(() => [
            createVNode(VCard, {
              color: "#00afb9",
              dark: ""
            }, {
              default: withCtx(() => [
                createVNode(VCardText, { class: "font-weight-black text-subtitle-1" }, {
                  default: withCtx(() => [
                    _hoisted_21$1,
                    createBaseVNode("h1", _hoisted_22$1, [
                      $data.vitalSignDescription == "Temperatura" ? (openBlock(), createBlock(VIcon, { key: 0 }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-thermometer-lines")
                        ]),
                        _: 1
                      })) : $data.vitalSignDescription == "Frecuencia cardiaca y Oxígeno" ? (openBlock(), createBlock(VIcon, { key: 1 }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-heart-pulse")
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      $data.vitalSignDescription == "Peso" ? (openBlock(), createBlock(VIcon, { key: 2 }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-weight-kilogram")
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      $data.vitalSignDescription == "Altura" ? (openBlock(), createBlock(VIcon, { key: 3 }, {
                        default: withCtx(() => [
                          createTextVNode("mdi-human-male-height")
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString($data.vitalSignDescription), 1)
                    ]),
                    createVNode(_component_ProgressLinearComponent)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createVNode(VToolbar, {
          height: "50",
          dense: "",
          class: "header-fix",
          elevation: "0"
        }, {
          default: withCtx(() => [
            createVNode(VSpacer),
            createVNode(VToolbarTitle, null, {
              default: withCtx(() => [
                _hoisted_23$1
              ]),
              _: 1
            }),
            createVNode(VSpacer)
          ]),
          _: 1
        })
      ]),
      createVNode(VRow, {
        class: "mt-10",
        "no-gutters": ""
      }, {
        default: withCtx(() => [
          createVNode(VCol, {
            style: { "background-color": "#fafafa" },
            cols: "12",
            md: "6"
          }, {
            default: withCtx(() => [
              createVNode(VCard, {
                style: { "background-color": "#fafafa" },
                rounded: "0",
                elevation: "0"
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_24$1, [
                    createBaseVNode("div", _hoisted_25$1, [
                      createBaseVNode("div", _hoisted_26$1, [
                        $data.videoBlocked ? (openBlock(), createElementBlock("div", _hoisted_27$1, [
                          createVNode(VCard, {
                            height: "250",
                            color: "grey-lighten-3",
                            variant: "outlined"
                          }, {
                            default: withCtx(() => [
                              createVNode(VListItem, { lines: "three" }, {
                                default: withCtx(() => [
                                  _hoisted_28$1,
                                  createVNode(VListItemTitle, { class: "text-h5 mb-1 mt-3" }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString($data.titleVideoEnded), 1)
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(VListItemSubtitle, { class: "text-subtitle-1" }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString($data.textVideoEnded), 1)
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(VAvatar, {
                                    tile: "",
                                    size: "80",
                                    color: "grey",
                                    style: "",
                                    rounded: ""
                                  }, {
                                    default: withCtx(() => [
                                      createVNode(VIcon, {
                                        dark: "",
                                        size: "45"
                                      }, {
                                        default: withCtx(() => [
                                          createTextVNode("mdi-video-off")
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ])) : createCommentVNode("", true),
                        createBaseVNode("div", null, [
                          (openBlock(), createElementBlock("div", { key: $data.keyDiv }, [
                            $data.waitingCall ? (openBlock(), createBlock(VCard, {
                              key: 0,
                              variant: "outlined",
                              class: "bg-grey-lighten-3 pa-5",
                              height: "215"
                            }, {
                              default: withCtx(() => [
                                createVNode(VListItem, { lines: "three" }, {
                                  append: withCtx(() => [
                                    createVNode(VAvatar, {
                                      tile: "",
                                      size: "80",
                                      color: "grey",
                                      style: "",
                                      rounded: ""
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          dark: "",
                                          size: "45"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-account-clock")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  default: withCtx(() => [
                                    createVNode(VListItemTitle, { class: "text-h5 mt-3" }, {
                                      default: withCtx(() => [
                                        createTextVNode(" Esperando a que inicie la "),
                                        _hoisted_29$1,
                                        createTextVNode("video llamada... ")
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VListItemSubtitle, { class: "mt-1 text-subtitle-1" }, {
                                      default: withCtx(() => [
                                        createTextVNode(" Tiempo aproximado ")
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VRow, { class: "mt-3 ml-1" }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          class: "mb-4 mr-1",
                                          color: "grey"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode(" mdi-clock-outline ")
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(_component_TimeComponent, {
                                          class: "mt-1",
                                          time: 180
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })) : createCommentVNode("", true),
                            $data.cardBlocked ? (openBlock(), createBlock(VCard, {
                              key: 1,
                              height: "400",
                              variant: "outlined"
                            }, {
                              default: withCtx(() => [
                                (openBlock(), createElementBlock("div", {
                                  id: "card-outlined",
                                  key: $data.componentKey
                                }, [
                                  createBaseVNode("div", null, [
                                    createVNode(VSystemBar, {
                                      color: "transparent",
                                      "lights-out": "",
                                      dark: "",
                                      class: "pa-4",
                                      style: { "z-index": "1", "bottom": "0", "position": "absolute", "border-top-right-radius": "5px" }
                                    }, {
                                      default: withCtx(() => [
                                        _hoisted_30$1,
                                        $data.downlinkNetworkQuality == 1 ? (openBlock(), createBlock(VIcon, {
                                          key: 0,
                                          size: "small",
                                          color: "green"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-signal-cellular-3")
                                          ]),
                                          _: 1
                                        })) : $data.downlinkNetworkQuality == 2 ? (openBlock(), createBlock(VIcon, {
                                          key: 1,
                                          size: "small",
                                          color: "orange"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-signal-cellular-2")
                                          ]),
                                          _: 1
                                        })) : (openBlock(), createBlock(VIcon, {
                                          key: 2,
                                          size: "small",
                                          color: "red"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-signal-cellular-1")
                                          ]),
                                          _: 1
                                        })),
                                        createBaseVNode("span", _hoisted_31$1, "Cabina " + toDisplayString($data.cabinId), 1),
                                        $data.downlinkNetworkQualityRemote == 1 ? (openBlock(), createBlock(VIcon, {
                                          key: 3,
                                          size: "small",
                                          color: "green"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-signal-cellular-3")
                                          ]),
                                          _: 1
                                        })) : $data.downlinkNetworkQualityRemote == 2 ? (openBlock(), createBlock(VIcon, {
                                          key: 4,
                                          size: "small",
                                          color: "orange"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-signal-cellular-2")
                                          ]),
                                          _: 1
                                        })) : (openBlock(), createBlock(VIcon, {
                                          key: 5,
                                          size: "small",
                                          color: "red"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-signal-cellular-1")
                                          ]),
                                          _: 1
                                        }))
                                      ]),
                                      _: 1
                                    })
                                  ])
                                ]))
                              ]),
                              _: 1
                            })) : createCommentVNode("", true)
                          ])),
                          createVNode(VCard, {
                            elevation: "0",
                            style: { "background-color": "#f5f5f5", "border-bottom": "0px", "border-top": "1px solid #00afb9", "border-right": "1px solid #00afb9", "border-left": "1px solid #00afb9" },
                            variant: "outlined",
                            class: "pa-5 mt-2",
                            "min-width": "100%",
                            "max-width": "100%"
                          }, {
                            default: withCtx(() => [
                              createVNode(VRow, { justify: "end" }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_32$1, [
                                    createVNode(VBtn, {
                                      color: "#00afb9",
                                      disabled: $data.remotePlayerContainer.id != "",
                                      size: "small",
                                      elevation: "0",
                                      onClick: _cache[13] || (_cache[13] = ($event) => $options.pushCall()),
                                      class: "ma-1 ml-2 pt-5 pb-5 d-flex"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, { dark: "" }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-video-account")
                                          ]),
                                          _: 1
                                        }),
                                        _hoisted_33$1
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ]),
                                  createBaseVNode("div", _hoisted_34$1, [
                                    createVNode(VBtn, {
                                      disabled: $data.disabledButtonVolMin,
                                      variant: "outlined",
                                      color: "#00afb9",
                                      size: "small",
                                      onClick: _cache[14] || (_cache[14] = ($event) => $options.settingVolume("call-min")),
                                      class: "ma-1 ml-2 pt-4 pb-4 d-flex"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          dark: "",
                                          size: "20"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-volume-minus")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ]),
                                  createBaseVNode("div", _hoisted_35$1, [
                                    $data.volumeMute ? (openBlock(), createBlock(VBtn, {
                                      key: 0,
                                      onClick: _cache[15] || (_cache[15] = ($event) => $options.settingVolume("call-unmute")),
                                      size: "small",
                                      elevation: "0",
                                      color: "#00afb9",
                                      class: "ma-1 ml-2 pt-4 pb-4 d-flex"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          dark: "",
                                          size: "20"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-microphone-off")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })) : (openBlock(), createBlock(VBtn, {
                                      key: 1,
                                      elevation: "0",
                                      size: "small",
                                      onClick: _cache[16] || (_cache[16] = ($event) => $options.settingVolume("call-mute")),
                                      color: "#00afb9",
                                      class: "ma-1 ml-2 pt-4 pb-4 d-flex"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          dark: "",
                                          size: "20"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-microphone")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }))
                                  ]),
                                  createBaseVNode("div", _hoisted_36$1, [
                                    createVNode(VBtn, {
                                      disabled: $data.disabledButtonVolUp,
                                      variant: "outlined",
                                      size: "small",
                                      color: "#00afb9",
                                      onClick: _cache[17] || (_cache[17] = ($event) => $options.settingVolume("call-up")),
                                      class: "ma-1 ml-2 pt-4 pb-4 d-flex"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          dark: "",
                                          size: "20"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-volume-plus")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ]),
                                  createBaseVNode("div", _hoisted_37$1, [
                                    createVNode(VBtn, {
                                      elevation: "0",
                                      onClick: _cache[18] || (_cache[18] = ($event) => ($options.openCabin(), $options.activateReceipt(), $options.leaveCall())),
                                      color: "#00afb9",
                                      size: "small",
                                      disabled: $data.videoBlocked,
                                      class: normalizeClass(
                                        !$data.videoBlocked ? "ma-1 mr-1 pt-5 pb-5 d-flex white--text" : "ma-1 mr-1 pt-5 pb-5 d-flex black--text"
                                      )
                                    }, {
                                      default: withCtx(() => [
                                        _hoisted_38
                                      ]),
                                      _: 1
                                    }, 8, ["disabled", "class"])
                                  ]),
                                  createBaseVNode("div", _hoisted_39, [
                                    createVNode(VRow, { class: "" }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          class: "mr-1",
                                          color: "black",
                                          size: "30"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode(" mdi-clock-outline ")
                                          ]),
                                          _: 1
                                        }),
                                        createBaseVNode("span", _hoisted_40, toDisplayString($data.time), 1)
                                      ]),
                                      _: 1
                                    })
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          createVNode(VCard, {
                            elevation: "0",
                            style: { "margin-top": "-10px", "background-color": "#f5f5f5", "border-top": "0px", "border-bottom": "1px solid #00afb9", "border-right": "1px solid #00afb9", "border-left": "1px solid #00afb9" },
                            variant: "outlined",
                            class: "pa-5",
                            "min-width": "100%",
                            "max-width": "100%"
                          }, {
                            default: withCtx(() => [
                              createVNode(VRow, { justify: "end" }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_41, [
                                    createVNode(VDialog, {
                                      persistent: "",
                                      modelValue: $data.dialogDevice,
                                      "onUpdate:modelValue": _cache[26] || (_cache[26] = ($event) => $data.dialogDevice = $event),
                                      height: "800",
                                      width: "800"
                                    }, {
                                      activator: withCtx(({ props }) => [
                                        createVNode(VBtn, mergeProps({ color: "#00afb9" }, props, {
                                          size: "small",
                                          elevation: "0",
                                          onClick: _cache[19] || (_cache[19] = ($event) => ($options.toggleDeviceTest(), $options.getDevices())),
                                          class: "ma-1 pt-5 pb-5 d-flex"
                                        }), {
                                          default: withCtx(() => [
                                            createVNode(VIcon, {
                                              start: "",
                                              color: "white"
                                            }, {
                                              default: withCtx(() => [
                                                createTextVNode("mdi-cog")
                                              ]),
                                              _: 1
                                            }),
                                            _hoisted_42
                                          ]),
                                          _: 2
                                        }, 1040)
                                      ]),
                                      default: withCtx(() => [
                                        createVNode(VCard, null, {
                                          default: withCtx(() => [
                                            createVNode(VCardTitle, { class: "text-h5 bg-grey-lighten-2" }, {
                                              default: withCtx(() => [
                                                createTextVNode(" Control de dispositivos ")
                                              ]),
                                              _: 1
                                            }),
                                            createVNode(VCardText, null, {
                                              default: withCtx(() => [
                                                createVNode(VTabs, {
                                                  modelValue: $data.tab,
                                                  "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => $data.tab = $event),
                                                  "bg-color": "transparent",
                                                  color: "#00afb9",
                                                  grow: ""
                                                }, {
                                                  default: withCtx(() => [
                                                    createVNode(VTab, null, {
                                                      default: withCtx(() => [
                                                        createTextVNode(" App Médico ")
                                                      ]),
                                                      _: 1
                                                    })
                                                  ]),
                                                  _: 1
                                                }, 8, ["modelValue"]),
                                                createVNode(VWindow, {
                                                  modelValue: $data.tab,
                                                  "onUpdate:modelValue": _cache[24] || (_cache[24] = ($event) => $data.tab = $event)
                                                }, {
                                                  default: withCtx(() => [
                                                    createVNode(VWindowItem, null, {
                                                      default: withCtx(() => [
                                                        createVNode(VCard, { text: "" }, {
                                                          default: withCtx(() => [
                                                            createVNode(VCardText, null, {
                                                              default: withCtx(() => [
                                                                createVNode(VContainer, { class: "justify-center" }, {
                                                                  default: withCtx(() => [
                                                                    createVNode(VRow, { align: "center" }, {
                                                                      default: withCtx(() => [
                                                                        createVNode(VCol, {
                                                                          cols: "12",
                                                                          sm: "12"
                                                                        }, {
                                                                          default: withCtx(() => [
                                                                            _hoisted_43
                                                                          ]),
                                                                          _: 1
                                                                        })
                                                                      ]),
                                                                      _: 1
                                                                    }),
                                                                    createVNode(VRow, null, {
                                                                      default: withCtx(() => [
                                                                        createVNode(VCol, {
                                                                          cols: "12",
                                                                          sm: "8"
                                                                        }, {
                                                                          default: withCtx(() => [
                                                                            createVNode(VSelect, {
                                                                              variant: "outlined",
                                                                              modelValue: $data.videoT,
                                                                              "onUpdate:modelValue": [
                                                                                _cache[21] || (_cache[21] = ($event) => $data.videoT = $event),
                                                                                $options.isVideoDevice
                                                                              ],
                                                                              items: $data.camerasAvailables,
                                                                              "item-value": "deviceId",
                                                                              "item-title": "label",
                                                                              label: "Seleccione una cámara disponible",
                                                                              "single-line": "",
                                                                              "return-object": "",
                                                                              "persistent-hint": ""
                                                                            }, null, 8, ["modelValue", "items", "onUpdate:modelValue"])
                                                                          ]),
                                                                          _: 1
                                                                        }),
                                                                        createVNode(VCol, {
                                                                          justify: "center",
                                                                          align: "center",
                                                                          cols: "12",
                                                                          sm: "4",
                                                                          class: "d-flex"
                                                                        }, {
                                                                          default: withCtx(() => [
                                                                            $data.cameraNotReadable ? (openBlock(), createElementBlock("div", _hoisted_44, [
                                                                              createVNode(VAlert, {
                                                                                text: "",
                                                                                type: "warning",
                                                                                density: "compact",
                                                                                border: "start",
                                                                                class: "",
                                                                                icon: "mdi-video-off"
                                                                              }, {
                                                                                default: withCtx(() => [
                                                                                  _hoisted_45
                                                                                ]),
                                                                                _: 1
                                                                              })
                                                                            ])) : (openBlock(), createElementBlock("div", _hoisted_46))
                                                                          ]),
                                                                          _: 1
                                                                        })
                                                                      ]),
                                                                      _: 1
                                                                    }),
                                                                    createVNode(VRow, null, {
                                                                      default: withCtx(() => [
                                                                        createVNode(VCol, {
                                                                          cols: "12",
                                                                          sm: "12"
                                                                        }, {
                                                                          default: withCtx(() => [
                                                                            _hoisted_47
                                                                          ]),
                                                                          _: 1
                                                                        })
                                                                      ]),
                                                                      _: 1
                                                                    }),
                                                                    createVNode(VRow, null, {
                                                                      default: withCtx(() => [
                                                                        createVNode(VCol, {
                                                                          cols: "12",
                                                                          sm: "8"
                                                                        }, {
                                                                          default: withCtx(() => [
                                                                            createVNode(VSelect, {
                                                                              variant: "outlined",
                                                                              modelValue: $data.audioT,
                                                                              "onUpdate:modelValue": [
                                                                                _cache[22] || (_cache[22] = ($event) => $data.audioT = $event),
                                                                                $options.isAudioDevice
                                                                              ],
                                                                              items: $data.microphonesAvailables,
                                                                              "item-value": "deviceId",
                                                                              "item-title": "label",
                                                                              label: "Seleccione un micrófono disponible",
                                                                              "single-line": "",
                                                                              "return-object": "",
                                                                              "persistent-hint": ""
                                                                            }, null, 8, ["modelValue", "items", "onUpdate:modelValue"])
                                                                          ]),
                                                                          _: 1
                                                                        }),
                                                                        createVNode(VCol, {
                                                                          cols: "12",
                                                                          sm: "4"
                                                                        }, {
                                                                          default: withCtx(() => [
                                                                            createVNode(VRow, {
                                                                              justify: "center",
                                                                              align: "center"
                                                                            }, {
                                                                              default: withCtx(() => [
                                                                                createVNode(VCol, {
                                                                                  cols: "12",
                                                                                  class: "mb-0 pb-0"
                                                                                }, {
                                                                                  default: withCtx(() => [
                                                                                    createBaseVNode("audio", _hoisted_48, null, 512)
                                                                                  ]),
                                                                                  _: 1
                                                                                }),
                                                                                createVNode(VCol, {
                                                                                  justify: "center",
                                                                                  align: "center",
                                                                                  cols: "12",
                                                                                  class: "mt-0 pt-0"
                                                                                }, {
                                                                                  default: withCtx(() => [
                                                                                    createVNode(VBtnToggle, {
                                                                                      modelValue: $data.text,
                                                                                      "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => $data.text = $event),
                                                                                      density: "compact",
                                                                                      color: "#00afb9",
                                                                                      mandatory: ""
                                                                                    }, {
                                                                                      default: withCtx(() => [
                                                                                        createVNode(VBtn, {
                                                                                          onClick: $options.playAudio,
                                                                                          value: "left"
                                                                                        }, {
                                                                                          default: withCtx(() => [
                                                                                            createVNode(VIcon, null, {
                                                                                              default: withCtx(() => [
                                                                                                createTextVNode("mdi-headphones")
                                                                                              ]),
                                                                                              _: 1
                                                                                            })
                                                                                          ]),
                                                                                          _: 1
                                                                                        }, 8, ["onClick"]),
                                                                                        createVNode(VBtn, {
                                                                                          onClick: $options.testAudio,
                                                                                          value: "center"
                                                                                        }, {
                                                                                          default: withCtx(() => [
                                                                                            createVNode(VIcon, null, {
                                                                                              default: withCtx(() => [
                                                                                                createTextVNode("mdi-microphone")
                                                                                              ]),
                                                                                              _: 1
                                                                                            })
                                                                                          ]),
                                                                                          _: 1
                                                                                        }, 8, ["onClick"])
                                                                                      ]),
                                                                                      _: 1
                                                                                    }, 8, ["modelValue"])
                                                                                  ]),
                                                                                  _: 1
                                                                                })
                                                                              ]),
                                                                              _: 1
                                                                            })
                                                                          ]),
                                                                          _: 1
                                                                        })
                                                                      ]),
                                                                      _: 1
                                                                    })
                                                                  ]),
                                                                  _: 1
                                                                })
                                                              ]),
                                                              _: 1
                                                            })
                                                          ]),
                                                          _: 1
                                                        })
                                                      ]),
                                                      _: 1
                                                    })
                                                  ]),
                                                  _: 1
                                                }, 8, ["modelValue"])
                                              ]),
                                              _: 1
                                            }),
                                            createVNode(VCardActions, null, {
                                              default: withCtx(() => [
                                                createVNode(VSpacer),
                                                createVNode(VBtn, {
                                                  color: "#00afb9",
                                                  variant: "text",
                                                  onClick: _cache[25] || (_cache[25] = ($event) => ($data.dialogDevice = false, $options.createVideoTrack()))
                                                }, {
                                                  default: withCtx(() => [
                                                    createTextVNode(" Aceptar ")
                                                  ]),
                                                  _: 1
                                                })
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["modelValue"])
                                  ]),
                                  createBaseVNode("div", _hoisted_49, [
                                    createBaseVNode("div", null, [
                                      createVNode(VBtn, {
                                        disabled: $data.dialogDoor,
                                        loading: $data.dialogDoor,
                                        size: "small",
                                        onClick: _cache[27] || (_cache[27] = ($event) => $data.emergencyDoor ? $options.emergencyDoorActivate() : $options.emergencyDoorDeactivate()),
                                        color: $data.emergencyDoor ? "orange" : "#00afb9",
                                        elevation: "0",
                                        variant: "outlined",
                                        class: "ma-1 pt-5 pb-5 d-flex"
                                      }, {
                                        default: withCtx(() => [
                                          _hoisted_50,
                                          createVNode(VIcon, {
                                            end: "",
                                            color: $data.emergencyDoor ? "orange" : "#00afb9",
                                            size: "25"
                                          }, {
                                            default: withCtx(() => [
                                              createTextVNode("mdi-alert-circle-outline")
                                            ]),
                                            _: 1
                                          }, 8, ["color"])
                                        ]),
                                        _: 1
                                      }, 8, ["disabled", "loading", "color"]),
                                      createVNode(VDialog, {
                                        modelValue: $data.dialogDoor,
                                        "onUpdate:modelValue": _cache[28] || (_cache[28] = ($event) => $data.dialogDoor = $event),
                                        scrim: false,
                                        persistent: "",
                                        width: "300"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(VCard, {
                                            color: "#00afb9",
                                            dark: ""
                                          }, {
                                            default: withCtx(() => [
                                              createVNode(VCardText, null, {
                                                default: withCtx(() => [
                                                  createTextVNode(" Procesando... "),
                                                  createVNode(_component_ProgressLinearComponent)
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      }, 8, ["modelValue"])
                                    ])
                                  ]),
                                  createVNode(VDialog, {
                                    transition: "dialog-top-transition",
                                    "max-width": "600"
                                  }, {
                                    activator: withCtx(({ props }) => [
                                      createVNode(VBtn, mergeProps({
                                        class: "ma-1 pt-5 pb-5 d-flex",
                                        color: "#00afb9",
                                        elevation: "0"
                                      }, props, {
                                        size: "small",
                                        onClick: _cache[29] || (_cache[29] = ($event) => $options.getScans())
                                      }), {
                                        default: withCtx(() => [
                                          createTextVNode("Documentos")
                                        ]),
                                        _: 2
                                      }, 1040)
                                    ]),
                                    default: withCtx((dialogDoc) => [
                                      createVNode(VCard, null, {
                                        default: withCtx(() => [
                                          createVNode(VToolbar, {
                                            color: "#00afb9",
                                            dark: ""
                                          }, {
                                            default: withCtx(() => [
                                              _hoisted_51
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VCardText, null, {
                                            default: withCtx(() => [
                                              $data.listScans.length == 0 ? (openBlock(), createElementBlock("div", _hoisted_52, " - Sin registros. ")) : (openBlock(), createElementBlock("div", _hoisted_53, [
                                                (openBlock(true), createElementBlock(Fragment, null, renderList($data.listScans, (item, index) => {
                                                  return openBlock(), createElementBlock("ul", {
                                                    key: index,
                                                    class: "mt-5"
                                                  }, [
                                                    createBaseVNode("li", null, [
                                                      createBaseVNode("p", null, [
                                                        createBaseVNode("a", {
                                                          href: item.image,
                                                          target: "_blank",
                                                          class: "text-grey"
                                                        }, " No. documento: " + toDisplayString(item.id), 9, _hoisted_54)
                                                      ])
                                                    ])
                                                  ]);
                                                }), 128))
                                              ]))
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VCardActions, { class: "justify-end" }, {
                                            default: withCtx(() => [
                                              createVNode(VBtn, {
                                                color: "#00afb9",
                                                onClick: ($event) => dialogDoc.value = false
                                              }, {
                                                default: withCtx(() => [
                                                  createTextVNode("Cerrar")
                                                ]),
                                                _: 2
                                              }, 1032, ["onClick"])
                                            ]),
                                            _: 2
                                          }, 1024)
                                        ]),
                                        _: 2
                                      }, 1024)
                                    ]),
                                    _: 1
                                  }),
                                  createBaseVNode("div", _hoisted_55, [
                                    createVNode(VBtn, {
                                      elevation: "1",
                                      color: "error",
                                      size: "small",
                                      disabled: $data.disabledButtonEndCall,
                                      onClick: _cache[30] || (_cache[30] = ($event) => ($options.finishCallPatient(), $options.changeStatusOfCall())),
                                      class: "ma-1 pt-5 pb-5 d-flex"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VIcon, {
                                          dark: "",
                                          size: "25"
                                        }, {
                                          default: withCtx(() => [
                                            createTextVNode("mdi-phone-hangup")
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["disabled"])
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ])
                      ])
                    ])
                  ])
                ]),
                _: 1
              }),
              createBaseVNode("div", _hoisted_56, toDisplayString($data.cabinLocation), 1)
            ]),
            _: 1
          }),
          createVNode(VCol, {
            cols: "12",
            md: "6"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", null, [
                createVNode(VSnackbar, {
                  "max-width": "100",
                  color: "#00afb9",
                  timeout: $data.timeout,
                  bottom: $data.bottom,
                  right: $data.right,
                  class: "elevation-24",
                  modelValue: $data.snackBarWait,
                  "onUpdate:modelValue": _cache[31] || (_cache[31] = ($event) => $data.snackBarWait = $event)
                }, {
                  default: withCtx(() => [
                    createVNode(VRow, { justify: "center" }, {
                      default: withCtx(() => [
                        _hoisted_57,
                        createVNode(VProgressCircular, {
                          class: "ml-3",
                          width: 3,
                          size: "20",
                          color: "white",
                          indeterminate: ""
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["timeout", "bottom", "right", "modelValue"])
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("div", _hoisted_58, [
                  createBaseVNode("div", _hoisted_59, " Identificación del paciente: " + toDisplayString($data.gid), 1),
                  createVNode(VCard, { variant: "outlined" }, {
                    default: withCtx(() => [
                      createVNode(VTabs, {
                        "bg-color": "#00afb9",
                        "center-active": "",
                        modelValue: $data.tab2,
                        "onUpdate:modelValue": _cache[34] || (_cache[34] = ($event) => $data.tab2 = $event)
                      }, {
                        default: withCtx(() => [
                          createVNode(VTab, null, {
                            default: withCtx(() => [
                              createVNode(VIcon, { start: "" }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-account")
                                ]),
                                _: 1
                              }),
                              createTextVNode("Paciente")
                            ]),
                            _: 1
                          }),
                          createVNode(VTab, {
                            onClick: _cache[32] || (_cache[32] = ($event) => $options.switchVsOrScan("scan"))
                          }, {
                            default: withCtx(() => [
                              createVNode(VIcon, { start: "" }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-scanner")
                                ]),
                                _: 1
                              }),
                              createTextVNode(" Escaner")
                            ]),
                            _: 1
                          }),
                          createVNode(VTab, {
                            onClick: _cache[33] || (_cache[33] = ($event) => $options.switchVsOrScan("vs"))
                          }, {
                            default: withCtx(() => [
                              createVNode(VIcon, { start: "" }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-medical-bag")
                                ]),
                                _: 1
                              }),
                              createTextVNode(" Signos vitales")
                            ]),
                            _: 1
                          }),
                          $data.sthetoAvailable ? (openBlock(), createBlock(VTab, { key: 0 }, {
                            default: withCtx(() => [
                              createVNode(VIcon, { start: "" }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-stethoscope")
                                ]),
                                _: 1
                              }),
                              createTextVNode(" Examen físico ")
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createVNode(VTab, null, {
                            default: withCtx(() => [
                              createVNode(VIcon, { start: "" }, {
                                default: withCtx(() => [
                                  createTextVNode("mdi-tex-tbox-outline")
                                ]),
                                _: 1
                              }),
                              createTextVNode("Recetas")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"]),
                      createVNode(VWindow, {
                        modelValue: $data.tab2,
                        "onUpdate:modelValue": _cache[71] || (_cache[71] = ($event) => $data.tab2 = $event)
                      }, {
                        default: withCtx(() => [
                          createVNode(VWindowItem, null, {
                            default: withCtx(() => [
                              $data.dialogFormPatient ? (openBlock(), createBlock(VCard, { key: 0 }, {
                                default: withCtx(() => [
                                  createVNode(VCardTitle, null, {
                                    default: withCtx(() => [
                                      _hoisted_60
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(VCardSubtitle, null, {
                                    default: withCtx(() => [
                                      _hoisted_61
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(VCardText, null, {
                                    default: withCtx(() => [
                                      createVNode(VContainer, null, {
                                        default: withCtx(() => [
                                          (openBlock(), createBlock(VForm, {
                                            key: $data.componentKey,
                                            ref: "form1",
                                            style: { "margin-left": "40px", "margin-right": "40px", "margin-top": "15px" }
                                          }, {
                                            default: withCtx(() => [
                                              createVNode(VRow, { align: "center" }, {
                                                default: withCtx(() => [
                                                  createVNode(VCol, {
                                                    style: { "padding": "0px" },
                                                    class: "mr-2 mt-2"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_62,
                                                      createVNode(VTextField, {
                                                        color: "color: #67B0AC",
                                                        variant: "outlined",
                                                        density: "compact",
                                                        label: "",
                                                        modelValue: $data.form1.first_name,
                                                        "onUpdate:modelValue": _cache[35] || (_cache[35] = ($event) => $data.form1.first_name = $event),
                                                        modelModifiers: { trim: true },
                                                        required: "",
                                                        readonly: $data.buttonsBlocked
                                                      }, null, 8, ["modelValue", "readonly"])
                                                    ]),
                                                    _: 1
                                                  }),
                                                  createVNode(VCol, {
                                                    style: { "padding": "0px" },
                                                    class: "ml-2 mt-2"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_63,
                                                      createVNode(VTextField, {
                                                        color: "color: #67B0AC",
                                                        density: "compact",
                                                        label: "",
                                                        variant: "outlined",
                                                        modelValue: $data.form1.last_name,
                                                        "onUpdate:modelValue": _cache[36] || (_cache[36] = ($event) => $data.form1.last_name = $event),
                                                        modelModifiers: { trim: true },
                                                        readonly: $data.buttonsBlocked,
                                                        required: ""
                                                      }, null, 8, ["modelValue", "readonly"])
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              }),
                                              false ? (openBlock(), createBlock(VTextField, {
                                                key: 0,
                                                color: "color: #67B0AC",
                                                variant: "outlined",
                                                density: "compact",
                                                label: "",
                                                readonly: $data.buttonsBlocked,
                                                modelValue: $data.form1.cabin,
                                                "onUpdate:modelValue": _cache[37] || (_cache[37] = ($event) => $data.form1.cabin = $event),
                                                modelModifiers: { trim: true }
                                              }, null, 8, ["readonly", "modelValue"])) : createCommentVNode("", true),
                                              createVNode(VRow, { align: "center" }, {
                                                default: withCtx(() => [
                                                  createVNode(VCol, {
                                                    style: { "padding": "0px" },
                                                    class: "mr-2"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_64,
                                                      createVNode(VDialog, {
                                                        ref: "dialog0",
                                                        modelValue: $data.modal0,
                                                        "onUpdate:modelValue": _cache[42] || (_cache[42] = ($event) => $data.modal0 = $event),
                                                        "return-value": $data.form1.birth_date,
                                                        persistent: "",
                                                        width: "290px"
                                                      }, {
                                                        activator: withCtx(({ props }) => [
                                                          createVNode(VTextField, mergeProps({
                                                            modelValue: $data.form1.birth_date,
                                                            "onUpdate:modelValue": _cache[38] || (_cache[38] = ($event) => $data.form1.birth_date = $event),
                                                            modelModifiers: { trim: true },
                                                            color: "color: #67B0AC",
                                                            density: "compact",
                                                            variant: "outlined"
                                                          }, props, {
                                                            readonly: $data.buttonsBlocked,
                                                            required: ""
                                                          }), null, 16, ["modelValue", "readonly"])
                                                        ]),
                                                        default: withCtx(() => [
                                                          createVNode(_component_v_date_picker, {
                                                            modelValue: $data.form1.birth_date,
                                                            "onUpdate:modelValue": _cache[41] || (_cache[41] = ($event) => $data.form1.birth_date = $event),
                                                            modelModifiers: { trim: true },
                                                            scrollable: "",
                                                            color: "#67B0AC"
                                                          }, {
                                                            default: withCtx(() => [
                                                              createVNode(VSpacer),
                                                              createVNode(VBtn, {
                                                                variant: "text",
                                                                color: "color: #67B0AC",
                                                                onClick: _cache[39] || (_cache[39] = ($event) => $data.modal0 = false)
                                                              }, {
                                                                default: withCtx(() => [
                                                                  createTextVNode(" Cancel ")
                                                                ]),
                                                                _: 1
                                                              }),
                                                              createVNode(VBtn, {
                                                                variant: "text",
                                                                color: "color: #67B0AC",
                                                                onClick: _cache[40] || (_cache[40] = ($event) => _ctx.$refs.dialog0.save(
                                                                  $data.form1.birth_date
                                                                ))
                                                              }, {
                                                                default: withCtx(() => [
                                                                  createTextVNode(" OK ")
                                                                ]),
                                                                _: 1
                                                              })
                                                            ]),
                                                            _: 1
                                                          }, 8, ["modelValue"])
                                                        ]),
                                                        _: 1
                                                      }, 8, ["modelValue", "return-value"])
                                                    ]),
                                                    _: 1
                                                  }),
                                                  createVNode(VCol, {
                                                    style: { "padding": "0px" },
                                                    class: "ml-2"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_65,
                                                      createVNode(VSelect, {
                                                        color: "color: #67B0AC",
                                                        items: $data.gender,
                                                        label: this.form1.gender == null ? "Seleccione el género" : this.form1.gender === true ? "Masculino" : this.form1.gender === false ? "Femenino" : "Sin información.",
                                                        "single-line": "",
                                                        variant: "outlined",
                                                        "item-value": "value",
                                                        "item-title": "name",
                                                        "return-object": "",
                                                        "onUpdate:modelValue": $options.isGender,
                                                        placeholder: "",
                                                        required: "",
                                                        readonly: $data.buttonsBlocked
                                                      }, null, 8, ["items", "label", "onUpdate:modelValue", "readonly"])
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VRow, { align: "center" }, {
                                                default: withCtx(() => [
                                                  createVNode(VCol, {
                                                    style: { "padding": "0px" },
                                                    class: "mr-2"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_66,
                                                      createVNode(VTextField, {
                                                        color: "color: #67B0AC",
                                                        density: "compact",
                                                        label: "",
                                                        variant: "outlined",
                                                        modelValue: $data.form1.government_id,
                                                        "onUpdate:modelValue": _cache[43] || (_cache[43] = ($event) => $data.form1.government_id = $event),
                                                        modelModifiers: { trim: true },
                                                        counter: 13,
                                                        required: "",
                                                        readonly: !this.dialogFormPatient || $data.buttonsBlocked
                                                      }, null, 8, ["modelValue", "readonly"])
                                                    ]),
                                                    _: 1
                                                  }),
                                                  createVNode(VCol, {
                                                    style: { "padding": "0px" },
                                                    class: "ml-2"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_67,
                                                      createVNode(VTextField, {
                                                        color: "color: #67B0AC",
                                                        density: "compact",
                                                        label: "",
                                                        variant: "outlined",
                                                        modelValue: $data.form1.phone_number,
                                                        "onUpdate:modelValue": _cache[44] || (_cache[44] = ($event) => $data.form1.phone_number = $event),
                                                        modelModifiers: { trim: true },
                                                        counter: 8,
                                                        readonly: $data.buttonsBlocked,
                                                        required: ""
                                                      }, null, 8, ["modelValue", "readonly"])
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              }),
                                              createVNode(VRow, {
                                                align: "center",
                                                class: "mb-10",
                                                justify: "center"
                                              }, {
                                                default: withCtx(() => [
                                                  createBaseVNode("div", _hoisted_68, [
                                                    createVNode(VBtn, {
                                                      block: "",
                                                      elevation: "0",
                                                      onClick: _cache[45] || (_cache[45] = ($event) => $data.buttonsBlocked ? null : $options.createPatient()),
                                                      disabled: $data.dialog || $data.buttonsBlocked,
                                                      loading: $data.dialog,
                                                      class: "text-white mt-3 text-h5 pr-10 pl-10",
                                                      color: "#00afb9"
                                                    }, {
                                                      default: withCtx(() => [
                                                        createTextVNode(" Guardar "),
                                                        createVNode(VIcon, {
                                                          size: "25",
                                                          end: ""
                                                        }, {
                                                          default: withCtx(() => [
                                                            createTextVNode("mdi-content-save-outline")
                                                          ]),
                                                          _: 1
                                                        })
                                                      ]),
                                                      _: 1
                                                    }, 8, ["disabled", "loading"]),
                                                    createVNode(VDialog, {
                                                      modelValue: $data.dialog,
                                                      "onUpdate:modelValue": _cache[46] || (_cache[46] = ($event) => $data.dialog = $event),
                                                      scrim: false,
                                                      persistent: "",
                                                      width: "300"
                                                    }, {
                                                      default: withCtx(() => [
                                                        createVNode(VCard, {
                                                          color: "#67B0AC",
                                                          dark: ""
                                                        }, {
                                                          default: withCtx(() => [
                                                            createVNode(VCardText, null, {
                                                              default: withCtx(() => [
                                                                createTextVNode(" Guardando información... "),
                                                                createVNode(_component_ProgressLinearComponent)
                                                              ]),
                                                              _: 1
                                                            })
                                                          ]),
                                                          _: 1
                                                        })
                                                      ]),
                                                      _: 1
                                                    }, 8, ["modelValue"])
                                                  ])
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          }))
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })) : (openBlock(), createBlock(VRow, {
                                key: 1,
                                justify: "space-between"
                              }, {
                                default: withCtx(() => [
                                  createVNode(VCol, { cols: "6" }, {
                                    default: withCtx(() => [
                                      createVNode(VCard, {
                                        class: "mx-auto ma-8 ml-5",
                                        "max-width": "344",
                                        variant: "outlined"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(VCardItem, { "three-line": "" }, {
                                            default: withCtx(() => [
                                              createBaseVNode("div", null, [
                                                createBaseVNode("div", _hoisted_69, toDisplayString($data.form1.first_name) + " " + toDisplayString($data.form1.last_name), 1),
                                                createBaseVNode("div", _hoisted_70, "Género: " + toDisplayString($data.form1.gender ? "Masculino" : "Femenino"), 1),
                                                createBaseVNode("div", _hoisted_71, "Identificación: " + toDisplayString($data.form1.government_id), 1)
                                              ]),
                                              createVNode(VCardItem, {
                                                tile: "",
                                                size: "80",
                                                color: "grey"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VIcon, {
                                                    color: "white",
                                                    size: "55"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createTextVNode(" mdi-account-circle ")
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VCardActions, null, {
                                            default: withCtx(() => [
                                              createVNode(VBtn, {
                                                variant: "outlined",
                                                rounded: "",
                                                onClick: _cache[47] || (_cache[47] = ($event) => $data.dialogFormPatient = !$data.dialogFormPatient)
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VIcon, { start: "" }, {
                                                    default: withCtx(() => [
                                                      createTextVNode(" mdi-pencil ")
                                                    ]),
                                                    _: 1
                                                  }),
                                                  createTextVNode(" Editar ")
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(VCol, { cols: "6" })
                                ]),
                                _: 1
                              }))
                            ]),
                            _: 1
                          }),
                          createVNode(VWindowItem, null, {
                            default: withCtx(() => [
                              createVNode(VCard, {
                                flat: "",
                                class: "pa-10"
                              }, {
                                default: withCtx(() => [
                                  $data.waitingScanVar ? (openBlock(), createElementBlock("div", _hoisted_72, [
                                    createVNode(VCard, {
                                      "max-width": "500",
                                      variant: "outlined",
                                      class: "mx-auto",
                                      style: { "border": "1px solid grey" },
                                      color: "#f8f9fa"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VCardTitle, {
                                          "primary-title": "",
                                          class: "justify-center"
                                        }, {
                                          default: withCtx(() => [
                                            createBaseVNode("div", null, [
                                              createVNode(VIcon, { start: "" }, {
                                                default: withCtx(() => [
                                                  createTextVNode(" mdi-scanner ")
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            createBaseVNode("div", _hoisted_73, toDisplayString($data.waitingMessage), 1),
                                            _hoisted_74
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ])) : createCommentVNode("", true),
                                  $data.buttonsScan ? (openBlock(), createElementBlock("div", _hoisted_75, [
                                    $data.turnOnScanVar ? (openBlock(), createElementBlock("div", _hoisted_76, [
                                      createVNode(VCard, {
                                        onClick: _cache[48] || (_cache[48] = ($event) => $data.buttonsBlocked ? null : $options.turnOnScan()),
                                        style: { "border": "1px solid grey" },
                                        color: "#f6fff8",
                                        variant: "outlined",
                                        class: "mx-auto",
                                        "max-width": "270"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(VCardTitle, {
                                            "primary-title": "",
                                            class: "justify-center"
                                          }, {
                                            default: withCtx(() => [
                                              _hoisted_77
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VCardSubtitle, null, {
                                            default: withCtx(() => [
                                              createBaseVNode("div", _hoisted_78, toDisplayString($data.turnOnScanText), 1),
                                              _hoisted_79
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      })
                                    ])) : createCommentVNode("", true),
                                    $data.newScan ? (openBlock(), createElementBlock("div", _hoisted_80, [
                                      createVNode(VCard, {
                                        onClick: _cache[49] || (_cache[49] = ($event) => $options.scan()),
                                        class: "mx-auto",
                                        "max-width": "250",
                                        style: { "border": "1px solid grey" },
                                        color: "#f4faff",
                                        variant: "outlined"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(VCardTitle, {
                                            "primary-title": "",
                                            class: "justify-center"
                                          }, {
                                            default: withCtx(() => [
                                              _hoisted_81
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VCardSubtitle, null, {
                                            default: withCtx(() => [
                                              _hoisted_82,
                                              _hoisted_83
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      })
                                    ])) : createCommentVNode("", true),
                                    createVNode(VRow, { class: "ma-3" }, {
                                      default: withCtx(() => [
                                        createVNode(VCol, { cols: "6" }, {
                                          default: withCtx(() => [
                                            $data.scanAg ? (openBlock(), createElementBlock("div", _hoisted_84, [
                                              createVNode(VCard, {
                                                onClick: _cache[50] || (_cache[50] = ($event) => $options.scanAgain()),
                                                class: "mx-auto",
                                                "max-width": "250",
                                                style: { "border": "1px solid grey" },
                                                color: "#f8fbff",
                                                variant: "outlined"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VCardTitle, {
                                                    "primary-title": "",
                                                    class: "justify-center"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_85
                                                    ]),
                                                    _: 1
                                                  }),
                                                  createVNode(VCardSubtitle, null, {
                                                    default: withCtx(() => [
                                                      _hoisted_86,
                                                      _hoisted_87
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              })
                                            ])) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VCol, { cols: "6" }, {
                                          default: withCtx(() => [
                                            $data.scanAg ? (openBlock(), createElementBlock("div", _hoisted_88, [
                                              createVNode(VCard, {
                                                onClick: _cache[51] || (_cache[51] = ($event) => $options.saveScan()),
                                                class: "mx-auto",
                                                "max-width": "250",
                                                style: { "border": "1px solid grey" },
                                                color: "#f8f9fa",
                                                variant: "outlined"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VCardTitle, {
                                                    "primary-title": "",
                                                    class: "justify-center"
                                                  }, {
                                                    default: withCtx(() => [
                                                      _hoisted_89
                                                    ]),
                                                    _: 1
                                                  }),
                                                  createVNode(VCardSubtitle, null, {
                                                    default: withCtx(() => [
                                                      _hoisted_90,
                                                      _hoisted_91
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              })
                                            ])) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    $data.showScanResult ? (openBlock(), createElementBlock("div", _hoisted_92, [
                                      createVNode(VCard, {
                                        onClick: _cache[52] || (_cache[52] = ($event) => $options.showScan()),
                                        class: "mx-auto",
                                        "max-width": "250",
                                        style: { "border": "1px solid grey" },
                                        color: "#eafdf8",
                                        variant: "outlined"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(VCardTitle, {
                                            "primary-title": "",
                                            class: "justify-center"
                                          }, {
                                            default: withCtx(() => [
                                              _hoisted_93
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VCardSubtitle, null, {
                                            default: withCtx(() => [
                                              _hoisted_94,
                                              _hoisted_95
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      }),
                                      _hoisted_96,
                                      createVNode(VRow, {
                                        "no-gutters": "",
                                        justify: "center"
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(VBtn, {
                                            variant: "flat",
                                            color: "error",
                                            class: "mr-2",
                                            onClick: _cache[53] || (_cache[53] = ($event) => $options.alertToSaveOrNotSaveScan("Eliminando...", false))
                                          }, {
                                            default: withCtx(() => [
                                              createTextVNode(" No ")
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(VBtn, {
                                            variant: "flat",
                                            color: "#00afb9",
                                            dark: "",
                                            class: "ml-2",
                                            onClick: _cache[54] || (_cache[54] = ($event) => $options.alertToSaveOrNotSaveScan("Guardando...", true))
                                          }, {
                                            default: withCtx(() => [
                                              createTextVNode(" Sí ")
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 1
                                      })
                                    ])) : createCommentVNode("", true)
                                  ])) : createCommentVNode("", true)
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          createVNode(VWindowItem, null, {
                            default: withCtx(() => [
                              createVNode(VCard, {
                                flat: "",
                                class: "pa-10"
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_97, [
                                    createVNode(VTabs, {
                                      direction: "vertical",
                                      color: "#00afb9",
                                      modelValue: $data.tab3,
                                      "onUpdate:modelValue": _cache[60] || (_cache[60] = ($event) => $data.tab3 = $event)
                                    }, {
                                      default: withCtx(() => [
                                        $data.esfigmoAvailable ? (openBlock(), createBlock(VTab, {
                                          key: 0,
                                          onClick: _cache[55] || (_cache[55] = ($event) => $options.changeVsPathGif("e"))
                                        }, {
                                          default: withCtx(() => [
                                            _hoisted_98
                                          ]),
                                          _: 1
                                        })) : createCommentVNode("", true),
                                        createVNode(VTab, {
                                          onClick: _cache[56] || (_cache[56] = ($event) => $options.changeVsPathGif("o"))
                                        }, {
                                          default: withCtx(() => [
                                            _hoisted_99
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VTab, {
                                          onClick: _cache[57] || (_cache[57] = ($event) => $options.changeVsPathGif("w"))
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VIcon, { size: "32" }, {
                                              default: withCtx(() => [
                                                createTextVNode(" mdi-weight ")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VTab, {
                                          onClick: _cache[58] || (_cache[58] = ($event) => $options.changeVsPathGif("h"))
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VIcon, { size: "32" }, {
                                              default: withCtx(() => [
                                                createTextVNode(" mdi-human-male-height ")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VTab, {
                                          onClick: _cache[59] || (_cache[59] = ($event) => $options.changeVsPathGif("t"))
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VIcon, { size: "32" }, {
                                              default: withCtx(() => [
                                                createTextVNode(" mdi-thermometer-lines ")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["modelValue"]),
                                    createVNode(VWindow, {
                                      modelValue: $data.tab3,
                                      "onUpdate:modelValue": _cache[66] || (_cache[66] = ($event) => $data.tab3 = $event)
                                    }, {
                                      default: withCtx(() => [
                                        $data.esfigmoAvailable ? (openBlock(), createBlock(VWindowItem, { key: 0 }, {
                                          default: withCtx(() => [
                                            createVNode(_component_DiasSysComponent, {
                                              modelValue: $data.formvitalsign,
                                              "onUpdate:modelValue": _cache[61] || (_cache[61] = ($event) => $data.formvitalsign = $event),
                                              requestVsFunction: $options.requestSvFunction,
                                              requestVs: $data.typeRequest.requestSv,
                                              sendDataCabin: $options.sendVsDataCabin,
                                              cabin: $data.cabinId,
                                              hasTwoVs: "",
                                              vsNameToRequest: $data.vitalSigns.esfigmo,
                                              sisKeyVsToSend: $data.keyVsToSend.sis,
                                              diasKeyVsToSend: $data.keyVsToSend.dias,
                                              confirmRequest: $data.typeRequest.confirmSv,
                                              sisValue: this.formvitalsign.systolic_pressure,
                                              diasValue: this.formvitalsign.diastolic_pressure,
                                              disabledButton: this.disabledButton
                                            }, null, 8, ["modelValue", "requestVsFunction", "requestVs", "sendDataCabin", "cabin", "vsNameToRequest", "sisKeyVsToSend", "diasKeyVsToSend", "confirmRequest", "sisValue", "diasValue", "disabledButton"])
                                          ]),
                                          _: 1
                                        })) : createCommentVNode("", true),
                                        createVNode(VWindowItem, null, {
                                          default: withCtx(() => [
                                            createVNode(_component_HeartRateComponent, {
                                              modelValue: $data.formvitalsign,
                                              "onUpdate:modelValue": _cache[62] || (_cache[62] = ($event) => $data.formvitalsign = $event),
                                              requestVsFunction: $options.requestSvFunction,
                                              requestVs: $data.typeRequest.requestSv,
                                              sendDataCabin: $options.sendVsDataCabin,
                                              cabin: $data.cabinId,
                                              hasTwoVs: "",
                                              vsNameToRequest: $data.vitalSigns.oxygen,
                                              bpmKeyVsToSend: $data.keyVsToSend.bpm,
                                              spo2KeyVsToSend: $data.keyVsToSend.spo2,
                                              confirmRequest: $data.typeRequest.confirmSv,
                                              bpmValue: this.formvitalsign.heart_rate,
                                              spo2Value: this.formvitalsign.oxygen,
                                              disabledButton: this.disabledButton
                                            }, null, 8, ["modelValue", "requestVsFunction", "requestVs", "sendDataCabin", "cabin", "vsNameToRequest", "bpmKeyVsToSend", "spo2KeyVsToSend", "confirmRequest", "bpmValue", "spo2Value", "disabledButton"])
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VWindowItem, null, {
                                          default: withCtx(() => [
                                            createVNode(_component_WeightComponent, {
                                              modelValue: $data.formvitalsign,
                                              "onUpdate:modelValue": _cache[63] || (_cache[63] = ($event) => $data.formvitalsign = $event),
                                              requestVsFunction: $options.requestSvFunction,
                                              requestVs: $data.typeRequest.requestSv,
                                              sendDataCabin: $options.sendVsDataCabin,
                                              cabin: $data.cabinId,
                                              hasTwoVs: false,
                                              vsNameToRequest: $data.vitalSigns.weight,
                                              weightKeyVsToSend: $data.keyVsToSend.weight,
                                              confirmRequest: $data.typeRequest.confirmSv,
                                              weightValue: this.formvitalsign.weight,
                                              disabledButton: this.disabledButton
                                            }, null, 8, ["modelValue", "requestVsFunction", "requestVs", "sendDataCabin", "cabin", "vsNameToRequest", "weightKeyVsToSend", "confirmRequest", "weightValue", "disabledButton"])
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VWindowItem, null, {
                                          default: withCtx(() => [
                                            createVNode(_component_HeightComponent, {
                                              modelValue: $data.formvitalsign,
                                              "onUpdate:modelValue": _cache[64] || (_cache[64] = ($event) => $data.formvitalsign = $event),
                                              requestVsFunction: $options.requestSvFunction,
                                              requestVs: $data.typeRequest.requestSv,
                                              sendDataCabin: $options.sendVsDataCabin,
                                              cabin: $data.cabinId,
                                              hasTwoVs: false,
                                              vsNameToRequest: $data.vitalSigns.height,
                                              heightKeyVsToSend: $data.keyVsToSend.height,
                                              confirmRequest: $data.typeRequest.confirmSv,
                                              heightValue: this.formvitalsign.height,
                                              disabledButton: this.disabledButton
                                            }, null, 8, ["modelValue", "requestVsFunction", "requestVs", "sendDataCabin", "cabin", "vsNameToRequest", "heightKeyVsToSend", "confirmRequest", "heightValue", "disabledButton"])
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VWindowItem, null, {
                                          default: withCtx(() => [
                                            createVNode(_component_TemperatureComponent, {
                                              modelValue: $data.formvitalsign,
                                              "onUpdate:modelValue": _cache[65] || (_cache[65] = ($event) => $data.formvitalsign = $event),
                                              requestVsFunction: $options.requestSvFunction,
                                              requestVs: $data.typeRequest.requestSv,
                                              sendDataCabin: $options.sendVsDataCabin,
                                              cabin: $data.cabinId,
                                              hasTwoVs: false,
                                              vsNameToRequest: $data.vitalSigns.temperature,
                                              tmpKeyVsToSend: $data.keyVsToSend.tmp,
                                              confirmRequest: $data.typeRequest.confirmSv,
                                              tmpValue: this.formvitalsign.temperature,
                                              disabledButton: this.disabledButton
                                            }, null, 8, ["modelValue", "requestVsFunction", "requestVs", "sendDataCabin", "cabin", "vsNameToRequest", "tmpKeyVsToSend", "confirmRequest", "tmpValue", "disabledButton"])
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }, 8, ["modelValue"])
                                  ]),
                                  _hoisted_100,
                                  createVNode(_component_VitalSignsResults, {
                                    weight: this.formvitalsign.weight,
                                    height: this.formvitalsign.height,
                                    oxygen: this.formvitalsign.oxygen,
                                    bpmF: this.formvitalsign.heart_rate,
                                    temperature: this.formvitalsign.temperature,
                                    systolicPressure: this.formvitalsign.systolic_pressure,
                                    diastolicPressure: this.formvitalsign.diastolic_pressure,
                                    esfigmoAvailable: $data.esfigmoAvailable,
                                    imc: $data.imc
                                  }, null, 8, ["weight", "height", "oxygen", "bpmF", "temperature", "systolicPressure", "diastolicPressure", "esfigmoAvailable", "imc"])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          $data.sthetoAvailable ? (openBlock(), createBlock(VWindowItem, { key: 0 }, {
                            default: withCtx(() => [
                              createVNode(VCard, {
                                flat: "",
                                class: "pa-10"
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_101, [
                                    createVNode(VTabs, {
                                      direction: "vertical",
                                      color: "#00afb9",
                                      "justify-tab-title": "start"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VTab, null, {
                                          default: withCtx(() => [
                                            createVNode(VIcon, { size: "x-large" }, {
                                              default: withCtx(() => [
                                                createTextVNode("mdi-stethoscope")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VWindow, { dire: "" }, {
                                      default: withCtx(() => [
                                        createVNode(VWindowItem, null, {
                                          default: withCtx(() => [
                                            createVNode(VBtn, {
                                              dark: $data.estetoR,
                                              variant: !$data.estetoR && "outlined",
                                              onClick: _cache[67] || (_cache[67] = ($event) => $options.switchMic()),
                                              elevation: "0",
                                              color: $data.estetoR ? "#00afb9" : "black"
                                            }, {
                                              default: withCtx(() => [
                                                createTextVNode(toDisplayString($data.stethoText), 1)
                                              ]),
                                              _: 1
                                            }, 8, ["dark", "variant", "color"]),
                                            $data.estetoR ? (openBlock(), createElementBlock("div", _hoisted_102, [
                                              createVNode(VRow, {
                                                class: "ma-2",
                                                justify: "start"
                                              }, {
                                                default: withCtx(() => [
                                                  createBaseVNode("div", _hoisted_103, [
                                                    createVNode(VBtn, {
                                                      disabled: $data.sthetoMinVol,
                                                      variant: "outlined",
                                                      color: "#00afb9",
                                                      size: "small",
                                                      onClick: _cache[68] || (_cache[68] = ($event) => $options.settingVolume("stheto-min")),
                                                      class: "ma-1 pt-4 pb-4"
                                                    }, {
                                                      default: withCtx(() => [
                                                        createVNode(VIcon, {
                                                          dark: "",
                                                          size: "20"
                                                        }, {
                                                          default: withCtx(() => [
                                                            createTextVNode("mdi-volume-minus")
                                                          ]),
                                                          _: 1
                                                        })
                                                      ]),
                                                      _: 1
                                                    }, 8, ["disabled"])
                                                  ]),
                                                  createBaseVNode("div", _hoisted_104, [
                                                    createVNode(VBtn, {
                                                      disabled: $data.sthetoSaveVol,
                                                      elevation: "0",
                                                      dark: !$data.sthetoSaveVol,
                                                      size: "small",
                                                      onClick: _cache[69] || (_cache[69] = ($event) => $options.settingVolume("stheto-save")),
                                                      color: "#00afb9",
                                                      class: "ma-1 ml-2 pt-4 pb-4"
                                                    }, {
                                                      default: withCtx(() => [
                                                        createVNode(VIcon, {
                                                          dark: "",
                                                          size: "20"
                                                        }, {
                                                          default: withCtx(() => [
                                                            createTextVNode("mdi-content-save")
                                                          ]),
                                                          _: 1
                                                        })
                                                      ]),
                                                      _: 1
                                                    }, 8, ["disabled", "dark"])
                                                  ]),
                                                  createBaseVNode("div", _hoisted_105, [
                                                    createVNode(VBtn, {
                                                      disabled: $data.sthetoUpVol,
                                                      variant: "outlined",
                                                      size: "small",
                                                      color: "#00afb9",
                                                      onClick: _cache[70] || (_cache[70] = ($event) => $options.settingVolume("stheto-up")),
                                                      class: "ma-1 ml-2 pt-4 pb-4"
                                                    }, {
                                                      default: withCtx(() => [
                                                        createVNode(VIcon, {
                                                          dark: "",
                                                          size: "20"
                                                        }, {
                                                          default: withCtx(() => [
                                                            createTextVNode("mdi-volume-plus")
                                                          ]),
                                                          _: 1
                                                        })
                                                      ]),
                                                      _: 1
                                                    }, 8, ["disabled"])
                                                  ])
                                                ]),
                                                _: 1
                                              })
                                            ])) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ])
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })) : createCommentVNode("", true),
                          createVNode(VWindowItem, null, {
                            default: withCtx(() => [
                              createVNode(_component_PrescriptionsComponent, {
                                assistant: this.assistant,
                                assistantId: this.assistantId,
                                cabin: this.cabinId,
                                consultation: this.consultationId.toString(),
                                prescriptions: $data.patientPrescriptions,
                                patientFirstName: this.pfname,
                                patientLastName: this.plname,
                                patientProfilePicture: $data.patientProfilePicture,
                                requestVsFunction: $options.createOrSearchPatient
                              }, null, 8, ["assistant", "assistantId", "cabin", "consultation", "prescriptions", "patientFirstName", "patientLastName", "patientProfilePicture", "requestVsFunction"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }, 8, ["modelValue"])
                    ]),
                    _: 1
                  }),
                  withDirectives(createBaseVNode("div", null, [
                    createVNode(VAlert, {
                      text: "",
                      type: "warning",
                      prominent: "",
                      border: "start",
                      class: "ma-8 pa-5",
                      icon: "mdi-video-off"
                    }, {
                      default: withCtx(() => [
                        _hoisted_106,
                        _hoisted_107
                      ]),
                      _: 1
                    })
                  ], 512), [
                    [vShow, $data.cameraNotReadable]
                  ])
                ])
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }),
      createBaseVNode("div", _hoisted_108, [
        createVNode(VDialog, {
          modelValue: $data.statusDoor,
          "onUpdate:modelValue": _cache[74] || (_cache[74] = ($event) => $data.statusDoor = $event),
          width: "500"
        }, {
          default: withCtx(() => [
            createVNode(VCard, null, {
              default: withCtx(() => [
                $data.doorOpened ? (openBlock(), createElementBlock("div", _hoisted_109, [
                  createVNode(VCardTitle, { class: "text-h5 bg-red text-white" }, {
                    default: withCtx(() => [
                      createTextVNode(" ¡Aviso - Puerta Cabina! ")
                    ]),
                    _: 1
                  })
                ])) : $data.doorClosed ? (openBlock(), createElementBlock("div", _hoisted_110, [
                  createVNode(VCardTitle, { class: "text-h5 bg-green text-white" }, {
                    default: withCtx(() => [
                      createTextVNode(" ¡Aviso - Puerta Cabina! ")
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true),
                $data.doorOpened ? (openBlock(), createElementBlock("div", _hoisted_111, [
                  createVNode(VCardText, { class: "text-h6 mt-3" }, {
                    default: withCtx(() => [
                      createTextVNode(" ¡La puerta de la cabina se encuentra abierta! "),
                      _hoisted_112,
                      createTextVNode("Indicar al paciente cerrarla de manera adecuada. ")
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true),
                $data.doorClosed ? (openBlock(), createElementBlock("div", _hoisted_113, [
                  createVNode(VCardText, { class: "text-h6 mt-3" }, {
                    default: withCtx(() => [
                      createTextVNode(" ¡Puerta cerrada correctamente! ")
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true),
                createVNode(VDivider),
                createVNode(VCardActions, null, {
                  default: withCtx(() => [
                    createVNode(VSpacer),
                    $data.doorClosed ? (openBlock(), createElementBlock("div", _hoisted_114, [
                      createVNode(VBtn, {
                        color: "#00afb9",
                        variant: "text",
                        onClick: _cache[72] || (_cache[72] = ($event) => $data.statusDoor = false)
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" Aceptar ")
                        ]),
                        _: 1
                      })
                    ])) : $data.doorOpened ? (openBlock(), createElementBlock("div", _hoisted_115, [
                      createVNode(VBtn, {
                        color: "#00afb9",
                        variant: "text",
                        onClick: _cache[73] || (_cache[73] = ($event) => $data.statusDoor = false)
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" Aceptar ")
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createBaseVNode("div", null, [
          createVNode(VOverlay, {
            "model-value": $data.overlay,
            opacity: "0.5"
          }, {
            default: withCtx(() => [
              createVNode(VProgressCircular, {
                indeterminate: "",
                size: "64"
              })
            ]),
            _: 1
          }, 8, ["model-value"])
        ])
      ]),
      createBaseVNode("div", null, [
        createVNode(VSnackbar, {
          modelValue: $data.snackbarVar,
          "onUpdate:modelValue": _cache[75] || (_cache[75] = ($event) => $data.snackbarVar = $event),
          "max-width": "170",
          "min-width": "170"
        }, {
          default: withCtx(() => [
            createVNode(VRow, { justify: "space-around" }, {
              default: withCtx(() => [
                _hoisted_116,
                createBaseVNode("div", _hoisted_117, toDisplayString(this.textVol), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]),
      createVNode(_component_notifications, { group: "camera" })
    ]),
    _: 1
  });
}
const CallCenterInformation = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-507f268c"]]);
/*!
 * vuex v4.1.0
 * (c) 2022 Evan You
 * @license MIT
 */
var storeKey = "store";
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function(key) {
    return fn(obj[key], key);
  });
}
function isObject(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function partial(fn, arg) {
  return function() {
    return fn(arg);
  };
}
function genericSubscribe(fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend ? subs.unshift(fn) : subs.push(fn);
  }
  return function() {
    var i2 = subs.indexOf(fn);
    if (i2 > -1) {
      subs.splice(i2, 1);
    }
  };
}
function resetStore(store2, hot) {
  store2._actions = /* @__PURE__ */ Object.create(null);
  store2._mutations = /* @__PURE__ */ Object.create(null);
  store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state2 = store2.state;
  installModule(store2, state2, [], store2._modules.root, true);
  resetStoreState(store2, state2, hot);
}
function resetStoreState(store2, state2, hot) {
  var oldState = store2._state;
  var oldScope = store2._scope;
  store2.getters = {};
  store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store2._wrappedGetters;
  var computedObj = {};
  var computedCache = {};
  var scope = effectScope(true);
  scope.run(function() {
    forEachValue(wrappedGetters, function(fn, key) {
      computedObj[key] = partial(fn, store2);
      computedCache[key] = computed(function() {
        return computedObj[key]();
      });
      Object.defineProperty(store2.getters, key, {
        get: function() {
          return computedCache[key].value;
        },
        enumerable: true
        // for local getters
      });
    });
  });
  store2._state = reactive({
    data: state2
  });
  store2._scope = scope;
  if (store2.strict) {
    enableStrictMode(store2);
  }
  if (oldState) {
    if (hot) {
      store2._withCommit(function() {
        oldState.data = null;
      });
    }
  }
  if (oldScope) {
    oldScope.stop();
  }
}
function installModule(store2, rootState, path, module2, hot) {
  var isRoot = !path.length;
  var namespace = store2._modules.getNamespace(path);
  if (module2.namespaced) {
    if (store2._modulesNamespaceMap[namespace] && false) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store2._modulesNamespaceMap[namespace] = module2;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store2._withCommit(function() {
      parentState[moduleName] = module2.state;
    });
  }
  var local = module2.context = makeLocalContext(store2, namespace, path);
  module2.forEachMutation(function(mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store2, namespacedType, mutation, local);
  });
  module2.forEachAction(function(action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store2, type, handler, local);
  });
  module2.forEachGetter(function(getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store2, namespacedType, getter, local);
  });
  module2.forEachChild(function(child, key) {
    installModule(store2, rootState, path.concat(key), child, hot);
  });
}
function makeLocalContext(store2, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
      }
      return store2.dispatch(type, payload);
    },
    commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
      }
      store2.commit(type, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store2.getters;
      } : function() {
        return makeLocalGetters(store2, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store2.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store2, namespace) {
  if (!store2._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store2.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store2.getters[type];
        },
        enumerable: true
      });
    });
    store2._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store2._makeLocalGettersCache[namespace];
}
function registerMutation(store2, type, handler, local) {
  var entry = store2._mutations[type] || (store2._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store2, local.state, payload);
  });
}
function registerAction(store2, type, handler, local) {
  var entry = store2._actions[type] || (store2._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store2, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store2.getters,
      rootState: store2.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store2._devtoolHook) {
      return res.catch(function(err) {
        store2._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store2, type, rawGetter, local) {
  if (store2._wrappedGetters[type]) {
    return;
  }
  store2._wrappedGetters[type] = function wrappedGetter(store3) {
    return rawGetter(
      local.state,
      // local state
      local.getters,
      // local getters
      store3.state,
      // root state
      store3.getters
      // root getters
    );
  };
}
function enableStrictMode(store2) {
  watch(function() {
    return store2._state.data;
  }, function() {
  }, { deep: true, flush: "sync" });
}
function getNestedState(state2, path) {
  return path.reduce(function(state3, key) {
    return state3[key];
  }, state2);
}
function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }
  return { type, payload, options };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app2, store2) {
  setupDevtoolsPlugin(
    {
      id: "org.vuejs.vuex",
      app: app2,
      label: "Vuex",
      homepage: "https://next.vuex.vuejs.org/",
      logo: "https://vuejs.org/images/icons/favicon-96x96.png",
      packageName: "vuex",
      componentStateTypes: [LABEL_VUEX_BINDINGS]
    },
    function(api) {
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: "Vuex Mutations",
        color: COLOR_LIME_500
      });
      api.addTimelineLayer({
        id: ACTIONS_LAYER_ID,
        label: "Vuex Actions",
        color: COLOR_LIME_500
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Vuex",
        icon: "storage",
        treeFilterPlaceholder: "Filter stores..."
      });
      api.on.getInspectorTree(function(payload) {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          if (payload.filter) {
            var nodes = [];
            flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
            payload.rootNodes = nodes;
          } else {
            payload.rootNodes = [
              formatStoreForInspectorTree(store2._modules.root, "")
            ];
          }
        }
      });
      api.on.getInspectorState(function(payload) {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          makeLocalGetters(store2, modulePath);
          payload.state = formatStoreForInspectorState(
            getStoreModule(store2._modules, modulePath),
            modulePath === "root" ? store2.getters : store2._makeLocalGettersCache,
            modulePath
          );
        }
      });
      api.on.editInspectorState(function(payload) {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          var path = payload.path;
          if (modulePath !== "root") {
            path = modulePath.split("/").filter(Boolean).concat(path);
          }
          store2._withCommit(function() {
            payload.set(store2._state.data, path, payload.state.value);
          });
        }
      });
      store2.subscribe(function(mutation, state2) {
        var data2 = {};
        if (mutation.payload) {
          data2.payload = mutation.payload;
        }
        data2.state = state2;
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: mutation.type,
            data: data2
          }
        });
      });
      store2.subscribeAction({
        before: function(action, state2) {
          var data2 = {};
          if (action.payload) {
            data2.payload = action.payload;
          }
          action._id = actionId++;
          action._time = Date.now();
          data2.state = state2;
          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: action._time,
              title: action.type,
              groupId: action._id,
              subtitle: "start",
              data: data2
            }
          });
        },
        after: function(action, state2) {
          var data2 = {};
          var duration = Date.now() - action._time;
          data2.duration = {
            _custom: {
              type: "duration",
              display: duration + "ms",
              tooltip: "Action duration",
              value: duration
            }
          };
          if (action.payload) {
            data2.payload = action.payload;
          }
          data2.state = state2;
          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: action.type,
              groupId: action._id,
              subtitle: "end",
              data: data2
            }
          });
        }
      });
    }
  );
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path) {
  return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module2, path) {
  return {
    id: path || "root",
    // all modules end with a `/`, we want the last segment only
    // cart/ -> cart
    // nested/cart/ -> cart
    label: extractNameFromPath(path),
    tags: module2.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module2._children).map(
      function(moduleName) {
        return formatStoreForInspectorTree(
          module2._children[moduleName],
          path + moduleName + "/"
        );
      }
    )
  };
}
function flattenStoreForInspectorTree(result, module2, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || "root",
      label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
      tags: module2.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module2._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result, module2._children[moduleName], filter, path + moduleName + "/");
  });
}
function formatStoreForInspectorState(module2, getters2, path) {
  getters2 = path === "root" ? getters2 : getters2[path];
  var gettersKeys = Object.keys(getters2);
  var storeState = {
    state: Object.keys(module2.state).map(function(key) {
      return {
        key,
        editable: true,
        value: module2.state[key]
      };
    })
  };
  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters2);
    storeState.getters = Object.keys(tree).map(function(key) {
      return {
        key: key.endsWith("/") ? extractNameFromPath(key) : key,
        editable: false,
        value: canThrow(function() {
          return tree[key];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters2) {
  var result = {};
  Object.keys(getters2).forEach(function(key) {
    var path = key.split("/");
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function(p2) {
        if (!target[p2]) {
          target[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target = target[p2]._custom.value;
      });
      target[leafKey] = canThrow(function() {
        return getters2[key];
      });
    } else {
      result[key] = canThrow(function() {
        return getters2[key];
      });
    }
  });
  return result;
}
function getStoreModule(moduleMap, path) {
  var names = path.split("/").filter(function(n) {
    return n;
  });
  return names.reduce(
    function(module2, moduleName, i2) {
      var child = module2[moduleName];
      if (!child) {
        throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
      }
      return i2 === names.length - 1 ? child : child._children;
    },
    path === "root" ? moduleMap : moduleMap.root._children
  );
}
function canThrow(cb) {
  try {
    return cb();
  } catch (e) {
    return e;
  }
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key, module2) {
  this._children[key] = module2;
};
Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};
Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};
Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};
Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};
Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};
Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path) {
  return path.reduce(function(module2, key) {
    return module2.getChild(key);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module2 = this.root;
  return path.reduce(function(namespace, key) {
    module2 = module2.getChild(key);
    return namespace + (module2.namespaced ? key + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update2([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);
  if (!child) {
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent.removeChild(key);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (parent) {
    return parent.hasChild(key);
  }
  return false;
};
function update2(path, targetModule, newModule) {
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        return;
      }
      update2(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}
function createStore$1(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools = options.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._scope = null;
  this._devtools = devtools;
  var store2 = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch2.call(store2, type, payload);
  };
  this.commit = function boundCommit(type, payload, options2) {
    return commit2.call(store2, type, payload, options2);
  };
  this.strict = strict;
  var state2 = this._modules.root.state;
  installModule(this, state2, [], this._modules.root);
  resetStoreState(this, state2);
  plugins.forEach(function(plugin) {
    return plugin(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install(app2, injectKey) {
  app2.provide(injectKey || storeKey, this);
  app2.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : false;
  if (useDevtools) {
    addDevtools(app2, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v) {
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type = ref2.type;
  var payload = ref2.payload;
  var mutation = { type, payload };
  var entry = this._mutations[type];
  if (!entry) {
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type = ref2.type;
  var payload = ref2.payload;
  var action = { type, payload };
  var entry = this._actions[type];
  if (!entry) {
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e) {
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve2, reject) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e) {
      }
      resolve2(res);
    }, function(error) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error);
        });
      } catch (e) {
      }
      reject(error);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn, options) {
  return genericSubscribe(fn, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn, options) {
  var subs = typeof fn === "function" ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1(getter, cb, options) {
  var this$1$1 = this;
  return watch(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state2) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state2;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
var mapMutations = normalizeNamespace(function(namespace, mutations2) {
  var res = {};
  normalizeMap(mutations2).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    res[key] = function mappedMutation() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var commit2 = this.$store.commit;
      if (namespace) {
        var module2 = getModuleByNamespace(this.$store, "mapMutations", namespace);
        if (!module2) {
          return;
        }
        commit2 = module2.context.commit;
      }
      return typeof val === "function" ? val.apply(this, [commit2].concat(args)) : commit2.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
var mapGetters = normalizeNamespace(function(namespace, getters2) {
  var res = {};
  normalizeMap(getters2).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, "mapGetters", namespace)) {
        return;
      }
      return this.$store.getters[val];
    };
    res[key].vuex = true;
  });
  return res;
});
var mapActions = normalizeNamespace(function(namespace, actions2) {
  var res = {};
  normalizeMap(actions2).forEach(function(ref2) {
    var key = ref2.key;
    var val = ref2.val;
    res[key] = function mappedAction() {
      var args = [], len = arguments.length;
      while (len--)
        args[len] = arguments[len];
      var dispatch2 = this.$store.dispatch;
      if (namespace) {
        var module2 = getModuleByNamespace(this.$store, "mapActions", namespace);
        if (!module2) {
          return;
        }
        dispatch2 = module2.context.dispatch;
      }
      return typeof val === "function" ? val.apply(this, [dispatch2].concat(args)) : dispatch2.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
function normalizeMap(map2) {
  if (!isValidMap(map2)) {
    return [];
  }
  return Array.isArray(map2) ? map2.map(function(key) {
    return { key, val: key };
  }) : Object.keys(map2).map(function(key) {
    return { key, val: map2[key] };
  });
}
function isValidMap(map2) {
  return Array.isArray(map2) || isObject(map2);
}
function normalizeNamespace(fn) {
  return function(namespace, map2) {
    if (typeof namespace !== "string") {
      map2 = namespace;
      namespace = "";
    } else if (namespace.charAt(namespace.length - 1) !== "/") {
      namespace += "/";
    }
    return fn(namespace, map2);
  };
}
function getModuleByNamespace(store2, helper, namespace) {
  var module2 = store2._modulesNamespaceMap[namespace];
  return module2;
}
const LoginPage_vue_vue_type_style_index_0_scoped_94702e1e_lang = "";
const VMain$1 = "";
const makeVMainProps = propsFactory({
  scrollable: Boolean,
  ...makeComponentProps(),
  ...makeTagProps({
    tag: "main"
  })
}, "VMain");
const VMain = genericComponent()({
  name: "VMain",
  props: makeVMainProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      mainStyles
    } = useLayout();
    const {
      ssrBootStyles
    } = useSsrBoot();
    useRender(() => createVNode(props.tag, {
      "class": ["v-main", {
        "v-main--scrollable": props.scrollable
      }, props.class],
      "style": [mainStyles.value, ssrBootStyles.value, props.style]
    }, {
      default: () => [props.scrollable ? createVNode("div", {
        "class": "v-main__scroller"
      }, [slots.default?.()]) : slots.default?.()]
    }));
    return {};
  }
});
const _sfc_main$2 = {
  data: () => ({
    loading: false,
    loader: null,
    form: {
      email: "",
      password: ""
    },
    cabin: "",
    isDemoChannel: false,
    isInstallerChannel: false,
    isTestingChannel: false,
    isOperationsChannel: false
  }),
  props: {
    source: String
  },
  mounted() {
    if (localStorage.getItem("reloaded")) {
      localStorage.removeItem("reloaded");
    } else {
      localStorage.setItem("reloaded", "1");
      setTimeout(function() {
        window.location.reload();
      }.bind(this), 5e3);
    }
  },
  created() {
    if (localStorage.getItem("idAssistant")) {
      this.isDemoChannel = localStorage.getItem("is_demo");
      this.isInstallerChannel = localStorage.getItem("is_installer");
      this.isTestingChannel = localStorage.getItem("is_testing");
      this.isOperationsChannel = localStorage.getItem("is_operations");
    }
  },
  watch: {
    loader() {
      const l = this.loader;
      this[l] = !this[l];
      setTimeout(() => this[l] = false, 3e3);
      this.loader = null;
    }
  },
  methods: {
    ...mapActions(["loginAPI", "fetchAssistant"]),
    login() {
      var url2 = `${API_URL}api/staff/assistant/`;
      axios$1.get(url2, {
        headers: {
          "Authorization": `Token ${TOKEN}`
        }
      }).then((res) => {
        for (let index = 0; index < res.data.length; index++) {
          if (this.form.email === res.data[index]["email"] && this.form.password === res.data[index]["password"]) {
            localStorage.setItem("entity_id", res.data[index]["entity"]);
            localStorage.setItem("idAssistant", res.data[index]["id"]);
            this.loginAPI(localStorage.getItem("idAssistant"));
            switch (true) {
              case res.data[index]["is_demo"]:
                localStorage.setItem("is_demo", res.data[index]["is_demo"]);
                break;
              case res.data[index]["is_installer"]:
                localStorage.setItem("is_installer", res.data[index]["is_installer"]);
                break;
              case res.data[index]["is_testing"]:
                localStorage.setItem("is_testing", res.data[index]["is_testing"]);
                break;
              case res.data[index]["is_operation"]:
                localStorage.setItem("is_operations", res.data[index]["is_operation"]);
                break;
            }
            this.$router.push(`/dashboard/assistant-${res.data[index]["id"]}/ent-${res.data[index]["entity"]}`);
          } else {
            console.error("didnt match ");
          }
        }
      });
    }
  }
};
const _withScopeId$1 = (n) => (pushScopeId("data-v-94702e1e"), n = n(), popScopeId(), n);
const _hoisted_1$2 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h1", { class: "text-center text-h3 text-light-blue-accent-1" }, " WELCOME ASSISTANT! ", -1));
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-center mt-4" }, [
  /* @__PURE__ */ createBaseVNode("img", {
    height: "50",
    src: _imports_0,
    alt: ""
  })
], -1));
const _hoisted_3$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h4", { class: "text-center mt-4 text-grey darken-1--text" }, " Bitmec is a digital health system that delivers quality medical care at low cost to underserved rural areas ", -1));
const _hoisted_4$1 = { class: "text-center" };
const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Iniciando...", -1));
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(VApp, {
    id: "inspire",
    class: "back"
  }, {
    default: withCtx(() => [
      createVNode(VMain, null, {
        default: withCtx(() => [
          createVNode(VContainer, {
            class: "fill-height",
            fluid: ""
          }, {
            default: withCtx(() => [
              createVNode(VRow, {
                align: "center",
                justify: "center"
              }, {
                default: withCtx(() => [
                  createVNode(VCol, {
                    cols: "12",
                    sm: "8",
                    md: "8"
                  }, {
                    default: withCtx(() => [
                      createVNode(VCard, {
                        color: "white",
                        class: "elevation-12"
                      }, {
                        default: withCtx(() => [
                          createVNode(VRow, null, {
                            default: withCtx(() => [
                              createVNode(VCol, {
                                cols: "12",
                                md: "10"
                              }, {
                                default: withCtx(() => [
                                  createVNode(VCardText, { class: "mt-12" }, {
                                    default: withCtx(() => [
                                      _hoisted_1$2,
                                      _hoisted_2$1,
                                      _hoisted_3$1,
                                      createVNode(VForm, { class: "px-12" }, {
                                        default: withCtx(() => [
                                          createVNode(VTextField, {
                                            modelValue: _ctx.form.email,
                                            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.form.email = $event),
                                            label: "Email",
                                            name: "Email",
                                            "prepend-icon": "mdi-email",
                                            type: "text",
                                            color: "#8DDAFC"
                                          }, null, 8, ["modelValue"]),
                                          createVNode(VTextField, {
                                            modelValue: _ctx.form.password,
                                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.form.password = $event),
                                            id: "password",
                                            label: "Password",
                                            name: "Password",
                                            "prepend-icon": "mdi-lock",
                                            type: "password",
                                            color: "#8DDAFC"
                                          }, null, 8, ["modelValue"])
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  }),
                                  createBaseVNode("div", _hoisted_4$1, [
                                    createVNode(VBtn, {
                                      class: "ma-2 text-white",
                                      loading: _ctx.loading,
                                      disabled: _ctx.loading,
                                      color: "#8DDAFC",
                                      onClick: _cache[2] || (_cache[2] = ($event) => (_ctx.loader = "loading", $options.login()))
                                    }, {
                                      loader: withCtx(() => [
                                        _hoisted_5$1
                                      ]),
                                      default: withCtx(() => [
                                        createTextVNode(" Iniciar Sesión ")
                                      ]),
                                      _: 1
                                    }, 8, ["loading", "disabled"])
                                  ])
                                ]),
                                _: 1
                              }),
                              createVNode(VCol, {
                                cols: "12",
                                md: "2",
                                style: { "background": "#8DDAFC" }
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
const LoginPage = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-94702e1e"]]);
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
function useSound(url2, { volume = 1, playbackRate = 1, soundEnabled = true, interrupt = false, autoplay = false, onload, ...delegated } = {}) {
  const HowlConstructor = ref(null);
  const isPlaying = ref(false);
  const duration = ref(null);
  const sound = ref(null);
  function handleLoad() {
    if (typeof onload === "function")
      onload.call(this);
    duration.value = (duration.value || sound.value?.duration() || 0) * 1e3;
    if (autoplay === true) {
      isPlaying.value = true;
    }
  }
  onMounted(async () => {
    const howler = await __vitePreload(() => import("./howler-fc27c35d.js").then((n) => n.h), true ? [] : void 0, import.meta.url);
    HowlConstructor.value = howler.default.Howl;
    sound.value = new HowlConstructor.value({
      src: unref(url2),
      volume: unref(volume),
      rate: unref(playbackRate),
      onload: handleLoad,
      ...delegated
    });
  });
  watch(
    () => [url2],
    () => {
      if (HowlConstructor.value && HowlConstructor.value && sound && sound.value) {
        sound.value = new HowlConstructor.value({
          src: unref(url2),
          volume: unref(volume),
          rate: unref(playbackRate),
          onload: handleLoad,
          ...delegated
        });
      }
    }
  );
  watch(
    () => [unref(volume), unref(playbackRate)],
    () => {
      if (sound.value) {
        sound.value.volume(unref(volume));
        sound.value.rate(unref(playbackRate));
      }
    }
  );
  const play = (options) => {
    if (typeof options === "undefined") {
      options = {};
    }
    if (!sound.value || !soundEnabled && !options.forceSoundEnabled) {
      return;
    }
    if (interrupt) {
      sound.value.stop();
    }
    if (options.playbackRate) {
      sound.value.rate(options.playbackRate);
    }
    sound.value.play(options.id);
    sound.value.once("end", () => {
      if (sound.value && sound.value && !sound.value.playing()) {
        isPlaying.value = false;
      }
    });
    isPlaying.value = true;
  };
  const stop = (id) => {
    if (!sound.value) {
      return;
    }
    sound.value.stop(typeof id === "number" ? id : void 0);
    isPlaying.value = false;
  };
  const pause = (id) => {
    if (!sound.value) {
      return;
    }
    sound.value.pause(typeof id === "number" ? id : void 0);
    isPlaying.value = false;
  };
  const returnedValue = {
    play,
    sound,
    isPlaying,
    duration,
    pause,
    stop
  };
  return returnedValue;
}
const buttonSfx = "" + new URL("phoning-bc64516e.mp3", import.meta.url).href;
const DashboardPrincipal_vue_vue_type_style_index_0_scoped_63d0e47f_lang = "";
const VLayout$1 = "";
const makeVLayoutProps = propsFactory({
  ...makeComponentProps(),
  ...makeLayoutProps()
}, "VLayout");
const VLayout = genericComponent()({
  name: "VLayout",
  props: makeVLayoutProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      layoutClasses,
      layoutStyles,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props);
    useRender(() => createVNode("div", {
      "ref": layoutRef,
      "class": [layoutClasses.value, props.class],
      "style": [layoutStyles.value, props.style]
    }, [slots.default?.()]));
    return {
      getLayoutItem,
      items
    };
  }
});
const VTable$1 = "";
const makeVTableProps = propsFactory({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VTable");
const VTable = genericComponent()({
  name: "VTable",
  props: makeVTableProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    useRender(() => createVNode(props.tag, {
      "class": ["v-table", {
        "v-table--fixed-height": !!props.height,
        "v-table--fixed-header": props.fixedHeader,
        "v-table--fixed-footer": props.fixedFooter,
        "v-table--has-top": !!slots.top,
        "v-table--has-bottom": !!slots.bottom,
        "v-table--hover": props.hover
      }, themeClasses.value, densityClasses.value, props.class],
      "style": props.style
    }, {
      default: () => [slots.top?.(), slots.default ? createVNode("div", {
        "class": "v-table__wrapper",
        "style": {
          height: convertToUnit(props.height)
        }
      }, [createVNode("table", null, [slots.default()])]) : slots.wrapper?.(), slots.bottom?.()]
    }));
    return {};
  }
});
let socket;
const state = reactive({
  connected: false
});
const _sfc_main$1 = {
  setup() {
    const { play, stop } = useSound(buttonSfx);
    return {
      play,
      stop
    };
  },
  data() {
    return {
      isLoading: false,
      value: "",
      speedtest: 0,
      patientDpi: "",
      dialogTakeCallOrNot: false,
      channel: "",
      baseMode: "avc",
      transcode: "interop",
      codec: "h264",
      attendeeMode: "video",
      videoProfile: "360p_1",
      dialog: false,
      loader: null,
      message: "",
      cabin_location: "",
      cabin_entity: "",
      cabin_entity_name: "",
      cabin_no: "",
      cabinChannel: "",
      aId: this.$route.params.assistantId,
      entId: this.$route.params.entityId,
      assistantId: "",
      assistantIsLunch: false,
      assistantIsBreak: false,
      dialogReload: false,
      dialogClose: false,
      dialogTakingCall: false,
      idCall: "",
      isDemoChannel: false,
      isInstallerChannel: false,
      isTestingChannel: false,
      isOperationsChannel: false,
      counterAssistantsCalls: "",
      counterAssistantsCallsToday: "",
      entityId: "",
      overlay: false,
      typeOfCall: "",
      connection: false,
      busyOk: false,
      dialogNew: false,
      dialogTakeCallDoctor: false,
      attempt: 0,
      redirectCall: false,
      stillThere: false,
      timeStampCall: "",
      listCalls: [],
      firstCall: {},
      firstC: [],
      messageConnectingCall: "",
      assistantTakingCall: false,
      changeStatusOfAssistant: false,
      showStillThereAlert: true,
      app_version: "",
      wsConnected: false,
      menu: false,
      itemGroup: 0,
      componentKey: 0,
      entityName: "",
      userType: "",
      getCall: true,
      callTaken: false,
      callIdTaken: "",
      cabinIdTaken: "",
      cabinLocation: "",
      callTimestamp: "",
      clockTime: "",
      dateTime: "",
      doctor: ""
    };
  },
  computed: {
    ...mapGetters(["assistant", "getAssistantCalls"])
  },
  created() {
    this.overlay = !this.overlay;
    this.aId = localStorage.getItem("idAssistant");
    this.entityId = localStorage.getItem("entity_id");
    this.assistantId = localStorage.getItem("idAssistant");
    this.app_version = localStorage.getItem("app_version");
    this.getAssistant();
    this.getLastCall();
    this.connectWebSocket();
    this.reload();
    this.fetchAssistant(this.assistantId);
    this.changeStatusOnInit();
    this.changeAppVersionOfAssistant();
    this.getEntity();
    setInterval(() => {
      if (this.dialogTakeCallOrNot === false) {
        if (this.showStillThereAlert) {
          this.stillThere = true;
        }
      }
    }, 9e5);
    setInterval(() => {
      if (this.getCall) {
        this.getLastCall();
      }
    }, 3e4);
  },
  methods: {
    connectSocketIO() {
      if (this.assistant.first_name != void 0) {
        socket.emit("publish", {
          channel: this.activeChannel,
          message: `set-name:${this.assistant.first_name}${this.assistant.last_name}`
        });
      }
      socket.on("message", (data2) => {
        let content = data2;
        if ("message" in content && "senderId" in content) {
          if (data2.senderId !== socket.id)
            return;
          content = JSON.parse(content["message"]);
        }
        switch (content["type"]) {
          case "test":
            this.callTaken = true;
            break;
        }
        if (this.busyOk == false && this.assistantIsLunch == false && this.assistantIsBreak == false) {
          switch (content["type"]) {
            case "alarm":
              if (content["doctor"] == "ack") {
                this.dialogTakeCallDoctor = false;
                this.stop();
                let headers = {
                  Authorization: `Token ${TOKEN}`,
                  "Content-Type": "application/json;charset=utf-8"
                };
                var path2 = `${API_URL}api/cabin/pos/get-call/${this.callIdTaken}/`;
                axios$1.get(path2, { headers }).then((response) => {
                  if (response.data.assistant != this.aId) {
                    this.dialogClose = true;
                    this.dialogTakeCallOrNot = false;
                    this.redirectCall = true;
                    this.firstCall = {};
                    this.getLastCall();
                    this.getCall = true;
                  } else {
                    this.firstCall = {};
                    this.postSlackMessage(`Se ha iniciado una llamada en la Cabina de telemedicina (${this.cabinIdTaken}) ubicada en ${this.cabinLocation} a las ${this.fixDateAndHour(Date())} atendida por ${this.assistant.first_name} ${this.assistant.last_name}`);
                    setTimeout(() => {
                      this.genericAlert("success", "Llamada conectada", `Cabina No: ${this.cabinIdTaken} Redirigiéndote...`, true, false);
                    }, 2e3);
                  }
                });
              }
              break;
            case "notification-call-testing":
              this.play();
              this.getLastCall();
              this.patientDpi = content["patient-dpi"];
              this.stillThere = false;
              setTimeout(() => {
                this.callIdTaken = localStorage.getItem("call_id");
                this.cabinIdTaken = localStorage.getItem("cabin_t_id");
                this.cabinLocation = localStorage.getItem("cabin_location");
                this.callTimestamp = localStorage.getItem("call_timestamp");
                this.postSlackMessage(`Ha llegado la notificacion al medico ${this.assistant.first_name} ${this.assistant.last_name} en la cabina ${this.cabinIdTaken} a las ${this.fixDateAndHour(Date())}`);
              }, 1e3);
              break;
            case "notification-call-operation":
              this.play();
              this.getLastCall();
              setTimeout(() => {
                this.callIdTaken = localStorage.getItem("call_id");
                this.cabinIdTaken = localStorage.getItem("cabin_t_id");
                this.cabinLocation = localStorage.getItem("cabin_location");
                this.postSlackMessage(`Ha llegado la notificacion al medico ${this.assistant.first_name} ${this.assistant.last_name} en la cabina ${this.cabinIdTaken} a las ${this.fixDateAndHour(Date())}`);
              }, 1e3);
              break;
          }
        }
        var that = this;
        socket.on("disconnect", (reason) => {
          console.log("Socket is closed. Reconnect will be attempted in 1 second.", reason);
          setTimeout(function() {
            console.log("reconnecting...");
            that.connectSocketIO();
          }, 1e3);
        });
        socket.on("connect_error", () => {
          console.error("Closing socket.io");
          state.connected = false;
        });
      });
    },
    getDownloadSpeed() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/speedtest/`;
      axios$1.get(path, { headers }).then((r) => {
        this.speedtest = r.data.download_speed.toFixed(2);
        localStorage.setItem("download_speed", this.speedtest);
      }).catch((err) => {
        this.speedtest = 0;
        console.log(err);
      });
    },
    // clock
    currentTime() {
      const now2 = /* @__PURE__ */ new Date();
      let mins = now2.getMinutes();
      let hour = now2.getHours();
      hour = hour < 10 ? `0${hour}` : hour;
      mins = mins < 10 ? `0${mins}` : mins;
      let time = `${hour}:${mins}`;
      this.clockTime = time;
      this.dateTime = `${now2.getDate()}/${now2.getMonth() + 1}/${now2.getFullYear()}`;
    },
    getEntity() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/entities/${this.entId}/`;
      axios$1.get(path, { headers }).then((response) => {
        this.entityName = response.data["name"];
      }).catch((err) => {
        console.log(err);
      });
    },
    forceRerender() {
      this.componentKey += 1;
    },
    getLastCall() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/get_call_queue_items/${this.entId}`;
      axios$1.get(path, { headers }).then((response) => {
        this.listCalls = response.data;
        if (this.listCalls.length > 0) {
          this.firstCall = this.listCalls[0];
          localStorage.setItem("call_id", this.firstCall["id"]);
          localStorage.setItem("cabin_t_id", this.firstCall["cabin_id"]);
          localStorage.setItem("cabin_location", this.firstCall["location"]);
          localStorage.setItem("call_timestamp", this.firstCall["timestamp"]);
          this.callIdTaken = localStorage.getItem("call_id");
          this.cabinIdTaken = localStorage.getItem("cabin_t_id");
          this.cabinLocation = localStorage.getItem("cabin_location");
          this.callTimestamp = localStorage.getItem("call_timestamp");
          this.forceRerender();
        } else {
          this.listCalls = [];
        }
      }).catch((err) => {
        console.log(err, " error ");
      });
    },
    connectWebSocket: function() {
      try {
        socket = new WebSocket("ws://3.143.233.51:3001/");
        console.log("Web Socket connected!", socket);
        socket.onopen = () => {
          if (this.assistant.first_name != void 0) {
            socket.send(`set-name:${this.assistant.first_name}${this.assistant.last_name}`);
          }
        };
      } catch (err) {
        console.log("error web socket connection", err);
      }
      socket.onmessage = ({ data: data2 }) => {
        let content = JSON.parse(data2);
        if ("message" in content && "channel" in content) {
          if (content.channel !== this.activeChannel)
            return;
          content = content["message"];
        }
        switch (content["type"]) {
          case "test":
            this.callTaken = true;
            break;
        }
        if (this.busyOk == false && this.assistantIsLunch == false && this.assistantIsBreak == false) {
          switch (content["type"]) {
            case "alarm":
              if (content["doctor"] == "ack") {
                this.dialogTakeCallDoctor = false;
                this.stop();
                let headers = {
                  Authorization: `Token ${TOKEN}`,
                  "Content-Type": "application/json;charset=utf-8"
                };
                var path2 = `${API_URL}api/cabin/pos/get-call/${this.callIdTaken}/`;
                axios$1.get(path2, { headers }).then((response) => {
                  if (response.data.assistant != this.aId) {
                    this.dialogClose = true;
                    this.dialogTakeCallOrNot = false;
                    this.redirectCall = true;
                    this.firstCall = {};
                    this.getLastCall();
                    this.getCall = true;
                  } else {
                    this.firstCall = {};
                    this.postSlackMessage(`Se ha iniciado una llamada en la Cabina de telemedicina (${this.cabinIdTaken}) ubicada en ${this.cabinLocation} a las ${this.fixDateAndHour(Date())} atendida por ${this.assistant.first_name} ${this.assistant.last_name}`);
                    setTimeout(() => {
                      this.genericAlert("success", "Llamada conectada", `Cabina No: ${this.cabinIdTaken} Redirigiéndote...`, true, false);
                    }, 2e3);
                  }
                });
              }
              break;
            case "notification-call-testing":
              this.play();
              this.getLastCall();
              this.patientDpi = content["patient-dpi"];
              this.stillThere = false;
              setTimeout(() => {
                this.callIdTaken = localStorage.getItem("call_id");
                this.cabinIdTaken = localStorage.getItem("cabin_t_id");
                this.cabinLocation = localStorage.getItem("cabin_location");
                this.callTimestamp = localStorage.getItem("call_timestamp");
                this.postSlackMessage(`Ha llegado la notificacion al medico ${this.assistant.first_name} ${this.assistant.last_name} en la cabina ${this.cabinIdTaken} a las ${this.fixDateAndHour(Date())}`);
              }, 1e3);
              break;
            case "notification-call-operation":
              this.play();
              this.getLastCall();
              setTimeout(() => {
                this.callIdTaken = localStorage.getItem("call_id");
                this.cabinIdTaken = localStorage.getItem("cabin_t_id");
                this.cabinLocation = localStorage.getItem("cabin_location");
                this.postSlackMessage(`Ha llegado la notificacion al medico ${this.assistant.first_name} ${this.assistant.last_name} en la cabina ${this.cabinIdTaken} a las ${this.fixDateAndHour(Date())}`);
              }, 1e3);
              break;
          }
        }
      };
      var that = this;
      socket.onclose = function(e) {
        console.log("Socket is closed. Reconnect will be attempted in 1 second.", e.reason);
        setTimeout(function() {
          console.log("reconnecting...");
          that.connectWebSocket();
        }, 1e3);
      };
      socket.onerror = function(err) {
        console.error("Socket encountered error: ", err.message, "Closing socket");
        socket.close();
      };
    },
    async changeAppVersionOfAssistant() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/staff/assistant/${this.assistantId}/`;
      await axios$1.patch(path, { "app_version": this.app_version }, { headers }).then((res) => {
        return res.data;
      }).catch((err) => {
        return err;
      });
    },
    async changeStatusOnInit() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/staff/assistant/${this.assistantId}/`;
      await axios$1.patch(path, { is_busy: false, in_break: false, in_lunch: false }, { headers }).then((res) => {
        this.getAssistant();
        return res.data;
      }).catch((err) => {
        return err;
      });
    },
    ...mapMutations(["logOut"]),
    statusActive() {
      this.stillThere = false;
      window.location.reload();
    },
    genericAlert(icon, title, text, redirect, reload) {
      let timerInterval;
      this.$swal({
        icon,
        title,
        text,
        timer: 5e3,
        timerProgressBar: true,
        didOpen: () => {
          this.$swal.showLoading();
        },
        willClose: () => {
          clearInterval(timerInterval);
        }
      }).then((result) => {
        if (redirect) {
          this.changeStatusForCallCenter();
          setTimeout(() => {
            this.$router.push(
              `/cabin-${this.cabinIdTaken}/callcenter/call-${this.callIdTaken}`
            );
          }, 2e3);
        }
        if (reload) {
          window.location.reload();
        }
        return result;
      });
    },
    ...mapActions(["fetchAssistant"]),
    getAssistant() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      axios$1.get(`${API_URL}api/staff/assistant_calls/${this.aId}/`, { headers }).then((response) => {
        this.doctor = `${response.data["first_name"]} ${response.data["last_name"]}`;
        localStorage.setItem("doctor", this.doctor);
        localStorage.setItem("doctorId", response.data["id"]);
        this.connection = false;
        this.busyOk = response.data["is_busy"];
        this.assistantIsLunch = response.data["in_lunch"];
        this.assistantIsBreak = response.data["in_break"];
        this.isDemoChannel = response.data["is_demo"];
        this.isInstallerChannel = response.data["is_installer"];
        this.isTestingChannel = response.data["is_testing"];
        this.isOperationsChannel = response.data["is_operation"];
        this.isDemoChannel = response.data["is_demo"];
        this.isInstallerChannel = response.data["is_installer"];
        this.isTestingChannel = response.data["is_testing"];
        this.isOperationsChannel = response.data["is_operation"];
        this.assistantFirstName = response.data["first_name"];
        this.assistantLastName = response.data["last_name"];
        this.itemGroup = this.busyOk ? 1 : 0;
        if (this.isDemoChannel == true) {
          this.userType = "Demos";
          this.activeChannel = `is-demo-channel-${response.data["entity"]}`;
        } else if (this.isInstallerChannel == true) {
          this.userType = "Instaladores";
          this.activeChannel = `is-installer-channel-${response.data["entity"]}`;
        } else if (this.isTestingChannel == true) {
          this.userType = "Pruebas";
          this.activeChannel = `is-testing-channel-${response.data["entity"]}`;
        } else if (this.isOperationsChannel) {
          this.userType = "Operaciones";
          this.activeChannel = `is-operations-channel-${response.data["entity"]}`;
        }
        socket.emit("publish", {
          channel: this.activeChannel,
          message: `set-name:${this.assistantFirstName}${this.assistantLastName}`
        });
      }).catch((err) => {
        if (err.message == "Network Error") {
          this.connection = true;
          this.$swal.fire({
            title: "Conexión",
            text: `¡No estas conectado a internet!`,
            icon: "warning",
            confirmButtonColor: "#284b63",
            confirmButtonText: "Aceptar",
            showClass: {
              popup: "animate__animated animate__fadeInDown"
            },
            hideClass: {
              popup: "animate__animated animate__fadeOutUp"
            }
          });
        }
        return err;
      });
    },
    reload2() {
      localStorage.removeItem("call_id");
      localStorage.removeItem("cabin_t_id");
      localStorage.removeItem("cabin_location");
      localStorage.removeItem("call_timestamp");
      this.stop();
      this.dialogClose = false;
      this.firstCall = {};
      this.getLastCall();
      this.changeStatusOnInit();
    },
    reload() {
      this.dialogReload = true;
      setTimeout(() => this.dialogReload = false, 3e3);
      window.onload = function() {
        if (!window.location.hash) {
          window.location = window.location + "#loaded";
          window.location.reload();
        }
      };
    },
    logOutApp() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/staff/assistant/${this.aId}/`;
      axios$1.patch(
        path,
        {
          "is_busy": true,
          "in_break": true,
          "in_lunch": true
        },
        { headers }
      ).then((response) => {
        return response;
      }).catch((e) => {
        return e;
      });
      localStorage.clear();
      this.activeChannel = "";
      try {
        const ws = socket;
        ws.send(this.activeChannel);
      } catch (error) {
        console.log(error, "errro ");
        return error;
      }
      localStorage.clear();
      this.$router.push("/login");
      localStorage.removeItem("idAssistant");
      this.logOut();
    },
    async changeStatusOfCabin() {
      this.cabinIdTaken = localStorage.getItem("cabin_t_id");
      this.callIdTaken = localStorage.getItem("call_id");
      this.getCall = false;
      this.stop();
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/get_call_queue/${this.aId}/${this.callIdTaken}`;
      await axios$1.get(path, { headers }).then((response) => {
        if (response.data.result) {
          this.stop();
          this.patchOkCall();
          this.assistantTakingCall = true;
          this.messageConnectingCall = "Tomando llamada...";
          this.dialogTakeCallDoctor = true;
        } else {
          this.stop();
          this.dialogClose = true;
        }
      }).catch((error) => {
        return error;
      });
    },
    docTakeCallView() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      let path = `${API_URL}api/cabin/doctor-call-taken/`;
      axios$1.post(path, {
        "channel": this.activeChannel
      }, { headers }).then((response) => {
        return response.data;
      }).catch((err) => {
        return err;
      });
    },
    patchOkCall() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/cabin/doc-take-call/${this.callIdTaken}/`;
      axios$1.patch(
        path,
        {
          status: 1
        },
        { headers }
      ).then((response) => {
        try {
          const ws = socket;
          ws.send(this.activeChannel);
        } catch (error) {
          return error;
        }
        return response.data;
      });
    },
    async changeStatusForCallCenter() {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/staff/assistant/${this.assistantId}/`;
      await axios$1.patch(path, { is_busy: true }, { headers }).then((res) => {
        this.getAssistant();
        return res.data;
      }).catch((err) => {
        return err;
      });
    },
    async changeStatus(status) {
      let headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      const path = `${API_URL}api/staff/assistant/${this.assistantId}/`;
      await axios$1.patch(
        path,
        {
          is_busy: status ? true : false,
          in_lunch: status ? true : false,
          in_break: status ? true : false
        },
        { headers }
      ).then((res) => {
        this.busyOk = res.data["is_busy"];
        this.assistantIsLunch = res.data["in_lunch"];
        this.assistantIsBreak = res.data["in_break"];
        if (this.busyOk == false) {
          window.location.reload();
        }
        this.getAssistant();
        return res.data;
      }).catch((err) => {
        return err;
      });
    },
    postSlackMessage(text) {
      const headers = {
        Authorization: `Token ${TOKEN}`,
        "Content-Type": "application/json;charset=utf-8"
      };
      axios$1.post(
        `${API_URL}api/cabin/send-message/`,
        {
          "text": text
        },
        { headers }
      ).then((r) => {
        return r.data;
      }).catch((e) => {
        console.log(e);
        return e;
      });
    },
    fixDateAndHour(d) {
      let result = new Date(d).toLocaleString();
      return result + " hrs";
    }
  },
  mounted() {
    this.fetchAssistant(this.assistantId);
    this.counterAssistantsCalls = this.assistant.calls;
    this.counterAssistantsCallsToday = this.assistant.today_calls;
    this.currentTime();
    setInterval(() => {
      this.currentTime();
    }, 1e3);
  },
  watch: {
    stillThere(val) {
      if (!val)
        return;
      setTimeout(() => {
        this.stillThere = false;
        this.changeStatusOfAssistant = true;
        if (this.changeStatusOfAssistant) {
          this.changeStatusForCallCenter();
          this.showStillThereAlert = false;
          this.$swal.fire({
            title: "Usuario ocupado ",
            text: "Has permanecido inactivo y el estado de tu usuario ha cambiado a ocupado",
            icon: "warning",
            showCancelButton: true,
            confirmButtonText: "Cambiar a disponible",
            cancelButtonText: "Dejar en ocupado",
            confirmButtonColor: "#00afb9",
            cancelButtonColor: "#d33",
            reverseButtons: true
          }).then((result) => {
            this.showStillThereAlert = true;
            if (result.isConfirmed) {
              let headers = {
                Authorization: `Token ${TOKEN}`,
                "Content-Type": "application/json;charset=utf-8"
              };
              let path = `${API_URL}api/staff/assistant/${this.aId}/`;
              axios$1.patch(
                path,
                {
                  "is_busy": false,
                  "in_break": false,
                  "in_lunch": false
                },
                { headers }
              ).then((response) => {
                this.getAssistant();
                return response;
              }).catch((e) => {
                return e;
              });
            } else if (result.dismiss === this.$swal.DismissReason.cancel) {
              this.showStillThereAlert = true;
              return result;
            }
          });
        }
      }, 12e4);
    },
    overlay(val) {
      val && setTimeout(() => {
        this.overlay = false;
      }, 3e3);
    },
    loader() {
      const l = this.loader;
      this[l] = !this[l];
      setTimeout(() => this[l] = false, 3e3);
      this.loader = null;
    }
  }
};
const _withScopeId = (n) => (pushScopeId("data-v-63d0e47f"), n = n(), popScopeId(), n);
const _hoisted_1$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("img", {
  src: _imports_0,
  alt: "logo",
  style: { "padding": "10px", "height": "100%" }
}, null, -1));
const _hoisted_2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("pre", null, "Inestable", -1));
const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("pre", null, "Conectado", -1));
const _hoisted_4 = { class: "wrapper meeting mt-10" };
const _hoisted_5 = { class: "text-center" };
const _hoisted_6 = { class: "ml-5 mt-5 mb-5" };
const _hoisted_7 = { class: "mb-4" };
const _hoisted_8 = { class: "mb-4" };
const _hoisted_9 = { key: 0 };
const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("thead", null, [
  /* @__PURE__ */ createBaseVNode("tr", null, [
    /* @__PURE__ */ createBaseVNode("th", { class: "text-left black-text text-h6 font-weight-bold" }, " No. "),
    /* @__PURE__ */ createBaseVNode("th", { class: "text-left black-text text-h6 font-weight-bold" }, " Cabina "),
    /* @__PURE__ */ createBaseVNode("th", { class: "text-left black-text text-h6 font-weight-bold" }, " Ubicación "),
    /* @__PURE__ */ createBaseVNode("th", { class: "text-left black-text text-h6 font-weight-bold" }, " Empresa "),
    /* @__PURE__ */ createBaseVNode("th", { class: "text-left black-text text-h6 font-weight-bold" }, " Fecha "),
    /* @__PURE__ */ createBaseVNode("th", { class: "text-left black-text text-h6 font-weight-bold" }, " Tiempo de llamada ")
  ])
], -1));
const _hoisted_11 = { class: "text-left grey-text text-subtitle-1" };
const _hoisted_12 = { class: "text-left grey-text text-subtitle-1" };
const _hoisted_13 = { class: "text-left grey-text text-subtitle-1" };
const _hoisted_14 = { class: "text-left grey-text text-subtitle-1" };
const _hoisted_15 = { class: "text-left grey-text text-subtitle-1" };
const _hoisted_16 = { class: "text-left grey-text text-subtitle-1" };
const _hoisted_17 = {
  key: 1,
  class: "mt-15 mr-10 ml-5"
};
const _hoisted_18 = { class: "text-overline mb-4title" };
const _hoisted_19 = {
  key: 0,
  class: "ma-2 text-black"
};
const _hoisted_20 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6" }, "Ocupado", -1));
const _hoisted_21 = {
  key: 1,
  class: "ma-2 text-black"
};
const _hoisted_22 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6" }, "Disponible", -1));
const _hoisted_23 = { class: "text-h6 text-grey font-weight-medium" };
const _hoisted_24 = { class: "text-white mt-3 text-center text-h6" };
const _hoisted_25 = { class: "text-white text-center text-subtitle-1" };
const _hoisted_26 = { class: "text-black" };
const _hoisted_27 = { class: "text-white mt-3 text-center text-h6" };
const _hoisted_28 = { class: "text-white text-center text-subtitle-1" };
const _hoisted_29 = { class: "text-black" };
const _hoisted_30 = { key: 1 };
const _hoisted_31 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 text-grey mt-6" }, "No hay llamadas en espera", -1));
const _hoisted_32 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-black pb-1 pt-5 pl-5 text-subtitle-1" }, " ¡Hay una llamada que espera ser atendida! ", -1));
const _hoisted_33 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-h6 text-center pb-7 text-black" }, " ¿Deseas atenderla? ", -1));
const _hoisted_34 = { class: "text-center pt-5" };
const _hoisted_35 = { class: "text-grey font-weight-bold text-h5 text-center mb-5" };
const _hoisted_36 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "text-center pb-5" }, [
  /* @__PURE__ */ createBaseVNode("span", { class: "text-grey font-weight-bold text-subtitle-1 text-center mb-5" }, "Esto puede tomar algunos minutos.")
], -1));
const _hoisted_37 = { class: "text-center mt-3 mb-3" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_notifications = resolveComponent("notifications");
  return openBlock(), createBlock(VApp, null, {
    default: withCtx(() => [
      createBaseVNode("div", null, [
        createVNode(VToolbar, { elevation: "0" }, {
          default: withCtx(() => [
            createVNode(VSpacer),
            _hoisted_1$1,
            createVNode(VSpacer),
            withDirectives(createBaseVNode("div", null, [
              this.speedtest < 5 ? (openBlock(), createBlock(VAlert, {
                key: 0,
                variant: "outlined",
                class: "pa-1 px-4",
                icon: "mdi-wifi-alert",
                type: "warning"
              }, {
                default: withCtx(() => [
                  _hoisted_2
                ]),
                _: 1
              })) : (openBlock(), createBlock(VAlert, {
                key: 1,
                variant: "outlined",
                class: "pa-1 px-4",
                icon: "mdi-wifi",
                type: "success"
              }, {
                default: withCtx(() => [
                  _hoisted_3
                ]),
                _: 1
              }))
            ], 512), [
              [vShow, this.speedtest != 0]
            ])
          ]),
          _: 1
        })
      ]),
      createBaseVNode("div", _hoisted_4, [
        createBaseVNode("div", _hoisted_5, [
          createVNode(VDialog, {
            modelValue: $data.dialogClose,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.dialogClose = $event),
            width: "400"
          }, {
            default: withCtx(() => [
              createVNode(VCard, null, {
                default: withCtx(() => [
                  createVNode(VCardTitle, { class: "text-h6 text-white bg-red-lighten-1" }, {
                    default: withCtx(() => [
                      createTextVNode(" Llamada no disponible. ")
                    ]),
                    _: 1
                  }),
                  createBaseVNode("div", _hoisted_6, [
                    createVNode(VBtn, {
                      color: "red-lighten-1",
                      class: "text-white",
                      onClick: _cache[0] || (_cache[0] = ($event) => $options.reload2()),
                      size: "large"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(" Aceptar ")
                      ]),
                      _: 1
                    })
                  ]),
                  createVNode(VDivider),
                  createVNode(VCardActions, null, {
                    default: withCtx(() => [
                      createVNode(VSpacer)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]),
        createVNode(VLayout, { row: "" }, {
          default: withCtx(() => [
            createVNode(VCol, { md: "8" }, {
              default: withCtx(() => [
                createVNode(VContainer, { class: "md-15 ml-8" }, {
                  default: withCtx(() => [
                    createVNode(VRow, { class: "px-4" }, {
                      default: withCtx(() => [
                        createVNode(VCol, {
                          cols: "12",
                          sm: "4"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCard, {
                              variant: "outlined",
                              class: "py-1 py-sm-0"
                            }, {
                              default: withCtx(() => [
                                createVNode(VRow, null, {
                                  default: withCtx(() => [
                                    createVNode(VCol, { cols: "8" }, {
                                      default: withCtx(() => [
                                        createVNode(VListItem, { lines: "three" }, {
                                          default: withCtx(() => [
                                            createBaseVNode("div", _hoisted_7, [
                                              createVNode(VBtn, {
                                                class: "text-white text-h5 font-weight-bold",
                                                color: "#6c5a8e",
                                                elevation: "0"
                                              }, {
                                                default: withCtx(() => [
                                                  createTextVNode(toDisplayString(_ctx.assistant.calls), 1)
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            createVNode(VListItemSubtitle, { class: "text-black font-weight-bold" }, {
                                              default: withCtx(() => [
                                                createTextVNode("LLamadas atendidas")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VCol, { cols: "4" }, {
                                      default: withCtx(() => [
                                        createVNode(VAvatar, {
                                          size: "90",
                                          class: "ml-n10 mt-2",
                                          tile: ""
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VImg, { src: "https://freesvg.org/img/1520566908.png" })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(VCol, {
                          cols: "12",
                          sm: "4"
                        }, {
                          default: withCtx(() => [
                            createVNode(VCard, {
                              onClick: _cache[2] || (_cache[2] = ($event) => $options.docTakeCallView()),
                              color: "",
                              variant: "outlined",
                              class: "py-1 py-sm-0"
                            }, {
                              default: withCtx(() => [
                                createVNode(VRow, null, {
                                  default: withCtx(() => [
                                    createVNode(VCol, { cols: "8" }, {
                                      default: withCtx(() => [
                                        createVNode(VListItem, { lines: "three" }, {
                                          default: withCtx(() => [
                                            createBaseVNode("div", _hoisted_8, [
                                              createVNode(VBtn, {
                                                class: "text-white text-h5 font-weight-bold",
                                                color: "#6c4769",
                                                elevation: "0"
                                              }, {
                                                default: withCtx(() => [
                                                  createTextVNode(toDisplayString(_ctx.assistant.today_calls), 1)
                                                ]),
                                                _: 1
                                              })
                                            ]),
                                            createVNode(VListItemSubtitle, { class: "text-black font-weight-bold" }, {
                                              default: withCtx(() => [
                                                createTextVNode("Llamadas de hoy")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VCol, { cols: "4" }, {
                                      default: withCtx(() => [
                                        createVNode(VAvatar, {
                                          size: "90",
                                          class: "ml-n10 mt-2",
                                          tile: ""
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VImg, { src: "https://freesvg.org/img/1520566908.png" })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })
                      ]),
                      _: 1
                    }),
                    _ctx.getAssistantCalls.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_9, [
                      createVNode(VCol, null, {
                        default: withCtx(() => [
                          createVNode(VList, { class: "mt-5" }, {
                            default: withCtx(() => [
                              createVNode(VListItem, null, {
                                default: withCtx(() => [
                                  createVNode(VListItemTitle, { class: "black-text text-h5" }, {
                                    default: withCtx(() => [
                                      createTextVNode("Llamadas recientes")
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      createVNode(VCard, {
                        variant: "outlined",
                        class: "mr-5 ml-5"
                      }, {
                        default: withCtx(() => [
                          createVNode(VTable, { "fixed-header": "" }, {
                            default: withCtx(() => [
                              _hoisted_10,
                              createBaseVNode("tbody", null, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getAssistantCalls.slice(0, 5), (item, i2) => {
                                  return openBlock(), createElementBlock("tr", {
                                    key: item.name
                                  }, [
                                    createBaseVNode("td", _hoisted_11, toDisplayString(i2 + 1), 1),
                                    createBaseVNode("td", _hoisted_12, toDisplayString(item.cabin_name), 1),
                                    createBaseVNode("td", _hoisted_13, toDisplayString(item.cabin_location), 1),
                                    createBaseVNode("td", _hoisted_14, toDisplayString(item.cabin_entity), 1),
                                    createBaseVNode("td", _hoisted_15, toDisplayString(item.timestamp.substring(0, 10)), 1),
                                    createBaseVNode("td", _hoisted_16, toDisplayString(item.duration) + " Min. ", 1)
                                  ]);
                                }), 128))
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])) : (openBlock(), createElementBlock("div", _hoisted_17, [
                      createVNode(VAlert, {
                        density: "compact",
                        type: "info"
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" Sin llamadas. ")
                        ]),
                        _: 1
                      })
                    ]))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            createVNode(VCol, { md: "4" }, {
              default: withCtx(() => [
                createVNode(VContainer, null, {
                  default: withCtx(() => [
                    createVNode(VCol, null, {
                      default: withCtx(() => [
                        createVNode(VRow, {
                          justify: "center",
                          class: "mb-3",
                          "no-gutters": ""
                        }, {
                          default: withCtx(() => [
                            createVNode(VMenu, {
                              modelValue: $data.menu,
                              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $data.menu = $event),
                              location: "bottom right",
                              transition: "scale-transition",
                              origin: "top left"
                            }, {
                              activator: withCtx(({ props }) => [
                                createVNode(VCard, mergeProps({
                                  variant: "outlined",
                                  width: "300",
                                  style: $data.busyOk ? "background-color: #FDF1F2; border: 2px solid #E63946;" : "background-color: #F2FFFE; border: 2px solid #07BEB8;"
                                }, props), {
                                  default: withCtx(() => [
                                    createVNode(VListItem, { lines: "three" }, {
                                      append: withCtx(() => [
                                        createVNode(VAvatar, {
                                          size: "80",
                                          color: "grey"
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VImg, {
                                              src: _ctx.assistant.profile_picture
                                            }, null, 8, ["src"])
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      default: withCtx(() => [
                                        createBaseVNode("div", _hoisted_18, toDisplayString($data.userType), 1),
                                        createVNode(VListItemTitle, { class: "text-h5 mb-1" }, {
                                          default: withCtx(() => [
                                            createTextVNode(toDisplayString(_ctx.assistant.first_name) + " " + toDisplayString(_ctx.assistant.last_name), 1)
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VListItemSubtitle, { class: "text-subtitle-1" }, {
                                          default: withCtx(() => [
                                            createTextVNode(toDisplayString($data.entityName), 1)
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VCardActions, null, {
                                      default: withCtx(() => [
                                        createVNode(VRow, { justify: "center" }, {
                                          default: withCtx(() => [
                                            $data.busyOk ? (openBlock(), createElementBlock("div", _hoisted_19, [
                                              createVNode(VChip, {
                                                color: "#E63946",
                                                variant: "outlined",
                                                class: "ma-2",
                                                label: ""
                                              }, {
                                                default: withCtx(() => [
                                                  _hoisted_20,
                                                  createVNode(VIcon, {
                                                    end: "",
                                                    dark: ""
                                                  }, {
                                                    default: withCtx(() => [
                                                      createTextVNode(" mdi-cached ")
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              })
                                            ])) : (openBlock(), createElementBlock("div", _hoisted_21, [
                                              createVNode(VChip, {
                                                variant: "outlined",
                                                color: "#07BEB8",
                                                class: "ma-2",
                                                label: ""
                                              }, {
                                                default: withCtx(() => [
                                                  _hoisted_22,
                                                  createVNode(VIcon, {
                                                    end: "",
                                                    color: "#07BEB8"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createTextVNode(" mdi-cached ")
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              })
                                            ]))
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1040, ["style"])
                              ]),
                              default: withCtx(() => [
                                createVNode(VCard, { width: "300" }, {
                                  default: withCtx(() => [
                                    createVNode(VList, { theme: "dark" }, {
                                      default: withCtx(() => [
                                        createVNode(VListItem, {
                                          "prepend-avatar": _ctx.assistant.profile_picture,
                                          title: `${_ctx.assistant.first_name} ${_ctx.assistant.last_name}`,
                                          subtitle: _ctx.assistant.address
                                        }, {
                                          append: withCtx(() => [
                                            createVNode(VBtn, {
                                              icon: "",
                                              onClick: _cache[3] || (_cache[3] = ($event) => $data.menu = false)
                                            }, {
                                              default: withCtx(() => [
                                                createVNode(VIcon, { icon: "mdi-close-circle" })
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }, 8, ["prepend-avatar", "title", "subtitle"])
                                      ]),
                                      _: 1
                                    }),
                                    createVNode(VList, {
                                      modelValue: $data.itemGroup,
                                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.itemGroup = $event),
                                      mandatory: "",
                                      color: $data.itemGroup ? "red" : "green"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(VListItem, {
                                          onClick: _cache[4] || (_cache[4] = ($event) => $options.changeStatus(false)),
                                          color: "green",
                                          value: ""
                                        }, {
                                          prepend: withCtx(() => [
                                            createVNode(VIcon, { color: "green" }, {
                                              default: withCtx(() => [
                                                createTextVNode("mdi-circle")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          default: withCtx(() => [
                                            createVNode(VListItemSubtitle, { class: "text-subtitle-1" }, {
                                              default: withCtx(() => [
                                                createTextVNode("Disponible")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VListItem, {
                                          onClick: _cache[5] || (_cache[5] = ($event) => $options.changeStatus(true)),
                                          value: ""
                                        }, {
                                          prepend: withCtx(() => [
                                            createVNode(VIcon, { color: "red" }, {
                                              default: withCtx(() => [
                                                createTextVNode("mdi-circle")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          default: withCtx(() => [
                                            createVNode(VListItemSubtitle, { class: "text-subtitle-1" }, {
                                              default: withCtx(() => [
                                                createTextVNode("Ocupado")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VDivider),
                                        createVNode(VListItem, {
                                          onClick: _cache[6] || (_cache[6] = withModifiers(($event) => $data.dialog = true, ["stop"])),
                                          value: ""
                                        }, {
                                          prepend: withCtx(() => [
                                            createVNode(VIcon, { color: "black" }, {
                                              default: withCtx(() => [
                                                createTextVNode("mdi-power")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          default: withCtx(() => [
                                            createVNode(VListItemSubtitle, { class: "text-subtitle-1" }, {
                                              default: withCtx(() => [
                                                createTextVNode("Cerrar sesión")
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(VDialog, {
                                          modelValue: $data.dialog,
                                          "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.dialog = $event),
                                          "max-width": "290"
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(VCard, null, {
                                              default: withCtx(() => [
                                                createVNode(VCardTitle, { class: "text-h5" }, {
                                                  default: withCtx(() => [
                                                    createTextVNode(" ¿Deseas cerrar sesión? ")
                                                  ]),
                                                  _: 1
                                                }),
                                                createVNode(VCardActions, null, {
                                                  default: withCtx(() => [
                                                    createVNode(VSpacer),
                                                    createVNode(VBtn, {
                                                      color: "#8F4667",
                                                      variant: "text",
                                                      onClick: _cache[7] || (_cache[7] = ($event) => $data.dialog = false)
                                                    }, {
                                                      default: withCtx(() => [
                                                        createTextVNode(" Cancelar ")
                                                      ]),
                                                      _: 1
                                                    }),
                                                    createVNode(VBtn, {
                                                      color: "#8F4667",
                                                      variant: "text",
                                                      onClick: _cache[8] || (_cache[8] = ($event) => ($data.dialog = false, $options.logOutApp()))
                                                    }, {
                                                      default: withCtx(() => [
                                                        createTextVNode(" Cerrar sesión ")
                                                      ]),
                                                      _: 1
                                                    })
                                                  ]),
                                                  _: 1
                                                })
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        }, 8, ["modelValue"])
                                      ]),
                                      _: 1
                                    }, 8, ["modelValue", "color"])
                                  ]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            }, 8, ["modelValue"])
                          ]),
                          _: 1
                        }),
                        createVNode(VRow, { justify: "center" }, {
                          default: withCtx(() => [
                            createVNode(VChip, {
                              class: "pa-5",
                              color: "#282828",
                              label: "",
                              variant: "outlined"
                            }, {
                              default: withCtx(() => [
                                createVNode(VIcon, {
                                  start: "",
                                  color: "grey"
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(" mdi-clock-outline ")
                                  ]),
                                  _: 1
                                }),
                                createBaseVNode("div", _hoisted_23, toDisplayString($data.clockTime) + " - " + toDisplayString($data.dateTime), 1)
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }),
                        createVNode(VDivider, { class: "mr-10 mt-6" }),
                        Object.entries($data.firstCall).length > 0 ? (openBlock(), createElementBlock("div", { key: $data.componentKey }, [
                          createBaseVNode("div", null, [
                            createVNode(VChip, {
                              class: "ma-2",
                              color: "#07BEB8",
                              label: ""
                            }, {
                              default: withCtx(() => [
                                createVNode(VIcon, { start: "" }, {
                                  default: withCtx(() => [
                                    createTextVNode(" mdi-phone ")
                                  ]),
                                  _: 1
                                }),
                                createTextVNode(" Llamadas en espera ")
                              ]),
                              _: 1
                            })
                          ]),
                          createVNode(VRow, { justify: "center" }, {
                            default: withCtx(() => [
                              createVNode(VCard, {
                                variant: "outlined",
                                width: "250",
                                class: "ml-5 mb-2 mt-3 mr-2 bg-grey-darken-3"
                              }, {
                                default: withCtx(() => [
                                  createBaseVNode("div", _hoisted_24, " Cabina " + toDisplayString($data.firstCall["cabin_id"]), 1),
                                  createBaseVNode("div", _hoisted_25, toDisplayString($data.firstCall["location"]), 1),
                                  createVNode(VCardActions, null, {
                                    default: withCtx(() => [
                                      createVNode(VRow, {
                                        justify: "center",
                                        class: "mt-1"
                                      }, {
                                        default: withCtx(() => [
                                          createBaseVNode("div", _hoisted_26, [
                                            createVNode(VBtn, {
                                              disabled: $data.busyOk,
                                              onClick: _cache[12] || (_cache[12] = ($event) => $data.busyOk && $data.firstCall["status"] == 1 ? null : $options.changeStatusOfCabin()),
                                              color: "#07BEB8",
                                              variant: "flat",
                                              size: "medium",
                                              class: "mb-5 pa-3 pl-5 pr-5 box bounce-3",
                                              label: ""
                                            }, {
                                              default: withCtx(() => [
                                                createVNode(VIcon, {
                                                  color: "white",
                                                  size: "large"
                                                }, {
                                                  default: withCtx(() => [
                                                    createTextVNode(" mdi-phone ")
                                                  ]),
                                                  _: 1
                                                })
                                              ]),
                                              _: 1
                                            }, 8, ["disabled"])
                                          ])
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    _: 1
                                  })
                                ]),
                                _: 1
                              })
                            ]),
                            _: 1
                          }),
                          createVNode(VDivider, { class: "mt-5" }),
                          (openBlock(true), createElementBlock(Fragment, null, renderList(this.listCalls.slice(1), (item, index) => {
                            return openBlock(), createBlock(VRow, {
                              justify: "center",
                              "no-gutters": "",
                              key: index
                            }, {
                              default: withCtx(() => [
                                createVNode(VCard, {
                                  variant: "outlined",
                                  width: "250",
                                  class: "ml-5 mb-2 mt-3 mr-2 bg-grey-darken-3"
                                }, {
                                  default: withCtx(() => [
                                    createBaseVNode("div", _hoisted_27, " Cabina " + toDisplayString(item["cabin_id"]), 1),
                                    createBaseVNode("div", _hoisted_28, toDisplayString(item["location"]), 1),
                                    createVNode(VCardActions, null, {
                                      default: withCtx(() => [
                                        createVNode(VRow, {
                                          justify: "center",
                                          class: "mt-1"
                                        }, {
                                          default: withCtx(() => [
                                            createBaseVNode("div", _hoisted_29, [
                                              createVNode(VBtn, {
                                                disabled: $data.busyOk,
                                                color: "grey",
                                                size: "small",
                                                class: "mb-5 pa-5 box bounce-3",
                                                label: ""
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode(VIcon, { dark: "" }, {
                                                    default: withCtx(() => [
                                                      createTextVNode(" mdi-phone ")
                                                    ]),
                                                    _: 1
                                                  })
                                                ]),
                                                _: 1
                                              }, 8, ["disabled"])
                                            ])
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  _: 2
                                }, 1024)
                              ]),
                              _: 2
                            }, 1024);
                          }), 128))
                        ])) : (openBlock(), createElementBlock("div", _hoisted_30, [
                          createVNode(VRow, { justify: "center" }, {
                            default: withCtx(() => [
                              _hoisted_31
                            ]),
                            _: 1
                          })
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        createBaseVNode("div", null, [
          createVNode(VDialog, {
            modelValue: $data.dialogTakingCall,
            "onUpdate:modelValue": _cache[13] || (_cache[13] = ($event) => $data.dialogTakingCall = $event),
            scrim: false,
            persistent: "",
            width: "300"
          }, {
            default: withCtx(() => [
              createVNode(VCard, {
                color: "#95A5D4",
                dark: ""
              }, {
                default: withCtx(() => [
                  createVNode(VCardText, null, {
                    default: withCtx(() => [
                      createTextVNode(" Tomando llamada... "),
                      createVNode(VProgressLinear, {
                        indeterminate: "",
                        color: "white",
                        class: "mb-0"
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(VRow, { justify: "center" }, {
            default: withCtx(() => [
              createVNode(VDialog, {
                modelValue: $data.stillThere,
                "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => $data.stillThere = $event),
                "max-width": "290",
                persistent: ""
              }, {
                default: withCtx(() => [
                  createVNode(VCard, null, {
                    default: withCtx(() => [
                      createVNode(VCardTitle, { class: "text-h5 text-center" }, {
                        default: withCtx(() => [
                          createTextVNode(" ¿Sigues ahí? ")
                        ]),
                        _: 1
                      }),
                      createVNode(VCardText),
                      createVNode(VCardActions, null, {
                        default: withCtx(() => [
                          createVNode(VSpacer),
                          createVNode(VBtn, {
                            color: "green-darken-1",
                            class: "text-h6",
                            variant: "text outlined",
                            onClick: _cache[14] || (_cache[14] = ($event) => $options.statusActive())
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" Sí ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          }),
          createVNode(VOverlay, { "model-value": $data.overlay }, {
            default: withCtx(() => [
              createVNode(VProgressCircular, {
                indeterminate: "",
                size: "64"
              })
            ]),
            _: 1
          }, 8, ["model-value"]),
          createVNode(VRow, { justify: "center" }, {
            default: withCtx(() => [
              createVNode(VDialog, {
                modelValue: $data.dialogTakeCallOrNot,
                "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => $data.dialogTakeCallOrNot = $event),
                persistent: "",
                "max-width": "300"
              }, {
                default: withCtx(() => [
                  createVNode(VCard, null, {
                    default: withCtx(() => [
                      createVNode(VCardTitle, {
                        class: "text-h6 text-white",
                        style: { "background-color": "#284b63" }
                      }, {
                        default: withCtx(() => [
                          createTextVNode(" Solicitud para atender llamada ")
                        ]),
                        _: 1
                      }),
                      _hoisted_32,
                      _hoisted_33,
                      createVNode(VCardActions, null, {
                        default: withCtx(() => [
                          createVNode(VSpacer),
                          createVNode(VBtn, {
                            class: "mb-2 box bounce-3",
                            color: "#284b63",
                            elevation: "0",
                            onClick: _cache[16] || (_cache[16] = ($event) => ($data.dialogTakeCallOrNot = false, $options.changeStatusOfCabin()))
                          }, {
                            default: withCtx(() => [
                              createTextVNode(" Sí, atender ")
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue"]),
              createVNode(VDialog, {
                modelValue: $data.dialogTakeCallDoctor,
                "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => $data.dialogTakeCallDoctor = $event),
                "max-width": "500px"
              }, {
                default: withCtx(() => [
                  createVNode(VCard, { class: "pa-5 text-center" }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_34, [
                        createBaseVNode("span", _hoisted_35, toDisplayString($data.messageConnectingCall), 1)
                      ]),
                      _hoisted_36,
                      createVNode(VSpacer),
                      createBaseVNode("div", _hoisted_37, [
                        createVNode(VProgressCircular, {
                          size: 50,
                          color: "#14213d",
                          indeterminate: ""
                        })
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            _: 1
          })
        ])
      ]),
      createVNode(_component_notifications, { group: "doctor" })
    ]),
    _: 1
  });
}
const DashboardPrincipal = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-63d0e47f"]]);
const routes = [
  {
    path: "/",
    name: "splash-screen",
    component: SplashScreen
  },
  {
    path: "/login",
    name: "login",
    component: LoginPage
  },
  {
    path: "/dashboard/assistant-:assistantId/ent-:entityId",
    name: "dashboard",
    component: DashboardPrincipal
  },
  {
    path: "/cabin-:cabinId/callcenter/call-:callId",
    name: "callcenter",
    component: CallCenterInformation
  }
];
const router = createRouter({
  history: createWebHashHistory(),
  routes
});
const assistant = function(state2) {
  return state2.assistant;
};
const getAssistantCalls = function(state2) {
  return state2.assistant.assistantCalls;
};
const getters = {
  assistant,
  getAssistantCalls
};
const loginAPI = (context, id) => {
  localStorage.setItem("idAssistant", id);
};
const fetchAssistant = async function({ commit: commit2 }, assistantId) {
  let headers = {
    Authorization: `Token ${TOKEN}`,
    "Content-Type": "application/json;charset=utf-8"
  };
  await axios$1.get(`${API_URL}api/staff/assistant_calls/${assistantId}/`, { headers }).then((response) => {
    commit2("setAssistant", response.data);
    commit2("setAssistantCalls", response.data.assistant_calls);
  }).catch((err) => console.error(err));
};
const actions = {
  fetchAssistant,
  loginAPI
};
const setAssistant = (state2, assistant2) => {
  state2.assistant = assistant2;
};
const setAssistantCalls = (state2, assistantCalls) => {
  state2.assistant.assistantCalls = assistantCalls;
};
const setVariable = (state2, newValue) => {
  state2.miVariable = newValue;
};
const logOut = (state2) => {
  state2.assistant = null;
  localStorage.clear();
};
const mutations = {
  setAssistant,
  setAssistantCalls,
  setVariable,
  logOut
};
function createStore() {
  return createStore$1({
    strict: true,
    state: {
      assistant: {
        assistantCalls: [],
        assistantBussy: false,
        assistantLunch: false,
        assistantBreak: false
      }
    },
    getters,
    actions,
    mutations
  });
}
const App_vue_vue_type_style_index_0_lang = "";
const _sfc_main = {
  name: "App",
  created() {
    localStorage.setItem("app_version", this.version);
  }
};
const _hoisted_1 = { id: "app" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createVNode(_component_router_view)
  ]);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var sweetalert2 = { exports: {} };
/*!
* sweetalert2 v11.4.0
* Released under the MIT License.
*/
(function(module2, exports) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    const consolePrefix = "SweetAlert2:";
    const uniqueArray = (arr) => {
      const result = [];
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (result.indexOf(arr[i2]) === -1) {
          result.push(arr[i2]);
        }
      }
      return result;
    };
    const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);
    const toArray2 = (nodeList) => Array.prototype.slice.call(nodeList);
    const warn2 = (message) => {
      console.warn("".concat(consolePrefix, " ").concat(typeof message === "object" ? message.join(" ") : message));
    };
    const error = (message) => {
      console.error("".concat(consolePrefix, " ").concat(message));
    };
    const previousWarnOnceMessages = [];
    const warnOnce = (message) => {
      if (!previousWarnOnceMessages.includes(message)) {
        previousWarnOnceMessages.push(message);
        warn2(message);
      }
    };
    const warnAboutDeprecation = (deprecatedParam, useInstead) => {
      warnOnce('"'.concat(deprecatedParam, '" is deprecated and will be removed in the next major release. Please use "').concat(useInstead, '" instead.'));
    };
    const callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
    const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === "function";
    const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
    const isPromise2 = (arg) => arg && Promise.resolve(arg) === arg;
    const defaultParams = {
      title: "",
      titleText: "",
      text: "",
      html: "",
      footer: "",
      icon: void 0,
      iconColor: void 0,
      iconHtml: void 0,
      template: void 0,
      toast: false,
      showClass: {
        popup: "swal2-show",
        backdrop: "swal2-backdrop-show",
        icon: "swal2-icon-show"
      },
      hideClass: {
        popup: "swal2-hide",
        backdrop: "swal2-backdrop-hide",
        icon: "swal2-icon-hide"
      },
      customClass: {},
      target: "body",
      color: void 0,
      backdrop: true,
      heightAuto: true,
      allowOutsideClick: true,
      allowEscapeKey: true,
      allowEnterKey: true,
      stopKeydownPropagation: true,
      keydownListenerCapture: false,
      showConfirmButton: true,
      showDenyButton: false,
      showCancelButton: false,
      preConfirm: void 0,
      preDeny: void 0,
      confirmButtonText: "OK",
      confirmButtonAriaLabel: "",
      confirmButtonColor: void 0,
      denyButtonText: "No",
      denyButtonAriaLabel: "",
      denyButtonColor: void 0,
      cancelButtonText: "Cancel",
      cancelButtonAriaLabel: "",
      cancelButtonColor: void 0,
      buttonsStyling: true,
      reverseButtons: false,
      focusConfirm: true,
      focusDeny: false,
      focusCancel: false,
      returnFocus: true,
      showCloseButton: false,
      closeButtonHtml: "&times;",
      closeButtonAriaLabel: "Close this dialog",
      loaderHtml: "",
      showLoaderOnConfirm: false,
      showLoaderOnDeny: false,
      imageUrl: void 0,
      imageWidth: void 0,
      imageHeight: void 0,
      imageAlt: "",
      timer: void 0,
      timerProgressBar: false,
      width: void 0,
      padding: void 0,
      background: void 0,
      input: void 0,
      inputPlaceholder: "",
      inputLabel: "",
      inputValue: "",
      inputOptions: {},
      inputAutoTrim: true,
      inputAttributes: {},
      inputValidator: void 0,
      returnInputValueOnDeny: false,
      validationMessage: void 0,
      grow: false,
      position: "center",
      progressSteps: [],
      currentProgressStep: void 0,
      progressStepsDistance: void 0,
      willOpen: void 0,
      didOpen: void 0,
      didRender: void 0,
      willClose: void 0,
      didClose: void 0,
      didDestroy: void 0,
      scrollbarPadding: true
    };
    const updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"];
    const deprecatedParams = {};
    const toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
    const isValidParameter = (paramName) => {
      return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
    };
    const isUpdatableParameter = (paramName) => {
      return updatableParams.indexOf(paramName) !== -1;
    };
    const isDeprecatedParameter = (paramName) => {
      return deprecatedParams[paramName];
    };
    const checkIfParamIsValid = (param) => {
      if (!isValidParameter(param)) {
        warn2('Unknown parameter "'.concat(param, '"'));
      }
    };
    const checkIfToastParamIsValid = (param) => {
      if (toastIncompatibleParams.includes(param)) {
        warn2('The parameter "'.concat(param, '" is incompatible with toasts'));
      }
    };
    const checkIfParamIsDeprecated = (param) => {
      if (isDeprecatedParameter(param)) {
        warnAboutDeprecation(param, isDeprecatedParameter(param));
      }
    };
    const showWarningsForParams = (params) => {
      if (!params.backdrop && params.allowOutsideClick) {
        warn2('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
      }
      for (const param in params) {
        checkIfParamIsValid(param);
        if (params.toast) {
          checkIfToastParamIsValid(param);
        }
        checkIfParamIsDeprecated(param);
      }
    };
    const swalPrefix = "swal2-";
    const prefix = (items) => {
      const result = {};
      for (const i2 in items) {
        result[items[i2]] = swalPrefix + items[i2];
      }
      return result;
    };
    const swalClasses = prefix(["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"]);
    const iconTypes = prefix(["success", "warning", "info", "question", "error"]);
    const getContainer = () => document.body.querySelector(".".concat(swalClasses.container));
    const elementBySelector = (selectorString) => {
      const container = getContainer();
      return container ? container.querySelector(selectorString) : null;
    };
    const elementByClass = (className) => {
      return elementBySelector(".".concat(className));
    };
    const getPopup = () => elementByClass(swalClasses.popup);
    const getIcon = () => elementByClass(swalClasses.icon);
    const getTitle = () => elementByClass(swalClasses.title);
    const getHtmlContainer = () => elementByClass(swalClasses["html-container"]);
    const getImage = () => elementByClass(swalClasses.image);
    const getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
    const getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
    const getConfirmButton = () => elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm));
    const getDenyButton = () => elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny));
    const getInputLabel = () => elementByClass(swalClasses["input-label"]);
    const getLoader = () => elementBySelector(".".concat(swalClasses.loader));
    const getCancelButton = () => elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel));
    const getActions = () => elementByClass(swalClasses.actions);
    const getFooter = () => elementByClass(swalClasses.footer);
    const getTimerProgressBar = () => elementByClass(swalClasses["timer-progress-bar"]);
    const getCloseButton = () => elementByClass(swalClasses.close);
    const focusable = '\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n';
    const getFocusableElements = () => {
      const focusableElementsWithTabindex = toArray2(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort((a, b) => {
        const tabindexA = parseInt(a.getAttribute("tabindex"));
        const tabindexB = parseInt(b.getAttribute("tabindex"));
        if (tabindexA > tabindexB) {
          return 1;
        } else if (tabindexA < tabindexB) {
          return -1;
        }
        return 0;
      });
      const otherFocusableElements = toArray2(getPopup().querySelectorAll(focusable)).filter((el) => el.getAttribute("tabindex") !== "-1");
      return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter((el) => isVisible(el));
    };
    const isModal = () => {
      return !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
    };
    const isToast = () => {
      return getPopup() && hasClass(getPopup(), swalClasses.toast);
    };
    const isLoading = () => {
      return getPopup().hasAttribute("data-loading");
    };
    const states = {
      previousBodyPadding: null
    };
    const setInnerHtml = (elem, html) => {
      elem.textContent = "";
      if (html) {
        const parser2 = new DOMParser();
        const parsed = parser2.parseFromString(html, "text/html");
        toArray2(parsed.querySelector("head").childNodes).forEach((child) => {
          elem.appendChild(child);
        });
        toArray2(parsed.querySelector("body").childNodes).forEach((child) => {
          elem.appendChild(child);
        });
      }
    };
    const hasClass = (elem, className) => {
      if (!className) {
        return false;
      }
      const classList = className.split(/\s+/);
      for (let i2 = 0; i2 < classList.length; i2++) {
        if (!elem.classList.contains(classList[i2])) {
          return false;
        }
      }
      return true;
    };
    const removeCustomClasses = (elem, params) => {
      toArray2(elem.classList).forEach((className) => {
        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass).includes(className)) {
          elem.classList.remove(className);
        }
      });
    };
    const applyCustomClass = (elem, params, className) => {
      removeCustomClasses(elem, params);
      if (params.customClass && params.customClass[className]) {
        if (typeof params.customClass[className] !== "string" && !params.customClass[className].forEach) {
          return warn2("Invalid type of customClass.".concat(className, '! Expected string or iterable object, got "').concat(typeof params.customClass[className], '"'));
        }
        addClass(elem, params.customClass[className]);
      }
    };
    const getInput = (popup, inputType) => {
      if (!inputType) {
        return null;
      }
      switch (inputType) {
        case "select":
        case "textarea":
        case "file":
          return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses[inputType]));
        case "checkbox":
          return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.checkbox, " input"));
        case "radio":
          return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:checked")) || popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:first-child"));
        case "range":
          return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.range, " input"));
        default:
          return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.input));
      }
    };
    const focusInput = (input) => {
      input.focus();
      if (input.type !== "file") {
        const val = input.value;
        input.value = "";
        input.value = val;
      }
    };
    const toggleClass = (target, classList, condition) => {
      if (!target || !classList) {
        return;
      }
      if (typeof classList === "string") {
        classList = classList.split(/\s+/).filter(Boolean);
      }
      classList.forEach((className) => {
        if (Array.isArray(target)) {
          target.forEach((elem) => {
            condition ? elem.classList.add(className) : elem.classList.remove(className);
          });
        } else {
          condition ? target.classList.add(className) : target.classList.remove(className);
        }
      });
    };
    const addClass = (target, classList) => {
      toggleClass(target, classList, true);
    };
    const removeClass = (target, classList) => {
      toggleClass(target, classList, false);
    };
    const getDirectChildByClass = (elem, className) => {
      const childNodes = toArray2(elem.childNodes);
      for (let i2 = 0; i2 < childNodes.length; i2++) {
        if (hasClass(childNodes[i2], className)) {
          return childNodes[i2];
        }
      }
    };
    const applyNumericalStyle = (elem, property, value2) => {
      if (value2 === "".concat(parseInt(value2))) {
        value2 = parseInt(value2);
      }
      if (value2 || parseInt(value2) === 0) {
        elem.style[property] = typeof value2 === "number" ? "".concat(value2, "px") : value2;
      } else {
        elem.style.removeProperty(property);
      }
    };
    const show = function(elem) {
      let display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "flex";
      elem.style.display = display;
    };
    const hide = (elem) => {
      elem.style.display = "none";
    };
    const setStyle2 = (parent, selector, property, value2) => {
      const el = parent.querySelector(selector);
      if (el) {
        el.style[property] = value2;
      }
    };
    const toggle = (elem, condition, display) => {
      condition ? show(elem, display) : hide(elem);
    };
    const isVisible = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
    const allButtonsAreHidden = () => !isVisible(getConfirmButton()) && !isVisible(getDenyButton()) && !isVisible(getCancelButton());
    const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
    const hasCssAnimation = (elem) => {
      const style = window.getComputedStyle(elem);
      const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
      const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
      return animDuration > 0 || transDuration > 0;
    };
    const animateTimerProgressBar = function(timer) {
      let reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const timerProgressBar = getTimerProgressBar();
      if (isVisible(timerProgressBar)) {
        if (reset) {
          timerProgressBar.style.transition = "none";
          timerProgressBar.style.width = "100%";
        }
        setTimeout(() => {
          timerProgressBar.style.transition = "width ".concat(timer / 1e3, "s linear");
          timerProgressBar.style.width = "0%";
        }, 10);
      }
    };
    const stopTimerProgressBar = () => {
      const timerProgressBar = getTimerProgressBar();
      const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
      timerProgressBar.style.removeProperty("transition");
      timerProgressBar.style.width = "100%";
      const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
      const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
      timerProgressBar.style.removeProperty("transition");
      timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
    };
    const isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";
    const RESTORE_FOCUS_TIMEOUT = 100;
    const globalState = {};
    const focusPreviousActiveElement = () => {
      if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
        globalState.previousActiveElement.focus();
        globalState.previousActiveElement = null;
      } else if (document.body) {
        document.body.focus();
      }
    };
    const restoreActiveElement = (returnFocus) => {
      return new Promise((resolve2) => {
        if (!returnFocus) {
          return resolve2();
        }
        const x2 = window.scrollX;
        const y = window.scrollY;
        globalState.restoreFocusTimeout = setTimeout(() => {
          focusPreviousActiveElement();
          resolve2();
        }, RESTORE_FOCUS_TIMEOUT);
        window.scrollTo(x2, y);
      });
    };
    const sweetHTML = '\n <div aria-labelledby="'.concat(swalClasses.title, '" aria-describedby="').concat(swalClasses["html-container"], '" class="').concat(swalClasses.popup, '" tabindex="-1">\n   <button type="button" class="').concat(swalClasses.close, '"></button>\n   <ul class="').concat(swalClasses["progress-steps"], '"></ul>\n   <div class="').concat(swalClasses.icon, '"></div>\n   <img class="').concat(swalClasses.image, '" />\n   <h2 class="').concat(swalClasses.title, '" id="').concat(swalClasses.title, '"></h2>\n   <div class="').concat(swalClasses["html-container"], '" id="').concat(swalClasses["html-container"], '"></div>\n   <input class="').concat(swalClasses.input, '" />\n   <input type="file" class="').concat(swalClasses.file, '" />\n   <div class="').concat(swalClasses.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(swalClasses.select, '"></select>\n   <div class="').concat(swalClasses.radio, '"></div>\n   <label for="').concat(swalClasses.checkbox, '" class="').concat(swalClasses.checkbox, '">\n     <input type="checkbox" />\n     <span class="').concat(swalClasses.label, '"></span>\n   </label>\n   <textarea class="').concat(swalClasses.textarea, '"></textarea>\n   <div class="').concat(swalClasses["validation-message"], '" id="').concat(swalClasses["validation-message"], '"></div>\n   <div class="').concat(swalClasses.actions, '">\n     <div class="').concat(swalClasses.loader, '"></div>\n     <button type="button" class="').concat(swalClasses.confirm, '"></button>\n     <button type="button" class="').concat(swalClasses.deny, '"></button>\n     <button type="button" class="').concat(swalClasses.cancel, '"></button>\n   </div>\n   <div class="').concat(swalClasses.footer, '"></div>\n   <div class="').concat(swalClasses["timer-progress-bar-container"], '">\n     <div class="').concat(swalClasses["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, "");
    const resetOldContainer = () => {
      const oldContainer = getContainer();
      if (!oldContainer) {
        return false;
      }
      oldContainer.remove();
      removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
      return true;
    };
    const resetValidationMessage = () => {
      globalState.currentInstance.resetValidationMessage();
    };
    const addInputChangeListeners = () => {
      const popup = getPopup();
      const input = getDirectChildByClass(popup, swalClasses.input);
      const file = getDirectChildByClass(popup, swalClasses.file);
      const range = popup.querySelector(".".concat(swalClasses.range, " input"));
      const rangeOutput = popup.querySelector(".".concat(swalClasses.range, " output"));
      const select = getDirectChildByClass(popup, swalClasses.select);
      const checkbox = popup.querySelector(".".concat(swalClasses.checkbox, " input"));
      const textarea = getDirectChildByClass(popup, swalClasses.textarea);
      input.oninput = resetValidationMessage;
      file.onchange = resetValidationMessage;
      select.onchange = resetValidationMessage;
      checkbox.onchange = resetValidationMessage;
      textarea.oninput = resetValidationMessage;
      range.oninput = () => {
        resetValidationMessage();
        rangeOutput.value = range.value;
      };
      range.onchange = () => {
        resetValidationMessage();
        range.nextSibling.value = range.value;
      };
    };
    const getTarget2 = (target) => typeof target === "string" ? document.querySelector(target) : target;
    const setupAccessibility = (params) => {
      const popup = getPopup();
      popup.setAttribute("role", params.toast ? "alert" : "dialog");
      popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
      if (!params.toast) {
        popup.setAttribute("aria-modal", "true");
      }
    };
    const setupRTL = (targetElement) => {
      if (window.getComputedStyle(targetElement).direction === "rtl") {
        addClass(getContainer(), swalClasses.rtl);
      }
    };
    const init = (params) => {
      const oldContainerExisted = resetOldContainer();
      if (isNodeEnv()) {
        error("SweetAlert2 requires document to initialize");
        return;
      }
      const container = document.createElement("div");
      container.className = swalClasses.container;
      if (oldContainerExisted) {
        addClass(container, swalClasses["no-transition"]);
      }
      setInnerHtml(container, sweetHTML);
      const targetElement = getTarget2(params.target);
      targetElement.appendChild(container);
      setupAccessibility(params);
      setupRTL(targetElement);
      addInputChangeListeners();
    };
    const parseHtmlToContainer = (param, target) => {
      if (param instanceof HTMLElement) {
        target.appendChild(param);
      } else if (typeof param === "object") {
        handleObject(param, target);
      } else if (param) {
        setInnerHtml(target, param);
      }
    };
    const handleObject = (param, target) => {
      if (param.jquery) {
        handleJqueryElem(target, param);
      } else {
        setInnerHtml(target, param.toString());
      }
    };
    const handleJqueryElem = (target, elem) => {
      target.textContent = "";
      if (0 in elem) {
        for (let i2 = 0; i2 in elem; i2++) {
          target.appendChild(elem[i2].cloneNode(true));
        }
      } else {
        target.appendChild(elem.cloneNode(true));
      }
    };
    const animationEndEvent = (() => {
      if (isNodeEnv()) {
        return false;
      }
      const testEl = document.createElement("div");
      const transEndEventNames = {
        WebkitAnimation: "webkitAnimationEnd",
        animation: "animationend"
      };
      for (const i2 in transEndEventNames) {
        if (Object.prototype.hasOwnProperty.call(transEndEventNames, i2) && typeof testEl.style[i2] !== "undefined") {
          return transEndEventNames[i2];
        }
      }
      return false;
    })();
    const measureScrollbar = () => {
      const scrollDiv = document.createElement("div");
      scrollDiv.className = swalClasses["scrollbar-measure"];
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    };
    const renderActions = (instance, params) => {
      const actions2 = getActions();
      const loader = getLoader();
      if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
        hide(actions2);
      } else {
        show(actions2);
      }
      applyCustomClass(actions2, params, "actions");
      renderButtons(actions2, loader, params);
      setInnerHtml(loader, params.loaderHtml);
      applyCustomClass(loader, params, "loader");
    };
    function renderButtons(actions2, loader, params) {
      const confirmButton = getConfirmButton();
      const denyButton = getDenyButton();
      const cancelButton = getCancelButton();
      renderButton(confirmButton, "confirm", params);
      renderButton(denyButton, "deny", params);
      renderButton(cancelButton, "cancel", params);
      handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
      if (params.reverseButtons) {
        if (params.toast) {
          actions2.insertBefore(cancelButton, confirmButton);
          actions2.insertBefore(denyButton, confirmButton);
        } else {
          actions2.insertBefore(cancelButton, loader);
          actions2.insertBefore(denyButton, loader);
          actions2.insertBefore(confirmButton, loader);
        }
      }
    }
    function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
      if (!params.buttonsStyling) {
        return removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
      }
      addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
      if (params.confirmButtonColor) {
        confirmButton.style.backgroundColor = params.confirmButtonColor;
        addClass(confirmButton, swalClasses["default-outline"]);
      }
      if (params.denyButtonColor) {
        denyButton.style.backgroundColor = params.denyButtonColor;
        addClass(denyButton, swalClasses["default-outline"]);
      }
      if (params.cancelButtonColor) {
        cancelButton.style.backgroundColor = params.cancelButtonColor;
        addClass(cancelButton, swalClasses["default-outline"]);
      }
    }
    function renderButton(button, buttonType, params) {
      toggle(button, params["show".concat(capitalizeFirstLetter(buttonType), "Button")], "inline-block");
      setInnerHtml(button, params["".concat(buttonType, "ButtonText")]);
      button.setAttribute("aria-label", params["".concat(buttonType, "ButtonAriaLabel")]);
      button.className = swalClasses[buttonType];
      applyCustomClass(button, params, "".concat(buttonType, "Button"));
      addClass(button, params["".concat(buttonType, "ButtonClass")]);
    }
    function handleBackdropParam(container, backdrop) {
      if (typeof backdrop === "string") {
        container.style.background = backdrop;
      } else if (!backdrop) {
        addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
      }
    }
    function handlePositionParam(container, position) {
      if (position in swalClasses) {
        addClass(container, swalClasses[position]);
      } else {
        warn2('The "position" parameter is not valid, defaulting to "center"');
        addClass(container, swalClasses.center);
      }
    }
    function handleGrowParam(container, grow) {
      if (grow && typeof grow === "string") {
        const growClass = "grow-".concat(grow);
        if (growClass in swalClasses) {
          addClass(container, swalClasses[growClass]);
        }
      }
    }
    const renderContainer = (instance, params) => {
      const container = getContainer();
      if (!container) {
        return;
      }
      handleBackdropParam(container, params.backdrop);
      handlePositionParam(container, params.position);
      handleGrowParam(container, params.grow);
      applyCustomClass(container, params, "container");
    };
    var privateProps = {
      awaitingPromise: /* @__PURE__ */ new WeakMap(),
      promise: /* @__PURE__ */ new WeakMap(),
      innerParams: /* @__PURE__ */ new WeakMap(),
      domCache: /* @__PURE__ */ new WeakMap()
    };
    const inputTypes = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
    const renderInput = (instance, params) => {
      const popup = getPopup();
      const innerParams = privateProps.innerParams.get(instance);
      const rerender = !innerParams || params.input !== innerParams.input;
      inputTypes.forEach((inputType) => {
        const inputClass = swalClasses[inputType];
        const inputContainer = getDirectChildByClass(popup, inputClass);
        setAttributes(inputType, params.inputAttributes);
        inputContainer.className = inputClass;
        if (rerender) {
          hide(inputContainer);
        }
      });
      if (params.input) {
        if (rerender) {
          showInput(params);
        }
        setCustomClass(params);
      }
    };
    const showInput = (params) => {
      if (!renderInputType[params.input]) {
        return error('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(params.input, '"'));
      }
      const inputContainer = getInputContainer(params.input);
      const input = renderInputType[params.input](inputContainer, params);
      show(input);
      setTimeout(() => {
        focusInput(input);
      });
    };
    const removeAttributes = (input) => {
      for (let i2 = 0; i2 < input.attributes.length; i2++) {
        const attrName = input.attributes[i2].name;
        if (!["type", "value", "style"].includes(attrName)) {
          input.removeAttribute(attrName);
        }
      }
    };
    const setAttributes = (inputType, inputAttributes) => {
      const input = getInput(getPopup(), inputType);
      if (!input) {
        return;
      }
      removeAttributes(input);
      for (const attr in inputAttributes) {
        input.setAttribute(attr, inputAttributes[attr]);
      }
    };
    const setCustomClass = (params) => {
      const inputContainer = getInputContainer(params.input);
      if (params.customClass) {
        addClass(inputContainer, params.customClass.input);
      }
    };
    const setInputPlaceholder = (input, params) => {
      if (!input.placeholder || params.inputPlaceholder) {
        input.placeholder = params.inputPlaceholder;
      }
    };
    const setInputLabel = (input, prependTo, params) => {
      if (params.inputLabel) {
        input.id = swalClasses.input;
        const label = document.createElement("label");
        const labelClass = swalClasses["input-label"];
        label.setAttribute("for", input.id);
        label.className = labelClass;
        addClass(label, params.customClass.inputLabel);
        label.innerText = params.inputLabel;
        prependTo.insertAdjacentElement("beforebegin", label);
      }
    };
    const getInputContainer = (inputType) => {
      const inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
      return getDirectChildByClass(getPopup(), inputClass);
    };
    const renderInputType = {};
    renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (input, params) => {
      if (typeof params.inputValue === "string" || typeof params.inputValue === "number") {
        input.value = params.inputValue;
      } else if (!isPromise2(params.inputValue)) {
        warn2('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(typeof params.inputValue, '"'));
      }
      setInputLabel(input, input, params);
      setInputPlaceholder(input, params);
      input.type = params.input;
      return input;
    };
    renderInputType.file = (input, params) => {
      setInputLabel(input, input, params);
      setInputPlaceholder(input, params);
      return input;
    };
    renderInputType.range = (range, params) => {
      const rangeInput = range.querySelector("input");
      const rangeOutput = range.querySelector("output");
      rangeInput.value = params.inputValue;
      rangeInput.type = params.input;
      rangeOutput.value = params.inputValue;
      setInputLabel(rangeInput, range, params);
      return range;
    };
    renderInputType.select = (select, params) => {
      select.textContent = "";
      if (params.inputPlaceholder) {
        const placeholder = document.createElement("option");
        setInnerHtml(placeholder, params.inputPlaceholder);
        placeholder.value = "";
        placeholder.disabled = true;
        placeholder.selected = true;
        select.appendChild(placeholder);
      }
      setInputLabel(select, select, params);
      return select;
    };
    renderInputType.radio = (radio) => {
      radio.textContent = "";
      return radio;
    };
    renderInputType.checkbox = (checkboxContainer, params) => {
      const checkbox = getInput(getPopup(), "checkbox");
      checkbox.value = "1";
      checkbox.id = swalClasses.checkbox;
      checkbox.checked = Boolean(params.inputValue);
      const label = checkboxContainer.querySelector("span");
      setInnerHtml(label, params.inputPlaceholder);
      return checkboxContainer;
    };
    renderInputType.textarea = (textarea, params) => {
      textarea.value = params.inputValue;
      setInputPlaceholder(textarea, params);
      setInputLabel(textarea, textarea, params);
      const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
      setTimeout(() => {
        if ("MutationObserver" in window) {
          const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
          const textareaResizeHandler = () => {
            const textareaWidth = textarea.offsetWidth + getMargin(textarea);
            if (textareaWidth > initialPopupWidth) {
              getPopup().style.width = "".concat(textareaWidth, "px");
            } else {
              getPopup().style.width = null;
            }
          };
          new MutationObserver(textareaResizeHandler).observe(textarea, {
            attributes: true,
            attributeFilter: ["style"]
          });
        }
      });
      return textarea;
    };
    const renderContent = (instance, params) => {
      const htmlContainer = getHtmlContainer();
      applyCustomClass(htmlContainer, params, "htmlContainer");
      if (params.html) {
        parseHtmlToContainer(params.html, htmlContainer);
        show(htmlContainer, "block");
      } else if (params.text) {
        htmlContainer.textContent = params.text;
        show(htmlContainer, "block");
      } else {
        hide(htmlContainer);
      }
      renderInput(instance, params);
    };
    const renderFooter = (instance, params) => {
      const footer = getFooter();
      toggle(footer, params.footer);
      if (params.footer) {
        parseHtmlToContainer(params.footer, footer);
      }
      applyCustomClass(footer, params, "footer");
    };
    const renderCloseButton = (instance, params) => {
      const closeButton = getCloseButton();
      setInnerHtml(closeButton, params.closeButtonHtml);
      applyCustomClass(closeButton, params, "closeButton");
      toggle(closeButton, params.showCloseButton);
      closeButton.setAttribute("aria-label", params.closeButtonAriaLabel);
    };
    const renderIcon = (instance, params) => {
      const innerParams = privateProps.innerParams.get(instance);
      const icon = getIcon();
      if (innerParams && params.icon === innerParams.icon) {
        setContent(icon, params);
        applyStyles(icon, params);
        return;
      }
      if (!params.icon && !params.iconHtml) {
        return hide(icon);
      }
      if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
        error('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(params.icon, '"'));
        return hide(icon);
      }
      show(icon);
      setContent(icon, params);
      applyStyles(icon, params);
      addClass(icon, params.showClass.icon);
    };
    const applyStyles = (icon, params) => {
      for (const iconType in iconTypes) {
        if (params.icon !== iconType) {
          removeClass(icon, iconTypes[iconType]);
        }
      }
      addClass(icon, iconTypes[params.icon]);
      setColor(icon, params);
      adjustSuccessIconBackgroundColor();
      applyCustomClass(icon, params, "icon");
    };
    const adjustSuccessIconBackgroundColor = () => {
      const popup = getPopup();
      const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
      const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
      for (let i2 = 0; i2 < successIconParts.length; i2++) {
        successIconParts[i2].style.backgroundColor = popupBackgroundColor;
      }
    };
    const successIconHtml = '\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n';
    const errorIconHtml = '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n';
    const setContent = (icon, params) => {
      icon.textContent = "";
      if (params.iconHtml) {
        setInnerHtml(icon, iconContent(params.iconHtml));
      } else if (params.icon === "success") {
        setInnerHtml(icon, successIconHtml);
      } else if (params.icon === "error") {
        setInnerHtml(icon, errorIconHtml);
      } else {
        const defaultIconHtml = {
          question: "?",
          warning: "!",
          info: "i"
        };
        setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));
      }
    };
    const setColor = (icon, params) => {
      if (!params.iconColor) {
        return;
      }
      icon.style.color = params.iconColor;
      icon.style.borderColor = params.iconColor;
      for (const sel of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) {
        setStyle2(icon, sel, "backgroundColor", params.iconColor);
      }
      setStyle2(icon, ".swal2-success-ring", "borderColor", params.iconColor);
    };
    const iconContent = (content) => '<div class="'.concat(swalClasses["icon-content"], '">').concat(content, "</div>");
    const renderImage = (instance, params) => {
      const image = getImage();
      if (!params.imageUrl) {
        return hide(image);
      }
      show(image, "");
      image.setAttribute("src", params.imageUrl);
      image.setAttribute("alt", params.imageAlt);
      applyNumericalStyle(image, "width", params.imageWidth);
      applyNumericalStyle(image, "height", params.imageHeight);
      image.className = swalClasses.image;
      applyCustomClass(image, params, "image");
    };
    const createStepElement = (step) => {
      const stepEl = document.createElement("li");
      addClass(stepEl, swalClasses["progress-step"]);
      setInnerHtml(stepEl, step);
      return stepEl;
    };
    const createLineElement = (params) => {
      const lineEl = document.createElement("li");
      addClass(lineEl, swalClasses["progress-step-line"]);
      if (params.progressStepsDistance) {
        lineEl.style.width = params.progressStepsDistance;
      }
      return lineEl;
    };
    const renderProgressSteps = (instance, params) => {
      const progressStepsContainer = getProgressSteps();
      if (!params.progressSteps || params.progressSteps.length === 0) {
        return hide(progressStepsContainer);
      }
      show(progressStepsContainer);
      progressStepsContainer.textContent = "";
      if (params.currentProgressStep >= params.progressSteps.length) {
        warn2("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
      }
      params.progressSteps.forEach((step, index) => {
        const stepEl = createStepElement(step);
        progressStepsContainer.appendChild(stepEl);
        if (index === params.currentProgressStep) {
          addClass(stepEl, swalClasses["active-progress-step"]);
        }
        if (index !== params.progressSteps.length - 1) {
          const lineEl = createLineElement(params);
          progressStepsContainer.appendChild(lineEl);
        }
      });
    };
    const renderTitle = (instance, params) => {
      const title = getTitle();
      toggle(title, params.title || params.titleText, "block");
      if (params.title) {
        parseHtmlToContainer(params.title, title);
      }
      if (params.titleText) {
        title.innerText = params.titleText;
      }
      applyCustomClass(title, params, "title");
    };
    const renderPopup = (instance, params) => {
      const container = getContainer();
      const popup = getPopup();
      if (params.toast) {
        applyNumericalStyle(container, "width", params.width);
        popup.style.width = "100%";
        popup.insertBefore(getLoader(), getIcon());
      } else {
        applyNumericalStyle(popup, "width", params.width);
      }
      applyNumericalStyle(popup, "padding", params.padding);
      if (params.color) {
        popup.style.color = params.color;
      }
      if (params.background) {
        popup.style.background = params.background;
      }
      hide(getValidationMessage());
      addClasses(popup, params);
    };
    const addClasses = (popup, params) => {
      popup.className = "".concat(swalClasses.popup, " ").concat(isVisible(popup) ? params.showClass.popup : "");
      if (params.toast) {
        addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
        addClass(popup, swalClasses.toast);
      } else {
        addClass(popup, swalClasses.modal);
      }
      applyCustomClass(popup, params, "popup");
      if (typeof params.customClass === "string") {
        addClass(popup, params.customClass);
      }
      if (params.icon) {
        addClass(popup, swalClasses["icon-".concat(params.icon)]);
      }
    };
    const render = (instance, params) => {
      renderPopup(instance, params);
      renderContainer(instance, params);
      renderProgressSteps(instance, params);
      renderIcon(instance, params);
      renderImage(instance, params);
      renderTitle(instance, params);
      renderCloseButton(instance, params);
      renderContent(instance, params);
      renderActions(instance, params);
      renderFooter(instance, params);
      if (typeof params.didRender === "function") {
        params.didRender(getPopup());
      }
    };
    const DismissReason = Object.freeze({
      cancel: "cancel",
      backdrop: "backdrop",
      close: "close",
      esc: "esc",
      timer: "timer"
    });
    const setAriaHidden = () => {
      const bodyChildren = toArray2(document.body.children);
      bodyChildren.forEach((el) => {
        if (el === getContainer() || el.contains(getContainer())) {
          return;
        }
        if (el.hasAttribute("aria-hidden")) {
          el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden"));
        }
        el.setAttribute("aria-hidden", "true");
      });
    };
    const unsetAriaHidden = () => {
      const bodyChildren = toArray2(document.body.children);
      bodyChildren.forEach((el) => {
        if (el.hasAttribute("data-previous-aria-hidden")) {
          el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden"));
          el.removeAttribute("data-previous-aria-hidden");
        } else {
          el.removeAttribute("aria-hidden");
        }
      });
    };
    const swalStringParams = ["swal-title", "swal-html", "swal-footer"];
    const getTemplateParams = (params) => {
      const template = typeof params.template === "string" ? document.querySelector(params.template) : params.template;
      if (!template) {
        return {};
      }
      const templateContent = template.content;
      showWarningsForElements(templateContent);
      const result = Object.assign(getSwalParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
      return result;
    };
    const getSwalParams = (templateContent) => {
      const result = {};
      toArray2(templateContent.querySelectorAll("swal-param")).forEach((param) => {
        showWarningsForAttributes(param, ["name", "value"]);
        const paramName = param.getAttribute("name");
        const value2 = param.getAttribute("value");
        if (typeof defaultParams[paramName] === "boolean" && value2 === "false") {
          result[paramName] = false;
        }
        if (typeof defaultParams[paramName] === "object") {
          result[paramName] = JSON.parse(value2);
        }
      });
      return result;
    };
    const getSwalButtons = (templateContent) => {
      const result = {};
      toArray2(templateContent.querySelectorAll("swal-button")).forEach((button) => {
        showWarningsForAttributes(button, ["type", "color", "aria-label"]);
        const type = button.getAttribute("type");
        result["".concat(type, "ButtonText")] = button.innerHTML;
        result["show".concat(capitalizeFirstLetter(type), "Button")] = true;
        if (button.hasAttribute("color")) {
          result["".concat(type, "ButtonColor")] = button.getAttribute("color");
        }
        if (button.hasAttribute("aria-label")) {
          result["".concat(type, "ButtonAriaLabel")] = button.getAttribute("aria-label");
        }
      });
      return result;
    };
    const getSwalImage = (templateContent) => {
      const result = {};
      const image = templateContent.querySelector("swal-image");
      if (image) {
        showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
        if (image.hasAttribute("src")) {
          result.imageUrl = image.getAttribute("src");
        }
        if (image.hasAttribute("width")) {
          result.imageWidth = image.getAttribute("width");
        }
        if (image.hasAttribute("height")) {
          result.imageHeight = image.getAttribute("height");
        }
        if (image.hasAttribute("alt")) {
          result.imageAlt = image.getAttribute("alt");
        }
      }
      return result;
    };
    const getSwalIcon = (templateContent) => {
      const result = {};
      const icon = templateContent.querySelector("swal-icon");
      if (icon) {
        showWarningsForAttributes(icon, ["type", "color"]);
        if (icon.hasAttribute("type")) {
          result.icon = icon.getAttribute("type");
        }
        if (icon.hasAttribute("color")) {
          result.iconColor = icon.getAttribute("color");
        }
        result.iconHtml = icon.innerHTML;
      }
      return result;
    };
    const getSwalInput = (templateContent) => {
      const result = {};
      const input = templateContent.querySelector("swal-input");
      if (input) {
        showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
        result.input = input.getAttribute("type") || "text";
        if (input.hasAttribute("label")) {
          result.inputLabel = input.getAttribute("label");
        }
        if (input.hasAttribute("placeholder")) {
          result.inputPlaceholder = input.getAttribute("placeholder");
        }
        if (input.hasAttribute("value")) {
          result.inputValue = input.getAttribute("value");
        }
      }
      const inputOptions = templateContent.querySelectorAll("swal-input-option");
      if (inputOptions.length) {
        result.inputOptions = {};
        toArray2(inputOptions).forEach((option) => {
          showWarningsForAttributes(option, ["value"]);
          const optionValue = option.getAttribute("value");
          const optionName = option.innerHTML;
          result.inputOptions[optionValue] = optionName;
        });
      }
      return result;
    };
    const getSwalStringParams = (templateContent, paramNames) => {
      const result = {};
      for (const i2 in paramNames) {
        const paramName = paramNames[i2];
        const tag = templateContent.querySelector(paramName);
        if (tag) {
          showWarningsForAttributes(tag, []);
          result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
        }
      }
      return result;
    };
    const showWarningsForElements = (templateContent) => {
      const allowedElements = swalStringParams.concat(["swal-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
      toArray2(templateContent.children).forEach((el) => {
        const tagName = el.tagName.toLowerCase();
        if (allowedElements.indexOf(tagName) === -1) {
          warn2("Unrecognized element <".concat(tagName, ">"));
        }
      });
    };
    const showWarningsForAttributes = (el, allowedAttributes) => {
      toArray2(el.attributes).forEach((attribute) => {
        if (allowedAttributes.indexOf(attribute.name) === -1) {
          warn2(['Unrecognized attribute "'.concat(attribute.name, '" on <').concat(el.tagName.toLowerCase(), ">."), "".concat(allowedAttributes.length ? "Allowed attributes are: ".concat(allowedAttributes.join(", ")) : "To set the value, use HTML within the element.")]);
        }
      });
    };
    var defaultInputValidators = {
      email: (string, validationMessage) => {
        return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
      },
      url: (string, validationMessage) => {
        return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
      }
    };
    function setDefaultInputValidators(params) {
      if (!params.inputValidator) {
        Object.keys(defaultInputValidators).forEach((key) => {
          if (params.input === key) {
            params.inputValidator = defaultInputValidators[key];
          }
        });
      }
    }
    function validateCustomTargetElement(params) {
      if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
        warn2('Target parameter is not valid, defaulting to "body"');
        params.target = "body";
      }
    }
    function setParameters(params) {
      setDefaultInputValidators(params);
      if (params.showLoaderOnConfirm && !params.preConfirm) {
        warn2("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
      }
      validateCustomTargetElement(params);
      if (typeof params.title === "string") {
        params.title = params.title.split("\n").join("<br />");
      }
      init(params);
    }
    class Timer {
      constructor(callback, delay) {
        this.callback = callback;
        this.remaining = delay;
        this.running = false;
        this.start();
      }
      start() {
        if (!this.running) {
          this.running = true;
          this.started = /* @__PURE__ */ new Date();
          this.id = setTimeout(this.callback, this.remaining);
        }
        return this.remaining;
      }
      stop() {
        if (this.running) {
          this.running = false;
          clearTimeout(this.id);
          this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime();
        }
        return this.remaining;
      }
      increase(n) {
        const running = this.running;
        if (running) {
          this.stop();
        }
        this.remaining += n;
        if (running) {
          this.start();
        }
        return this.remaining;
      }
      getTimerLeft() {
        if (this.running) {
          this.stop();
          this.start();
        }
        return this.remaining;
      }
      isRunning() {
        return this.running;
      }
    }
    const fixScrollbar = () => {
      if (states.previousBodyPadding !== null) {
        return;
      }
      if (document.body.scrollHeight > window.innerHeight) {
        states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
        document.body.style.paddingRight = "".concat(states.previousBodyPadding + measureScrollbar(), "px");
      }
    };
    const undoScrollbar = () => {
      if (states.previousBodyPadding !== null) {
        document.body.style.paddingRight = "".concat(states.previousBodyPadding, "px");
        states.previousBodyPadding = null;
      }
    };
    const iOSfix = () => {
      const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
      if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
        const offset2 = document.body.scrollTop;
        document.body.style.top = "".concat(offset2 * -1, "px");
        addClass(document.body, swalClasses.iosfix);
        lockBodyScroll();
        addBottomPaddingForTallPopups();
      }
    };
    const addBottomPaddingForTallPopups = () => {
      const ua = navigator.userAgent;
      const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
      const webkit = !!ua.match(/WebKit/i);
      const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);
      if (iOSSafari) {
        const bottomPanelHeight = 44;
        if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {
          getContainer().style.paddingBottom = "".concat(bottomPanelHeight, "px");
        }
      }
    };
    const lockBodyScroll = () => {
      const container = getContainer();
      let preventTouchMove;
      container.ontouchstart = (e) => {
        preventTouchMove = shouldPreventTouchMove(e);
      };
      container.ontouchmove = (e) => {
        if (preventTouchMove) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
    };
    const shouldPreventTouchMove = (event) => {
      const target = event.target;
      const container = getContainer();
      if (isStylus(event) || isZoom(event)) {
        return false;
      }
      if (target === container) {
        return true;
      }
      if (!isScrollable(container) && target.tagName !== "INPUT" && target.tagName !== "TEXTAREA" && !(isScrollable(getHtmlContainer()) && getHtmlContainer().contains(target))) {
        return true;
      }
      return false;
    };
    const isStylus = (event) => {
      return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
    };
    const isZoom = (event) => {
      return event.touches && event.touches.length > 1;
    };
    const undoIOSfix = () => {
      if (hasClass(document.body, swalClasses.iosfix)) {
        const offset2 = parseInt(document.body.style.top, 10);
        removeClass(document.body, swalClasses.iosfix);
        document.body.style.top = "";
        document.body.scrollTop = offset2 * -1;
      }
    };
    const SHOW_CLASS_TIMEOUT = 10;
    const openPopup = (params) => {
      const container = getContainer();
      const popup = getPopup();
      if (typeof params.willOpen === "function") {
        params.willOpen(popup);
      }
      const bodyStyles = window.getComputedStyle(document.body);
      const initialBodyOverflow = bodyStyles.overflowY;
      addClasses$1(container, popup, params);
      setTimeout(() => {
        setScrollingVisibility(container, popup);
      }, SHOW_CLASS_TIMEOUT);
      if (isModal()) {
        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
        setAriaHidden();
      }
      if (!isToast() && !globalState.previousActiveElement) {
        globalState.previousActiveElement = document.activeElement;
      }
      if (typeof params.didOpen === "function") {
        setTimeout(() => params.didOpen(popup));
      }
      removeClass(container, swalClasses["no-transition"]);
    };
    const swalOpenAnimationFinished = (event) => {
      const popup = getPopup();
      if (event.target !== popup) {
        return;
      }
      const container = getContainer();
      popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
      container.style.overflowY = "auto";
    };
    const setScrollingVisibility = (container, popup) => {
      if (animationEndEvent && hasCssAnimation(popup)) {
        container.style.overflowY = "hidden";
        popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
      } else {
        container.style.overflowY = "auto";
      }
    };
    const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
      iOSfix();
      if (scrollbarPadding && initialBodyOverflow !== "hidden") {
        fixScrollbar();
      }
      setTimeout(() => {
        container.scrollTop = 0;
      });
    };
    const addClasses$1 = (container, popup, params) => {
      addClass(container, params.showClass.backdrop);
      popup.style.setProperty("opacity", "0", "important");
      show(popup, "grid");
      setTimeout(() => {
        addClass(popup, params.showClass.popup);
        popup.style.removeProperty("opacity");
      }, SHOW_CLASS_TIMEOUT);
      addClass([document.documentElement, document.body], swalClasses.shown);
      if (params.heightAuto && params.backdrop && !params.toast) {
        addClass([document.documentElement, document.body], swalClasses["height-auto"]);
      }
    };
    const showLoading = (buttonToReplace) => {
      let popup = getPopup();
      if (!popup) {
        new Swal2();
      }
      popup = getPopup();
      const loader = getLoader();
      if (isToast()) {
        hide(getIcon());
      } else {
        replaceButton(popup, buttonToReplace);
      }
      show(loader);
      popup.setAttribute("data-loading", true);
      popup.setAttribute("aria-busy", true);
      popup.focus();
    };
    const replaceButton = (popup, buttonToReplace) => {
      const actions2 = getActions();
      const loader = getLoader();
      if (!buttonToReplace && isVisible(getConfirmButton())) {
        buttonToReplace = getConfirmButton();
      }
      show(actions2);
      if (buttonToReplace) {
        hide(buttonToReplace);
        loader.setAttribute("data-button-to-replace", buttonToReplace.className);
      }
      loader.parentNode.insertBefore(loader, buttonToReplace);
      addClass([popup, actions2], swalClasses.loading);
    };
    const handleInputOptionsAndValue = (instance, params) => {
      if (params.input === "select" || params.input === "radio") {
        handleInputOptions(instance, params);
      } else if (["text", "email", "number", "tel", "textarea"].includes(params.input) && (hasToPromiseFn(params.inputValue) || isPromise2(params.inputValue))) {
        showLoading(getConfirmButton());
        handleInputValue(instance, params);
      }
    };
    const getInputValue = (instance, innerParams) => {
      const input = instance.getInput();
      if (!input) {
        return null;
      }
      switch (innerParams.input) {
        case "checkbox":
          return getCheckboxValue(input);
        case "radio":
          return getRadioValue(input);
        case "file":
          return getFileValue(input);
        default:
          return innerParams.inputAutoTrim ? input.value.trim() : input.value;
      }
    };
    const getCheckboxValue = (input) => input.checked ? 1 : 0;
    const getRadioValue = (input) => input.checked ? input.value : null;
    const getFileValue = (input) => input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
    const handleInputOptions = (instance, params) => {
      const popup = getPopup();
      const processInputOptions = (inputOptions) => populateInputOptions[params.input](popup, formatInputOptions(inputOptions), params);
      if (hasToPromiseFn(params.inputOptions) || isPromise2(params.inputOptions)) {
        showLoading(getConfirmButton());
        asPromise(params.inputOptions).then((inputOptions) => {
          instance.hideLoading();
          processInputOptions(inputOptions);
        });
      } else if (typeof params.inputOptions === "object") {
        processInputOptions(params.inputOptions);
      } else {
        error("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(typeof params.inputOptions));
      }
    };
    const handleInputValue = (instance, params) => {
      const input = instance.getInput();
      hide(input);
      asPromise(params.inputValue).then((inputValue) => {
        input.value = params.input === "number" ? parseFloat(inputValue) || 0 : "".concat(inputValue);
        show(input);
        input.focus();
        instance.hideLoading();
      }).catch((err) => {
        error("Error in inputValue promise: ".concat(err));
        input.value = "";
        show(input);
        input.focus();
        instance.hideLoading();
      });
    };
    const populateInputOptions = {
      select: (popup, inputOptions, params) => {
        const select = getDirectChildByClass(popup, swalClasses.select);
        const renderOption = (parent, optionLabel, optionValue) => {
          const option = document.createElement("option");
          option.value = optionValue;
          setInnerHtml(option, optionLabel);
          option.selected = isSelected(optionValue, params.inputValue);
          parent.appendChild(option);
        };
        inputOptions.forEach((inputOption) => {
          const optionValue = inputOption[0];
          const optionLabel = inputOption[1];
          if (Array.isArray(optionLabel)) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = optionValue;
            optgroup.disabled = false;
            select.appendChild(optgroup);
            optionLabel.forEach((o) => renderOption(optgroup, o[1], o[0]));
          } else {
            renderOption(select, optionLabel, optionValue);
          }
        });
        select.focus();
      },
      radio: (popup, inputOptions, params) => {
        const radio = getDirectChildByClass(popup, swalClasses.radio);
        inputOptions.forEach((inputOption) => {
          const radioValue = inputOption[0];
          const radioLabel = inputOption[1];
          const radioInput = document.createElement("input");
          const radioLabelElement = document.createElement("label");
          radioInput.type = "radio";
          radioInput.name = swalClasses.radio;
          radioInput.value = radioValue;
          if (isSelected(radioValue, params.inputValue)) {
            radioInput.checked = true;
          }
          const label = document.createElement("span");
          setInnerHtml(label, radioLabel);
          label.className = swalClasses.label;
          radioLabelElement.appendChild(radioInput);
          radioLabelElement.appendChild(label);
          radio.appendChild(radioLabelElement);
        });
        const radios = radio.querySelectorAll("input");
        if (radios.length) {
          radios[0].focus();
        }
      }
    };
    const formatInputOptions = (inputOptions) => {
      const result = [];
      if (typeof Map !== "undefined" && inputOptions instanceof Map) {
        inputOptions.forEach((value2, key) => {
          let valueFormatted = value2;
          if (typeof valueFormatted === "object") {
            valueFormatted = formatInputOptions(valueFormatted);
          }
          result.push([key, valueFormatted]);
        });
      } else {
        Object.keys(inputOptions).forEach((key) => {
          let valueFormatted = inputOptions[key];
          if (typeof valueFormatted === "object") {
            valueFormatted = formatInputOptions(valueFormatted);
          }
          result.push([key, valueFormatted]);
        });
      }
      return result;
    };
    const isSelected = (optionValue, inputValue) => {
      return inputValue && inputValue.toString() === optionValue.toString();
    };
    const handleConfirmButtonClick = (instance) => {
      const innerParams = privateProps.innerParams.get(instance);
      instance.disableButtons();
      if (innerParams.input) {
        handleConfirmOrDenyWithInput(instance, "confirm");
      } else {
        confirm(instance, true);
      }
    };
    const handleDenyButtonClick = (instance) => {
      const innerParams = privateProps.innerParams.get(instance);
      instance.disableButtons();
      if (innerParams.returnInputValueOnDeny) {
        handleConfirmOrDenyWithInput(instance, "deny");
      } else {
        deny(instance, false);
      }
    };
    const handleCancelButtonClick = (instance, dismissWith) => {
      instance.disableButtons();
      dismissWith(DismissReason.cancel);
    };
    const handleConfirmOrDenyWithInput = (instance, type) => {
      const innerParams = privateProps.innerParams.get(instance);
      if (!innerParams.input) {
        return error('The "input" parameter is needed to be set when using returnInputValueOn'.concat(capitalizeFirstLetter(type)));
      }
      const inputValue = getInputValue(instance, innerParams);
      if (innerParams.inputValidator) {
        handleInputValidator(instance, inputValue, type);
      } else if (!instance.getInput().checkValidity()) {
        instance.enableButtons();
        instance.showValidationMessage(innerParams.validationMessage);
      } else if (type === "deny") {
        deny(instance, inputValue);
      } else {
        confirm(instance, inputValue);
      }
    };
    const handleInputValidator = (instance, inputValue, type) => {
      const innerParams = privateProps.innerParams.get(instance);
      instance.disableInput();
      const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
      validationPromise.then((validationMessage) => {
        instance.enableButtons();
        instance.enableInput();
        if (validationMessage) {
          instance.showValidationMessage(validationMessage);
        } else if (type === "deny") {
          deny(instance, inputValue);
        } else {
          confirm(instance, inputValue);
        }
      });
    };
    const deny = (instance, value2) => {
      const innerParams = privateProps.innerParams.get(instance || void 0);
      if (innerParams.showLoaderOnDeny) {
        showLoading(getDenyButton());
      }
      if (innerParams.preDeny) {
        privateProps.awaitingPromise.set(instance || void 0, true);
        const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value2, innerParams.validationMessage)));
        preDenyPromise.then((preDenyValue) => {
          if (preDenyValue === false) {
            instance.hideLoading();
          } else {
            instance.closePopup({
              isDenied: true,
              value: typeof preDenyValue === "undefined" ? value2 : preDenyValue
            });
          }
        }).catch((error$$1) => rejectWith(instance || void 0, error$$1));
      } else {
        instance.closePopup({
          isDenied: true,
          value: value2
        });
      }
    };
    const succeedWith = (instance, value2) => {
      instance.closePopup({
        isConfirmed: true,
        value: value2
      });
    };
    const rejectWith = (instance, error$$1) => {
      instance.rejectPromise(error$$1);
    };
    const confirm = (instance, value2) => {
      const innerParams = privateProps.innerParams.get(instance || void 0);
      if (innerParams.showLoaderOnConfirm) {
        showLoading();
      }
      if (innerParams.preConfirm) {
        instance.resetValidationMessage();
        privateProps.awaitingPromise.set(instance || void 0, true);
        const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value2, innerParams.validationMessage)));
        preConfirmPromise.then((preConfirmValue) => {
          if (isVisible(getValidationMessage()) || preConfirmValue === false) {
            instance.hideLoading();
          } else {
            succeedWith(instance, typeof preConfirmValue === "undefined" ? value2 : preConfirmValue);
          }
        }).catch((error$$1) => rejectWith(instance || void 0, error$$1));
      } else {
        succeedWith(instance, value2);
      }
    };
    const handlePopupClick = (instance, domCache, dismissWith) => {
      const innerParams = privateProps.innerParams.get(instance);
      if (innerParams.toast) {
        handleToastClick(instance, domCache, dismissWith);
      } else {
        handleModalMousedown(domCache);
        handleContainerMousedown(domCache);
        handleModalClick(instance, domCache, dismissWith);
      }
    };
    const handleToastClick = (instance, domCache, dismissWith) => {
      domCache.popup.onclick = () => {
        const innerParams = privateProps.innerParams.get(instance);
        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
          return;
        }
        dismissWith(DismissReason.close);
      };
    };
    const isAnyButtonShown = (innerParams) => {
      return innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton;
    };
    let ignoreOutsideClick = false;
    const handleModalMousedown = (domCache) => {
      domCache.popup.onmousedown = () => {
        domCache.container.onmouseup = function(e) {
          domCache.container.onmouseup = void 0;
          if (e.target === domCache.container) {
            ignoreOutsideClick = true;
          }
        };
      };
    };
    const handleContainerMousedown = (domCache) => {
      domCache.container.onmousedown = () => {
        domCache.popup.onmouseup = function(e) {
          domCache.popup.onmouseup = void 0;
          if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
            ignoreOutsideClick = true;
          }
        };
      };
    };
    const handleModalClick = (instance, domCache, dismissWith) => {
      domCache.container.onclick = (e) => {
        const innerParams = privateProps.innerParams.get(instance);
        if (ignoreOutsideClick) {
          ignoreOutsideClick = false;
          return;
        }
        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
          dismissWith(DismissReason.backdrop);
        }
      };
    };
    const isVisible$1 = () => {
      return isVisible(getPopup());
    };
    const clickConfirm = () => getConfirmButton() && getConfirmButton().click();
    const clickDeny = () => getDenyButton() && getDenyButton().click();
    const clickCancel = () => getCancelButton() && getCancelButton().click();
    const addKeydownHandler = (instance, globalState2, innerParams, dismissWith) => {
      if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
        globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
          capture: globalState2.keydownListenerCapture
        });
        globalState2.keydownHandlerAdded = false;
      }
      if (!innerParams.toast) {
        globalState2.keydownHandler = (e) => keydownHandler(instance, e, dismissWith);
        globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
        globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
        globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
          capture: globalState2.keydownListenerCapture
        });
        globalState2.keydownHandlerAdded = true;
      }
    };
    const setFocus = (innerParams, index, increment) => {
      const focusableElements = getFocusableElements();
      if (focusableElements.length) {
        index = index + increment;
        if (index === focusableElements.length) {
          index = 0;
        } else if (index === -1) {
          index = focusableElements.length - 1;
        }
        return focusableElements[index].focus();
      }
      getPopup().focus();
    };
    const arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
    const arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
    const keydownHandler = (instance, e, dismissWith) => {
      const innerParams = privateProps.innerParams.get(instance);
      if (!innerParams) {
        return;
      }
      if (innerParams.stopKeydownPropagation) {
        e.stopPropagation();
      }
      if (e.key === "Enter") {
        handleEnter(instance, e, innerParams);
      } else if (e.key === "Tab") {
        handleTab(e, innerParams);
      } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(e.key)) {
        handleArrows(e.key);
      } else if (e.key === "Escape") {
        handleEsc(e, innerParams, dismissWith);
      }
    };
    const handleEnter = (instance, e, innerParams) => {
      if (!callIfFunction(innerParams.allowEnterKey) || e.isComposing) {
        return;
      }
      if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {
        if (["textarea", "file"].includes(innerParams.input)) {
          return;
        }
        clickConfirm();
        e.preventDefault();
      }
    };
    const handleTab = (e, innerParams) => {
      const targetElement = e.target;
      const focusableElements = getFocusableElements();
      let btnIndex = -1;
      for (let i2 = 0; i2 < focusableElements.length; i2++) {
        if (targetElement === focusableElements[i2]) {
          btnIndex = i2;
          break;
        }
      }
      if (!e.shiftKey) {
        setFocus(innerParams, btnIndex, 1);
      } else {
        setFocus(innerParams, btnIndex, -1);
      }
      e.stopPropagation();
      e.preventDefault();
    };
    const handleArrows = (key) => {
      const confirmButton = getConfirmButton();
      const denyButton = getDenyButton();
      const cancelButton = getCancelButton();
      if (![confirmButton, denyButton, cancelButton].includes(document.activeElement)) {
        return;
      }
      const sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
      const buttonToFocus = document.activeElement[sibling];
      if (buttonToFocus instanceof HTMLElement) {
        buttonToFocus.focus();
      }
    };
    const handleEsc = (e, innerParams, dismissWith) => {
      if (callIfFunction(innerParams.allowEscapeKey)) {
        e.preventDefault();
        dismissWith(DismissReason.esc);
      }
    };
    const isJqueryElement = (elem) => typeof elem === "object" && elem.jquery;
    const isElement = (elem) => elem instanceof Element || isJqueryElement(elem);
    const argsToParams = (args) => {
      const params = {};
      if (typeof args[0] === "object" && !isElement(args[0])) {
        Object.assign(params, args[0]);
      } else {
        ["title", "html", "icon"].forEach((name, index) => {
          const arg = args[index];
          if (typeof arg === "string" || isElement(arg)) {
            params[name] = arg;
          } else if (arg !== void 0) {
            error("Unexpected type of ".concat(name, '! Expected "string" or "Element", got ').concat(typeof arg));
          }
        });
      }
      return params;
    };
    function fire() {
      const Swal3 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return new Swal3(...args);
    }
    function mixin2(mixinParams) {
      class MixinSwal extends this {
        _main(params, priorityMixinParams) {
          return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
        }
      }
      return MixinSwal;
    }
    const getTimerLeft = () => {
      return globalState.timeout && globalState.timeout.getTimerLeft();
    };
    const stopTimer = () => {
      if (globalState.timeout) {
        stopTimerProgressBar();
        return globalState.timeout.stop();
      }
    };
    const resumeTimer = () => {
      if (globalState.timeout) {
        const remaining = globalState.timeout.start();
        animateTimerProgressBar(remaining);
        return remaining;
      }
    };
    const toggleTimer = () => {
      const timer = globalState.timeout;
      return timer && (timer.running ? stopTimer() : resumeTimer());
    };
    const increaseTimer = (n) => {
      if (globalState.timeout) {
        const remaining = globalState.timeout.increase(n);
        animateTimerProgressBar(remaining, true);
        return remaining;
      }
    };
    const isTimerRunning = () => {
      return globalState.timeout && globalState.timeout.isRunning();
    };
    let bodyClickListenerAdded = false;
    const clickHandlers = {};
    function bindClickHandler() {
      let attr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data-swal-template";
      clickHandlers[attr] = this;
      if (!bodyClickListenerAdded) {
        document.body.addEventListener("click", bodyClickListener);
        bodyClickListenerAdded = true;
      }
    }
    const bodyClickListener = (event) => {
      for (let el = event.target; el && el !== document; el = el.parentNode) {
        for (const attr in clickHandlers) {
          const template = el.getAttribute(attr);
          if (template) {
            clickHandlers[attr].fire({
              template
            });
            return;
          }
        }
      }
    };
    var staticMethods = /* @__PURE__ */ Object.freeze({
      isValidParameter,
      isUpdatableParameter,
      isDeprecatedParameter,
      argsToParams,
      isVisible: isVisible$1,
      clickConfirm,
      clickDeny,
      clickCancel,
      getContainer,
      getPopup,
      getTitle,
      getHtmlContainer,
      getImage,
      getIcon,
      getInputLabel,
      getCloseButton,
      getActions,
      getConfirmButton,
      getDenyButton,
      getCancelButton,
      getLoader,
      getFooter,
      getTimerProgressBar,
      getFocusableElements,
      getValidationMessage,
      isLoading,
      fire,
      mixin: mixin2,
      showLoading,
      enableLoading: showLoading,
      getTimerLeft,
      stopTimer,
      resumeTimer,
      toggleTimer,
      increaseTimer,
      isTimerRunning,
      bindClickHandler
    });
    function hideLoading() {
      const innerParams = privateProps.innerParams.get(this);
      if (!innerParams) {
        return;
      }
      const domCache = privateProps.domCache.get(this);
      hide(domCache.loader);
      if (isToast()) {
        if (innerParams.icon) {
          show(getIcon());
        }
      } else {
        showRelatedButton(domCache);
      }
      removeClass([domCache.popup, domCache.actions], swalClasses.loading);
      domCache.popup.removeAttribute("aria-busy");
      domCache.popup.removeAttribute("data-loading");
      domCache.confirmButton.disabled = false;
      domCache.denyButton.disabled = false;
      domCache.cancelButton.disabled = false;
    }
    const showRelatedButton = (domCache) => {
      const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
      if (buttonToReplace.length) {
        show(buttonToReplace[0], "inline-block");
      } else if (allButtonsAreHidden()) {
        hide(domCache.actions);
      }
    };
    function getInput$1(instance) {
      const innerParams = privateProps.innerParams.get(instance || this);
      const domCache = privateProps.domCache.get(instance || this);
      if (!domCache) {
        return null;
      }
      return getInput(domCache.popup, innerParams.input);
    }
    var privateMethods = {
      swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
      swalPromiseReject: /* @__PURE__ */ new WeakMap()
    };
    function removePopupAndResetState(instance, container, returnFocus, didClose) {
      if (isToast()) {
        triggerDidCloseAndDispose(instance, didClose);
      } else {
        restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
        globalState.keydownTarget.removeEventListener("keydown", globalState.keydownHandler, {
          capture: globalState.keydownListenerCapture
        });
        globalState.keydownHandlerAdded = false;
      }
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (isSafari) {
        container.setAttribute("style", "display:none !important");
        container.removeAttribute("class");
        container.innerHTML = "";
      } else {
        container.remove();
      }
      if (isModal()) {
        undoScrollbar();
        undoIOSfix();
        unsetAriaHidden();
      }
      removeBodyClasses();
    }
    function removeBodyClasses() {
      removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
    }
    function close(resolveValue) {
      resolveValue = prepareResolveValue(resolveValue);
      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
      const didClose = triggerClosePopup(this);
      if (this.isAwaitingPromise()) {
        if (!resolveValue.isDismissed) {
          handleAwaitingPromise(this);
          swalPromiseResolve(resolveValue);
        }
      } else if (didClose) {
        swalPromiseResolve(resolveValue);
      }
    }
    function isAwaitingPromise() {
      return !!privateProps.awaitingPromise.get(this);
    }
    const triggerClosePopup = (instance) => {
      const popup = getPopup();
      if (!popup) {
        return false;
      }
      const innerParams = privateProps.innerParams.get(instance);
      if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
        return false;
      }
      removeClass(popup, innerParams.showClass.popup);
      addClass(popup, innerParams.hideClass.popup);
      const backdrop = getContainer();
      removeClass(backdrop, innerParams.showClass.backdrop);
      addClass(backdrop, innerParams.hideClass.backdrop);
      handlePopupAnimation(instance, popup, innerParams);
      return true;
    };
    function rejectPromise(error2) {
      const rejectPromise2 = privateMethods.swalPromiseReject.get(this);
      handleAwaitingPromise(this);
      if (rejectPromise2) {
        rejectPromise2(error2);
      }
    }
    const handleAwaitingPromise = (instance) => {
      if (instance.isAwaitingPromise()) {
        privateProps.awaitingPromise.delete(instance);
        if (!privateProps.innerParams.get(instance)) {
          instance._destroy();
        }
      }
    };
    const prepareResolveValue = (resolveValue) => {
      if (typeof resolveValue === "undefined") {
        return {
          isConfirmed: false,
          isDenied: false,
          isDismissed: true
        };
      }
      return Object.assign({
        isConfirmed: false,
        isDenied: false,
        isDismissed: false
      }, resolveValue);
    };
    const handlePopupAnimation = (instance, popup, innerParams) => {
      const container = getContainer();
      const animationIsSupported = animationEndEvent && hasCssAnimation(popup);
      if (typeof innerParams.willClose === "function") {
        innerParams.willClose(popup);
      }
      if (animationIsSupported) {
        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
      } else {
        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
      }
    };
    const animatePopup = (instance, popup, container, returnFocus, didClose) => {
      globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
      popup.addEventListener(animationEndEvent, function(e) {
        if (e.target === popup) {
          globalState.swalCloseEventFinishedCallback();
          delete globalState.swalCloseEventFinishedCallback;
        }
      });
    };
    const triggerDidCloseAndDispose = (instance, didClose) => {
      setTimeout(() => {
        if (typeof didClose === "function") {
          didClose.bind(instance.params)();
        }
        instance._destroy();
      });
    };
    function setButtonsDisabled(instance, buttons, disabled) {
      const domCache = privateProps.domCache.get(instance);
      buttons.forEach((button) => {
        domCache[button].disabled = disabled;
      });
    }
    function setInputDisabled(input, disabled) {
      if (!input) {
        return false;
      }
      if (input.type === "radio") {
        const radiosContainer = input.parentNode.parentNode;
        const radios = radiosContainer.querySelectorAll("input");
        for (let i2 = 0; i2 < radios.length; i2++) {
          radios[i2].disabled = disabled;
        }
      } else {
        input.disabled = disabled;
      }
    }
    function enableButtons() {
      setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
    }
    function disableButtons() {
      setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
    }
    function enableInput() {
      return setInputDisabled(this.getInput(), false);
    }
    function disableInput() {
      return setInputDisabled(this.getInput(), true);
    }
    function showValidationMessage(error2) {
      const domCache = privateProps.domCache.get(this);
      const params = privateProps.innerParams.get(this);
      setInnerHtml(domCache.validationMessage, error2);
      domCache.validationMessage.className = swalClasses["validation-message"];
      if (params.customClass && params.customClass.validationMessage) {
        addClass(domCache.validationMessage, params.customClass.validationMessage);
      }
      show(domCache.validationMessage);
      const input = this.getInput();
      if (input) {
        input.setAttribute("aria-invalid", true);
        input.setAttribute("aria-describedby", swalClasses["validation-message"]);
        focusInput(input);
        addClass(input, swalClasses.inputerror);
      }
    }
    function resetValidationMessage$1() {
      const domCache = privateProps.domCache.get(this);
      if (domCache.validationMessage) {
        hide(domCache.validationMessage);
      }
      const input = this.getInput();
      if (input) {
        input.removeAttribute("aria-invalid");
        input.removeAttribute("aria-describedby");
        removeClass(input, swalClasses.inputerror);
      }
    }
    function getProgressSteps$1() {
      const domCache = privateProps.domCache.get(this);
      return domCache.progressSteps;
    }
    function update3(params) {
      const popup = getPopup();
      const innerParams = privateProps.innerParams.get(this);
      if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
        return warn2("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
      }
      const validUpdatableParams = filterValidParams(params);
      const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
      render(this, updatedParams);
      privateProps.innerParams.set(this, updatedParams);
      Object.defineProperties(this, {
        params: {
          value: Object.assign({}, this.params, params),
          writable: false,
          enumerable: true
        }
      });
    }
    const filterValidParams = (params) => {
      const validUpdatableParams = {};
      Object.keys(params).forEach((param) => {
        if (isUpdatableParameter(param)) {
          validUpdatableParams[param] = params[param];
        } else {
          warn2('Invalid parameter to update: "'.concat(param, '". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\n\nIf you think this parameter should be updatable, request it here: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md'));
        }
      });
      return validUpdatableParams;
    };
    function _destroy() {
      const domCache = privateProps.domCache.get(this);
      const innerParams = privateProps.innerParams.get(this);
      if (!innerParams) {
        disposeWeakMaps(this);
        return;
      }
      if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
        globalState.swalCloseEventFinishedCallback();
        delete globalState.swalCloseEventFinishedCallback;
      }
      if (globalState.deferDisposalTimer) {
        clearTimeout(globalState.deferDisposalTimer);
        delete globalState.deferDisposalTimer;
      }
      if (typeof innerParams.didDestroy === "function") {
        innerParams.didDestroy();
      }
      disposeSwal(this);
    }
    const disposeSwal = (instance) => {
      disposeWeakMaps(instance);
      delete instance.params;
      delete globalState.keydownHandler;
      delete globalState.keydownTarget;
      delete globalState.currentInstance;
    };
    const disposeWeakMaps = (instance) => {
      if (instance.isAwaitingPromise()) {
        unsetWeakMaps(privateProps, instance);
        privateProps.awaitingPromise.set(instance, true);
      } else {
        unsetWeakMaps(privateMethods, instance);
        unsetWeakMaps(privateProps, instance);
      }
    };
    const unsetWeakMaps = (obj, instance) => {
      for (const i2 in obj) {
        obj[i2].delete(instance);
      }
    };
    var instanceMethods = /* @__PURE__ */ Object.freeze({
      hideLoading,
      disableLoading: hideLoading,
      getInput: getInput$1,
      close,
      isAwaitingPromise,
      rejectPromise,
      closePopup: close,
      closeModal: close,
      closeToast: close,
      enableButtons,
      disableButtons,
      enableInput,
      disableInput,
      showValidationMessage,
      resetValidationMessage: resetValidationMessage$1,
      getProgressSteps: getProgressSteps$1,
      update: update3,
      _destroy
    });
    let currentInstance2;
    class SweetAlert {
      constructor() {
        if (typeof window === "undefined") {
          return;
        }
        currentInstance2 = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const outerParams = Object.freeze(this.constructor.argsToParams(args));
        Object.defineProperties(this, {
          params: {
            value: outerParams,
            writable: false,
            enumerable: true,
            configurable: true
          }
        });
        const promise = this._main(this.params);
        privateProps.promise.set(this, promise);
      }
      _main(userParams) {
        let mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        showWarningsForParams(Object.assign({}, mixinParams, userParams));
        if (globalState.currentInstance) {
          globalState.currentInstance._destroy();
          if (isModal()) {
            unsetAriaHidden();
          }
        }
        globalState.currentInstance = this;
        const innerParams = prepareParams(userParams, mixinParams);
        setParameters(innerParams);
        Object.freeze(innerParams);
        if (globalState.timeout) {
          globalState.timeout.stop();
          delete globalState.timeout;
        }
        clearTimeout(globalState.restoreFocusTimeout);
        const domCache = populateDomCache(this);
        render(this, innerParams);
        privateProps.innerParams.set(this, innerParams);
        return swalPromise(this, domCache, innerParams);
      }
      then(onFulfilled) {
        const promise = privateProps.promise.get(this);
        return promise.then(onFulfilled);
      }
      finally(onFinally) {
        const promise = privateProps.promise.get(this);
        return promise.finally(onFinally);
      }
    }
    const swalPromise = (instance, domCache, innerParams) => {
      return new Promise((resolve2, reject) => {
        const dismissWith = (dismiss) => {
          instance.closePopup({
            isDismissed: true,
            dismiss
          });
        };
        privateMethods.swalPromiseResolve.set(instance, resolve2);
        privateMethods.swalPromiseReject.set(instance, reject);
        domCache.confirmButton.onclick = () => handleConfirmButtonClick(instance);
        domCache.denyButton.onclick = () => handleDenyButtonClick(instance);
        domCache.cancelButton.onclick = () => handleCancelButtonClick(instance, dismissWith);
        domCache.closeButton.onclick = () => dismissWith(DismissReason.close);
        handlePopupClick(instance, domCache, dismissWith);
        addKeydownHandler(instance, globalState, innerParams, dismissWith);
        handleInputOptionsAndValue(instance, innerParams);
        openPopup(innerParams);
        setupTimer(globalState, innerParams, dismissWith);
        initFocus(domCache, innerParams);
        setTimeout(() => {
          domCache.container.scrollTop = 0;
        });
      });
    };
    const prepareParams = (userParams, mixinParams) => {
      const templateParams = getTemplateParams(userParams);
      const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
      params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
      params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
      return params;
    };
    const populateDomCache = (instance) => {
      const domCache = {
        popup: getPopup(),
        container: getContainer(),
        actions: getActions(),
        confirmButton: getConfirmButton(),
        denyButton: getDenyButton(),
        cancelButton: getCancelButton(),
        loader: getLoader(),
        closeButton: getCloseButton(),
        validationMessage: getValidationMessage(),
        progressSteps: getProgressSteps()
      };
      privateProps.domCache.set(instance, domCache);
      return domCache;
    };
    const setupTimer = (globalState$$1, innerParams, dismissWith) => {
      const timerProgressBar = getTimerProgressBar();
      hide(timerProgressBar);
      if (innerParams.timer) {
        globalState$$1.timeout = new Timer(() => {
          dismissWith("timer");
          delete globalState$$1.timeout;
        }, innerParams.timer);
        if (innerParams.timerProgressBar) {
          show(timerProgressBar);
          applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
          setTimeout(() => {
            if (globalState$$1.timeout && globalState$$1.timeout.running) {
              animateTimerProgressBar(innerParams.timer);
            }
          });
        }
      }
    };
    const initFocus = (domCache, innerParams) => {
      if (innerParams.toast) {
        return;
      }
      if (!callIfFunction(innerParams.allowEnterKey)) {
        return blurActiveElement();
      }
      if (!focusButton(domCache, innerParams)) {
        setFocus(innerParams, -1, 1);
      }
    };
    const focusButton = (domCache, innerParams) => {
      if (innerParams.focusDeny && isVisible(domCache.denyButton)) {
        domCache.denyButton.focus();
        return true;
      }
      if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
        domCache.cancelButton.focus();
        return true;
      }
      if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
        domCache.confirmButton.focus();
        return true;
      }
      return false;
    };
    const blurActiveElement = () => {
      if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
        document.activeElement.blur();
      }
    };
    Object.assign(SweetAlert.prototype, instanceMethods);
    Object.assign(SweetAlert, staticMethods);
    Object.keys(instanceMethods).forEach((key) => {
      SweetAlert[key] = function() {
        if (currentInstance2) {
          return currentInstance2[key](...arguments);
        }
      };
    });
    SweetAlert.DismissReason = DismissReason;
    SweetAlert.version = "11.4.0";
    const Swal2 = SweetAlert;
    Swal2.default = Swal2;
    return Swal2;
  });
  if (typeof commonjsGlobal !== "undefined" && commonjsGlobal.Sweetalert2) {
    commonjsGlobal.swal = commonjsGlobal.sweetAlert = commonjsGlobal.Swal = commonjsGlobal.SweetAlert = commonjsGlobal.Sweetalert2;
  }
})(sweetalert2);
var Swal = sweetalert2.exports;
class VueSweetalert2 {
  static install(vue, options = {}) {
    var _a;
    const swalLocalInstance = Swal.mixin(options);
    const swalFunction = function(...args) {
      return swalLocalInstance.fire.call(swalLocalInstance, ...args);
    };
    Object.assign(swalFunction, Swal);
    Object.keys(Swal).filter((key) => typeof Swal[key] === "function").forEach((methodName) => {
      swalFunction[methodName] = swalLocalInstance[methodName].bind(swalLocalInstance);
    });
    if (((_a = vue.config) == null ? void 0 : _a.globalProperties) && !vue.config.globalProperties.$swal) {
      vue.config.globalProperties.$swal = swalFunction;
      vue.provide("$swal", swalFunction);
    } else if (!Object.prototype.hasOwnProperty.call(vue, "$swal")) {
      vue.prototype.$swal = swalFunction;
      vue["swal"] = swalFunction;
    }
  }
}
var dist = { exports: {} };
(function(module2, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module2.exports = factory();
  })(commonjsGlobal$1, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.i = function(value2) {
          return value2;
        };
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {
              /******/
              configurable: false,
              /******/
              enumerable: true,
              /******/
              get: getter
              /******/
            });
          }
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "/dist/";
        return __webpack_require__(__webpack_require__.s = 75);
      }([
        /* 0 */
        /***/
        function(module3, exports2) {
          var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
          if (typeof __g == "number")
            __g = global2;
        },
        /* 1 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var store2 = __webpack_require__(46)("wks");
          var uid2 = __webpack_require__(50);
          var Symbol2 = __webpack_require__(0).Symbol;
          var USE_SYMBOL = typeof Symbol2 == "function";
          var $exports = module3.exports = function(name) {
            return store2[name] || (store2[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid2)("Symbol." + name));
          };
          $exports.store = store2;
        },
        /* 2 */
        /***/
        function(module3, exports2) {
          var process2 = module3.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue2 = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue2 = currentQueue.concat(queue2);
            } else {
              queueIndex = -1;
            }
            if (queue2.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue2.length;
            while (len) {
              currentQueue = queue2;
              queue2 = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue2.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i2 = 1; i2 < arguments.length; i2++) {
                args[i2 - 1] = arguments[i2];
              }
            }
            queue2.push(new Item(fun, args));
            if (queue2.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process2.title = "browser";
          process2.browser = true;
          process2.env = {};
          process2.argv = [];
          process2.version = "";
          process2.versions = {};
          function noop2() {
          }
          process2.on = noop2;
          process2.addListener = noop2;
          process2.once = noop2;
          process2.off = noop2;
          process2.removeListener = noop2;
          process2.removeAllListeners = noop2;
          process2.emit = noop2;
          process2.prependListener = noop2;
          process2.prependOnceListener = noop2;
          process2.listeners = function(name) {
            return [];
          };
          process2.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process2.cwd = function() {
            return "/";
          };
          process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process2.umask = function() {
            return 0;
          };
        },
        /* 3 */
        /***/
        function(module3, exports2) {
          var core = module3.exports = { version: "2.6.12" };
          if (typeof __e == "number")
            __e = core;
        },
        /* 4 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__(13);
          module3.exports = function(it) {
            if (!isObject2(it))
              throw TypeError(it + " is not an object!");
            return it;
          };
        },
        /* 5 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(global2) {
            /*!
            * The buffer module from node.js, for the browser.
            *
            * @author   Feross Aboukhadijeh <http://feross.org>
            * @license  MIT
            */
            var base64 = __webpack_require__(82);
            var ieee754 = __webpack_require__(137);
            var isArray2 = __webpack_require__(138);
            exports2.Buffer = Buffer2;
            exports2.SlowBuffer = SlowBuffer;
            exports2.INSPECT_MAX_BYTES = 50;
            Buffer2.TYPED_ARRAY_SUPPORT = global2.TYPED_ARRAY_SUPPORT !== void 0 ? global2.TYPED_ARRAY_SUPPORT : typedArraySupport();
            exports2.kMaxLength = kMaxLength();
            function typedArraySupport() {
              try {
                var arr = new Uint8Array(1);
                arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } };
                return arr.foo() === 42 && // typed array instances can be augmented
                typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                arr.subarray(1, 1).byteLength === 0;
              } catch (e) {
                return false;
              }
            }
            function kMaxLength() {
              return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
            }
            function createBuffer(that, length2) {
              if (kMaxLength() < length2) {
                throw new RangeError("Invalid typed array length");
              }
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                that = new Uint8Array(length2);
                that.__proto__ = Buffer2.prototype;
              } else {
                if (that === null) {
                  that = new Buffer2(length2);
                }
                that.length = length2;
              }
              return that;
            }
            function Buffer2(arg, encodingOrOffset, length2) {
              if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
                return new Buffer2(arg, encodingOrOffset, length2);
              }
              if (typeof arg === "number") {
                if (typeof encodingOrOffset === "string") {
                  throw new Error(
                    "If encoding is specified then the first argument must be a string"
                  );
                }
                return allocUnsafe(this, arg);
              }
              return from2(this, arg, encodingOrOffset, length2);
            }
            Buffer2.poolSize = 8192;
            Buffer2._augment = function(arr) {
              arr.__proto__ = Buffer2.prototype;
              return arr;
            };
            function from2(that, value2, encodingOrOffset, length2) {
              if (typeof value2 === "number") {
                throw new TypeError('"value" argument must not be a number');
              }
              if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
                return fromArrayBuffer(that, value2, encodingOrOffset, length2);
              }
              if (typeof value2 === "string") {
                return fromString(that, value2, encodingOrOffset);
              }
              return fromObject(that, value2);
            }
            Buffer2.from = function(value2, encodingOrOffset, length2) {
              return from2(null, value2, encodingOrOffset, length2);
            };
            if (Buffer2.TYPED_ARRAY_SUPPORT) {
              Buffer2.prototype.__proto__ = Uint8Array.prototype;
              Buffer2.__proto__ = Uint8Array;
              if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
                Object.defineProperty(Buffer2, Symbol.species, {
                  value: null,
                  configurable: true
                });
              }
            }
            function assertSize(size2) {
              if (typeof size2 !== "number") {
                throw new TypeError('"size" argument must be a number');
              } else if (size2 < 0) {
                throw new RangeError('"size" argument must not be negative');
              }
            }
            function alloc(that, size2, fill, encoding) {
              assertSize(size2);
              if (size2 <= 0) {
                return createBuffer(that, size2);
              }
              if (fill !== void 0) {
                return typeof encoding === "string" ? createBuffer(that, size2).fill(fill, encoding) : createBuffer(that, size2).fill(fill);
              }
              return createBuffer(that, size2);
            }
            Buffer2.alloc = function(size2, fill, encoding) {
              return alloc(null, size2, fill, encoding);
            };
            function allocUnsafe(that, size2) {
              assertSize(size2);
              that = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
              if (!Buffer2.TYPED_ARRAY_SUPPORT) {
                for (var i2 = 0; i2 < size2; ++i2) {
                  that[i2] = 0;
                }
              }
              return that;
            }
            Buffer2.allocUnsafe = function(size2) {
              return allocUnsafe(null, size2);
            };
            Buffer2.allocUnsafeSlow = function(size2) {
              return allocUnsafe(null, size2);
            };
            function fromString(that, string, encoding) {
              if (typeof encoding !== "string" || encoding === "") {
                encoding = "utf8";
              }
              if (!Buffer2.isEncoding(encoding)) {
                throw new TypeError('"encoding" must be a valid string encoding');
              }
              var length2 = byteLength2(string, encoding) | 0;
              that = createBuffer(that, length2);
              var actual = that.write(string, encoding);
              if (actual !== length2) {
                that = that.slice(0, actual);
              }
              return that;
            }
            function fromArrayLike(that, array) {
              var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
              that = createBuffer(that, length2);
              for (var i2 = 0; i2 < length2; i2 += 1) {
                that[i2] = array[i2] & 255;
              }
              return that;
            }
            function fromArrayBuffer(that, array, byteOffset, length2) {
              array.byteLength;
              if (byteOffset < 0 || array.byteLength < byteOffset) {
                throw new RangeError("'offset' is out of bounds");
              }
              if (array.byteLength < byteOffset + (length2 || 0)) {
                throw new RangeError("'length' is out of bounds");
              }
              if (byteOffset === void 0 && length2 === void 0) {
                array = new Uint8Array(array);
              } else if (length2 === void 0) {
                array = new Uint8Array(array, byteOffset);
              } else {
                array = new Uint8Array(array, byteOffset, length2);
              }
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                that = array;
                that.__proto__ = Buffer2.prototype;
              } else {
                that = fromArrayLike(that, array);
              }
              return that;
            }
            function fromObject(that, obj) {
              if (Buffer2.isBuffer(obj)) {
                var len = checked(obj.length) | 0;
                that = createBuffer(that, len);
                if (that.length === 0) {
                  return that;
                }
                obj.copy(that, 0, 0, len);
                return that;
              }
              if (obj) {
                if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                  if (typeof obj.length !== "number" || isnan(obj.length)) {
                    return createBuffer(that, 0);
                  }
                  return fromArrayLike(that, obj);
                }
                if (obj.type === "Buffer" && isArray2(obj.data)) {
                  return fromArrayLike(that, obj.data);
                }
              }
              throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
            }
            function checked(length2) {
              if (length2 >= kMaxLength()) {
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
              }
              return length2 | 0;
            }
            function SlowBuffer(length2) {
              if (+length2 != length2) {
                length2 = 0;
              }
              return Buffer2.alloc(+length2);
            }
            Buffer2.isBuffer = function isBuffer2(b) {
              return !!(b != null && b._isBuffer);
            };
            Buffer2.compare = function compare(a, b) {
              if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                throw new TypeError("Arguments must be Buffers");
              }
              if (a === b)
                return 0;
              var x2 = a.length;
              var y = b.length;
              for (var i2 = 0, len = Math.min(x2, y); i2 < len; ++i2) {
                if (a[i2] !== b[i2]) {
                  x2 = a[i2];
                  y = b[i2];
                  break;
                }
              }
              if (x2 < y)
                return -1;
              if (y < x2)
                return 1;
              return 0;
            };
            Buffer2.isEncoding = function isEncoding(encoding) {
              switch (String(encoding).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            };
            Buffer2.concat = function concat(list, length2) {
              if (!isArray2(list)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              if (list.length === 0) {
                return Buffer2.alloc(0);
              }
              var i2;
              if (length2 === void 0) {
                length2 = 0;
                for (i2 = 0; i2 < list.length; ++i2) {
                  length2 += list[i2].length;
                }
              }
              var buffer = Buffer2.allocUnsafe(length2);
              var pos = 0;
              for (i2 = 0; i2 < list.length; ++i2) {
                var buf = list[i2];
                if (!Buffer2.isBuffer(buf)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                buf.copy(buffer, pos);
                pos += buf.length;
              }
              return buffer;
            };
            function byteLength2(string, encoding) {
              if (Buffer2.isBuffer(string)) {
                return string.length;
              }
              if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                return string.byteLength;
              }
              if (typeof string !== "string") {
                string = "" + string;
              }
              var len = string.length;
              if (len === 0)
                return 0;
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return len;
                  case "utf8":
                  case "utf-8":
                  case void 0:
                    return utf8ToBytes(string).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return len * 2;
                  case "hex":
                    return len >>> 1;
                  case "base64":
                    return base64ToBytes(string).length;
                  default:
                    if (loweredCase)
                      return utf8ToBytes(string).length;
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.byteLength = byteLength2;
            function slowToString(encoding, start, end) {
              var loweredCase = false;
              if (start === void 0 || start < 0) {
                start = 0;
              }
              if (start > this.length) {
                return "";
              }
              if (end === void 0 || end > this.length) {
                end = this.length;
              }
              if (end <= 0) {
                return "";
              }
              end >>>= 0;
              start >>>= 0;
              if (end <= start) {
                return "";
              }
              if (!encoding)
                encoding = "utf8";
              while (true) {
                switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);
                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);
                  case "ascii":
                    return asciiSlice(this, start, end);
                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);
                  case "base64":
                    return base64Slice(this, start, end);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase();
                    loweredCase = true;
                }
              }
            }
            Buffer2.prototype._isBuffer = true;
            function swap(b, n, m) {
              var i2 = b[n];
              b[n] = b[m];
              b[m] = i2;
            }
            Buffer2.prototype.swap16 = function swap16() {
              var len = this.length;
              if (len % 2 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              }
              for (var i2 = 0; i2 < len; i2 += 2) {
                swap(this, i2, i2 + 1);
              }
              return this;
            };
            Buffer2.prototype.swap32 = function swap32() {
              var len = this.length;
              if (len % 4 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              }
              for (var i2 = 0; i2 < len; i2 += 4) {
                swap(this, i2, i2 + 3);
                swap(this, i2 + 1, i2 + 2);
              }
              return this;
            };
            Buffer2.prototype.swap64 = function swap64() {
              var len = this.length;
              if (len % 8 !== 0) {
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              }
              for (var i2 = 0; i2 < len; i2 += 8) {
                swap(this, i2, i2 + 7);
                swap(this, i2 + 1, i2 + 6);
                swap(this, i2 + 2, i2 + 5);
                swap(this, i2 + 3, i2 + 4);
              }
              return this;
            };
            Buffer2.prototype.toString = function toString2() {
              var length2 = this.length | 0;
              if (length2 === 0)
                return "";
              if (arguments.length === 0)
                return utf8Slice(this, 0, length2);
              return slowToString.apply(this, arguments);
            };
            Buffer2.prototype.equals = function equals(b) {
              if (!Buffer2.isBuffer(b))
                throw new TypeError("Argument must be a Buffer");
              if (this === b)
                return true;
              return Buffer2.compare(this, b) === 0;
            };
            Buffer2.prototype.inspect = function inspect2() {
              var str = "";
              var max2 = exports2.INSPECT_MAX_BYTES;
              if (this.length > 0) {
                str = this.toString("hex", 0, max2).match(/.{2}/g).join(" ");
                if (this.length > max2)
                  str += " ... ";
              }
              return "<Buffer " + str + ">";
            };
            Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
              if (!Buffer2.isBuffer(target)) {
                throw new TypeError("Argument must be a Buffer");
              }
              if (start === void 0) {
                start = 0;
              }
              if (end === void 0) {
                end = target ? target.length : 0;
              }
              if (thisStart === void 0) {
                thisStart = 0;
              }
              if (thisEnd === void 0) {
                thisEnd = this.length;
              }
              if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                throw new RangeError("out of range index");
              }
              if (thisStart >= thisEnd && start >= end) {
                return 0;
              }
              if (thisStart >= thisEnd) {
                return -1;
              }
              if (start >= end) {
                return 1;
              }
              start >>>= 0;
              end >>>= 0;
              thisStart >>>= 0;
              thisEnd >>>= 0;
              if (this === target)
                return 0;
              var x2 = thisEnd - thisStart;
              var y = end - start;
              var len = Math.min(x2, y);
              var thisCopy = this.slice(thisStart, thisEnd);
              var targetCopy = target.slice(start, end);
              for (var i2 = 0; i2 < len; ++i2) {
                if (thisCopy[i2] !== targetCopy[i2]) {
                  x2 = thisCopy[i2];
                  y = targetCopy[i2];
                  break;
                }
              }
              if (x2 < y)
                return -1;
              if (y < x2)
                return 1;
              return 0;
            };
            function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
              if (buffer.length === 0)
                return -1;
              if (typeof byteOffset === "string") {
                encoding = byteOffset;
                byteOffset = 0;
              } else if (byteOffset > 2147483647) {
                byteOffset = 2147483647;
              } else if (byteOffset < -2147483648) {
                byteOffset = -2147483648;
              }
              byteOffset = +byteOffset;
              if (isNaN(byteOffset)) {
                byteOffset = dir ? 0 : buffer.length - 1;
              }
              if (byteOffset < 0)
                byteOffset = buffer.length + byteOffset;
              if (byteOffset >= buffer.length) {
                if (dir)
                  return -1;
                else
                  byteOffset = buffer.length - 1;
              } else if (byteOffset < 0) {
                if (dir)
                  byteOffset = 0;
                else
                  return -1;
              }
              if (typeof val === "string") {
                val = Buffer2.from(val, encoding);
              }
              if (Buffer2.isBuffer(val)) {
                if (val.length === 0) {
                  return -1;
                }
                return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
              } else if (typeof val === "number") {
                val = val & 255;
                if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                  if (dir) {
                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                  } else {
                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                  }
                }
                return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
              }
              throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
              var indexSize = 1;
              var arrLength = arr.length;
              var valLength = val.length;
              if (encoding !== void 0) {
                encoding = String(encoding).toLowerCase();
                if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                  if (arr.length < 2 || val.length < 2) {
                    return -1;
                  }
                  indexSize = 2;
                  arrLength /= 2;
                  valLength /= 2;
                  byteOffset /= 2;
                }
              }
              function read(buf, i3) {
                if (indexSize === 1) {
                  return buf[i3];
                } else {
                  return buf.readUInt16BE(i3 * indexSize);
                }
              }
              var i2;
              if (dir) {
                var foundIndex = -1;
                for (i2 = byteOffset; i2 < arrLength; i2++) {
                  if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
                    if (foundIndex === -1)
                      foundIndex = i2;
                    if (i2 - foundIndex + 1 === valLength)
                      return foundIndex * indexSize;
                  } else {
                    if (foundIndex !== -1)
                      i2 -= i2 - foundIndex;
                    foundIndex = -1;
                  }
                }
              } else {
                if (byteOffset + valLength > arrLength)
                  byteOffset = arrLength - valLength;
                for (i2 = byteOffset; i2 >= 0; i2--) {
                  var found = true;
                  for (var j2 = 0; j2 < valLength; j2++) {
                    if (read(arr, i2 + j2) !== read(val, j2)) {
                      found = false;
                      break;
                    }
                  }
                  if (found)
                    return i2;
                }
              }
              return -1;
            }
            Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
              return this.indexOf(val, byteOffset, encoding) !== -1;
            };
            Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
            };
            Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
              return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
            };
            function hexWrite(buf, string, offset2, length2) {
              offset2 = Number(offset2) || 0;
              var remaining = buf.length - offset2;
              if (!length2) {
                length2 = remaining;
              } else {
                length2 = Number(length2);
                if (length2 > remaining) {
                  length2 = remaining;
                }
              }
              var strLen = string.length;
              if (strLen % 2 !== 0)
                throw new TypeError("Invalid hex string");
              if (length2 > strLen / 2) {
                length2 = strLen / 2;
              }
              for (var i2 = 0; i2 < length2; ++i2) {
                var parsed = parseInt(string.substr(i2 * 2, 2), 16);
                if (isNaN(parsed))
                  return i2;
                buf[offset2 + i2] = parsed;
              }
              return i2;
            }
            function utf8Write(buf, string, offset2, length2) {
              return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
            }
            function asciiWrite(buf, string, offset2, length2) {
              return blitBuffer(asciiToBytes(string), buf, offset2, length2);
            }
            function latin1Write(buf, string, offset2, length2) {
              return asciiWrite(buf, string, offset2, length2);
            }
            function base64Write(buf, string, offset2, length2) {
              return blitBuffer(base64ToBytes(string), buf, offset2, length2);
            }
            function ucs2Write(buf, string, offset2, length2) {
              return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
            }
            Buffer2.prototype.write = function write(string, offset2, length2, encoding) {
              if (offset2 === void 0) {
                encoding = "utf8";
                length2 = this.length;
                offset2 = 0;
              } else if (length2 === void 0 && typeof offset2 === "string") {
                encoding = offset2;
                length2 = this.length;
                offset2 = 0;
              } else if (isFinite(offset2)) {
                offset2 = offset2 | 0;
                if (isFinite(length2)) {
                  length2 = length2 | 0;
                  if (encoding === void 0)
                    encoding = "utf8";
                } else {
                  encoding = length2;
                  length2 = void 0;
                }
              } else {
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              }
              var remaining = this.length - offset2;
              if (length2 === void 0 || length2 > remaining)
                length2 = remaining;
              if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
                throw new RangeError("Attempt to write outside buffer bounds");
              }
              if (!encoding)
                encoding = "utf8";
              var loweredCase = false;
              for (; ; ) {
                switch (encoding) {
                  case "hex":
                    return hexWrite(this, string, offset2, length2);
                  case "utf8":
                  case "utf-8":
                    return utf8Write(this, string, offset2, length2);
                  case "ascii":
                    return asciiWrite(this, string, offset2, length2);
                  case "latin1":
                  case "binary":
                    return latin1Write(this, string, offset2, length2);
                  case "base64":
                    return base64Write(this, string, offset2, length2);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ucs2Write(this, string, offset2, length2);
                  default:
                    if (loweredCase)
                      throw new TypeError("Unknown encoding: " + encoding);
                    encoding = ("" + encoding).toLowerCase();
                    loweredCase = true;
                }
              }
            };
            Buffer2.prototype.toJSON = function toJSON3() {
              return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
              };
            };
            function base64Slice(buf, start, end) {
              if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf);
              } else {
                return base64.fromByteArray(buf.slice(start, end));
              }
            }
            function utf8Slice(buf, start, end) {
              end = Math.min(buf.length, end);
              var res = [];
              var i2 = start;
              while (i2 < end) {
                var firstByte = buf[i2];
                var codePoint = null;
                var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                if (i2 + bytesPerSequence <= end) {
                  var secondByte, thirdByte, fourthByte, tempCodePoint;
                  switch (bytesPerSequence) {
                    case 1:
                      if (firstByte < 128) {
                        codePoint = firstByte;
                      }
                      break;
                    case 2:
                      secondByte = buf[i2 + 1];
                      if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 3:
                      secondByte = buf[i2 + 1];
                      thirdByte = buf[i2 + 2];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                          codePoint = tempCodePoint;
                        }
                      }
                      break;
                    case 4:
                      secondByte = buf[i2 + 1];
                      thirdByte = buf[i2 + 2];
                      fourthByte = buf[i2 + 3];
                      if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                          codePoint = tempCodePoint;
                        }
                      }
                  }
                }
                if (codePoint === null) {
                  codePoint = 65533;
                  bytesPerSequence = 1;
                } else if (codePoint > 65535) {
                  codePoint -= 65536;
                  res.push(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                res.push(codePoint);
                i2 += bytesPerSequence;
              }
              return decodeCodePointsArray(res);
            }
            var MAX_ARGUMENTS_LENGTH = 4096;
            function decodeCodePointsArray(codePoints) {
              var len = codePoints.length;
              if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints);
              }
              var res = "";
              var i2 = 0;
              while (i2 < len) {
                res += String.fromCharCode.apply(
                  String,
                  codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
                );
              }
              return res;
            }
            function asciiSlice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i2 = start; i2 < end; ++i2) {
                ret += String.fromCharCode(buf[i2] & 127);
              }
              return ret;
            }
            function latin1Slice(buf, start, end) {
              var ret = "";
              end = Math.min(buf.length, end);
              for (var i2 = start; i2 < end; ++i2) {
                ret += String.fromCharCode(buf[i2]);
              }
              return ret;
            }
            function hexSlice(buf, start, end) {
              var len = buf.length;
              if (!start || start < 0)
                start = 0;
              if (!end || end < 0 || end > len)
                end = len;
              var out = "";
              for (var i2 = start; i2 < end; ++i2) {
                out += toHex2(buf[i2]);
              }
              return out;
            }
            function utf16leSlice(buf, start, end) {
              var bytes = buf.slice(start, end);
              var res = "";
              for (var i2 = 0; i2 < bytes.length; i2 += 2) {
                res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
              }
              return res;
            }
            Buffer2.prototype.slice = function slice(start, end) {
              var len = this.length;
              start = ~~start;
              end = end === void 0 ? len : ~~end;
              if (start < 0) {
                start += len;
                if (start < 0)
                  start = 0;
              } else if (start > len) {
                start = len;
              }
              if (end < 0) {
                end += len;
                if (end < 0)
                  end = 0;
              } else if (end > len) {
                end = len;
              }
              if (end < start)
                end = start;
              var newBuf;
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer2.prototype;
              } else {
                var sliceLen = end - start;
                newBuf = new Buffer2(sliceLen, void 0);
                for (var i2 = 0; i2 < sliceLen; ++i2) {
                  newBuf[i2] = this[i2 + start];
                }
              }
              return newBuf;
            };
            function checkOffset(offset2, ext, length2) {
              if (offset2 % 1 !== 0 || offset2 < 0)
                throw new RangeError("offset is not uint");
              if (offset2 + ext > length2)
                throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
              offset2 = offset2 | 0;
              byteLength3 = byteLength3 | 0;
              if (!noAssert)
                checkOffset(offset2, byteLength3, this.length);
              var val = this[offset2];
              var mul = 1;
              var i2 = 0;
              while (++i2 < byteLength3 && (mul *= 256)) {
                val += this[offset2 + i2] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
              offset2 = offset2 | 0;
              byteLength3 = byteLength3 | 0;
              if (!noAssert) {
                checkOffset(offset2, byteLength3, this.length);
              }
              var val = this[offset2 + --byteLength3];
              var mul = 1;
              while (byteLength3 > 0 && (mul *= 256)) {
                val += this[offset2 + --byteLength3] * mul;
              }
              return val;
            };
            Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 1, this.length);
              return this[offset2];
            };
            Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              return this[offset2] | this[offset2 + 1] << 8;
            };
            Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              return this[offset2] << 8 | this[offset2 + 1];
            };
            Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
            };
            Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
            };
            Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
              offset2 = offset2 | 0;
              byteLength3 = byteLength3 | 0;
              if (!noAssert)
                checkOffset(offset2, byteLength3, this.length);
              var val = this[offset2];
              var mul = 1;
              var i2 = 0;
              while (++i2 < byteLength3 && (mul *= 256)) {
                val += this[offset2 + i2] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength3);
              return val;
            };
            Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
              offset2 = offset2 | 0;
              byteLength3 = byteLength3 | 0;
              if (!noAssert)
                checkOffset(offset2, byteLength3, this.length);
              var i2 = byteLength3;
              var mul = 1;
              var val = this[offset2 + --i2];
              while (i2 > 0 && (mul *= 256)) {
                val += this[offset2 + --i2] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength3);
              return val;
            };
            Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 1, this.length);
              if (!(this[offset2] & 128))
                return this[offset2];
              return (255 - this[offset2] + 1) * -1;
            };
            Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              var val = this[offset2] | this[offset2 + 1] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 2, this.length);
              var val = this[offset2 + 1] | this[offset2] << 8;
              return val & 32768 ? val | 4294901760 : val;
            };
            Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
            };
            Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
            };
            Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return ieee754.read(this, offset2, true, 23, 4);
            };
            Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 4, this.length);
              return ieee754.read(this, offset2, false, 23, 4);
            };
            Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 8, this.length);
              return ieee754.read(this, offset2, true, 52, 8);
            };
            Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
              if (!noAssert)
                checkOffset(offset2, 8, this.length);
              return ieee754.read(this, offset2, false, 52, 8);
            };
            function checkInt(buf, value2, offset2, ext, max2, min2) {
              if (!Buffer2.isBuffer(buf))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (value2 > max2 || value2 < min2)
                throw new RangeError('"value" argument is out of bounds');
              if (offset2 + ext > buf.length)
                throw new RangeError("Index out of range");
            }
            Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset2, byteLength3, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              byteLength3 = byteLength3 | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
                checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
              }
              var mul = 1;
              var i2 = 0;
              this[offset2] = value2 & 255;
              while (++i2 < byteLength3 && (mul *= 256)) {
                this[offset2 + i2] = value2 / mul & 255;
              }
              return offset2 + byteLength3;
            };
            Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset2, byteLength3, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              byteLength3 = byteLength3 | 0;
              if (!noAssert) {
                var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
                checkInt(this, value2, offset2, byteLength3, maxBytes, 0);
              }
              var i2 = byteLength3 - 1;
              var mul = 1;
              this[offset2 + i2] = value2 & 255;
              while (--i2 >= 0 && (mul *= 256)) {
                this[offset2 + i2] = value2 / mul & 255;
              }
              return offset2 + byteLength3;
            };
            Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 1, 255, 0);
              if (!Buffer2.TYPED_ARRAY_SUPPORT)
                value2 = Math.floor(value2);
              this[offset2] = value2 & 255;
              return offset2 + 1;
            };
            function objectWriteUInt16(buf, value2, offset2, littleEndian) {
              if (value2 < 0)
                value2 = 65535 + value2 + 1;
              for (var i2 = 0, j2 = Math.min(buf.length - offset2, 2); i2 < j2; ++i2) {
                buf[offset2 + i2] = (value2 & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
              }
            }
            Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 2, 65535, 0);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 & 255;
                this[offset2 + 1] = value2 >>> 8;
              } else {
                objectWriteUInt16(this, value2, offset2, true);
              }
              return offset2 + 2;
            };
            Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 2, 65535, 0);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 >>> 8;
                this[offset2 + 1] = value2 & 255;
              } else {
                objectWriteUInt16(this, value2, offset2, false);
              }
              return offset2 + 2;
            };
            function objectWriteUInt32(buf, value2, offset2, littleEndian) {
              if (value2 < 0)
                value2 = 4294967295 + value2 + 1;
              for (var i2 = 0, j2 = Math.min(buf.length - offset2, 4); i2 < j2; ++i2) {
                buf[offset2 + i2] = value2 >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
              }
            }
            Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 4, 4294967295, 0);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2 + 3] = value2 >>> 24;
                this[offset2 + 2] = value2 >>> 16;
                this[offset2 + 1] = value2 >>> 8;
                this[offset2] = value2 & 255;
              } else {
                objectWriteUInt32(this, value2, offset2, true);
              }
              return offset2 + 4;
            };
            Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 4, 4294967295, 0);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 >>> 24;
                this[offset2 + 1] = value2 >>> 16;
                this[offset2 + 2] = value2 >>> 8;
                this[offset2 + 3] = value2 & 255;
              } else {
                objectWriteUInt32(this, value2, offset2, false);
              }
              return offset2 + 4;
            };
            Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset2, byteLength3, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength3 - 1);
                checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
              }
              var i2 = 0;
              var mul = 1;
              var sub = 0;
              this[offset2] = value2 & 255;
              while (++i2 < byteLength3 && (mul *= 256)) {
                if (value2 < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
                  sub = 1;
                }
                this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
              }
              return offset2 + byteLength3;
            };
            Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset2, byteLength3, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength3 - 1);
                checkInt(this, value2, offset2, byteLength3, limit - 1, -limit);
              }
              var i2 = byteLength3 - 1;
              var mul = 1;
              var sub = 0;
              this[offset2 + i2] = value2 & 255;
              while (--i2 >= 0 && (mul *= 256)) {
                if (value2 < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
                  sub = 1;
                }
                this[offset2 + i2] = (value2 / mul >> 0) - sub & 255;
              }
              return offset2 + byteLength3;
            };
            Buffer2.prototype.writeInt8 = function writeInt8(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 1, 127, -128);
              if (!Buffer2.TYPED_ARRAY_SUPPORT)
                value2 = Math.floor(value2);
              if (value2 < 0)
                value2 = 255 + value2 + 1;
              this[offset2] = value2 & 255;
              return offset2 + 1;
            };
            Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 2, 32767, -32768);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 & 255;
                this[offset2 + 1] = value2 >>> 8;
              } else {
                objectWriteUInt16(this, value2, offset2, true);
              }
              return offset2 + 2;
            };
            Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 2, 32767, -32768);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 >>> 8;
                this[offset2 + 1] = value2 & 255;
              } else {
                objectWriteUInt16(this, value2, offset2, false);
              }
              return offset2 + 2;
            };
            Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 & 255;
                this[offset2 + 1] = value2 >>> 8;
                this[offset2 + 2] = value2 >>> 16;
                this[offset2 + 3] = value2 >>> 24;
              } else {
                objectWriteUInt32(this, value2, offset2, true);
              }
              return offset2 + 4;
            };
            Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset2, noAssert) {
              value2 = +value2;
              offset2 = offset2 | 0;
              if (!noAssert)
                checkInt(this, value2, offset2, 4, 2147483647, -2147483648);
              if (value2 < 0)
                value2 = 4294967295 + value2 + 1;
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                this[offset2] = value2 >>> 24;
                this[offset2 + 1] = value2 >>> 16;
                this[offset2 + 2] = value2 >>> 8;
                this[offset2 + 3] = value2 & 255;
              } else {
                objectWriteUInt32(this, value2, offset2, false);
              }
              return offset2 + 4;
            };
            function checkIEEE754(buf, value2, offset2, ext, max2, min2) {
              if (offset2 + ext > buf.length)
                throw new RangeError("Index out of range");
              if (offset2 < 0)
                throw new RangeError("Index out of range");
            }
            function writeFloat(buf, value2, offset2, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value2, offset2, 4);
              }
              ieee754.write(buf, value2, offset2, littleEndian, 23, 4);
              return offset2 + 4;
            }
            Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset2, noAssert) {
              return writeFloat(this, value2, offset2, true, noAssert);
            };
            Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset2, noAssert) {
              return writeFloat(this, value2, offset2, false, noAssert);
            };
            function writeDouble(buf, value2, offset2, littleEndian, noAssert) {
              if (!noAssert) {
                checkIEEE754(buf, value2, offset2, 8);
              }
              ieee754.write(buf, value2, offset2, littleEndian, 52, 8);
              return offset2 + 8;
            }
            Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset2, noAssert) {
              return writeDouble(this, value2, offset2, true, noAssert);
            };
            Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset2, noAssert) {
              return writeDouble(this, value2, offset2, false, noAssert);
            };
            Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
              if (!start)
                start = 0;
              if (!end && end !== 0)
                end = this.length;
              if (targetStart >= target.length)
                targetStart = target.length;
              if (!targetStart)
                targetStart = 0;
              if (end > 0 && end < start)
                end = start;
              if (end === start)
                return 0;
              if (target.length === 0 || this.length === 0)
                return 0;
              if (targetStart < 0) {
                throw new RangeError("targetStart out of bounds");
              }
              if (start < 0 || start >= this.length)
                throw new RangeError("sourceStart out of bounds");
              if (end < 0)
                throw new RangeError("sourceEnd out of bounds");
              if (end > this.length)
                end = this.length;
              if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start;
              }
              var len = end - start;
              var i2;
              if (this === target && start < targetStart && targetStart < end) {
                for (i2 = len - 1; i2 >= 0; --i2) {
                  target[i2 + targetStart] = this[i2 + start];
                }
              } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
                for (i2 = 0; i2 < len; ++i2) {
                  target[i2 + targetStart] = this[i2 + start];
                }
              } else {
                Uint8Array.prototype.set.call(
                  target,
                  this.subarray(start, start + len),
                  targetStart
                );
              }
              return len;
            };
            Buffer2.prototype.fill = function fill(val, start, end, encoding) {
              if (typeof val === "string") {
                if (typeof start === "string") {
                  encoding = start;
                  start = 0;
                  end = this.length;
                } else if (typeof end === "string") {
                  encoding = end;
                  end = this.length;
                }
                if (val.length === 1) {
                  var code = val.charCodeAt(0);
                  if (code < 256) {
                    val = code;
                  }
                }
                if (encoding !== void 0 && typeof encoding !== "string") {
                  throw new TypeError("encoding must be a string");
                }
                if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
              } else if (typeof val === "number") {
                val = val & 255;
              }
              if (start < 0 || this.length < start || this.length < end) {
                throw new RangeError("Out of range index");
              }
              if (end <= start) {
                return this;
              }
              start = start >>> 0;
              end = end === void 0 ? this.length : end >>> 0;
              if (!val)
                val = 0;
              var i2;
              if (typeof val === "number") {
                for (i2 = start; i2 < end; ++i2) {
                  this[i2] = val;
                }
              } else {
                var bytes = Buffer2.isBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
                var len = bytes.length;
                for (i2 = 0; i2 < end - start; ++i2) {
                  this[i2 + start] = bytes[i2 % len];
                }
              }
              return this;
            };
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
            function base64clean(str) {
              str = stringtrim(str).replace(INVALID_BASE64_RE, "");
              if (str.length < 2)
                return "";
              while (str.length % 4 !== 0) {
                str = str + "=";
              }
              return str;
            }
            function stringtrim(str) {
              if (str.trim)
                return str.trim();
              return str.replace(/^\s+|\s+$/g, "");
            }
            function toHex2(n) {
              if (n < 16)
                return "0" + n.toString(16);
              return n.toString(16);
            }
            function utf8ToBytes(string, units) {
              units = units || Infinity;
              var codePoint;
              var length2 = string.length;
              var leadSurrogate = null;
              var bytes = [];
              for (var i2 = 0; i2 < length2; ++i2) {
                codePoint = string.charCodeAt(i2);
                if (codePoint > 55295 && codePoint < 57344) {
                  if (!leadSurrogate) {
                    if (codePoint > 56319) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    } else if (i2 + 1 === length2) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      continue;
                    }
                    leadSurrogate = codePoint;
                    continue;
                  }
                  if (codePoint < 56320) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    leadSurrogate = codePoint;
                    continue;
                  }
                  codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                } else if (leadSurrogate) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = null;
                if (codePoint < 128) {
                  if ((units -= 1) < 0)
                    break;
                  bytes.push(codePoint);
                } else if (codePoint < 2048) {
                  if ((units -= 2) < 0)
                    break;
                  bytes.push(
                    codePoint >> 6 | 192,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 65536) {
                  if ((units -= 3) < 0)
                    break;
                  bytes.push(
                    codePoint >> 12 | 224,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else if (codePoint < 1114112) {
                  if ((units -= 4) < 0)
                    break;
                  bytes.push(
                    codePoint >> 18 | 240,
                    codePoint >> 12 & 63 | 128,
                    codePoint >> 6 & 63 | 128,
                    codePoint & 63 | 128
                  );
                } else {
                  throw new Error("Invalid code point");
                }
              }
              return bytes;
            }
            function asciiToBytes(str) {
              var byteArray = [];
              for (var i2 = 0; i2 < str.length; ++i2) {
                byteArray.push(str.charCodeAt(i2) & 255);
              }
              return byteArray;
            }
            function utf16leToBytes(str, units) {
              var c, hi, lo;
              var byteArray = [];
              for (var i2 = 0; i2 < str.length; ++i2) {
                if ((units -= 2) < 0)
                  break;
                c = str.charCodeAt(i2);
                hi = c >> 8;
                lo = c % 256;
                byteArray.push(lo);
                byteArray.push(hi);
              }
              return byteArray;
            }
            function base64ToBytes(str) {
              return base64.toByteArray(base64clean(str));
            }
            function blitBuffer(src, dst, offset2, length2) {
              for (var i2 = 0; i2 < length2; ++i2) {
                if (i2 + offset2 >= dst.length || i2 >= src.length)
                  break;
                dst[i2 + offset2] = src[i2];
              }
              return i2;
            }
            function isnan(val) {
              return val !== val;
            }
          }).call(exports2, __webpack_require__(10));
        },
        /* 6 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var dP = __webpack_require__(22);
          var createDesc = __webpack_require__(45);
          module3.exports = __webpack_require__(12) ? function(object, key, value2) {
            return dP.f(object, key, createDesc(1, value2));
          } : function(object, key, value2) {
            object[key] = value2;
            return object;
          };
        },
        /* 7 */
        /***/
        function(module3, exports2) {
          if (typeof Object.create === "function") {
            module3.exports = function inherits2(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              }
            };
          } else {
            module3.exports = function inherits2(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {
                };
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              }
            };
          }
        },
        /* 8 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var codes = {};
          function createErrorType(code, message, Base) {
            if (!Base) {
              Base = Error;
            }
            function getMessage(arg1, arg2, arg3) {
              if (typeof message === "string") {
                return message;
              } else {
                return message(arg1, arg2, arg3);
              }
            }
            var NodeError = /* @__PURE__ */ function(_Base) {
              _inheritsLoose(NodeError2, _Base);
              function NodeError2(arg1, arg2, arg3) {
                return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
              }
              return NodeError2;
            }(Base);
            NodeError.prototype.name = Base.name;
            NodeError.prototype.code = code;
            codes[code] = NodeError;
          }
          function oneOf(expected, thing) {
            if (Array.isArray(expected)) {
              var len = expected.length;
              expected = expected.map(function(i2) {
                return String(i2);
              });
              if (len > 2) {
                return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
              } else if (len === 2) {
                return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
              } else {
                return "of ".concat(thing, " ").concat(expected[0]);
              }
            } else {
              return "of ".concat(thing, " ").concat(String(expected));
            }
          }
          function startsWith(str, search, pos) {
            return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
          }
          function endsWith2(str, search, this_len) {
            if (this_len === void 0 || this_len > str.length) {
              this_len = str.length;
            }
            return str.substring(this_len - search.length, this_len) === search;
          }
          function includes2(str, search, start) {
            if (typeof start !== "number") {
              start = 0;
            }
            if (start + search.length > str.length) {
              return false;
            } else {
              return str.indexOf(search, start) !== -1;
            }
          }
          createErrorType("ERR_INVALID_OPT_VALUE", function(name, value2) {
            return 'The value "' + value2 + '" is invalid for option "' + name + '"';
          }, TypeError);
          createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
            var determiner;
            if (typeof expected === "string" && startsWith(expected, "not ")) {
              determiner = "must not be";
              expected = expected.replace(/^not /, "");
            } else {
              determiner = "must be";
            }
            var msg;
            if (endsWith2(name, " argument")) {
              msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
            } else {
              var type = includes2(name, ".") ? "property" : "argument";
              msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
            }
            msg += ". Received type ".concat(typeof actual);
            return msg;
          }, TypeError);
          createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
          createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
            return "The " + name + " method is not implemented";
          });
          createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
          createErrorType("ERR_STREAM_DESTROYED", function(name) {
            return "Cannot call " + name + " after a stream was destroyed";
          });
          createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
          createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
          createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
          createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
          createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
            return "Unknown encoding: " + arg;
          }, TypeError);
          createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
          module3.exports.codes = codes;
        },
        /* 9 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            var objectKeys = Object.keys || function(obj) {
              var keys3 = [];
              for (var key in obj) {
                keys3.push(key);
              }
              return keys3;
            };
            module3.exports = Duplex;
            var Readable = __webpack_require__(60);
            var Writable = __webpack_require__(62);
            __webpack_require__(7)(Duplex, Readable);
            {
              var keys2 = objectKeys(Writable.prototype);
              for (var v = 0; v < keys2.length; v++) {
                var method = keys2[v];
                if (!Duplex.prototype[method])
                  Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options) {
              if (!(this instanceof Duplex))
                return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              this.allowHalfOpen = true;
              if (options) {
                if (options.readable === false)
                  this.readable = false;
                if (options.writable === false)
                  this.writable = false;
                if (options.allowHalfOpen === false) {
                  this.allowHalfOpen = false;
                  this.once("end", onend);
                }
              }
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.highWaterMark;
              }
            });
            Object.defineProperty(Duplex.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            Object.defineProperty(Duplex.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.length;
              }
            });
            function onend() {
              if (this._writableState.ended)
                return;
              process2.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function set2(value2) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value2;
                this._writableState.destroyed = value2;
              }
            });
          }).call(exports2, __webpack_require__(2));
        },
        /* 10 */
        /***/
        function(module3, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || Function("return this")() || (1, eval)("this");
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module3.exports = g;
        },
        /* 11 */
        /***/
        function(module3, exports2, __webpack_require__) {
          {
            module3.exports = Emitter2;
          }
          function Emitter2(obj) {
            if (obj)
              return mixin2(obj);
          }
          function mixin2(obj) {
            for (var key in Emitter2.prototype) {
              obj[key] = Emitter2.prototype[key];
            }
            return obj;
          }
          Emitter2.prototype.on = Emitter2.prototype.addEventListener = function(event, fn) {
            this._callbacks = this._callbacks || {};
            (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
            return this;
          };
          Emitter2.prototype.once = function(event, fn) {
            function on2() {
              this.off(event, on2);
              fn.apply(this, arguments);
            }
            on2.fn = fn;
            this.on(event, on2);
            return this;
          };
          Emitter2.prototype.off = Emitter2.prototype.removeListener = Emitter2.prototype.removeAllListeners = Emitter2.prototype.removeEventListener = function(event, fn) {
            this._callbacks = this._callbacks || {};
            if (0 == arguments.length) {
              this._callbacks = {};
              return this;
            }
            var callbacks = this._callbacks["$" + event];
            if (!callbacks)
              return this;
            if (1 == arguments.length) {
              delete this._callbacks["$" + event];
              return this;
            }
            var cb;
            for (var i2 = 0; i2 < callbacks.length; i2++) {
              cb = callbacks[i2];
              if (cb === fn || cb.fn === fn) {
                callbacks.splice(i2, 1);
                break;
              }
            }
            if (callbacks.length === 0) {
              delete this._callbacks["$" + event];
            }
            return this;
          };
          Emitter2.prototype.emit = function(event) {
            this._callbacks = this._callbacks || {};
            var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
            for (var i2 = 1; i2 < arguments.length; i2++) {
              args[i2 - 1] = arguments[i2];
            }
            if (callbacks) {
              callbacks = callbacks.slice(0);
              for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
                callbacks[i2].apply(this, args);
              }
            }
            return this;
          };
          Emitter2.prototype.listeners = function(event) {
            this._callbacks = this._callbacks || {};
            return this._callbacks["$" + event] || [];
          };
          Emitter2.prototype.hasListeners = function(event) {
            return !!this.listeners(event).length;
          };
        },
        /* 12 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = !__webpack_require__(40)(function() {
            return Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        },
        /* 13 */
        /***/
        function(module3, exports2) {
          module3.exports = function(it) {
            return typeof it === "object" ? it !== null : typeof it === "function";
          };
        },
        /* 14 */
        /***/
        function(module3, exports2) {
          module3.exports = {};
        },
        /* 15 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            exports2.formatArgs = formatArgs;
            exports2.save = save;
            exports2.load = load;
            exports2.useColors = useColors;
            exports2.storage = localstorage();
            exports2.destroy = (() => {
              let warned = false;
              return () => {
                if (!warned) {
                  warned = true;
                  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
              };
            })();
            exports2.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33"
            ];
            function useColors() {
              if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
              }
              if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
              }
              return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
              typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
              // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            function formatArgs(args) {
              args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff);
              if (!this.useColors) {
                return;
              }
              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              let index = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index++;
                if (match === "%c") {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }
            exports2.log = console.debug || console.log || (() => {
            });
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports2.storage.setItem("debug", namespaces);
                } else {
                  exports2.storage.removeItem("debug");
                }
              } catch (error) {
              }
            }
            function load() {
              let r;
              try {
                r = exports2.storage.getItem("debug");
              } catch (error) {
              }
              if (!r && typeof process2 !== "undefined" && "env" in process2) {
                r = __webpack_require__.i({ "NODE_ENV": "production" }).DEBUG;
              }
              return r;
            }
            function localstorage() {
              try {
                return localStorage;
              } catch (error) {
              }
            }
            module3.exports = __webpack_require__(130)(exports2);
            const { formatters } = module3.exports;
            formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(exports2, __webpack_require__(2));
        },
        /* 16 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const encodePacket2 = __webpack_require__(133);
          const decodePacket2 = __webpack_require__(132);
          const SEPARATOR2 = String.fromCharCode(30);
          const encodePayload2 = (packets, callback) => {
            const length2 = packets.length;
            const encodedPackets = new Array(length2);
            let count = 0;
            packets.forEach((packet, i2) => {
              encodePacket2(packet, false, (encodedPacket) => {
                encodedPackets[i2] = encodedPacket;
                if (++count === length2) {
                  callback(encodedPackets.join(SEPARATOR2));
                }
              });
            });
          };
          const decodePayload2 = (encodedPayload, binaryType) => {
            const encodedPackets = encodedPayload.split(SEPARATOR2);
            const packets = [];
            for (let i2 = 0; i2 < encodedPackets.length; i2++) {
              const decodedPacket = decodePacket2(encodedPackets[i2], binaryType);
              packets.push(decodedPacket);
              if (decodedPacket.type === "error") {
                break;
              }
            }
            return packets;
          };
          module3.exports = {
            protocol: 4,
            encodePacket: encodePacket2,
            encodePayload: encodePayload2,
            decodePacket: decodePacket2,
            decodePayload: decodePayload2
          };
        },
        /* 17 */
        /***/
        function(module3, exports2) {
          module3.exports = function(it) {
            if (typeof it != "function")
              throw TypeError(it + " is not a function!");
            return it;
          };
        },
        /* 18 */
        /***/
        function(module3, exports2) {
          var toString2 = {}.toString;
          module3.exports = function(it) {
            return toString2.call(it).slice(8, -1);
          };
        },
        /* 19 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var aFunction = __webpack_require__(17);
          module3.exports = function(fn, that, length2) {
            aFunction(fn);
            if (that === void 0)
              return fn;
            switch (length2) {
              case 1:
                return function(a) {
                  return fn.call(that, a);
                };
              case 2:
                return function(a, b) {
                  return fn.call(that, a, b);
                };
              case 3:
                return function(a, b, c) {
                  return fn.call(that, a, b, c);
                };
            }
            return function() {
              return fn.apply(that, arguments);
            };
          };
        },
        /* 20 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__(0);
          var core = __webpack_require__(3);
          var ctx = __webpack_require__(19);
          var hide = __webpack_require__(6);
          var has2 = __webpack_require__(21);
          var PROTOTYPE = "prototype";
          var $export = function(type, name, source) {
            var IS_FORCED = type & $export.F;
            var IS_GLOBAL = type & $export.G;
            var IS_STATIC = type & $export.S;
            var IS_PROTO = type & $export.P;
            var IS_BIND = type & $export.B;
            var IS_WRAP = type & $export.W;
            var exports3 = IS_GLOBAL ? core : core[name] || (core[name] = {});
            var expProto = exports3[PROTOTYPE];
            var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE];
            var key, own, out;
            if (IS_GLOBAL)
              source = name;
            for (key in source) {
              own = !IS_FORCED && target && target[key] !== void 0;
              if (own && has2(exports3, key))
                continue;
              out = own ? target[key] : source[key];
              exports3[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function(C) {
                var F2 = function(a, b, c) {
                  if (this instanceof C) {
                    switch (arguments.length) {
                      case 0:
                        return new C();
                      case 1:
                        return new C(a);
                      case 2:
                        return new C(a, b);
                    }
                    return new C(a, b, c);
                  }
                  return C.apply(this, arguments);
                };
                F2[PROTOTYPE] = C[PROTOTYPE];
                return F2;
              }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
              if (IS_PROTO) {
                (exports3.virtual || (exports3.virtual = {}))[key] = out;
                if (type & $export.R && expProto && !expProto[key])
                  hide(expProto, key, out);
              }
            }
          };
          $export.F = 1;
          $export.G = 2;
          $export.S = 4;
          $export.P = 8;
          $export.B = 16;
          $export.W = 32;
          $export.U = 64;
          $export.R = 128;
          module3.exports = $export;
        },
        /* 21 */
        /***/
        function(module3, exports2) {
          var hasOwnProperty2 = {}.hasOwnProperty;
          module3.exports = function(it, key) {
            return hasOwnProperty2.call(it, key);
          };
        },
        /* 22 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__(4);
          var IE8_DOM_DEFINE = __webpack_require__(89);
          var toPrimitive = __webpack_require__(109);
          var dP = Object.defineProperty;
          exports2.f = __webpack_require__(12) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPrimitive(P, true);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return dP(O, P, Attributes);
              } catch (e) {
              }
            if ("get" in Attributes || "set" in Attributes)
              throw TypeError("Accessors not supported!");
            if ("value" in Attributes)
              O[P] = Attributes.value;
            return O;
          };
        },
        /* 23 */
        /***/
        function(module3, exports2) {
          module3.exports = (() => {
            if (typeof self !== "undefined") {
              return self;
            } else if (typeof window !== "undefined") {
              return window;
            } else {
              return Function("return this")();
            }
          })();
        },
        /* 24 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            exports2.formatArgs = formatArgs;
            exports2.save = save;
            exports2.load = load;
            exports2.useColors = useColors;
            exports2.storage = localstorage();
            exports2.destroy = (() => {
              let warned = false;
              return () => {
                if (!warned) {
                  warned = true;
                  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
              };
            })();
            exports2.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33"
            ];
            function useColors() {
              if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
              }
              if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
              }
              return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
              typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
              // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            function formatArgs(args) {
              args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff);
              if (!this.useColors) {
                return;
              }
              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              let index = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index++;
                if (match === "%c") {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }
            exports2.log = console.debug || console.log || (() => {
            });
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports2.storage.setItem("debug", namespaces);
                } else {
                  exports2.storage.removeItem("debug");
                }
              } catch (error) {
              }
            }
            function load() {
              let r;
              try {
                r = exports2.storage.getItem("debug");
              } catch (error) {
              }
              if (!r && typeof process2 !== "undefined" && "env" in process2) {
                r = __webpack_require__.i({ "NODE_ENV": "production" }).DEBUG;
              }
              return r;
            }
            function localstorage() {
              try {
                return localStorage;
              } catch (error) {
              }
            }
            module3.exports = __webpack_require__(160)(exports2);
            const { formatters } = module3.exports;
            formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(exports2, __webpack_require__(2));
        },
        /* 25 */
        /***/
        function(module3, exports2) {
          module3.exports = function(it) {
            if (it == void 0)
              throw TypeError("Can't call method on  " + it);
            return it;
          };
        },
        /* 26 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__(13);
          var document2 = __webpack_require__(0).document;
          var is = isObject2(document2) && isObject2(document2.createElement);
          module3.exports = function(it) {
            return is ? document2.createElement(it) : {};
          };
        },
        /* 27 */
        /***/
        function(module3, exports2) {
          module3.exports = true;
        },
        /* 28 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var aFunction = __webpack_require__(17);
          function PromiseCapability(C) {
            var resolve2, reject;
            this.promise = new C(function($$resolve, $$reject) {
              if (resolve2 !== void 0 || reject !== void 0)
                throw TypeError("Bad Promise constructor");
              resolve2 = $$resolve;
              reject = $$reject;
            });
            this.resolve = aFunction(resolve2);
            this.reject = aFunction(reject);
          }
          module3.exports.f = function(C) {
            return new PromiseCapability(C);
          };
        },
        /* 29 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var def2 = __webpack_require__(22).f;
          var has2 = __webpack_require__(21);
          var TAG = __webpack_require__(1)("toStringTag");
          module3.exports = function(it, tag, stat) {
            if (it && !has2(it = stat ? it : it.prototype, TAG))
              def2(it, TAG, { configurable: true, value: tag });
          };
        },
        /* 30 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var shared = __webpack_require__(46)("keys");
          var uid2 = __webpack_require__(50);
          module3.exports = function(key) {
            return shared[key] || (shared[key] = uid2(key));
          };
        },
        /* 31 */
        /***/
        function(module3, exports2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module3.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
          };
        },
        /* 32 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var IObject = __webpack_require__(91);
          var defined = __webpack_require__(25);
          module3.exports = function(it) {
            return IObject(defined(it));
          };
        },
        /* 33 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const parser2 = __webpack_require__(16);
          const Emitter2 = __webpack_require__(11);
          const debug = __webpack_require__(15)("engine.io-client:transport");
          class Transport2 extends Emitter2 {
            /**
             * Transport abstract constructor.
             *
             * @param {Object} options.
             * @api private
             */
            constructor(opts) {
              super();
              this.opts = opts;
              this.query = opts.query;
              this.readyState = "";
              this.socket = opts.socket;
            }
            /**
             * Emits an error.
             *
             * @param {String} str
             * @return {Transport} for chaining
             * @api public
             */
            onError(msg, desc) {
              const err = new Error(msg);
              err.type = "TransportError";
              err.description = desc;
              this.emit("error", err);
              return this;
            }
            /**
             * Opens the transport.
             *
             * @api public
             */
            open() {
              if ("closed" === this.readyState || "" === this.readyState) {
                this.readyState = "opening";
                this.doOpen();
              }
              return this;
            }
            /**
             * Closes the transport.
             *
             * @api private
             */
            close() {
              if ("opening" === this.readyState || "open" === this.readyState) {
                this.doClose();
                this.onClose();
              }
              return this;
            }
            /**
             * Sends multiple packets.
             *
             * @param {Array} packets
             * @api private
             */
            send(packets) {
              if ("open" === this.readyState) {
                this.write(packets);
              } else {
                debug("transport is not open, discarding packets");
              }
            }
            /**
             * Called upon open
             *
             * @api private
             */
            onOpen() {
              this.readyState = "open";
              this.writable = true;
              this.emit("open");
            }
            /**
             * Called with data.
             *
             * @param {String} data
             * @api private
             */
            onData(data2) {
              const packet = parser2.decodePacket(data2, this.socket.binaryType);
              this.onPacket(packet);
            }
            /**
             * Called with a decoded packet.
             */
            onPacket(packet) {
              this.emit("packet", packet);
            }
            /**
             * Called upon close.
             *
             * @api private
             */
            onClose() {
              this.readyState = "closed";
              this.emit("close");
            }
          }
          module3.exports = Transport2;
        },
        /* 34 */
        /***/
        function(module3, exports2) {
          assert.notEqual = notEqual;
          assert.notOk = notOk;
          assert.equal = equal;
          assert.ok = assert;
          module3.exports = assert;
          function equal(a, b, m) {
            assert(a == b, m);
          }
          function notEqual(a, b, m) {
            assert(a != b, m);
          }
          function notOk(t, m) {
            assert(!t, m);
          }
          function assert(t, m) {
            if (!t)
              throw new Error(m || "AssertionError");
          }
        },
        /* 35 */
        /***/
        function(module3, exports2) {
          exports2.encode = function(obj) {
            var str = "";
            for (var i2 in obj) {
              if (obj.hasOwnProperty(i2)) {
                if (str.length)
                  str += "&";
                str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
              }
            }
            return str;
          };
          exports2.decode = function(qs) {
            var qry = {};
            var pairs = qs.split("&");
            for (var i2 = 0, l = pairs.length; i2 < l; i2++) {
              var pair = pairs[i2].split("=");
              qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
            }
            return qry;
          };
        },
        /* 36 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(8).codes.ERR_STREAM_PREMATURE_CLOSE;
          function once(callback) {
            var called = false;
            return function() {
              if (called)
                return;
              called = true;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              callback.apply(this, args);
            };
          }
          function noop2() {
          }
          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          }
          function eos(stream, opts, callback) {
            if (typeof opts === "function")
              return eos(stream, null, opts);
            if (!opts)
              opts = {};
            callback = once(callback || noop2);
            var readable = opts.readable || opts.readable !== false && stream.readable;
            var writable = opts.writable || opts.writable !== false && stream.writable;
            var onlegacyfinish = function onlegacyfinish2() {
              if (!stream.writable)
                onfinish();
            };
            var writableEnded = stream._writableState && stream._writableState.finished;
            var onfinish = function onfinish2() {
              writable = false;
              writableEnded = true;
              if (!readable)
                callback.call(stream);
            };
            var readableEnded = stream._readableState && stream._readableState.endEmitted;
            var onend = function onend2() {
              readable = false;
              readableEnded = true;
              if (!writable)
                callback.call(stream);
            };
            var onerror = function onerror2(err) {
              callback.call(stream, err);
            };
            var onclose = function onclose2() {
              var err;
              if (readable && !readableEnded) {
                if (!stream._readableState || !stream._readableState.ended)
                  err = new ERR_STREAM_PREMATURE_CLOSE();
                return callback.call(stream, err);
              }
              if (writable && !writableEnded) {
                if (!stream._writableState || !stream._writableState.ended)
                  err = new ERR_STREAM_PREMATURE_CLOSE();
                return callback.call(stream, err);
              }
            };
            var onrequest = function onrequest2() {
              stream.req.on("finish", onfinish);
            };
            if (isRequest(stream)) {
              stream.on("complete", onfinish);
              stream.on("abort", onclose);
              if (stream.req)
                onrequest();
              else
                stream.on("request", onrequest);
            } else if (writable && !stream._writableState) {
              stream.on("end", onlegacyfinish);
              stream.on("close", onlegacyfinish);
            }
            stream.on("end", onend);
            stream.on("finish", onfinish);
            if (opts.error !== false)
              stream.on("error", onerror);
            stream.on("close", onclose);
            return function() {
              stream.removeListener("complete", onfinish);
              stream.removeListener("abort", onclose);
              stream.removeListener("request", onrequest);
              if (stream.req)
                stream.req.removeListener("finish", onfinish);
              stream.removeListener("end", onlegacyfinish);
              stream.removeListener("close", onlegacyfinish);
              stream.removeListener("finish", onfinish);
              stream.removeListener("end", onend);
              stream.removeListener("error", onerror);
              stream.removeListener("close", onclose);
            };
          }
          module3.exports = eos;
        },
        /* 37 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Decoder = exports2.Encoder = exports2.PacketType = exports2.protocol = void 0;
          const Emitter2 = __webpack_require__(11);
          const binary_1 = __webpack_require__(162);
          const is_binary_1 = __webpack_require__(71);
          const debug = __webpack_require__(163)("socket.io-parser");
          exports2.protocol = 5;
          var PacketType2;
          (function(PacketType3) {
            PacketType3[PacketType3["CONNECT"] = 0] = "CONNECT";
            PacketType3[PacketType3["DISCONNECT"] = 1] = "DISCONNECT";
            PacketType3[PacketType3["EVENT"] = 2] = "EVENT";
            PacketType3[PacketType3["ACK"] = 3] = "ACK";
            PacketType3[PacketType3["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
            PacketType3[PacketType3["BINARY_EVENT"] = 5] = "BINARY_EVENT";
            PacketType3[PacketType3["BINARY_ACK"] = 6] = "BINARY_ACK";
          })(PacketType2 = exports2.PacketType || (exports2.PacketType = {}));
          class Encoder2 {
            /**
             * Encode a packet as a single string if non-binary, or as a
             * buffer sequence, depending on packet type.
             *
             * @param {Object} obj - packet object
             */
            encode(obj) {
              debug("encoding packet %j", obj);
              if (obj.type === PacketType2.EVENT || obj.type === PacketType2.ACK) {
                if (is_binary_1.hasBinary(obj)) {
                  obj.type = obj.type === PacketType2.EVENT ? PacketType2.BINARY_EVENT : PacketType2.BINARY_ACK;
                  return this.encodeAsBinary(obj);
                }
              }
              return [this.encodeAsString(obj)];
            }
            /**
             * Encode packet as string.
             */
            encodeAsString(obj) {
              let str = "" + obj.type;
              if (obj.type === PacketType2.BINARY_EVENT || obj.type === PacketType2.BINARY_ACK) {
                str += obj.attachments + "-";
              }
              if (obj.nsp && "/" !== obj.nsp) {
                str += obj.nsp + ",";
              }
              if (null != obj.id) {
                str += obj.id;
              }
              if (null != obj.data) {
                str += JSON.stringify(obj.data);
              }
              debug("encoded %j as %s", obj, str);
              return str;
            }
            /**
             * Encode packet as 'buffer sequence' by removing blobs, and
             * deconstructing packet into object with placeholders and
             * a list of buffers.
             */
            encodeAsBinary(obj) {
              const deconstruction = binary_1.deconstructPacket(obj);
              const pack = this.encodeAsString(deconstruction.packet);
              const buffers = deconstruction.buffers;
              buffers.unshift(pack);
              return buffers;
            }
          }
          exports2.Encoder = Encoder2;
          class Decoder2 extends Emitter2 {
            constructor() {
              super();
            }
            /**
             * Decodes an encoded packet string into packet JSON.
             *
             * @param {String} obj - encoded packet
             */
            add(obj) {
              let packet;
              if (typeof obj === "string") {
                packet = this.decodeString(obj);
                if (packet.type === PacketType2.BINARY_EVENT || packet.type === PacketType2.BINARY_ACK) {
                  this.reconstructor = new BinaryReconstructor2(packet);
                  if (packet.attachments === 0) {
                    super.emit("decoded", packet);
                  }
                } else {
                  super.emit("decoded", packet);
                }
              } else if (is_binary_1.isBinary(obj) || obj.base64) {
                if (!this.reconstructor) {
                  throw new Error("got binary data when not reconstructing a packet");
                } else {
                  packet = this.reconstructor.takeBinaryData(obj);
                  if (packet) {
                    this.reconstructor = null;
                    super.emit("decoded", packet);
                  }
                }
              } else {
                throw new Error("Unknown type: " + obj);
              }
            }
            /**
             * Decode a packet String (JSON data)
             *
             * @param {String} str
             * @return {Object} packet
             */
            decodeString(str) {
              let i2 = 0;
              const p2 = {
                type: Number(str.charAt(0))
              };
              if (PacketType2[p2.type] === void 0) {
                throw new Error("unknown packet type " + p2.type);
              }
              if (p2.type === PacketType2.BINARY_EVENT || p2.type === PacketType2.BINARY_ACK) {
                const start = i2 + 1;
                while (str.charAt(++i2) !== "-" && i2 != str.length) {
                }
                const buf = str.substring(start, i2);
                if (buf != Number(buf) || str.charAt(i2) !== "-") {
                  throw new Error("Illegal attachments");
                }
                p2.attachments = Number(buf);
              }
              if ("/" === str.charAt(i2 + 1)) {
                const start = i2 + 1;
                while (++i2) {
                  const c = str.charAt(i2);
                  if ("," === c)
                    break;
                  if (i2 === str.length)
                    break;
                }
                p2.nsp = str.substring(start, i2);
              } else {
                p2.nsp = "/";
              }
              const next = str.charAt(i2 + 1);
              if ("" !== next && Number(next) == next) {
                const start = i2 + 1;
                while (++i2) {
                  const c = str.charAt(i2);
                  if (null == c || Number(c) != c) {
                    --i2;
                    break;
                  }
                  if (i2 === str.length)
                    break;
                }
                p2.id = Number(str.substring(start, i2 + 1));
              }
              if (str.charAt(++i2)) {
                const payload = tryParse(str.substr(i2));
                if (Decoder2.isPayloadValid(p2.type, payload)) {
                  p2.data = payload;
                } else {
                  throw new Error("invalid payload");
                }
              }
              debug("decoded %s as %j", str, p2);
              return p2;
            }
            static isPayloadValid(type, payload) {
              switch (type) {
                case PacketType2.CONNECT:
                  return typeof payload === "object";
                case PacketType2.DISCONNECT:
                  return payload === void 0;
                case PacketType2.CONNECT_ERROR:
                  return typeof payload === "string" || typeof payload === "object";
                case PacketType2.EVENT:
                case PacketType2.BINARY_EVENT:
                  return Array.isArray(payload) && payload.length > 0;
                case PacketType2.ACK:
                case PacketType2.BINARY_ACK:
                  return Array.isArray(payload);
              }
            }
            /**
             * Deallocates a parser's resources
             */
            destroy() {
              if (this.reconstructor) {
                this.reconstructor.finishedReconstruction();
              }
            }
          }
          exports2.Decoder = Decoder2;
          function tryParse(str) {
            try {
              return JSON.parse(str);
            } catch (e) {
              return false;
            }
          }
          class BinaryReconstructor2 {
            constructor(packet) {
              this.packet = packet;
              this.buffers = [];
              this.reconPack = packet;
            }
            /**
             * Method to be called when binary data received from connection
             * after a BINARY_EVENT packet.
             *
             * @param {Buffer | ArrayBuffer} binData - the raw binary data received
             * @return {null | Object} returns null if more binary data is expected or
             *   a reconstructed packet object if all buffers have been received.
             */
            takeBinaryData(binData) {
              this.buffers.push(binData);
              if (this.buffers.length === this.reconPack.attachments) {
                const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
                this.finishedReconstruction();
                return packet;
              }
              return null;
            }
            /**
             * Cleans up binary packet reconstruction variables.
             */
            finishedReconstruction() {
              this.reconPack = null;
              this.buffers = [];
            }
          }
        },
        /* 38 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var cof = __webpack_require__(18);
          var TAG = __webpack_require__(1)("toStringTag");
          var ARG = cof(function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (e) {
            }
          };
          module3.exports = function(it) {
            var O, T, B;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = tryGet(O = Object(it), TAG)) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
          };
        },
        /* 39 */
        /***/
        function(module3, exports2) {
          module3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
        },
        /* 40 */
        /***/
        function(module3, exports2) {
          module3.exports = function(exec) {
            try {
              return !!exec();
            } catch (e) {
              return true;
            }
          };
        },
        /* 41 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var document2 = __webpack_require__(0).document;
          module3.exports = document2 && document2.documentElement;
        },
        /* 42 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var LIBRARY = __webpack_require__(27);
          var $export = __webpack_require__(20);
          var redefine = __webpack_require__(104);
          var hide = __webpack_require__(6);
          var Iterators = __webpack_require__(14);
          var $iterCreate = __webpack_require__(94);
          var setToStringTag = __webpack_require__(29);
          var getPrototypeOf = __webpack_require__(100);
          var ITERATOR = __webpack_require__(1)("iterator");
          var BUGGY = !([].keys && "next" in [].keys());
          var FF_ITERATOR = "@@iterator";
          var KEYS = "keys";
          var VALUES = "values";
          var returnThis = function() {
            return this;
          };
          module3.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var getMethod = function(kind) {
              if (!BUGGY && kind in proto2)
                return proto2[kind];
              switch (kind) {
                case KEYS:
                  return function keys2() {
                    return new Constructor(this, kind);
                  };
                case VALUES:
                  return function values() {
                    return new Constructor(this, kind);
                  };
              }
              return function entries() {
                return new Constructor(this, kind);
              };
            };
            var TAG = NAME + " Iterator";
            var DEF_VALUES = DEFAULT == VALUES;
            var VALUES_BUG = false;
            var proto2 = Base.prototype;
            var $native = proto2[ITERATOR] || proto2[FF_ITERATOR] || DEFAULT && proto2[DEFAULT];
            var $default = $native || getMethod(DEFAULT);
            var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod("entries") : void 0;
            var $anyNative = NAME == "Array" ? proto2.entries || $native : $native;
            var methods, key, IteratorPrototype;
            if ($anyNative) {
              IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
              if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
                setToStringTag(IteratorPrototype, TAG, true);
                if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != "function")
                  hide(IteratorPrototype, ITERATOR, returnThis);
              }
            }
            if (DEF_VALUES && $native && $native.name !== VALUES) {
              VALUES_BUG = true;
              $default = function values() {
                return $native.call(this);
              };
            }
            if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto2[ITERATOR])) {
              hide(proto2, ITERATOR, $default);
            }
            Iterators[NAME] = $default;
            Iterators[TAG] = returnThis;
            if (DEFAULT) {
              methods = {
                values: DEF_VALUES ? $default : getMethod(VALUES),
                keys: IS_SET ? $default : getMethod(KEYS),
                entries: $entries
              };
              if (FORCED)
                for (key in methods) {
                  if (!(key in proto2))
                    redefine(proto2, key, methods[key]);
                }
              else
                $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            }
            return methods;
          };
        },
        /* 43 */
        /***/
        function(module3, exports2) {
          module3.exports = function(exec) {
            try {
              return { e: false, v: exec() };
            } catch (e) {
              return { e: true, v: e };
            }
          };
        },
        /* 44 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__(4);
          var isObject2 = __webpack_require__(13);
          var newPromiseCapability = __webpack_require__(28);
          module3.exports = function(C, x2) {
            anObject(C);
            if (isObject2(x2) && x2.constructor === C)
              return x2;
            var promiseCapability = newPromiseCapability.f(C);
            var resolve2 = promiseCapability.resolve;
            resolve2(x2);
            return promiseCapability.promise;
          };
        },
        /* 45 */
        /***/
        function(module3, exports2) {
          module3.exports = function(bitmap, value2) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value: value2
            };
          };
        },
        /* 46 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var core = __webpack_require__(3);
          var global2 = __webpack_require__(0);
          var SHARED = "__core-js_shared__";
          var store2 = global2[SHARED] || (global2[SHARED] = {});
          (module3.exports = function(key, value2) {
            return store2[key] || (store2[key] = value2 !== void 0 ? value2 : {});
          })("versions", []).push({
            version: core.version,
            mode: __webpack_require__(27) ? "pure" : "global",
            copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
          });
        },
        /* 47 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__(4);
          var aFunction = __webpack_require__(17);
          var SPECIES = __webpack_require__(1)("species");
          module3.exports = function(O, D) {
            var C = anObject(O).constructor;
            var S;
            return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? D : aFunction(S);
          };
        },
        /* 48 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var ctx = __webpack_require__(19);
          var invoke = __webpack_require__(90);
          var html = __webpack_require__(41);
          var cel = __webpack_require__(26);
          var global2 = __webpack_require__(0);
          var process2 = global2.process;
          var setTask = global2.setImmediate;
          var clearTask = global2.clearImmediate;
          var MessageChannel = global2.MessageChannel;
          var Dispatch = global2.Dispatch;
          var counter = 0;
          var queue2 = {};
          var ONREADYSTATECHANGE = "onreadystatechange";
          var defer, channel, port;
          var run2 = function() {
            var id = +this;
            if (queue2.hasOwnProperty(id)) {
              var fn = queue2[id];
              delete queue2[id];
              fn();
            }
          };
          var listener = function(event) {
            run2.call(event.data);
          };
          if (!setTask || !clearTask) {
            setTask = function setImmediate(fn) {
              var args = [];
              var i2 = 1;
              while (arguments.length > i2)
                args.push(arguments[i2++]);
              queue2[++counter] = function() {
                invoke(typeof fn == "function" ? fn : Function(fn), args);
              };
              defer(counter);
              return counter;
            };
            clearTask = function clearImmediate(id) {
              delete queue2[id];
            };
            if (__webpack_require__(18)(process2) == "process") {
              defer = function(id) {
                process2.nextTick(ctx(run2, id, 1));
              };
            } else if (Dispatch && Dispatch.now) {
              defer = function(id) {
                Dispatch.now(ctx(run2, id, 1));
              };
            } else if (MessageChannel) {
              channel = new MessageChannel();
              port = channel.port2;
              channel.port1.onmessage = listener;
              defer = ctx(port.postMessage, port, 1);
            } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts) {
              defer = function(id) {
                global2.postMessage(id + "", "*");
              };
              global2.addEventListener("message", listener, false);
            } else if (ONREADYSTATECHANGE in cel("script")) {
              defer = function(id) {
                html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                  html.removeChild(this);
                  run2.call(id);
                };
              };
            } else {
              defer = function(id) {
                setTimeout(ctx(run2, id, 1), 0);
              };
            }
          }
          module3.exports = {
            set: setTask,
            clear: clearTask
          };
        },
        /* 49 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__(31);
          var min2 = Math.min;
          module3.exports = function(it) {
            return it > 0 ? min2(toInteger(it), 9007199254740991) : 0;
          };
        },
        /* 50 */
        /***/
        function(module3, exports2) {
          var id = 0;
          var px = Math.random();
          module3.exports = function(key) {
            return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
          };
        },
        /* 51 */
        /***/
        function(module3, exports2) {
          module3.exports = function pad(num, size2) {
            var s = "000000000" + num;
            return s.substr(s.length - size2);
          };
        },
        /* 52 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const XMLHttpRequest2 = __webpack_require__(55);
          const XHR2 = __webpack_require__(127);
          const JSONP = __webpack_require__(126);
          const websocket = __webpack_require__(129);
          exports2.polling = polling;
          exports2.websocket = websocket;
          function polling(opts) {
            let xhr2;
            let xd = false;
            let xs = false;
            const jsonp = false !== opts.jsonp;
            if (typeof location !== "undefined") {
              const isSSL = "https:" === location.protocol;
              let port = location.port;
              if (!port) {
                port = isSSL ? 443 : 80;
              }
              xd = opts.hostname !== location.hostname || port !== opts.port;
              xs = opts.secure !== isSSL;
            }
            opts.xdomain = xd;
            opts.xscheme = xs;
            xhr2 = new XMLHttpRequest2(opts);
            if ("open" in xhr2 && !opts.forceJSONP) {
              return new XHR2(opts);
            } else {
              if (!jsonp)
                throw new Error("JSONP disabled");
              return new JSONP(opts);
            }
          }
        },
        /* 53 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const Transport2 = __webpack_require__(33);
          const parseqs = __webpack_require__(35);
          const parser2 = __webpack_require__(16);
          const yeast2 = __webpack_require__(72);
          const debug = __webpack_require__(15)("engine.io-client:polling");
          class Polling2 extends Transport2 {
            /**
             * Transport name.
             */
            get name() {
              return "polling";
            }
            /**
             * Opens the socket (triggers polling). We write a PING message to determine
             * when the transport is open.
             *
             * @api private
             */
            doOpen() {
              this.poll();
            }
            /**
             * Pauses polling.
             *
             * @param {Function} callback upon buffers are flushed and transport is paused
             * @api private
             */
            pause(onPause) {
              this.readyState = "pausing";
              const pause = () => {
                debug("paused");
                this.readyState = "paused";
                onPause();
              };
              if (this.polling || !this.writable) {
                let total = 0;
                if (this.polling) {
                  debug("we are currently polling - waiting to pause");
                  total++;
                  this.once("pollComplete", function() {
                    debug("pre-pause polling complete");
                    --total || pause();
                  });
                }
                if (!this.writable) {
                  debug("we are currently writing - waiting to pause");
                  total++;
                  this.once("drain", function() {
                    debug("pre-pause writing complete");
                    --total || pause();
                  });
                }
              } else {
                pause();
              }
            }
            /**
             * Starts polling cycle.
             *
             * @api public
             */
            poll() {
              debug("polling");
              this.polling = true;
              this.doPoll();
              this.emit("poll");
            }
            /**
             * Overloads onData to detect payloads.
             *
             * @api private
             */
            onData(data2) {
              debug("polling got data %s", data2);
              const callback = (packet) => {
                if ("opening" === this.readyState && packet.type === "open") {
                  this.onOpen();
                }
                if ("close" === packet.type) {
                  this.onClose();
                  return false;
                }
                this.onPacket(packet);
              };
              parser2.decodePayload(data2, this.socket.binaryType).forEach(callback);
              if ("closed" !== this.readyState) {
                this.polling = false;
                this.emit("pollComplete");
                if ("open" === this.readyState) {
                  this.poll();
                } else {
                  debug('ignoring poll - transport state "%s"', this.readyState);
                }
              }
            }
            /**
             * For polling, send a close packet.
             *
             * @api private
             */
            doClose() {
              const close = () => {
                debug("writing close packet");
                this.write([{ type: "close" }]);
              };
              if ("open" === this.readyState) {
                debug("transport open - closing");
                close();
              } else {
                debug("transport not open - deferring close");
                this.once("open", close);
              }
            }
            /**
             * Writes a packets payload.
             *
             * @param {Array} data packets
             * @param {Function} drain callback
             * @api private
             */
            write(packets) {
              this.writable = false;
              parser2.encodePayload(packets, (data2) => {
                this.doWrite(data2, () => {
                  this.writable = true;
                  this.emit("drain");
                });
              });
            }
            /**
             * Generates uri for connection.
             *
             * @api private
             */
            uri() {
              let query = this.query || {};
              const schema = this.opts.secure ? "https" : "http";
              let port = "";
              if (false !== this.opts.timestampRequests) {
                query[this.opts.timestampParam] = yeast2();
              }
              if (!this.supportsBinary && !query.sid) {
                query.b64 = 1;
              }
              query = parseqs.encode(query);
              if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
                port = ":" + this.opts.port;
              }
              if (query.length) {
                query = "?" + query;
              }
              const ipv6 = this.opts.hostname.indexOf(":") !== -1;
              return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
            }
          }
          module3.exports = Polling2;
        },
        /* 54 */
        /***/
        function(module3, exports2) {
          module3.exports.pick = (obj, ...attr) => {
            return attr.reduce((acc, k2) => {
              if (obj.hasOwnProperty(k2)) {
                acc[k2] = obj[k2];
              }
              return acc;
            }, {});
          };
        },
        /* 55 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const hasCORS2 = __webpack_require__(136);
          const globalThis2 = __webpack_require__(23);
          module3.exports = function(opts) {
            const xdomain = opts.xdomain;
            const xscheme = opts.xscheme;
            const enablesXDR = opts.enablesXDR;
            try {
              if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS2)) {
                return new XMLHttpRequest();
              }
            } catch (e) {
            }
            try {
              if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
                return new XDomainRequest();
              }
            } catch (e) {
            }
            if (!xdomain) {
              try {
                return new globalThis2[["Active"].concat("Object").join("X")](
                  "Microsoft.XMLHTTP"
                );
              } catch (e) {
              }
            }
          };
        },
        /* 56 */
        /***/
        function(module3, exports2) {
          const PACKET_TYPES2 = /* @__PURE__ */ Object.create(null);
          PACKET_TYPES2["open"] = "0";
          PACKET_TYPES2["close"] = "1";
          PACKET_TYPES2["ping"] = "2";
          PACKET_TYPES2["pong"] = "3";
          PACKET_TYPES2["message"] = "4";
          PACKET_TYPES2["upgrade"] = "5";
          PACKET_TYPES2["noop"] = "6";
          const PACKET_TYPES_REVERSE2 = /* @__PURE__ */ Object.create(null);
          Object.keys(PACKET_TYPES2).forEach((key) => {
            PACKET_TYPES_REVERSE2[PACKET_TYPES2[key]] = key;
          });
          const ERROR_PACKET2 = { type: "error", data: "parser error" };
          module3.exports = {
            PACKET_TYPES: PACKET_TYPES2,
            PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE2,
            ERROR_PACKET: ERROR_PACKET2
          };
        },
        /* 57 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var R = typeof Reflect === "object" ? Reflect : null;
          var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
          };
          var ReflectOwnKeys;
          if (R && typeof R.ownKeys === "function") {
            ReflectOwnKeys = R.ownKeys;
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys2(target) {
              return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
            };
          } else {
            ReflectOwnKeys = function ReflectOwnKeys2(target) {
              return Object.getOwnPropertyNames(target);
            };
          }
          function ProcessEmitWarning(warning) {
            if (console && console.warn)
              console.warn(warning);
          }
          var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
            return value2 !== value2;
          };
          function EventEmitter() {
            EventEmitter.init.call(this);
          }
          module3.exports = EventEmitter;
          module3.exports.once = once;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = void 0;
          EventEmitter.prototype._eventsCount = 0;
          EventEmitter.prototype._maxListeners = void 0;
          var defaultMaxListeners = 10;
          function checkListener(listener) {
            if (typeof listener !== "function") {
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
            }
          }
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners;
            },
            set: function(arg) {
              if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
              }
              defaultMaxListeners = arg;
            }
          });
          EventEmitter.init = function() {
            if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || void 0;
          };
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
            }
            this._maxListeners = n;
            return this;
          };
          function _getMaxListeners(that) {
            if (that._maxListeners === void 0)
              return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
          }
          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this);
          };
          EventEmitter.prototype.emit = function emit2(type) {
            var args = [];
            for (var i2 = 1; i2 < arguments.length; i2++)
              args.push(arguments[i2]);
            var doError = type === "error";
            var events = this._events;
            if (events !== void 0)
              doError = doError && events.error === void 0;
            else if (!doError)
              return false;
            if (doError) {
              var er;
              if (args.length > 0)
                er = args[0];
              if (er instanceof Error) {
                throw er;
              }
              var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
              err.context = er;
              throw err;
            }
            var handler = events[type];
            if (handler === void 0)
              return false;
            if (typeof handler === "function") {
              ReflectApply(handler, this, args);
            } else {
              var len = handler.length;
              var listeners = arrayClone(handler, len);
              for (var i2 = 0; i2 < len; ++i2)
                ReflectApply(listeners[i2], this, args);
            }
            return true;
          };
          function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;
            checkListener(listener);
            events = target._events;
            if (events === void 0) {
              events = target._events = /* @__PURE__ */ Object.create(null);
              target._eventsCount = 0;
            } else {
              if (events.newListener !== void 0) {
                target.emit(
                  "newListener",
                  type,
                  listener.listener ? listener.listener : listener
                );
                events = target._events;
              }
              existing = events[type];
            }
            if (existing === void 0) {
              existing = events[type] = listener;
              ++target._eventsCount;
            } else {
              if (typeof existing === "function") {
                existing = events[type] = prepend ? [listener, existing] : [existing, listener];
              } else if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
              m = _getMaxListeners(target);
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true;
                var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                w2.name = "MaxListenersExceededWarning";
                w2.emitter = target;
                w2.type = type;
                w2.count = existing.length;
                ProcessEmitWarning(w2);
              }
            }
            return target;
          }
          EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false);
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.prependListener = function prependListener(type, listener) {
            return _addListener(this, type, listener, true);
          };
          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn);
              this.fired = true;
              if (arguments.length === 0)
                return this.listener.call(this.target);
              return this.listener.apply(this.target, arguments);
            }
          }
          function _onceWrap(target, type, listener) {
            var state2 = { fired: false, wrapFn: void 0, target, type, listener };
            var wrapped = onceWrapper.bind(state2);
            wrapped.listener = listener;
            state2.wrapFn = wrapped;
            return wrapped;
          }
          EventEmitter.prototype.once = function once2(type, listener) {
            checkListener(listener);
            this.on(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
            checkListener(listener);
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.removeListener = function removeListener(type, listener) {
            var list, events, position, i2, originalListener;
            checkListener(listener);
            events = this._events;
            if (events === void 0)
              return this;
            list = events[type];
            if (list === void 0)
              return this;
            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit("removeListener", type, list.listener || listener);
              }
            } else if (typeof list !== "function") {
              position = -1;
              for (i2 = list.length - 1; i2 >= 0; i2--) {
                if (list[i2] === listener || list[i2].listener === listener) {
                  originalListener = list[i2].listener;
                  position = i2;
                  break;
                }
              }
              if (position < 0)
                return this;
              if (position === 0)
                list.shift();
              else {
                spliceOne(list, position);
              }
              if (list.length === 1)
                events[type] = list[0];
              if (events.removeListener !== void 0)
                this.emit("removeListener", type, originalListener || listener);
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
            var listeners, events, i2;
            events = this._events;
            if (events === void 0)
              return this;
            if (events.removeListener === void 0) {
              if (arguments.length === 0) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              } else if (events[type] !== void 0) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else
                  delete events[type];
              }
              return this;
            }
            if (arguments.length === 0) {
              var keys2 = Object.keys(events);
              var key;
              for (i2 = 0; i2 < keys2.length; ++i2) {
                key = keys2[i2];
                if (key === "removeListener")
                  continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
              return this;
            }
            listeners = events[type];
            if (typeof listeners === "function") {
              this.removeListener(type, listeners);
            } else if (listeners !== void 0) {
              for (i2 = listeners.length - 1; i2 >= 0; i2--) {
                this.removeListener(type, listeners[i2]);
              }
            }
            return this;
          };
          function _listeners(target, type, unwrap) {
            var events = target._events;
            if (events === void 0)
              return [];
            var evlistener = events[type];
            if (evlistener === void 0)
              return [];
            if (typeof evlistener === "function")
              return unwrap ? [evlistener.listener || evlistener] : [evlistener];
            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
          }
          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
          };
          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
          };
          EventEmitter.listenerCount = function(emitter, type) {
            if (typeof emitter.listenerCount === "function") {
              return emitter.listenerCount(type);
            } else {
              return listenerCount.call(emitter, type);
            }
          };
          EventEmitter.prototype.listenerCount = listenerCount;
          function listenerCount(type) {
            var events = this._events;
            if (events !== void 0) {
              var evlistener = events[type];
              if (typeof evlistener === "function") {
                return 1;
              } else if (evlistener !== void 0) {
                return evlistener.length;
              }
            }
            return 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
          };
          function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i2 = 0; i2 < n; ++i2)
              copy[i2] = arr[i2];
            return copy;
          }
          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1];
            list.pop();
          }
          function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i2 = 0; i2 < ret.length; ++i2) {
              ret[i2] = arr[i2].listener || arr[i2];
            }
            return ret;
          }
          function once(emitter, name) {
            return new Promise(function(resolve2, reject) {
              function errorListener(err) {
                emitter.removeListener(name, resolver);
                reject(err);
              }
              function resolver() {
                if (typeof emitter.removeListener === "function") {
                  emitter.removeListener("error", errorListener);
                }
                resolve2([].slice.call(arguments));
              }
              eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
              if (name !== "error") {
                addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
              }
            });
          }
          function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === "function") {
              eventTargetAgnosticAddListener(emitter, "error", handler, flags);
            }
          }
          function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
            if (typeof emitter.on === "function") {
              if (flags.once) {
                emitter.once(name, listener);
              } else {
                emitter.on(name, listener);
              }
            } else if (typeof emitter.addEventListener === "function") {
              emitter.addEventListener(name, function wrapListener(arg) {
                if (flags.once) {
                  emitter.removeEventListener(name, wrapListener);
                }
                listener(arg);
              });
            } else {
              throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
            }
          }
        },
        /* 58 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var Buffer2 = __webpack_require__(66).Buffer;
          var isEncoding = Buffer2.isEncoding || function(encoding) {
            encoding = "" + encoding;
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;
              default:
                return false;
            }
          };
          function _normalizeEncoding(enc) {
            if (!enc)
              return "utf8";
            var retried;
            while (true) {
              switch (enc) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return enc;
                default:
                  if (retried)
                    return;
                  enc = ("" + enc).toLowerCase();
                  retried = true;
              }
            }
          }
          function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc);
            if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
              throw new Error("Unknown encoding: " + enc);
            return nenc || enc;
          }
          exports2.StringDecoder = StringDecoder;
          function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding);
            var nb;
            switch (this.encoding) {
              case "utf16le":
                this.text = utf16Text;
                this.end = utf16End;
                nb = 4;
                break;
              case "utf8":
                this.fillLast = utf8FillLast;
                nb = 4;
                break;
              case "base64":
                this.text = base64Text;
                this.end = base64End;
                nb = 3;
                break;
              default:
                this.write = simpleWrite;
                this.end = simpleEnd;
                return;
            }
            this.lastNeed = 0;
            this.lastTotal = 0;
            this.lastChar = Buffer2.allocUnsafe(nb);
          }
          StringDecoder.prototype.write = function(buf) {
            if (buf.length === 0)
              return "";
            var r;
            var i2;
            if (this.lastNeed) {
              r = this.fillLast(buf);
              if (r === void 0)
                return "";
              i2 = this.lastNeed;
              this.lastNeed = 0;
            } else {
              i2 = 0;
            }
            if (i2 < buf.length)
              return r ? r + this.text(buf, i2) : this.text(buf, i2);
            return r || "";
          };
          StringDecoder.prototype.end = utf8End;
          StringDecoder.prototype.text = utf8Text;
          StringDecoder.prototype.fillLast = function(buf) {
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
            this.lastNeed -= buf.length;
          };
          function utf8CheckByte(byte) {
            if (byte <= 127)
              return 0;
            else if (byte >> 5 === 6)
              return 2;
            else if (byte >> 4 === 14)
              return 3;
            else if (byte >> 3 === 30)
              return 4;
            return byte >> 6 === 2 ? -1 : -2;
          }
          function utf8CheckIncomplete(self2, buf, i2) {
            var j2 = buf.length - 1;
            if (j2 < i2)
              return 0;
            var nb = utf8CheckByte(buf[j2]);
            if (nb >= 0) {
              if (nb > 0)
                self2.lastNeed = nb - 1;
              return nb;
            }
            if (--j2 < i2 || nb === -2)
              return 0;
            nb = utf8CheckByte(buf[j2]);
            if (nb >= 0) {
              if (nb > 0)
                self2.lastNeed = nb - 2;
              return nb;
            }
            if (--j2 < i2 || nb === -2)
              return 0;
            nb = utf8CheckByte(buf[j2]);
            if (nb >= 0) {
              if (nb > 0) {
                if (nb === 2)
                  nb = 0;
                else
                  self2.lastNeed = nb - 3;
              }
              return nb;
            }
            return 0;
          }
          function utf8CheckExtraBytes(self2, buf, p2) {
            if ((buf[0] & 192) !== 128) {
              self2.lastNeed = 0;
              return "�";
            }
            if (self2.lastNeed > 1 && buf.length > 1) {
              if ((buf[1] & 192) !== 128) {
                self2.lastNeed = 1;
                return "�";
              }
              if (self2.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 192) !== 128) {
                  self2.lastNeed = 2;
                  return "�";
                }
              }
            }
          }
          function utf8FillLast(buf) {
            var p2 = this.lastTotal - this.lastNeed;
            var r = utf8CheckExtraBytes(this, buf);
            if (r !== void 0)
              return r;
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, p2, 0, this.lastNeed);
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, p2, 0, buf.length);
            this.lastNeed -= buf.length;
          }
          function utf8Text(buf, i2) {
            var total = utf8CheckIncomplete(this, buf, i2);
            if (!this.lastNeed)
              return buf.toString("utf8", i2);
            this.lastTotal = total;
            var end = buf.length - (total - this.lastNeed);
            buf.copy(this.lastChar, 0, end);
            return buf.toString("utf8", i2, end);
          }
          function utf8End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed)
              return r + "�";
            return r;
          }
          function utf16Text(buf, i2) {
            if ((buf.length - i2) % 2 === 0) {
              var r = buf.toString("utf16le", i2);
              if (r) {
                var c = r.charCodeAt(r.length - 1);
                if (c >= 55296 && c <= 56319) {
                  this.lastNeed = 2;
                  this.lastTotal = 4;
                  this.lastChar[0] = buf[buf.length - 2];
                  this.lastChar[1] = buf[buf.length - 1];
                  return r.slice(0, -1);
                }
              }
              return r;
            }
            this.lastNeed = 1;
            this.lastTotal = 2;
            this.lastChar[0] = buf[buf.length - 1];
            return buf.toString("utf16le", i2, buf.length - 1);
          }
          function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) {
              var end = this.lastTotal - this.lastNeed;
              return r + this.lastChar.toString("utf16le", 0, end);
            }
            return r;
          }
          function base64Text(buf, i2) {
            var n = (buf.length - i2) % 3;
            if (n === 0)
              return buf.toString("base64", i2);
            this.lastNeed = 3 - n;
            this.lastTotal = 3;
            if (n === 1) {
              this.lastChar[0] = buf[buf.length - 1];
            } else {
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
            }
            return buf.toString("base64", i2, buf.length - n);
          }
          function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed)
              return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
            return r;
          }
          function simpleWrite(buf) {
            return buf.toString(this.encoding);
          }
          function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : "";
          }
        },
        /* 59 */
        /***/
        function(module3, exports2) {
          var re2 = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
          var parts2 = [
            "source",
            "protocol",
            "authority",
            "userInfo",
            "user",
            "password",
            "host",
            "port",
            "relative",
            "path",
            "directory",
            "file",
            "query",
            "anchor"
          ];
          module3.exports = function parseuri(str) {
            var src = str, b = str.indexOf("["), e = str.indexOf("]");
            if (b != -1 && e != -1) {
              str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
            }
            var m = re2.exec(str || ""), uri = {}, i2 = 14;
            while (i2--) {
              uri[parts2[i2]] = m[i2] || "";
            }
            if (b != -1 && e != -1) {
              uri.source = src;
              uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
              uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
              uri.ipv6uri = true;
            }
            uri.pathNames = pathNames2(uri, uri["path"]);
            uri.queryKey = queryKey2(uri, uri["query"]);
            return uri;
          };
          function pathNames2(obj, path) {
            var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
            if (path.substr(0, 1) == "/" || path.length === 0) {
              names.splice(0, 1);
            }
            if (path.substr(path.length - 1, 1) == "/") {
              names.splice(names.length - 1, 1);
            }
            return names;
          }
          function queryKey2(uri, query) {
            var data2 = {};
            query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
              if ($1) {
                data2[$1] = $2;
              }
            });
            return data2;
          }
        },
        /* 60 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(global2, process2) {
            module3.exports = Readable;
            var Duplex;
            Readable.ReadableState = ReadableState;
            __webpack_require__(57).EventEmitter;
            var EElistenerCount = function EElistenerCount2(emitter, type) {
              return emitter.listeners(type).length;
            };
            var Stream = __webpack_require__(65);
            var Buffer2 = __webpack_require__(5).Buffer;
            var OurUint8Array = global2.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk2) {
              return Buffer2.from(chunk2);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var debugUtil = __webpack_require__(172);
            var debug;
            if (debugUtil && debugUtil.debuglog) {
              debug = debugUtil.debuglog("stream");
            } else {
              debug = function debug2() {
              };
            }
            var BufferList = __webpack_require__(146);
            var destroyImpl = __webpack_require__(63);
            var _require = __webpack_require__(64), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = __webpack_require__(8).codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            var StringDecoder;
            var createReadableStreamAsyncIterator;
            var from2;
            __webpack_require__(7)(Readable, Stream);
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
            function prependListener(emitter, event, fn) {
              if (typeof emitter.prependListener === "function")
                return emitter.prependListener(event, fn);
              if (!emitter._events || !emitter._events[event])
                emitter.on(event, fn);
              else if (Array.isArray(emitter._events[event]))
                emitter._events[event].unshift(fn);
              else
                emitter._events[event] = [fn, emitter._events[event]];
            }
            function ReadableState(options, stream, isDuplex) {
              Duplex = Duplex || __webpack_require__(9);
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.readableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
              this.buffer = new BufferList();
              this.length = 0;
              this.pipes = null;
              this.pipesCount = 0;
              this.flowing = null;
              this.ended = false;
              this.endEmitted = false;
              this.reading = false;
              this.sync = true;
              this.needReadable = false;
              this.emittedReadable = false;
              this.readableListening = false;
              this.resumeScheduled = false;
              this.paused = true;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.destroyed = false;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.awaitDrain = 0;
              this.readingMore = false;
              this.decoder = null;
              this.encoding = null;
              if (options.encoding) {
                if (!StringDecoder)
                  StringDecoder = __webpack_require__(58).StringDecoder;
                this.decoder = new StringDecoder(options.encoding);
                this.encoding = options.encoding;
              }
            }
            function Readable(options) {
              Duplex = Duplex || __webpack_require__(9);
              if (!(this instanceof Readable))
                return new Readable(options);
              var isDuplex = this instanceof Duplex;
              this._readableState = new ReadableState(options, this, isDuplex);
              this.readable = true;
              if (options) {
                if (typeof options.read === "function")
                  this._read = options.read;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
              }
              Stream.call(this);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                if (this._readableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed;
              },
              set: function set2(value2) {
                if (!this._readableState) {
                  return;
                }
                this._readableState.destroyed = value2;
              }
            });
            Readable.prototype.destroy = destroyImpl.destroy;
            Readable.prototype._undestroy = destroyImpl.undestroy;
            Readable.prototype._destroy = function(err, cb) {
              cb(err);
            };
            Readable.prototype.push = function(chunk2, encoding) {
              var state2 = this._readableState;
              var skipChunkCheck;
              if (!state2.objectMode) {
                if (typeof chunk2 === "string") {
                  encoding = encoding || state2.defaultEncoding;
                  if (encoding !== state2.encoding) {
                    chunk2 = Buffer2.from(chunk2, encoding);
                    encoding = "";
                  }
                  skipChunkCheck = true;
                }
              } else {
                skipChunkCheck = true;
              }
              return readableAddChunk(this, chunk2, encoding, false, skipChunkCheck);
            };
            Readable.prototype.unshift = function(chunk2) {
              return readableAddChunk(this, chunk2, null, true, false);
            };
            function readableAddChunk(stream, chunk2, encoding, addToFront, skipChunkCheck) {
              debug("readableAddChunk", chunk2);
              var state2 = stream._readableState;
              if (chunk2 === null) {
                state2.reading = false;
                onEofChunk(stream, state2);
              } else {
                var er;
                if (!skipChunkCheck)
                  er = chunkInvalid(state2, chunk2);
                if (er) {
                  errorOrDestroy(stream, er);
                } else if (state2.objectMode || chunk2 && chunk2.length > 0) {
                  if (typeof chunk2 !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk2) !== Buffer2.prototype) {
                    chunk2 = _uint8ArrayToBuffer(chunk2);
                  }
                  if (addToFront) {
                    if (state2.endEmitted)
                      errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                    else
                      addChunk(stream, state2, chunk2, true);
                  } else if (state2.ended) {
                    errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                  } else if (state2.destroyed) {
                    return false;
                  } else {
                    state2.reading = false;
                    if (state2.decoder && !encoding) {
                      chunk2 = state2.decoder.write(chunk2);
                      if (state2.objectMode || chunk2.length !== 0)
                        addChunk(stream, state2, chunk2, false);
                      else
                        maybeReadMore(stream, state2);
                    } else {
                      addChunk(stream, state2, chunk2, false);
                    }
                  }
                } else if (!addToFront) {
                  state2.reading = false;
                  maybeReadMore(stream, state2);
                }
              }
              return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
            }
            function addChunk(stream, state2, chunk2, addToFront) {
              if (state2.flowing && state2.length === 0 && !state2.sync) {
                state2.awaitDrain = 0;
                stream.emit("data", chunk2);
              } else {
                state2.length += state2.objectMode ? 1 : chunk2.length;
                if (addToFront)
                  state2.buffer.unshift(chunk2);
                else
                  state2.buffer.push(chunk2);
                if (state2.needReadable)
                  emitReadable(stream);
              }
              maybeReadMore(stream, state2);
            }
            function chunkInvalid(state2, chunk2) {
              var er;
              if (!_isUint8Array(chunk2) && typeof chunk2 !== "string" && chunk2 !== void 0 && !state2.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk2);
              }
              return er;
            }
            Readable.prototype.isPaused = function() {
              return this._readableState.flowing === false;
            };
            Readable.prototype.setEncoding = function(enc) {
              if (!StringDecoder)
                StringDecoder = __webpack_require__(58).StringDecoder;
              var decoder = new StringDecoder(enc);
              this._readableState.decoder = decoder;
              this._readableState.encoding = this._readableState.decoder.encoding;
              var p2 = this._readableState.buffer.head;
              var content = "";
              while (p2 !== null) {
                content += decoder.write(p2.data);
                p2 = p2.next;
              }
              this._readableState.buffer.clear();
              if (content !== "")
                this._readableState.buffer.push(content);
              this._readableState.length = content.length;
              return this;
            };
            var MAX_HWM = 1073741824;
            function computeNewHighWaterMark(n) {
              if (n >= MAX_HWM) {
                n = MAX_HWM;
              } else {
                n--;
                n |= n >>> 1;
                n |= n >>> 2;
                n |= n >>> 4;
                n |= n >>> 8;
                n |= n >>> 16;
                n++;
              }
              return n;
            }
            function howMuchToRead(n, state2) {
              if (n <= 0 || state2.length === 0 && state2.ended)
                return 0;
              if (state2.objectMode)
                return 1;
              if (n !== n) {
                if (state2.flowing && state2.length)
                  return state2.buffer.head.data.length;
                else
                  return state2.length;
              }
              if (n > state2.highWaterMark)
                state2.highWaterMark = computeNewHighWaterMark(n);
              if (n <= state2.length)
                return n;
              if (!state2.ended) {
                state2.needReadable = true;
                return 0;
              }
              return state2.length;
            }
            Readable.prototype.read = function(n) {
              debug("read", n);
              n = parseInt(n, 10);
              var state2 = this._readableState;
              var nOrig = n;
              if (n !== 0)
                state2.emittedReadable = false;
              if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
                debug("read: emitReadable", state2.length, state2.ended);
                if (state2.length === 0 && state2.ended)
                  endReadable(this);
                else
                  emitReadable(this);
                return null;
              }
              n = howMuchToRead(n, state2);
              if (n === 0 && state2.ended) {
                if (state2.length === 0)
                  endReadable(this);
                return null;
              }
              var doRead = state2.needReadable;
              debug("need readable", doRead);
              if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
                doRead = true;
                debug("length less than watermark", doRead);
              }
              if (state2.ended || state2.reading) {
                doRead = false;
                debug("reading or ended", doRead);
              } else if (doRead) {
                debug("do read");
                state2.reading = true;
                state2.sync = true;
                if (state2.length === 0)
                  state2.needReadable = true;
                this._read(state2.highWaterMark);
                state2.sync = false;
                if (!state2.reading)
                  n = howMuchToRead(nOrig, state2);
              }
              var ret;
              if (n > 0)
                ret = fromList(n, state2);
              else
                ret = null;
              if (ret === null) {
                state2.needReadable = state2.length <= state2.highWaterMark;
                n = 0;
              } else {
                state2.length -= n;
                state2.awaitDrain = 0;
              }
              if (state2.length === 0) {
                if (!state2.ended)
                  state2.needReadable = true;
                if (nOrig !== n && state2.ended)
                  endReadable(this);
              }
              if (ret !== null)
                this.emit("data", ret);
              return ret;
            };
            function onEofChunk(stream, state2) {
              debug("onEofChunk");
              if (state2.ended)
                return;
              if (state2.decoder) {
                var chunk2 = state2.decoder.end();
                if (chunk2 && chunk2.length) {
                  state2.buffer.push(chunk2);
                  state2.length += state2.objectMode ? 1 : chunk2.length;
                }
              }
              state2.ended = true;
              if (state2.sync) {
                emitReadable(stream);
              } else {
                state2.needReadable = false;
                if (!state2.emittedReadable) {
                  state2.emittedReadable = true;
                  emitReadable_(stream);
                }
              }
            }
            function emitReadable(stream) {
              var state2 = stream._readableState;
              debug("emitReadable", state2.needReadable, state2.emittedReadable);
              state2.needReadable = false;
              if (!state2.emittedReadable) {
                debug("emitReadable", state2.flowing);
                state2.emittedReadable = true;
                process2.nextTick(emitReadable_, stream);
              }
            }
            function emitReadable_(stream) {
              var state2 = stream._readableState;
              debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
              if (!state2.destroyed && (state2.length || state2.ended)) {
                stream.emit("readable");
                state2.emittedReadable = false;
              }
              state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
              flow(stream);
            }
            function maybeReadMore(stream, state2) {
              if (!state2.readingMore) {
                state2.readingMore = true;
                process2.nextTick(maybeReadMore_, stream, state2);
              }
            }
            function maybeReadMore_(stream, state2) {
              while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
                var len = state2.length;
                debug("maybeReadMore read 0");
                stream.read(0);
                if (len === state2.length)
                  break;
              }
              state2.readingMore = false;
            }
            Readable.prototype._read = function(n) {
              errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
            };
            Readable.prototype.pipe = function(dest, pipeOpts) {
              var src = this;
              var state2 = this._readableState;
              switch (state2.pipesCount) {
                case 0:
                  state2.pipes = dest;
                  break;
                case 1:
                  state2.pipes = [state2.pipes, dest];
                  break;
                default:
                  state2.pipes.push(dest);
                  break;
              }
              state2.pipesCount += 1;
              debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
              var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
              var endFn = doEnd ? onend : unpipe;
              if (state2.endEmitted)
                process2.nextTick(endFn);
              else
                src.once("end", endFn);
              dest.on("unpipe", onunpipe);
              function onunpipe(readable, unpipeInfo) {
                debug("onunpipe");
                if (readable === src) {
                  if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                    unpipeInfo.hasUnpiped = true;
                    cleanup();
                  }
                }
              }
              function onend() {
                debug("onend");
                dest.end();
              }
              var ondrain = pipeOnDrain(src);
              dest.on("drain", ondrain);
              var cleanedUp = false;
              function cleanup() {
                debug("cleanup");
                dest.removeListener("close", onclose);
                dest.removeListener("finish", onfinish);
                dest.removeListener("drain", ondrain);
                dest.removeListener("error", onerror);
                dest.removeListener("unpipe", onunpipe);
                src.removeListener("end", onend);
                src.removeListener("end", unpipe);
                src.removeListener("data", ondata);
                cleanedUp = true;
                if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                  ondrain();
              }
              src.on("data", ondata);
              function ondata(chunk2) {
                debug("ondata");
                var ret = dest.write(chunk2);
                debug("dest.write", ret);
                if (ret === false) {
                  if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf2(state2.pipes, dest) !== -1) && !cleanedUp) {
                    debug("false write response, pause", state2.awaitDrain);
                    state2.awaitDrain++;
                  }
                  src.pause();
                }
              }
              function onerror(er) {
                debug("onerror", er);
                unpipe();
                dest.removeListener("error", onerror);
                if (EElistenerCount(dest, "error") === 0)
                  errorOrDestroy(dest, er);
              }
              prependListener(dest, "error", onerror);
              function onclose() {
                dest.removeListener("finish", onfinish);
                unpipe();
              }
              dest.once("close", onclose);
              function onfinish() {
                debug("onfinish");
                dest.removeListener("close", onclose);
                unpipe();
              }
              dest.once("finish", onfinish);
              function unpipe() {
                debug("unpipe");
                src.unpipe(dest);
              }
              dest.emit("pipe", src);
              if (!state2.flowing) {
                debug("pipe resume");
                src.resume();
              }
              return dest;
            };
            function pipeOnDrain(src) {
              return function pipeOnDrainFunctionResult() {
                var state2 = src._readableState;
                debug("pipeOnDrain", state2.awaitDrain);
                if (state2.awaitDrain)
                  state2.awaitDrain--;
                if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
                  state2.flowing = true;
                  flow(src);
                }
              };
            }
            Readable.prototype.unpipe = function(dest) {
              var state2 = this._readableState;
              var unpipeInfo = {
                hasUnpiped: false
              };
              if (state2.pipesCount === 0)
                return this;
              if (state2.pipesCount === 1) {
                if (dest && dest !== state2.pipes)
                  return this;
                if (!dest)
                  dest = state2.pipes;
                state2.pipes = null;
                state2.pipesCount = 0;
                state2.flowing = false;
                if (dest)
                  dest.emit("unpipe", this, unpipeInfo);
                return this;
              }
              if (!dest) {
                var dests = state2.pipes;
                var len = state2.pipesCount;
                state2.pipes = null;
                state2.pipesCount = 0;
                state2.flowing = false;
                for (var i2 = 0; i2 < len; i2++) {
                  dests[i2].emit("unpipe", this, {
                    hasUnpiped: false
                  });
                }
                return this;
              }
              var index = indexOf2(state2.pipes, dest);
              if (index === -1)
                return this;
              state2.pipes.splice(index, 1);
              state2.pipesCount -= 1;
              if (state2.pipesCount === 1)
                state2.pipes = state2.pipes[0];
              dest.emit("unpipe", this, unpipeInfo);
              return this;
            };
            Readable.prototype.on = function(ev, fn) {
              var res = Stream.prototype.on.call(this, ev, fn);
              var state2 = this._readableState;
              if (ev === "data") {
                state2.readableListening = this.listenerCount("readable") > 0;
                if (state2.flowing !== false)
                  this.resume();
              } else if (ev === "readable") {
                if (!state2.endEmitted && !state2.readableListening) {
                  state2.readableListening = state2.needReadable = true;
                  state2.flowing = false;
                  state2.emittedReadable = false;
                  debug("on readable", state2.length, state2.reading);
                  if (state2.length) {
                    emitReadable(this);
                  } else if (!state2.reading) {
                    process2.nextTick(nReadingNextTick, this);
                  }
                }
              }
              return res;
            };
            Readable.prototype.addListener = Readable.prototype.on;
            Readable.prototype.removeListener = function(ev, fn) {
              var res = Stream.prototype.removeListener.call(this, ev, fn);
              if (ev === "readable") {
                process2.nextTick(updateReadableListening, this);
              }
              return res;
            };
            Readable.prototype.removeAllListeners = function(ev) {
              var res = Stream.prototype.removeAllListeners.apply(this, arguments);
              if (ev === "readable" || ev === void 0) {
                process2.nextTick(updateReadableListening, this);
              }
              return res;
            };
            function updateReadableListening(self2) {
              var state2 = self2._readableState;
              state2.readableListening = self2.listenerCount("readable") > 0;
              if (state2.resumeScheduled && !state2.paused) {
                state2.flowing = true;
              } else if (self2.listenerCount("data") > 0) {
                self2.resume();
              }
            }
            function nReadingNextTick(self2) {
              debug("readable nexttick read 0");
              self2.read(0);
            }
            Readable.prototype.resume = function() {
              var state2 = this._readableState;
              if (!state2.flowing) {
                debug("resume");
                state2.flowing = !state2.readableListening;
                resume(this, state2);
              }
              state2.paused = false;
              return this;
            };
            function resume(stream, state2) {
              if (!state2.resumeScheduled) {
                state2.resumeScheduled = true;
                process2.nextTick(resume_, stream, state2);
              }
            }
            function resume_(stream, state2) {
              debug("resume", state2.reading);
              if (!state2.reading) {
                stream.read(0);
              }
              state2.resumeScheduled = false;
              stream.emit("resume");
              flow(stream);
              if (state2.flowing && !state2.reading)
                stream.read(0);
            }
            Readable.prototype.pause = function() {
              debug("call pause flowing=%j", this._readableState.flowing);
              if (this._readableState.flowing !== false) {
                debug("pause");
                this._readableState.flowing = false;
                this.emit("pause");
              }
              this._readableState.paused = true;
              return this;
            };
            function flow(stream) {
              var state2 = stream._readableState;
              debug("flow", state2.flowing);
              while (state2.flowing && stream.read() !== null) {
              }
            }
            Readable.prototype.wrap = function(stream) {
              var _this = this;
              var state2 = this._readableState;
              var paused = false;
              stream.on("end", function() {
                debug("wrapped end");
                if (state2.decoder && !state2.ended) {
                  var chunk2 = state2.decoder.end();
                  if (chunk2 && chunk2.length)
                    _this.push(chunk2);
                }
                _this.push(null);
              });
              stream.on("data", function(chunk2) {
                debug("wrapped data");
                if (state2.decoder)
                  chunk2 = state2.decoder.write(chunk2);
                if (state2.objectMode && (chunk2 === null || chunk2 === void 0))
                  return;
                else if (!state2.objectMode && (!chunk2 || !chunk2.length))
                  return;
                var ret = _this.push(chunk2);
                if (!ret) {
                  paused = true;
                  stream.pause();
                }
              });
              for (var i2 in stream) {
                if (this[i2] === void 0 && typeof stream[i2] === "function") {
                  this[i2] = function methodWrap(method) {
                    return function methodWrapReturnFunction() {
                      return stream[method].apply(stream, arguments);
                    };
                  }(i2);
                }
              }
              for (var n = 0; n < kProxyEvents.length; n++) {
                stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
              }
              this._read = function(n2) {
                debug("wrapped _read", n2);
                if (paused) {
                  paused = false;
                  stream.resume();
                }
              };
              return this;
            };
            if (typeof Symbol === "function") {
              Readable.prototype[Symbol.asyncIterator] = function() {
                if (createReadableStreamAsyncIterator === void 0) {
                  createReadableStreamAsyncIterator = __webpack_require__(145);
                }
                return createReadableStreamAsyncIterator(this);
              };
            }
            Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState.highWaterMark;
              }
            });
            Object.defineProperty(Readable.prototype, "readableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState && this._readableState.buffer;
              }
            });
            Object.defineProperty(Readable.prototype, "readableFlowing", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState.flowing;
              },
              set: function set2(state2) {
                if (this._readableState) {
                  this._readableState.flowing = state2;
                }
              }
            });
            Readable._fromList = fromList;
            Object.defineProperty(Readable.prototype, "readableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._readableState.length;
              }
            });
            function fromList(n, state2) {
              if (state2.length === 0)
                return null;
              var ret;
              if (state2.objectMode)
                ret = state2.buffer.shift();
              else if (!n || n >= state2.length) {
                if (state2.decoder)
                  ret = state2.buffer.join("");
                else if (state2.buffer.length === 1)
                  ret = state2.buffer.first();
                else
                  ret = state2.buffer.concat(state2.length);
                state2.buffer.clear();
              } else {
                ret = state2.buffer.consume(n, state2.decoder);
              }
              return ret;
            }
            function endReadable(stream) {
              var state2 = stream._readableState;
              debug("endReadable", state2.endEmitted);
              if (!state2.endEmitted) {
                state2.ended = true;
                process2.nextTick(endReadableNT, state2, stream);
              }
            }
            function endReadableNT(state2, stream) {
              debug("endReadableNT", state2.endEmitted, state2.length);
              if (!state2.endEmitted && state2.length === 0) {
                state2.endEmitted = true;
                stream.readable = false;
                stream.emit("end");
                if (state2.autoDestroy) {
                  var wState = stream._writableState;
                  if (!wState || wState.autoDestroy && wState.finished) {
                    stream.destroy();
                  }
                }
              }
            }
            if (typeof Symbol === "function") {
              Readable.from = function(iterable, opts) {
                if (from2 === void 0) {
                  from2 = __webpack_require__(147);
                }
                return from2(Readable, iterable, opts);
              };
            }
            function indexOf2(xs, x2) {
              for (var i2 = 0, l = xs.length; i2 < l; i2++) {
                if (xs[i2] === x2)
                  return i2;
              }
              return -1;
            }
          }).call(exports2, __webpack_require__(10), __webpack_require__(2));
        },
        /* 61 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = Transform;
          var _require$codes = __webpack_require__(8).codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
          var Duplex = __webpack_require__(9);
          __webpack_require__(7)(Transform, Duplex);
          function afterTransform(er, data2) {
            var ts = this._transformState;
            ts.transforming = false;
            var cb = ts.writecb;
            if (cb === null) {
              return this.emit("error", new ERR_MULTIPLE_CALLBACK());
            }
            ts.writechunk = null;
            ts.writecb = null;
            if (data2 != null)
              this.push(data2);
            cb(er);
            var rs = this._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
              this._read(rs.highWaterMark);
            }
          }
          function Transform(options) {
            if (!(this instanceof Transform))
              return new Transform(options);
            Duplex.call(this, options);
            this._transformState = {
              afterTransform: afterTransform.bind(this),
              needTransform: false,
              transforming: false,
              writecb: null,
              writechunk: null,
              writeencoding: null
            };
            this._readableState.needReadable = true;
            this._readableState.sync = false;
            if (options) {
              if (typeof options.transform === "function")
                this._transform = options.transform;
              if (typeof options.flush === "function")
                this._flush = options.flush;
            }
            this.on("prefinish", prefinish);
          }
          function prefinish() {
            var _this = this;
            if (typeof this._flush === "function" && !this._readableState.destroyed) {
              this._flush(function(er, data2) {
                done(_this, er, data2);
              });
            } else {
              done(this, null, null);
            }
          }
          Transform.prototype.push = function(chunk2, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk2, encoding);
          };
          Transform.prototype._transform = function(chunk2, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
          };
          Transform.prototype._write = function(chunk2, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk2;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
              var rs = this._readableState;
              if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                this._read(rs.highWaterMark);
            }
          };
          Transform.prototype._read = function(n) {
            var ts = this._transformState;
            if (ts.writechunk !== null && !ts.transforming) {
              ts.transforming = true;
              this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
              ts.needTransform = true;
            }
          };
          Transform.prototype._destroy = function(err, cb) {
            Duplex.prototype._destroy.call(this, err, function(err2) {
              cb(err2);
            });
          };
          function done(stream, er, data2) {
            if (er)
              return stream.emit("error", er);
            if (data2 != null)
              stream.push(data2);
            if (stream._writableState.length)
              throw new ERR_TRANSFORM_WITH_LENGTH_0();
            if (stream._transformState.transforming)
              throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
            return stream.push(null);
          }
        },
        /* 62 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(global2, process2) {
            module3.exports = Writable;
            function CorkedRequest(state2) {
              var _this = this;
              this.next = null;
              this.entry = null;
              this.finish = function() {
                onCorkedFinish(_this, state2);
              };
            }
            var Duplex;
            Writable.WritableState = WritableState;
            var internalUtil = {
              deprecate: __webpack_require__(166)
            };
            var Stream = __webpack_require__(65);
            var Buffer2 = __webpack_require__(5).Buffer;
            var OurUint8Array = global2.Uint8Array || function() {
            };
            function _uint8ArrayToBuffer(chunk2) {
              return Buffer2.from(chunk2);
            }
            function _isUint8Array(obj) {
              return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
            }
            var destroyImpl = __webpack_require__(63);
            var _require = __webpack_require__(64), getHighWaterMark = _require.getHighWaterMark;
            var _require$codes = __webpack_require__(8).codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
            var errorOrDestroy = destroyImpl.errorOrDestroy;
            __webpack_require__(7)(Writable, Stream);
            function nop() {
            }
            function WritableState(options, stream, isDuplex) {
              Duplex = Duplex || __webpack_require__(9);
              options = options || {};
              if (typeof isDuplex !== "boolean")
                isDuplex = stream instanceof Duplex;
              this.objectMode = !!options.objectMode;
              if (isDuplex)
                this.objectMode = this.objectMode || !!options.writableObjectMode;
              this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
              this.finalCalled = false;
              this.needDrain = false;
              this.ending = false;
              this.ended = false;
              this.finished = false;
              this.destroyed = false;
              var noDecode = options.decodeStrings === false;
              this.decodeStrings = !noDecode;
              this.defaultEncoding = options.defaultEncoding || "utf8";
              this.length = 0;
              this.writing = false;
              this.corked = 0;
              this.sync = true;
              this.bufferProcessing = false;
              this.onwrite = function(er) {
                onwrite(stream, er);
              };
              this.writecb = null;
              this.writelen = 0;
              this.bufferedRequest = null;
              this.lastBufferedRequest = null;
              this.pendingcb = 0;
              this.prefinished = false;
              this.errorEmitted = false;
              this.emitClose = options.emitClose !== false;
              this.autoDestroy = !!options.autoDestroy;
              this.bufferedRequestCount = 0;
              this.corkedRequestsFree = new CorkedRequest(this);
            }
            WritableState.prototype.getBuffer = function getBuffer() {
              var current = this.bufferedRequest;
              var out = [];
              while (current) {
                out.push(current);
                current = current.next;
              }
              return out;
            };
            (function() {
              try {
                Object.defineProperty(WritableState.prototype, "buffer", {
                  get: internalUtil.deprecate(function writableStateBufferGetter() {
                    return this.getBuffer();
                  }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
              } catch (_) {
              }
            })();
            var realHasInstance;
            if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
              realHasInstance = Function.prototype[Symbol.hasInstance];
              Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function value2(object) {
                  if (realHasInstance.call(this, object))
                    return true;
                  if (this !== Writable)
                    return false;
                  return object && object._writableState instanceof WritableState;
                }
              });
            } else {
              realHasInstance = function realHasInstance2(object) {
                return object instanceof this;
              };
            }
            function Writable(options) {
              Duplex = Duplex || __webpack_require__(9);
              var isDuplex = this instanceof Duplex;
              if (!isDuplex && !realHasInstance.call(Writable, this))
                return new Writable(options);
              this._writableState = new WritableState(options, this, isDuplex);
              this.writable = true;
              if (options) {
                if (typeof options.write === "function")
                  this._write = options.write;
                if (typeof options.writev === "function")
                  this._writev = options.writev;
                if (typeof options.destroy === "function")
                  this._destroy = options.destroy;
                if (typeof options.final === "function")
                  this._final = options.final;
              }
              Stream.call(this);
            }
            Writable.prototype.pipe = function() {
              errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
            };
            function writeAfterEnd(stream, cb) {
              var er = new ERR_STREAM_WRITE_AFTER_END();
              errorOrDestroy(stream, er);
              process2.nextTick(cb, er);
            }
            function validChunk(stream, state2, chunk2, cb) {
              var er;
              if (chunk2 === null) {
                er = new ERR_STREAM_NULL_VALUES();
              } else if (typeof chunk2 !== "string" && !state2.objectMode) {
                er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk2);
              }
              if (er) {
                errorOrDestroy(stream, er);
                process2.nextTick(cb, er);
                return false;
              }
              return true;
            }
            Writable.prototype.write = function(chunk2, encoding, cb) {
              var state2 = this._writableState;
              var ret = false;
              var isBuf = !state2.objectMode && _isUint8Array(chunk2);
              if (isBuf && !Buffer2.isBuffer(chunk2)) {
                chunk2 = _uint8ArrayToBuffer(chunk2);
              }
              if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (isBuf)
                encoding = "buffer";
              else if (!encoding)
                encoding = state2.defaultEncoding;
              if (typeof cb !== "function")
                cb = nop;
              if (state2.ending)
                writeAfterEnd(this, cb);
              else if (isBuf || validChunk(this, state2, chunk2, cb)) {
                state2.pendingcb++;
                ret = writeOrBuffer(this, state2, isBuf, chunk2, encoding, cb);
              }
              return ret;
            };
            Writable.prototype.cork = function() {
              this._writableState.corked++;
            };
            Writable.prototype.uncork = function() {
              var state2 = this._writableState;
              if (state2.corked) {
                state2.corked--;
                if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
                  clearBuffer(this, state2);
              }
            };
            Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
              if (typeof encoding === "string")
                encoding = encoding.toLowerCase();
              if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                throw new ERR_UNKNOWN_ENCODING(encoding);
              this._writableState.defaultEncoding = encoding;
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableBuffer", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState && this._writableState.getBuffer();
              }
            });
            function decodeChunk(state2, chunk2, encoding) {
              if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk2 === "string") {
                chunk2 = Buffer2.from(chunk2, encoding);
              }
              return chunk2;
            }
            Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.highWaterMark;
              }
            });
            function writeOrBuffer(stream, state2, isBuf, chunk2, encoding, cb) {
              if (!isBuf) {
                var newChunk = decodeChunk(state2, chunk2, encoding);
                if (chunk2 !== newChunk) {
                  isBuf = true;
                  encoding = "buffer";
                  chunk2 = newChunk;
                }
              }
              var len = state2.objectMode ? 1 : chunk2.length;
              state2.length += len;
              var ret = state2.length < state2.highWaterMark;
              if (!ret)
                state2.needDrain = true;
              if (state2.writing || state2.corked) {
                var last = state2.lastBufferedRequest;
                state2.lastBufferedRequest = {
                  chunk: chunk2,
                  encoding,
                  isBuf,
                  callback: cb,
                  next: null
                };
                if (last) {
                  last.next = state2.lastBufferedRequest;
                } else {
                  state2.bufferedRequest = state2.lastBufferedRequest;
                }
                state2.bufferedRequestCount += 1;
              } else {
                doWrite(stream, state2, false, len, chunk2, encoding, cb);
              }
              return ret;
            }
            function doWrite(stream, state2, writev, len, chunk2, encoding, cb) {
              state2.writelen = len;
              state2.writecb = cb;
              state2.writing = true;
              state2.sync = true;
              if (state2.destroyed)
                state2.onwrite(new ERR_STREAM_DESTROYED("write"));
              else if (writev)
                stream._writev(chunk2, state2.onwrite);
              else
                stream._write(chunk2, encoding, state2.onwrite);
              state2.sync = false;
            }
            function onwriteError(stream, state2, sync, er, cb) {
              --state2.pendingcb;
              if (sync) {
                process2.nextTick(cb, er);
                process2.nextTick(finishMaybe, stream, state2);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
              } else {
                cb(er);
                stream._writableState.errorEmitted = true;
                errorOrDestroy(stream, er);
                finishMaybe(stream, state2);
              }
            }
            function onwriteStateUpdate(state2) {
              state2.writing = false;
              state2.writecb = null;
              state2.length -= state2.writelen;
              state2.writelen = 0;
            }
            function onwrite(stream, er) {
              var state2 = stream._writableState;
              var sync = state2.sync;
              var cb = state2.writecb;
              if (typeof cb !== "function")
                throw new ERR_MULTIPLE_CALLBACK();
              onwriteStateUpdate(state2);
              if (er)
                onwriteError(stream, state2, sync, er, cb);
              else {
                var finished = needFinish(state2) || stream.destroyed;
                if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
                  clearBuffer(stream, state2);
                }
                if (sync) {
                  process2.nextTick(afterWrite, stream, state2, finished, cb);
                } else {
                  afterWrite(stream, state2, finished, cb);
                }
              }
            }
            function afterWrite(stream, state2, finished, cb) {
              if (!finished)
                onwriteDrain(stream, state2);
              state2.pendingcb--;
              cb();
              finishMaybe(stream, state2);
            }
            function onwriteDrain(stream, state2) {
              if (state2.length === 0 && state2.needDrain) {
                state2.needDrain = false;
                stream.emit("drain");
              }
            }
            function clearBuffer(stream, state2) {
              state2.bufferProcessing = true;
              var entry = state2.bufferedRequest;
              if (stream._writev && entry && entry.next) {
                var l = state2.bufferedRequestCount;
                var buffer = new Array(l);
                var holder = state2.corkedRequestsFree;
                holder.entry = entry;
                var count = 0;
                var allBuffers = true;
                while (entry) {
                  buffer[count] = entry;
                  if (!entry.isBuf)
                    allBuffers = false;
                  entry = entry.next;
                  count += 1;
                }
                buffer.allBuffers = allBuffers;
                doWrite(stream, state2, true, state2.length, buffer, "", holder.finish);
                state2.pendingcb++;
                state2.lastBufferedRequest = null;
                if (holder.next) {
                  state2.corkedRequestsFree = holder.next;
                  holder.next = null;
                } else {
                  state2.corkedRequestsFree = new CorkedRequest(state2);
                }
                state2.bufferedRequestCount = 0;
              } else {
                while (entry) {
                  var chunk2 = entry.chunk;
                  var encoding = entry.encoding;
                  var cb = entry.callback;
                  var len = state2.objectMode ? 1 : chunk2.length;
                  doWrite(stream, state2, false, len, chunk2, encoding, cb);
                  entry = entry.next;
                  state2.bufferedRequestCount--;
                  if (state2.writing) {
                    break;
                  }
                }
                if (entry === null)
                  state2.lastBufferedRequest = null;
              }
              state2.bufferedRequest = entry;
              state2.bufferProcessing = false;
            }
            Writable.prototype._write = function(chunk2, encoding, cb) {
              cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
            };
            Writable.prototype._writev = null;
            Writable.prototype.end = function(chunk2, encoding, cb) {
              var state2 = this._writableState;
              if (typeof chunk2 === "function") {
                cb = chunk2;
                chunk2 = null;
                encoding = null;
              } else if (typeof encoding === "function") {
                cb = encoding;
                encoding = null;
              }
              if (chunk2 !== null && chunk2 !== void 0)
                this.write(chunk2, encoding);
              if (state2.corked) {
                state2.corked = 1;
                this.uncork();
              }
              if (!state2.ending)
                endWritable(this, state2, cb);
              return this;
            };
            Object.defineProperty(Writable.prototype, "writableLength", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                return this._writableState.length;
              }
            });
            function needFinish(state2) {
              return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
            }
            function callFinal(stream, state2) {
              stream._final(function(err) {
                state2.pendingcb--;
                if (err) {
                  errorOrDestroy(stream, err);
                }
                state2.prefinished = true;
                stream.emit("prefinish");
                finishMaybe(stream, state2);
              });
            }
            function prefinish(stream, state2) {
              if (!state2.prefinished && !state2.finalCalled) {
                if (typeof stream._final === "function" && !state2.destroyed) {
                  state2.pendingcb++;
                  state2.finalCalled = true;
                  process2.nextTick(callFinal, stream, state2);
                } else {
                  state2.prefinished = true;
                  stream.emit("prefinish");
                }
              }
            }
            function finishMaybe(stream, state2) {
              var need = needFinish(state2);
              if (need) {
                prefinish(stream, state2);
                if (state2.pendingcb === 0) {
                  state2.finished = true;
                  stream.emit("finish");
                  if (state2.autoDestroy) {
                    var rState = stream._readableState;
                    if (!rState || rState.autoDestroy && rState.endEmitted) {
                      stream.destroy();
                    }
                  }
                }
              }
              return need;
            }
            function endWritable(stream, state2, cb) {
              state2.ending = true;
              finishMaybe(stream, state2);
              if (cb) {
                if (state2.finished)
                  process2.nextTick(cb);
                else
                  stream.once("finish", cb);
              }
              state2.ended = true;
              stream.writable = false;
            }
            function onCorkedFinish(corkReq, state2, err) {
              var entry = corkReq.entry;
              corkReq.entry = null;
              while (entry) {
                var cb = entry.callback;
                state2.pendingcb--;
                cb(err);
                entry = entry.next;
              }
              state2.corkedRequestsFree.next = corkReq;
            }
            Object.defineProperty(Writable.prototype, "destroyed", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function get3() {
                if (this._writableState === void 0) {
                  return false;
                }
                return this._writableState.destroyed;
              },
              set: function set2(value2) {
                if (!this._writableState) {
                  return;
                }
                this._writableState.destroyed = value2;
              }
            });
            Writable.prototype.destroy = destroyImpl.destroy;
            Writable.prototype._undestroy = destroyImpl.undestroy;
            Writable.prototype._destroy = function(err, cb) {
              cb(err);
            };
          }).call(exports2, __webpack_require__(10), __webpack_require__(2));
        },
        /* 63 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            function destroy(err, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err) {
                  if (!this._writableState) {
                    process2.nextTick(emitErrorNT, this, err);
                  } else if (!this._writableState.errorEmitted) {
                    this._writableState.errorEmitted = true;
                    process2.nextTick(emitErrorNT, this, err);
                  }
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err || null, function(err2) {
                if (!cb && err2) {
                  if (!_this._writableState) {
                    process2.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else if (!_this._writableState.errorEmitted) {
                    _this._writableState.errorEmitted = true;
                    process2.nextTick(emitErrorAndCloseNT, _this, err2);
                  } else {
                    process2.nextTick(emitCloseNT, _this);
                  }
                } else if (cb) {
                  process2.nextTick(emitCloseNT, _this);
                  cb(err2);
                } else {
                  process2.nextTick(emitCloseNT, _this);
                }
              });
              return this;
            }
            function emitErrorAndCloseNT(self2, err) {
              emitErrorNT(self2, err);
              emitCloseNT(self2);
            }
            function emitCloseNT(self2) {
              if (self2._writableState && !self2._writableState.emitClose)
                return;
              if (self2._readableState && !self2._readableState.emitClose)
                return;
              self2.emit("close");
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finalCalled = false;
                this._writableState.prefinished = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err) {
              self2.emit("error", err);
            }
            function errorOrDestroy(stream, err) {
              var rState = stream._readableState;
              var wState = stream._writableState;
              if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                stream.destroy(err);
              else
                stream.emit("error", err);
            }
            module3.exports = {
              destroy,
              undestroy,
              errorOrDestroy
            };
          }).call(exports2, __webpack_require__(2));
        },
        /* 64 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var ERR_INVALID_OPT_VALUE = __webpack_require__(8).codes.ERR_INVALID_OPT_VALUE;
          function highWaterMarkFrom(options, isDuplex, duplexKey) {
            return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
          }
          function getHighWaterMark(state2, options, duplexKey, isDuplex) {
            var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
            if (hwm != null) {
              if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                var name = isDuplex ? duplexKey : "highWaterMark";
                throw new ERR_INVALID_OPT_VALUE(name, hwm);
              }
              return Math.floor(hwm);
            }
            return state2.objectMode ? 16 : 16 * 1024;
          }
          module3.exports = {
            getHighWaterMark
          };
        },
        /* 65 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = __webpack_require__(57).EventEmitter;
        },
        /* 66 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var buffer = __webpack_require__(5);
          var Buffer2 = buffer.Buffer;
          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key];
            }
          }
          if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
            module3.exports = buffer;
          } else {
            copyProps(buffer, exports2);
            exports2.Buffer = SafeBuffer;
          }
          function SafeBuffer(arg, encodingOrOffset, length2) {
            return Buffer2(arg, encodingOrOffset, length2);
          }
          copyProps(Buffer2, SafeBuffer);
          SafeBuffer.from = function(arg, encodingOrOffset, length2) {
            if (typeof arg === "number") {
              throw new TypeError("Argument must not be a number");
            }
            return Buffer2(arg, encodingOrOffset, length2);
          };
          SafeBuffer.alloc = function(size2, fill, encoding) {
            if (typeof size2 !== "number") {
              throw new TypeError("Argument must be a number");
            }
            var buf = Buffer2(size2);
            if (fill !== void 0) {
              if (typeof encoding === "string") {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
            } else {
              buf.fill(0);
            }
            return buf;
          };
          SafeBuffer.allocUnsafe = function(size2) {
            if (typeof size2 !== "number") {
              throw new TypeError("Argument must be a number");
            }
            return Buffer2(size2);
          };
          SafeBuffer.allocUnsafeSlow = function(size2) {
            if (typeof size2 !== "number") {
              throw new TypeError("Argument must be a number");
            }
            return buffer.SlowBuffer(size2);
          };
        },
        /* 67 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Manager = void 0;
          const eio = __webpack_require__(124);
          const socket_1 = __webpack_require__(69);
          const parser2 = __webpack_require__(37);
          const on_1 = __webpack_require__(68);
          const Backoff2 = __webpack_require__(80);
          const typed_events_1 = __webpack_require__(70);
          const debug = __webpack_require__(24)("socket.io-client:manager");
          class Manager2 extends typed_events_1.StrictEventEmitter {
            constructor(uri, opts) {
              super();
              this.nsps = {};
              this.subs = [];
              if (uri && "object" === typeof uri) {
                opts = uri;
                uri = void 0;
              }
              opts = opts || {};
              opts.path = opts.path || "/socket.io";
              this.opts = opts;
              this.reconnection(opts.reconnection !== false);
              this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
              this.reconnectionDelay(opts.reconnectionDelay || 1e3);
              this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
              this.randomizationFactor(opts.randomizationFactor || 0.5);
              this.backoff = new Backoff2({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
              });
              this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
              this._readyState = "closed";
              this.uri = uri;
              const _parser = opts.parser || parser2;
              this.encoder = new _parser.Encoder();
              this.decoder = new _parser.Decoder();
              this._autoConnect = opts.autoConnect !== false;
              if (this._autoConnect)
                this.open();
            }
            reconnection(v) {
              if (!arguments.length)
                return this._reconnection;
              this._reconnection = !!v;
              return this;
            }
            reconnectionAttempts(v) {
              if (v === void 0)
                return this._reconnectionAttempts;
              this._reconnectionAttempts = v;
              return this;
            }
            reconnectionDelay(v) {
              var _a;
              if (v === void 0)
                return this._reconnectionDelay;
              this._reconnectionDelay = v;
              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
              return this;
            }
            randomizationFactor(v) {
              var _a;
              if (v === void 0)
                return this._randomizationFactor;
              this._randomizationFactor = v;
              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
              return this;
            }
            reconnectionDelayMax(v) {
              var _a;
              if (v === void 0)
                return this._reconnectionDelayMax;
              this._reconnectionDelayMax = v;
              (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
              return this;
            }
            timeout(v) {
              if (!arguments.length)
                return this._timeout;
              this._timeout = v;
              return this;
            }
            /**
             * Starts trying to reconnect if reconnection is enabled and we have not
             * started reconnecting yet
             *
             * @private
             */
            maybeReconnectOnOpen() {
              if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
                this.reconnect();
              }
            }
            /**
             * Sets the current transport `socket`.
             *
             * @param {Function} fn - optional, callback
             * @return self
             * @public
             */
            open(fn) {
              debug("readyState %s", this._readyState);
              if (~this._readyState.indexOf("open"))
                return this;
              debug("opening %s", this.uri);
              this.engine = eio(this.uri, this.opts);
              const socket2 = this.engine;
              const self2 = this;
              this._readyState = "opening";
              this.skipReconnect = false;
              const openSubDestroy = on_1.on(socket2, "open", function() {
                self2.onopen();
                fn && fn();
              });
              const errorSub = on_1.on(socket2, "error", (err) => {
                debug("error");
                self2.cleanup();
                self2._readyState = "closed";
                this.emitReserved("error", err);
                if (fn) {
                  fn(err);
                } else {
                  self2.maybeReconnectOnOpen();
                }
              });
              if (false !== this._timeout) {
                const timeout = this._timeout;
                debug("connect attempt will timeout after %d", timeout);
                if (timeout === 0) {
                  openSubDestroy();
                }
                const timer = setTimeout(() => {
                  debug("connect attempt timed out after %d", timeout);
                  openSubDestroy();
                  socket2.close();
                  socket2.emit("error", new Error("timeout"));
                }, timeout);
                if (this.opts.autoUnref) {
                  timer.unref();
                }
                this.subs.push(function subDestroy() {
                  clearTimeout(timer);
                });
              }
              this.subs.push(openSubDestroy);
              this.subs.push(errorSub);
              return this;
            }
            /**
             * Alias for open()
             *
             * @return self
             * @public
             */
            connect(fn) {
              return this.open(fn);
            }
            /**
             * Called upon transport open.
             *
             * @private
             */
            onopen() {
              debug("open");
              this.cleanup();
              this._readyState = "open";
              this.emitReserved("open");
              const socket2 = this.engine;
              this.subs.push(on_1.on(socket2, "ping", this.onping.bind(this)), on_1.on(socket2, "data", this.ondata.bind(this)), on_1.on(socket2, "error", this.onerror.bind(this)), on_1.on(socket2, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
            }
            /**
             * Called upon a ping.
             *
             * @private
             */
            onping() {
              this.emitReserved("ping");
            }
            /**
             * Called with data.
             *
             * @private
             */
            ondata(data2) {
              this.decoder.add(data2);
            }
            /**
             * Called when parser fully decodes a packet.
             *
             * @private
             */
            ondecoded(packet) {
              this.emitReserved("packet", packet);
            }
            /**
             * Called upon socket error.
             *
             * @private
             */
            onerror(err) {
              debug("error", err);
              this.emitReserved("error", err);
            }
            /**
             * Creates a new socket for the given `nsp`.
             *
             * @return {Socket}
             * @public
             */
            socket(nsp, opts) {
              let socket2 = this.nsps[nsp];
              if (!socket2) {
                socket2 = new socket_1.Socket(this, nsp, opts);
                this.nsps[nsp] = socket2;
              }
              return socket2;
            }
            /**
             * Called upon a socket close.
             *
             * @param socket
             * @private
             */
            _destroy(socket2) {
              const nsps = Object.keys(this.nsps);
              for (const nsp of nsps) {
                const socket3 = this.nsps[nsp];
                if (socket3.active) {
                  debug("socket %s is still active, skipping close", nsp);
                  return;
                }
              }
              this._close();
            }
            /**
             * Writes a packet.
             *
             * @param packet
             * @private
             */
            _packet(packet) {
              debug("writing packet %j", packet);
              const encodedPackets = this.encoder.encode(packet);
              for (let i2 = 0; i2 < encodedPackets.length; i2++) {
                this.engine.write(encodedPackets[i2], packet.options);
              }
            }
            /**
             * Clean up transport subscriptions and packet buffer.
             *
             * @private
             */
            cleanup() {
              debug("cleanup");
              this.subs.forEach((subDestroy) => subDestroy());
              this.subs.length = 0;
              this.decoder.destroy();
            }
            /**
             * Close the current socket.
             *
             * @private
             */
            _close() {
              debug("disconnect");
              this.skipReconnect = true;
              this._reconnecting = false;
              if ("opening" === this._readyState) {
                this.cleanup();
              }
              this.backoff.reset();
              this._readyState = "closed";
              if (this.engine)
                this.engine.close();
            }
            /**
             * Alias for close()
             *
             * @private
             */
            disconnect() {
              return this._close();
            }
            /**
             * Called upon engine close.
             *
             * @private
             */
            onclose(reason) {
              debug("onclose");
              this.cleanup();
              this.backoff.reset();
              this._readyState = "closed";
              this.emitReserved("close", reason);
              if (this._reconnection && !this.skipReconnect) {
                this.reconnect();
              }
            }
            /**
             * Attempt a reconnection.
             *
             * @private
             */
            reconnect() {
              if (this._reconnecting || this.skipReconnect)
                return this;
              const self2 = this;
              if (this.backoff.attempts >= this._reconnectionAttempts) {
                debug("reconnect failed");
                this.backoff.reset();
                this.emitReserved("reconnect_failed");
                this._reconnecting = false;
              } else {
                const delay = this.backoff.duration();
                debug("will wait %dms before reconnect attempt", delay);
                this._reconnecting = true;
                const timer = setTimeout(() => {
                  if (self2.skipReconnect)
                    return;
                  debug("attempting reconnect");
                  this.emitReserved("reconnect_attempt", self2.backoff.attempts);
                  if (self2.skipReconnect)
                    return;
                  self2.open((err) => {
                    if (err) {
                      debug("reconnect attempt error");
                      self2._reconnecting = false;
                      self2.reconnect();
                      this.emitReserved("reconnect_error", err);
                    } else {
                      debug("reconnect success");
                      self2.onreconnect();
                    }
                  });
                }, delay);
                if (this.opts.autoUnref) {
                  timer.unref();
                }
                this.subs.push(function subDestroy() {
                  clearTimeout(timer);
                });
              }
            }
            /**
             * Called upon successful reconnect.
             *
             * @private
             */
            onreconnect() {
              const attempt = this.backoff.attempts;
              this._reconnecting = false;
              this.backoff.reset();
              this.emitReserved("reconnect", attempt);
            }
          }
          exports2.Manager = Manager2;
        },
        /* 68 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.on = void 0;
          function on2(obj, ev, fn) {
            obj.on(ev, fn);
            return function subDestroy() {
              obj.off(ev, fn);
            };
          }
          exports2.on = on2;
        },
        /* 69 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Socket = void 0;
          const socket_io_parser_1 = __webpack_require__(37);
          const on_1 = __webpack_require__(68);
          const typed_events_1 = __webpack_require__(70);
          const debug = __webpack_require__(24)("socket.io-client:socket");
          const RESERVED_EVENTS2 = Object.freeze({
            connect: 1,
            connect_error: 1,
            disconnect: 1,
            disconnecting: 1,
            // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
            newListener: 1,
            removeListener: 1
          });
          class Socket3 extends typed_events_1.StrictEventEmitter {
            /**
             * `Socket` constructor.
             *
             * @public
             */
            constructor(io, nsp, opts) {
              super();
              this.receiveBuffer = [];
              this.sendBuffer = [];
              this.ids = 0;
              this.acks = {};
              this.flags = {};
              this.io = io;
              this.nsp = nsp;
              this.ids = 0;
              this.acks = {};
              this.receiveBuffer = [];
              this.sendBuffer = [];
              this.connected = false;
              this.disconnected = true;
              this.flags = {};
              if (opts && opts.auth) {
                this.auth = opts.auth;
              }
              if (this.io._autoConnect)
                this.open();
            }
            /**
             * Subscribe to open, close and packet events
             *
             * @private
             */
            subEvents() {
              if (this.subs)
                return;
              const io = this.io;
              this.subs = [
                on_1.on(io, "open", this.onopen.bind(this)),
                on_1.on(io, "packet", this.onpacket.bind(this)),
                on_1.on(io, "error", this.onerror.bind(this)),
                on_1.on(io, "close", this.onclose.bind(this))
              ];
            }
            /**
             * Whether the Socket will try to reconnect when its Manager connects or reconnects
             */
            get active() {
              return !!this.subs;
            }
            /**
             * "Opens" the socket.
             *
             * @public
             */
            connect() {
              if (this.connected)
                return this;
              this.subEvents();
              if (!this.io["_reconnecting"])
                this.io.open();
              if ("open" === this.io._readyState)
                this.onopen();
              return this;
            }
            /**
             * Alias for connect()
             */
            open() {
              return this.connect();
            }
            /**
             * Sends a `message` event.
             *
             * @return self
             * @public
             */
            send(...args) {
              args.unshift("message");
              this.emit.apply(this, args);
              return this;
            }
            /**
             * Override `emit`.
             * If the event is in `events`, it's emitted normally.
             *
             * @return self
             * @public
             */
            emit(ev, ...args) {
              if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
                throw new Error('"' + ev + '" is a reserved event name');
              }
              args.unshift(ev);
              const packet = {
                type: socket_io_parser_1.PacketType.EVENT,
                data: args
              };
              packet.options = {};
              packet.options.compress = this.flags.compress !== false;
              if ("function" === typeof args[args.length - 1]) {
                debug("emitting packet with ack id %d", this.ids);
                this.acks[this.ids] = args.pop();
                packet.id = this.ids++;
              }
              const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
              const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
              if (discardPacket) {
                debug("discard packet as the transport is not currently writable");
              } else if (this.connected) {
                this.packet(packet);
              } else {
                this.sendBuffer.push(packet);
              }
              this.flags = {};
              return this;
            }
            /**
             * Sends a packet.
             *
             * @param packet
             * @private
             */
            packet(packet) {
              packet.nsp = this.nsp;
              this.io._packet(packet);
            }
            /**
             * Called upon engine `open`.
             *
             * @private
             */
            onopen() {
              debug("transport is open - connecting");
              if (typeof this.auth == "function") {
                this.auth((data2) => {
                  this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: data2 });
                });
              } else {
                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
              }
            }
            /**
             * Called upon engine or manager `error`.
             *
             * @param err
             * @private
             */
            onerror(err) {
              if (!this.connected) {
                this.emitReserved("connect_error", err);
              }
            }
            /**
             * Called upon engine `close`.
             *
             * @param reason
             * @private
             */
            onclose(reason) {
              debug("close (%s)", reason);
              this.connected = false;
              this.disconnected = true;
              delete this.id;
              this.emitReserved("disconnect", reason);
            }
            /**
             * Called with socket packet.
             *
             * @param packet
             * @private
             */
            onpacket(packet) {
              const sameNamespace = packet.nsp === this.nsp;
              if (!sameNamespace)
                return;
              switch (packet.type) {
                case socket_io_parser_1.PacketType.CONNECT:
                  if (packet.data && packet.data.sid) {
                    const id = packet.data.sid;
                    this.onconnect(id);
                  } else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                  }
                  break;
                case socket_io_parser_1.PacketType.EVENT:
                  this.onevent(packet);
                  break;
                case socket_io_parser_1.PacketType.BINARY_EVENT:
                  this.onevent(packet);
                  break;
                case socket_io_parser_1.PacketType.ACK:
                  this.onack(packet);
                  break;
                case socket_io_parser_1.PacketType.BINARY_ACK:
                  this.onack(packet);
                  break;
                case socket_io_parser_1.PacketType.DISCONNECT:
                  this.ondisconnect();
                  break;
                case socket_io_parser_1.PacketType.CONNECT_ERROR:
                  const err = new Error(packet.data.message);
                  err.data = packet.data.data;
                  this.emitReserved("connect_error", err);
                  break;
              }
            }
            /**
             * Called upon a server event.
             *
             * @param packet
             * @private
             */
            onevent(packet) {
              const args = packet.data || [];
              debug("emitting event %j", args);
              if (null != packet.id) {
                debug("attaching ack callback to event");
                args.push(this.ack(packet.id));
              }
              if (this.connected) {
                this.emitEvent(args);
              } else {
                this.receiveBuffer.push(Object.freeze(args));
              }
            }
            emitEvent(args) {
              if (this._anyListeners && this._anyListeners.length) {
                const listeners = this._anyListeners.slice();
                for (const listener of listeners) {
                  listener.apply(this, args);
                }
              }
              super.emit.apply(this, args);
            }
            /**
             * Produces an ack callback to emit with an event.
             *
             * @private
             */
            ack(id) {
              const self2 = this;
              let sent = false;
              return function(...args) {
                if (sent)
                  return;
                sent = true;
                debug("sending ack %j", args);
                self2.packet({
                  type: socket_io_parser_1.PacketType.ACK,
                  id,
                  data: args
                });
              };
            }
            /**
             * Called upon a server acknowlegement.
             *
             * @param packet
             * @private
             */
            onack(packet) {
              const ack = this.acks[packet.id];
              if ("function" === typeof ack) {
                debug("calling ack %s with %j", packet.id, packet.data);
                ack.apply(this, packet.data);
                delete this.acks[packet.id];
              } else {
                debug("bad ack %s", packet.id);
              }
            }
            /**
             * Called upon server connect.
             *
             * @private
             */
            onconnect(id) {
              debug("socket connected with id %s", id);
              this.id = id;
              this.connected = true;
              this.disconnected = false;
              this.emitBuffered();
              this.emitReserved("connect");
            }
            /**
             * Emit buffered events (received and emitted).
             *
             * @private
             */
            emitBuffered() {
              this.receiveBuffer.forEach((args) => this.emitEvent(args));
              this.receiveBuffer = [];
              this.sendBuffer.forEach((packet) => this.packet(packet));
              this.sendBuffer = [];
            }
            /**
             * Called upon server disconnect.
             *
             * @private
             */
            ondisconnect() {
              debug("server disconnect (%s)", this.nsp);
              this.destroy();
              this.onclose("io server disconnect");
            }
            /**
             * Called upon forced client/server side disconnections,
             * this method ensures the manager stops tracking us and
             * that reconnections don't get triggered for this.
             *
             * @private
             */
            destroy() {
              if (this.subs) {
                this.subs.forEach((subDestroy) => subDestroy());
                this.subs = void 0;
              }
              this.io["_destroy"](this);
            }
            /**
             * Disconnects the socket manually.
             *
             * @return self
             * @public
             */
            disconnect() {
              if (this.connected) {
                debug("performing disconnect (%s)", this.nsp);
                this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
              }
              this.destroy();
              if (this.connected) {
                this.onclose("io client disconnect");
              }
              return this;
            }
            /**
             * Alias for disconnect()
             *
             * @return self
             * @public
             */
            close() {
              return this.disconnect();
            }
            /**
             * Sets the compress flag.
             *
             * @param compress - if `true`, compresses the sending data
             * @return self
             * @public
             */
            compress(compress) {
              this.flags.compress = compress;
              return this;
            }
            /**
             * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
             * ready to send messages.
             *
             * @returns self
             * @public
             */
            get volatile() {
              this.flags.volatile = true;
              return this;
            }
            /**
             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
             * callback.
             *
             * @param listener
             * @public
             */
            onAny(listener) {
              this._anyListeners = this._anyListeners || [];
              this._anyListeners.push(listener);
              return this;
            }
            /**
             * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
             * callback. The listener is added to the beginning of the listeners array.
             *
             * @param listener
             * @public
             */
            prependAny(listener) {
              this._anyListeners = this._anyListeners || [];
              this._anyListeners.unshift(listener);
              return this;
            }
            /**
             * Removes the listener that will be fired when any event is emitted.
             *
             * @param listener
             * @public
             */
            offAny(listener) {
              if (!this._anyListeners) {
                return this;
              }
              if (listener) {
                const listeners = this._anyListeners;
                for (let i2 = 0; i2 < listeners.length; i2++) {
                  if (listener === listeners[i2]) {
                    listeners.splice(i2, 1);
                    return this;
                  }
                }
              } else {
                this._anyListeners = [];
              }
              return this;
            }
            /**
             * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
             * e.g. to remove listeners.
             *
             * @public
             */
            listenersAny() {
              return this._anyListeners || [];
            }
          }
          exports2.Socket = Socket3;
        },
        /* 70 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.StrictEventEmitter = void 0;
          const Emitter2 = __webpack_require__(11);
          class StrictEventEmitter extends Emitter2 {
            /**
             * Adds the `listener` function as an event listener for `ev`.
             *
             * @param ev Name of the event
             * @param listener Callback function
             */
            on(ev, listener) {
              super.on(ev, listener);
              return this;
            }
            /**
             * Adds a one-time `listener` function as an event listener for `ev`.
             *
             * @param ev Name of the event
             * @param listener Callback function
             */
            once(ev, listener) {
              super.once(ev, listener);
              return this;
            }
            /**
             * Emits an event.
             *
             * @param ev Name of the event
             * @param args Values to send to listeners of this event
             */
            emit(ev, ...args) {
              super.emit(ev, ...args);
              return this;
            }
            /**
             * Emits a reserved event.
             *
             * This method is `protected`, so that only a class extending
             * `StrictEventEmitter` can emit its own reserved events.
             *
             * @param ev Reserved event name
             * @param args Arguments to emit along with the event
             */
            emitReserved(ev, ...args) {
              super.emit(ev, ...args);
              return this;
            }
            /**
             * Returns the listeners listening to an event.
             *
             * @param event Event name
             * @returns Array of listeners subscribed to `event`
             */
            listeners(event) {
              return super.listeners(event);
            }
          }
          exports2.StrictEventEmitter = StrictEventEmitter;
        },
        /* 71 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.hasBinary = exports2.isBinary = void 0;
          const withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
          const isView2 = (obj) => {
            return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
          };
          const toString2 = Object.prototype.toString;
          const withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString2.call(Blob) === "[object BlobConstructor]";
          const withNativeFile2 = typeof File === "function" || typeof File !== "undefined" && toString2.call(File) === "[object FileConstructor]";
          function isBinary2(obj) {
            return withNativeArrayBuffer2 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile2 && obj instanceof File;
          }
          exports2.isBinary = isBinary2;
          function hasBinary2(obj, toJSON3) {
            if (!obj || typeof obj !== "object") {
              return false;
            }
            if (Array.isArray(obj)) {
              for (let i2 = 0, l = obj.length; i2 < l; i2++) {
                if (hasBinary2(obj[i2])) {
                  return true;
                }
              }
              return false;
            }
            if (isBinary2(obj)) {
              return true;
            }
            if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
              return hasBinary2(obj.toJSON(), true);
            }
            for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary2(obj[key])) {
                return true;
              }
            }
            return false;
          }
          exports2.hasBinary = hasBinary2;
        },
        /* 72 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var alphabet2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length2 = 64, map2 = {}, seed2 = 0, i2 = 0, prev2;
          function encode2(num) {
            var encoded = "";
            do {
              encoded = alphabet2[num % length2] + encoded;
              num = Math.floor(num / length2);
            } while (num > 0);
            return encoded;
          }
          function decode2(str) {
            var decoded = 0;
            for (i2 = 0; i2 < str.length; i2++) {
              decoded = decoded * length2 + map2[str.charAt(i2)];
            }
            return decoded;
          }
          function yeast2() {
            var now2 = encode2(+/* @__PURE__ */ new Date());
            if (now2 !== prev2)
              return seed2 = 0, prev2 = now2;
            return now2 + "." + encode2(seed2++);
          }
          for (; i2 < length2; i2++)
            map2[alphabet2[i2]] = i2;
          yeast2.encode = encode2;
          yeast2.decode = decode2;
          module3.exports = yeast2;
        },
        /* 73 */
        /***/
        function(module3, exports2, __webpack_require__) {
          __webpack_require__(169);
          var Component = __webpack_require__(167)(
            /* script */
            __webpack_require__(74),
            /* template */
            __webpack_require__(168),
            /* scopeId */
            "data-v-49ef9b35",
            /* cssModules */
            null
          );
          module3.exports = Component.exports;
        },
        /* 74 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _stringify = __webpack_require__(76);
          var _stringify2 = _interopRequireDefault(_stringify);
          var _regenerator = __webpack_require__(79);
          var _regenerator2 = _interopRequireDefault(_regenerator);
          var _asyncToGenerator2 = __webpack_require__(78);
          var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var io = __webpack_require__(158);
          var SimpleSignalClient = __webpack_require__(157);
          exports2.default = {
            name: "vue-webrtc",
            components: {},
            data: function data2() {
              return {
                signalClient: null,
                videoList: [],
                canvas: null,
                socket: null
              };
            },
            props: {
              roomId: {
                type: String,
                default: "public-room-v2"
              },
              socketURL: {
                type: String,
                default: "https://weston-vue-webrtc-lobby.azurewebsites.net"
              },
              cameraHeight: {
                type: [Number, String],
                default: 160
              },
              autoplay: {
                type: Boolean,
                default: true
              },
              screenshotFormat: {
                type: String,
                default: "image/jpeg"
              },
              enableAudio: {
                type: Boolean,
                default: true
              },
              enableVideo: {
                type: Boolean,
                default: true
              },
              enableLogs: {
                type: Boolean,
                default: false
              },
              peerOptions: {
                type: Object,
                default: function _default() {
                  return {};
                }
              },
              deviceId: {
                type: String,
                default: null
              }
            },
            watch: {},
            mounted: function mounted2() {
            },
            methods: {
              join: function join() {
                var _this = this;
                return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
                  var that, constraints, localStream;
                  return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          that = _this;
                          _this.log("join");
                          _this.socket = io(_this.socketURL, { rejectUnauthorized: false, transports: ["websocket"] });
                          _this.signalClient = new SimpleSignalClient(_this.socket);
                          constraints = {
                            video: that.enableVideo,
                            audio: that.enableAudio
                          };
                          if (that.deviceId && that.enableVideo) {
                            constraints.video = { deviceId: { exact: that.deviceId } };
                          }
                          _context3.next = 8;
                          return navigator.mediaDevices.getUserMedia(constraints);
                        case 8:
                          localStream = _context3.sent;
                          _this.log("opened", localStream);
                          _this.joinedRoom(localStream, true);
                          _this.signalClient.once("discover", function(discoveryData) {
                            var connectToPeer = function() {
                              var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(peerID) {
                                var _ref2, peer;
                                return _regenerator2.default.wrap(function _callee$(_context) {
                                  while (1) {
                                    switch (_context.prev = _context.next) {
                                      case 0:
                                        if (!(peerID == that.socket.id)) {
                                          _context.next = 2;
                                          break;
                                        }
                                        return _context.abrupt("return");
                                      case 2:
                                        _context.prev = 2;
                                        that.log("Connecting to peer");
                                        _context.next = 6;
                                        return that.signalClient.connect(peerID, that.roomId, that.peerOptions);
                                      case 6:
                                        _ref2 = _context.sent;
                                        peer = _ref2.peer;
                                        that.videoList.forEach(function(v) {
                                          if (v.isLocal) {
                                            that.onPeer(peer, v.stream);
                                          }
                                        });
                                        _context.next = 14;
                                        break;
                                      case 11:
                                        _context.prev = 11;
                                        _context.t0 = _context["catch"](2);
                                        that.log("Error connecting to peer");
                                      case 14:
                                      case "end":
                                        return _context.stop();
                                    }
                                  }
                                }, _callee, this, [[2, 11]]);
                              }));
                              return function connectToPeer2(_x) {
                                return _ref.apply(this, arguments);
                              };
                            }();
                            that.log("discovered", discoveryData);
                            discoveryData.peers.forEach(function(peerID) {
                              return connectToPeer(peerID);
                            });
                            that.$emit("opened-room", that.roomId);
                          });
                          _this.signalClient.on("request", function() {
                            var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(request2) {
                              var _ref4, peer;
                              return _regenerator2.default.wrap(function _callee2$(_context2) {
                                while (1) {
                                  switch (_context2.prev = _context2.next) {
                                    case 0:
                                      that.log("requested", request2);
                                      _context2.next = 3;
                                      return request2.accept({}, that.peerOptions);
                                    case 3:
                                      _ref4 = _context2.sent;
                                      peer = _ref4.peer;
                                      that.log("accepted", peer);
                                      that.videoList.forEach(function(v) {
                                        if (v.isLocal) {
                                          that.onPeer(peer, v.stream);
                                        }
                                      });
                                    case 7:
                                    case "end":
                                      return _context2.stop();
                                  }
                                }
                              }, _callee2, _this);
                            }));
                            return function(_x2) {
                              return _ref3.apply(this, arguments);
                            };
                          }());
                          _this.signalClient.discover(that.roomId);
                        case 14:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, _this);
                }))();
              },
              onPeer: function onPeer(peer, localStream) {
                var that = this;
                that.log("onPeer");
                peer.addStream(localStream);
                peer.on("stream", function(remoteStream) {
                  that.joinedRoom(remoteStream, false);
                  peer.on("close", function() {
                    var newList = [];
                    that.videoList.forEach(function(item) {
                      if (item.id !== remoteStream.id) {
                        newList.push(item);
                      }
                    });
                    that.videoList = newList;
                    that.$emit("left-room", remoteStream.id);
                  });
                  peer.on("error", function(err) {
                    that.log("peer error ", err);
                  });
                });
              },
              joinedRoom: function joinedRoom(stream, isLocal2) {
                var that = this;
                var found = that.videoList.find(function(video2) {
                  return video2.id === stream.id;
                });
                if (found === void 0) {
                  var video = {
                    id: stream.id,
                    muted: isLocal2,
                    stream,
                    isLocal: isLocal2
                  };
                  that.videoList.push(video);
                }
                setTimeout(function() {
                  for (var i2 = 0, len = that.$refs.videos.length; i2 < len; i2++) {
                    if (that.$refs.videos[i2].id === stream.id) {
                      that.$refs.videos[i2].srcObject = stream;
                      break;
                    }
                  }
                }, 500);
                that.$emit("joined-room", stream.id);
              },
              leave: function leave() {
                this.videoList.forEach(function(v) {
                  return v.stream.getTracks().forEach(function(t) {
                    return t.stop();
                  });
                });
                this.videoList = [];
                this.signalClient.peers().forEach(function(peer) {
                  return peer.removeAllListeners();
                });
                this.signalClient.destroy();
                this.signalClient = null;
                this.socket.destroy();
                this.socket = null;
              },
              capture: function capture() {
                return this.getCanvas().toDataURL(this.screenshotFormat);
              },
              getCanvas: function getCanvas() {
                var video = this.$refs.videos[0];
                if (video !== null && !this.ctx) {
                  var _canvas = document.createElement("canvas");
                  _canvas.height = video.clientHeight;
                  _canvas.width = video.clientWidth;
                  this.canvas = _canvas;
                  this.ctx = _canvas.getContext("2d");
                }
                var ctx = this.ctx, canvas = this.canvas;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                return canvas;
              },
              shareScreen: function shareScreen() {
                var _this2 = this;
                return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
                  var that, screenStream;
                  return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          that = _this2;
                          if (!(navigator.mediaDevices == void 0)) {
                            _context4.next = 4;
                            break;
                          }
                          that.log("Error: https is required to load cameras");
                          return _context4.abrupt("return");
                        case 4:
                          _context4.prev = 4;
                          _context4.next = 7;
                          return navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                        case 7:
                          screenStream = _context4.sent;
                          _this2.joinedRoom(screenStream, true);
                          that.$emit("share-started", screenStream.id);
                          that.signalClient.peers().forEach(function(p2) {
                            return that.onPeer(p2, screenStream);
                          });
                          _context4.next = 16;
                          break;
                        case 13:
                          _context4.prev = 13;
                          _context4.t0 = _context4["catch"](4);
                          that.log("Media error: " + (0, _stringify2.default)(_context4.t0));
                        case 16:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4, _this2, [[4, 13]]);
                }))();
              },
              log: function log(message, data2) {
                if (this.enableLogs) {
                  console.log(message);
                  if (data2 != null) {
                    console.log(data2);
                  }
                }
              }
            }
          };
        },
        /* 75 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var _webrtc = __webpack_require__(73);
          var _webrtc2 = _interopRequireDefault(_webrtc);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var install2 = function install3(Vue) {
            if (install3.installed)
              return;
            Vue.component(_webrtc2.default.name, _webrtc2.default);
          };
          module3.exports = {
            WebRTC: _webrtc2.default,
            install: install2
          };
          module3.exports.default = module3.exports;
        },
        /* 76 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = { "default": __webpack_require__(83), __esModule: true };
        },
        /* 77 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = { "default": __webpack_require__(84), __esModule: true };
        },
        /* 78 */
        /***/
        function(module3, exports2, __webpack_require__) {
          exports2.__esModule = true;
          var _promise = __webpack_require__(77);
          var _promise2 = _interopRequireDefault(_promise);
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports2.default = function(fn) {
            return function() {
              var gen = fn.apply(this, arguments);
              return new _promise2.default(function(resolve2, reject) {
                function step(key, arg) {
                  try {
                    var info = gen[key](arg);
                    var value2 = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve2(value2);
                  } else {
                    return _promise2.default.resolve(value2).then(function(value3) {
                      step("next", value3);
                    }, function(err) {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            };
          };
        },
        /* 79 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = __webpack_require__(150);
        },
        /* 80 */
        /***/
        function(module3, exports2) {
          module3.exports = Backoff2;
          function Backoff2(opts) {
            opts = opts || {};
            this.ms = opts.min || 100;
            this.max = opts.max || 1e4;
            this.factor = opts.factor || 2;
            this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
            this.attempts = 0;
          }
          Backoff2.prototype.duration = function() {
            var ms = this.ms * Math.pow(this.factor, this.attempts++);
            if (this.jitter) {
              var rand = Math.random();
              var deviation = Math.floor(rand * this.jitter * ms);
              ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
            }
            return Math.min(ms, this.max) | 0;
          };
          Backoff2.prototype.reset = function() {
            this.attempts = 0;
          };
          Backoff2.prototype.setMin = function(min2) {
            this.ms = min2;
          };
          Backoff2.prototype.setMax = function(max2) {
            this.max = max2;
          };
          Backoff2.prototype.setJitter = function(jitter) {
            this.jitter = jitter;
          };
        },
        /* 81 */
        /***/
        function(module3, exports2) {
          (function(chars2) {
            exports2.encode = function(arraybuffer) {
              var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
              for (i2 = 0; i2 < len; i2 += 3) {
                base64 += chars2[bytes[i2] >> 2];
                base64 += chars2[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
                base64 += chars2[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
                base64 += chars2[bytes[i2 + 2] & 63];
              }
              if (len % 3 === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
              } else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
              }
              return base64;
            };
            exports2.decode = function(base64) {
              var bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
              if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                  bufferLength--;
                }
              }
              var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
              for (i2 = 0; i2 < len; i2 += 4) {
                encoded1 = chars2.indexOf(base64[i2]);
                encoded2 = chars2.indexOf(base64[i2 + 1]);
                encoded3 = chars2.indexOf(base64[i2 + 2]);
                encoded4 = chars2.indexOf(base64[i2 + 3]);
                bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
                bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
              }
              return arraybuffer;
            };
          })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        },
        /* 82 */
        /***/
        function(module3, exports2, __webpack_require__) {
          exports2.byteLength = byteLength2;
          exports2.toByteArray = toByteArray;
          exports2.fromByteArray = fromByteArray;
          var lookup2 = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i2 = 0, len = code.length; i2 < len; ++i2) {
            lookup2[i2] = code[i2];
            revLookup[code.charCodeAt(i2)] = i2;
          }
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
          function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
              throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1)
              validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [validLen, placeHoldersLen];
          }
          function byteLength2(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i3;
            for (i3 = 0; i3 < len2; i3 += 4) {
              tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
              arr[curByte++] = tmp >> 16 & 255;
              arr[curByte++] = tmp >> 8 & 255;
              arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
              tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
              arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
              tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
              arr[curByte++] = tmp >> 8 & 255;
              arr[curByte++] = tmp & 255;
            }
            return arr;
          }
          function tripletToBase64(num) {
            return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
          }
          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i3 = start; i3 < end; i3 += 3) {
              tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
              output.push(tripletToBase64(tmp));
            }
            return output.join("");
          }
          function fromByteArray(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts2 = [];
            var maxChunkLength = 16383;
            for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
              parts2.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
            }
            if (extraBytes === 1) {
              tmp = uint8[len2 - 1];
              parts2.push(
                lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
              );
            } else if (extraBytes === 2) {
              tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
              parts2.push(
                lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
              );
            }
            return parts2.join("");
          }
        },
        /* 83 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var core = __webpack_require__(3);
          var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
          module3.exports = function stringify(it) {
            return $JSON.stringify.apply($JSON, arguments);
          };
        },
        /* 84 */
        /***/
        function(module3, exports2, __webpack_require__) {
          __webpack_require__(113);
          __webpack_require__(115);
          __webpack_require__(118);
          __webpack_require__(114);
          __webpack_require__(116);
          __webpack_require__(117);
          module3.exports = __webpack_require__(3).Promise;
        },
        /* 85 */
        /***/
        function(module3, exports2) {
          module3.exports = function() {
          };
        },
        /* 86 */
        /***/
        function(module3, exports2) {
          module3.exports = function(it, Constructor, name, forbiddenField) {
            if (!(it instanceof Constructor) || forbiddenField !== void 0 && forbiddenField in it) {
              throw TypeError(name + ": incorrect invocation!");
            }
            return it;
          };
        },
        /* 87 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var toIObject = __webpack_require__(32);
          var toLength = __webpack_require__(49);
          var toAbsoluteIndex = __webpack_require__(107);
          module3.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIObject($this);
              var length2 = toLength(O.length);
              var index = toAbsoluteIndex(fromIndex, length2);
              var value2;
              if (IS_INCLUDES && el != el)
                while (length2 > index) {
                  value2 = O[index++];
                  if (value2 != value2)
                    return true;
                }
              else
                for (; length2 > index; index++)
                  if (IS_INCLUDES || index in O) {
                    if (O[index] === el)
                      return IS_INCLUDES || index || 0;
                  }
              return !IS_INCLUDES && -1;
            };
          };
        },
        /* 88 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var ctx = __webpack_require__(19);
          var call = __webpack_require__(93);
          var isArrayIter = __webpack_require__(92);
          var anObject = __webpack_require__(4);
          var toLength = __webpack_require__(49);
          var getIterFn = __webpack_require__(111);
          var BREAK = {};
          var RETURN = {};
          var exports2 = module3.exports = function(iterable, entries, fn, that, ITERATOR) {
            var iterFn = ITERATOR ? function() {
              return iterable;
            } : getIterFn(iterable);
            var f = ctx(fn, that, entries ? 2 : 1);
            var index = 0;
            var length2, step, iterator, result;
            if (typeof iterFn != "function")
              throw TypeError(iterable + " is not iterable!");
            if (isArrayIter(iterFn))
              for (length2 = toLength(iterable.length); length2 > index; index++) {
                result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
                if (result === BREAK || result === RETURN)
                  return result;
              }
            else
              for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
                result = call(iterator, f, step.value, entries);
                if (result === BREAK || result === RETURN)
                  return result;
              }
          };
          exports2.BREAK = BREAK;
          exports2.RETURN = RETURN;
        },
        /* 89 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = !__webpack_require__(12) && !__webpack_require__(40)(function() {
            return Object.defineProperty(__webpack_require__(26)("div"), "a", { get: function() {
              return 7;
            } }).a != 7;
          });
        },
        /* 90 */
        /***/
        function(module3, exports2) {
          module3.exports = function(fn, args, that) {
            var un = that === void 0;
            switch (args.length) {
              case 0:
                return un ? fn() : fn.call(that);
              case 1:
                return un ? fn(args[0]) : fn.call(that, args[0]);
              case 2:
                return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
              case 3:
                return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
              case 4:
                return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
            }
            return fn.apply(that, args);
          };
        },
        /* 91 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var cof = __webpack_require__(18);
          module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return cof(it) == "String" ? it.split("") : Object(it);
          };
        },
        /* 92 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var Iterators = __webpack_require__(14);
          var ITERATOR = __webpack_require__(1)("iterator");
          var ArrayProto = Array.prototype;
          module3.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
          };
        },
        /* 93 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__(4);
          module3.exports = function(iterator, fn, value2, entries) {
            try {
              return entries ? fn(anObject(value2)[0], value2[1]) : fn(value2);
            } catch (e) {
              var ret = iterator["return"];
              if (ret !== void 0)
                anObject(ret.call(iterator));
              throw e;
            }
          };
        },
        /* 94 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var create = __webpack_require__(98);
          var descriptor = __webpack_require__(45);
          var setToStringTag = __webpack_require__(29);
          var IteratorPrototype = {};
          __webpack_require__(6)(IteratorPrototype, __webpack_require__(1)("iterator"), function() {
            return this;
          });
          module3.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
            setToStringTag(Constructor, NAME + " Iterator");
          };
        },
        /* 95 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var ITERATOR = __webpack_require__(1)("iterator");
          var SAFE_CLOSING = false;
          try {
            var riter = [7][ITERATOR]();
            riter["return"] = function() {
              SAFE_CLOSING = true;
            };
            Array.from(riter, function() {
              throw 2;
            });
          } catch (e) {
          }
          module3.exports = function(exec, skipClosing) {
            if (!skipClosing && !SAFE_CLOSING)
              return false;
            var safe = false;
            try {
              var arr = [7];
              var iter = arr[ITERATOR]();
              iter.next = function() {
                return { done: safe = true };
              };
              arr[ITERATOR] = function() {
                return iter;
              };
              exec(arr);
            } catch (e) {
            }
            return safe;
          };
        },
        /* 96 */
        /***/
        function(module3, exports2) {
          module3.exports = function(done, value2) {
            return { value: value2, done: !!done };
          };
        },
        /* 97 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__(0);
          var macrotask = __webpack_require__(48).set;
          var Observer = global2.MutationObserver || global2.WebKitMutationObserver;
          var process2 = global2.process;
          var Promise2 = global2.Promise;
          var isNode = __webpack_require__(18)(process2) == "process";
          module3.exports = function() {
            var head, last, notify;
            var flush = function() {
              var parent, fn;
              if (isNode && (parent = process2.domain))
                parent.exit();
              while (head) {
                fn = head.fn;
                head = head.next;
                try {
                  fn();
                } catch (e) {
                  if (head)
                    notify();
                  else
                    last = void 0;
                  throw e;
                }
              }
              last = void 0;
              if (parent)
                parent.enter();
            };
            if (isNode) {
              notify = function() {
                process2.nextTick(flush);
              };
            } else if (Observer && !(global2.navigator && global2.navigator.standalone)) {
              var toggle = true;
              var node = document.createTextNode("");
              new Observer(flush).observe(node, { characterData: true });
              notify = function() {
                node.data = toggle = !toggle;
              };
            } else if (Promise2 && Promise2.resolve) {
              var promise = Promise2.resolve(void 0);
              notify = function() {
                promise.then(flush);
              };
            } else {
              notify = function() {
                macrotask.call(global2, flush);
              };
            }
            return function(fn) {
              var task = { fn, next: void 0 };
              if (last)
                last.next = task;
              if (!head) {
                head = task;
                notify();
              }
              last = task;
            };
          };
        },
        /* 98 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var anObject = __webpack_require__(4);
          var dPs = __webpack_require__(99);
          var enumBugKeys = __webpack_require__(39);
          var IE_PROTO = __webpack_require__(30)("IE_PROTO");
          var Empty = function() {
          };
          var PROTOTYPE = "prototype";
          var createDict = function() {
            var iframe = __webpack_require__(26)("iframe");
            var i2 = enumBugKeys.length;
            var lt = "<";
            var gt2 = ">";
            var iframeDocument;
            iframe.style.display = "none";
            __webpack_require__(41).appendChild(iframe);
            iframe.src = "javascript:";
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(lt + "script" + gt2 + "document.F=Object" + lt + "/script" + gt2);
            iframeDocument.close();
            createDict = iframeDocument.F;
            while (i2--)
              delete createDict[PROTOTYPE][enumBugKeys[i2]];
            return createDict();
          };
          module3.exports = Object.create || function create(O, Properties) {
            var result;
            if (O !== null) {
              Empty[PROTOTYPE] = anObject(O);
              result = new Empty();
              Empty[PROTOTYPE] = null;
              result[IE_PROTO] = O;
            } else
              result = createDict();
            return Properties === void 0 ? result : dPs(result, Properties);
          };
        },
        /* 99 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var dP = __webpack_require__(22);
          var anObject = __webpack_require__(4);
          var getKeys = __webpack_require__(102);
          module3.exports = __webpack_require__(12) ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var keys2 = getKeys(Properties);
            var length2 = keys2.length;
            var i2 = 0;
            var P;
            while (length2 > i2)
              dP.f(O, P = keys2[i2++], Properties[P]);
            return O;
          };
        },
        /* 100 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var has2 = __webpack_require__(21);
          var toObject2 = __webpack_require__(108);
          var IE_PROTO = __webpack_require__(30)("IE_PROTO");
          var ObjectProto = Object.prototype;
          module3.exports = Object.getPrototypeOf || function(O) {
            O = toObject2(O);
            if (has2(O, IE_PROTO))
              return O[IE_PROTO];
            if (typeof O.constructor == "function" && O instanceof O.constructor) {
              return O.constructor.prototype;
            }
            return O instanceof Object ? ObjectProto : null;
          };
        },
        /* 101 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var has2 = __webpack_require__(21);
          var toIObject = __webpack_require__(32);
          var arrayIndexOf = __webpack_require__(87)(false);
          var IE_PROTO = __webpack_require__(30)("IE_PROTO");
          module3.exports = function(object, names) {
            var O = toIObject(object);
            var i2 = 0;
            var result = [];
            var key;
            for (key in O)
              if (key != IE_PROTO)
                has2(O, key) && result.push(key);
            while (names.length > i2)
              if (has2(O, key = names[i2++])) {
                ~arrayIndexOf(result, key) || result.push(key);
              }
            return result;
          };
        },
        /* 102 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var $keys = __webpack_require__(101);
          var enumBugKeys = __webpack_require__(39);
          module3.exports = Object.keys || function keys2(O) {
            return $keys(O, enumBugKeys);
          };
        },
        /* 103 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var hide = __webpack_require__(6);
          module3.exports = function(target, src, safe) {
            for (var key in src) {
              if (safe && target[key])
                target[key] = src[key];
              else
                hide(target, key, src[key]);
            }
            return target;
          };
        },
        /* 104 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = __webpack_require__(6);
        },
        /* 105 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__(0);
          var core = __webpack_require__(3);
          var dP = __webpack_require__(22);
          var DESCRIPTORS = __webpack_require__(12);
          var SPECIES = __webpack_require__(1)("species");
          module3.exports = function(KEY) {
            var C = typeof core[KEY] == "function" ? core[KEY] : global2[KEY];
            if (DESCRIPTORS && C && !C[SPECIES])
              dP.f(C, SPECIES, {
                configurable: true,
                get: function() {
                  return this;
                }
              });
          };
        },
        /* 106 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__(31);
          var defined = __webpack_require__(25);
          module3.exports = function(TO_STRING) {
            return function(that, pos) {
              var s = String(defined(that));
              var i2 = toInteger(pos);
              var l = s.length;
              var a, b;
              if (i2 < 0 || i2 >= l)
                return TO_STRING ? "" : void 0;
              a = s.charCodeAt(i2);
              return a < 55296 || a > 56319 || i2 + 1 === l || (b = s.charCodeAt(i2 + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i2) : a : TO_STRING ? s.slice(i2, i2 + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
            };
          };
        },
        /* 107 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var toInteger = __webpack_require__(31);
          var max2 = Math.max;
          var min2 = Math.min;
          module3.exports = function(index, length2) {
            index = toInteger(index);
            return index < 0 ? max2(index + length2, 0) : min2(index, length2);
          };
        },
        /* 108 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var defined = __webpack_require__(25);
          module3.exports = function(it) {
            return Object(defined(it));
          };
        },
        /* 109 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var isObject2 = __webpack_require__(13);
          module3.exports = function(it, S) {
            if (!isObject2(it))
              return it;
            var fn, val;
            if (S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
              return val;
            if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it)))
              return val;
            if (!S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
              return val;
            throw TypeError("Can't convert object to primitive value");
          };
        },
        /* 110 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var global2 = __webpack_require__(0);
          var navigator2 = global2.navigator;
          module3.exports = navigator2 && navigator2.userAgent || "";
        },
        /* 111 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var classof = __webpack_require__(38);
          var ITERATOR = __webpack_require__(1)("iterator");
          var Iterators = __webpack_require__(14);
          module3.exports = __webpack_require__(3).getIteratorMethod = function(it) {
            if (it != void 0)
              return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
          };
        },
        /* 112 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var addToUnscopables = __webpack_require__(85);
          var step = __webpack_require__(96);
          var Iterators = __webpack_require__(14);
          var toIObject = __webpack_require__(32);
          module3.exports = __webpack_require__(42)(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated);
            this._i = 0;
            this._k = kind;
          }, function() {
            var O = this._t;
            var kind = this._k;
            var index = this._i++;
            if (!O || index >= O.length) {
              this._t = void 0;
              return step(1);
            }
            if (kind == "keys")
              return step(0, index);
            if (kind == "values")
              return step(0, O[index]);
            return step(0, [index, O[index]]);
          }, "values");
          Iterators.Arguments = Iterators.Array;
          addToUnscopables("keys");
          addToUnscopables("values");
          addToUnscopables("entries");
        },
        /* 113 */
        /***/
        function(module3, exports2) {
        },
        /* 114 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var LIBRARY = __webpack_require__(27);
          var global2 = __webpack_require__(0);
          var ctx = __webpack_require__(19);
          var classof = __webpack_require__(38);
          var $export = __webpack_require__(20);
          var isObject2 = __webpack_require__(13);
          var aFunction = __webpack_require__(17);
          var anInstance = __webpack_require__(86);
          var forOf = __webpack_require__(88);
          var speciesConstructor = __webpack_require__(47);
          var task = __webpack_require__(48).set;
          var microtask = __webpack_require__(97)();
          var newPromiseCapabilityModule = __webpack_require__(28);
          var perform = __webpack_require__(43);
          var userAgent = __webpack_require__(110);
          var promiseResolve = __webpack_require__(44);
          var PROMISE = "Promise";
          var TypeError2 = global2.TypeError;
          var process2 = global2.process;
          var versions = process2 && process2.versions;
          var v8 = versions && versions.v8 || "";
          var $Promise = global2[PROMISE];
          var isNode = classof(process2) == "process";
          var empty2 = function() {
          };
          var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
          var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
          var USE_NATIVE = !!function() {
            try {
              var promise = $Promise.resolve(1);
              var FakePromise = (promise.constructor = {})[__webpack_require__(1)("species")] = function(exec) {
                exec(empty2, empty2);
              };
              return (isNode || typeof PromiseRejectionEvent == "function") && promise.then(empty2) instanceof FakePromise && v8.indexOf("6.6") !== 0 && userAgent.indexOf("Chrome/66") === -1;
            } catch (e) {
            }
          }();
          var isThenable = function(it) {
            var then;
            return isObject2(it) && typeof (then = it.then) == "function" ? then : false;
          };
          var notify = function(promise, isReject) {
            if (promise._n)
              return;
            promise._n = true;
            var chain = promise._c;
            microtask(function() {
              var value2 = promise._v;
              var ok = promise._s == 1;
              var i2 = 0;
              var run2 = function(reaction) {
                var handler = ok ? reaction.ok : reaction.fail;
                var resolve2 = reaction.resolve;
                var reject = reaction.reject;
                var domain = reaction.domain;
                var result, then, exited;
                try {
                  if (handler) {
                    if (!ok) {
                      if (promise._h == 2)
                        onHandleUnhandled(promise);
                      promise._h = 1;
                    }
                    if (handler === true)
                      result = value2;
                    else {
                      if (domain)
                        domain.enter();
                      result = handler(value2);
                      if (domain) {
                        domain.exit();
                        exited = true;
                      }
                    }
                    if (result === reaction.promise) {
                      reject(TypeError2("Promise-chain cycle"));
                    } else if (then = isThenable(result)) {
                      then.call(result, resolve2, reject);
                    } else
                      resolve2(result);
                  } else
                    reject(value2);
                } catch (e) {
                  if (domain && !exited)
                    domain.exit();
                  reject(e);
                }
              };
              while (chain.length > i2)
                run2(chain[i2++]);
              promise._c = [];
              promise._n = false;
              if (isReject && !promise._h)
                onUnhandled(promise);
            });
          };
          var onUnhandled = function(promise) {
            task.call(global2, function() {
              var value2 = promise._v;
              var unhandled = isUnhandled(promise);
              var result, handler, console2;
              if (unhandled) {
                result = perform(function() {
                  if (isNode) {
                    process2.emit("unhandledRejection", value2, promise);
                  } else if (handler = global2.onunhandledrejection) {
                    handler({ promise, reason: value2 });
                  } else if ((console2 = global2.console) && console2.error) {
                    console2.error("Unhandled promise rejection", value2);
                  }
                });
                promise._h = isNode || isUnhandled(promise) ? 2 : 1;
              }
              promise._a = void 0;
              if (unhandled && result.e)
                throw result.v;
            });
          };
          var isUnhandled = function(promise) {
            return promise._h !== 1 && (promise._a || promise._c).length === 0;
          };
          var onHandleUnhandled = function(promise) {
            task.call(global2, function() {
              var handler;
              if (isNode) {
                process2.emit("rejectionHandled", promise);
              } else if (handler = global2.onrejectionhandled) {
                handler({ promise, reason: promise._v });
              }
            });
          };
          var $reject = function(value2) {
            var promise = this;
            if (promise._d)
              return;
            promise._d = true;
            promise = promise._w || promise;
            promise._v = value2;
            promise._s = 2;
            if (!promise._a)
              promise._a = promise._c.slice();
            notify(promise, true);
          };
          var $resolve = function(value2) {
            var promise = this;
            var then;
            if (promise._d)
              return;
            promise._d = true;
            promise = promise._w || promise;
            try {
              if (promise === value2)
                throw TypeError2("Promise can't be resolved itself");
              if (then = isThenable(value2)) {
                microtask(function() {
                  var wrapper = { _w: promise, _d: false };
                  try {
                    then.call(value2, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
                  } catch (e) {
                    $reject.call(wrapper, e);
                  }
                });
              } else {
                promise._v = value2;
                promise._s = 1;
                notify(promise, false);
              }
            } catch (e) {
              $reject.call({ _w: promise, _d: false }, e);
            }
          };
          if (!USE_NATIVE) {
            $Promise = function Promise2(executor) {
              anInstance(this, $Promise, PROMISE, "_h");
              aFunction(executor);
              Internal.call(this);
              try {
                executor(ctx($resolve, this, 1), ctx($reject, this, 1));
              } catch (err) {
                $reject.call(this, err);
              }
            };
            Internal = function Promise2(executor) {
              this._c = [];
              this._a = void 0;
              this._s = 0;
              this._d = false;
              this._v = void 0;
              this._h = 0;
              this._n = false;
            };
            Internal.prototype = __webpack_require__(103)($Promise.prototype, {
              // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
              then: function then(onFulfilled, onRejected) {
                var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
                reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
                reaction.fail = typeof onRejected == "function" && onRejected;
                reaction.domain = isNode ? process2.domain : void 0;
                this._c.push(reaction);
                if (this._a)
                  this._a.push(reaction);
                if (this._s)
                  notify(this, false);
                return reaction.promise;
              },
              // 25.4.5.1 Promise.prototype.catch(onRejected)
              "catch": function(onRejected) {
                return this.then(void 0, onRejected);
              }
            });
            OwnPromiseCapability = function() {
              var promise = new Internal();
              this.promise = promise;
              this.resolve = ctx($resolve, promise, 1);
              this.reject = ctx($reject, promise, 1);
            };
            newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
              return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
            };
          }
          $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
          __webpack_require__(29)($Promise, PROMISE);
          __webpack_require__(105)(PROMISE);
          Wrapper = __webpack_require__(3)[PROMISE];
          $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
            // 25.4.4.5 Promise.reject(r)
            reject: function reject(r) {
              var capability = newPromiseCapability(this);
              var $$reject = capability.reject;
              $$reject(r);
              return capability.promise;
            }
          });
          $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
            // 25.4.4.6 Promise.resolve(x)
            resolve: function resolve2(x2) {
              return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x2);
            }
          });
          $export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(95)(function(iter) {
            $Promise.all(iter)["catch"](empty2);
          })), PROMISE, {
            // 25.4.4.1 Promise.all(iterable)
            all: function all2(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var resolve2 = capability.resolve;
              var reject = capability.reject;
              var result = perform(function() {
                var values = [];
                var index = 0;
                var remaining = 1;
                forOf(iterable, false, function(promise) {
                  var $index = index++;
                  var alreadyCalled = false;
                  values.push(void 0);
                  remaining++;
                  C.resolve(promise).then(function(value2) {
                    if (alreadyCalled)
                      return;
                    alreadyCalled = true;
                    values[$index] = value2;
                    --remaining || resolve2(values);
                  }, reject);
                });
                --remaining || resolve2(values);
              });
              if (result.e)
                reject(result.v);
              return capability.promise;
            },
            // 25.4.4.4 Promise.race(iterable)
            race: function race(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var reject = capability.reject;
              var result = perform(function() {
                forOf(iterable, false, function(promise) {
                  C.resolve(promise).then(capability.resolve, reject);
                });
              });
              if (result.e)
                reject(result.v);
              return capability.promise;
            }
          });
        },
        /* 115 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var $at = __webpack_require__(106)(true);
          __webpack_require__(42)(String, "String", function(iterated) {
            this._t = String(iterated);
            this._i = 0;
          }, function() {
            var O = this._t;
            var index = this._i;
            var point;
            if (index >= O.length)
              return { value: void 0, done: true };
            point = $at(O, index);
            this._i += point.length;
            return { value: point, done: false };
          });
        },
        /* 116 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var $export = __webpack_require__(20);
          var core = __webpack_require__(3);
          var global2 = __webpack_require__(0);
          var speciesConstructor = __webpack_require__(47);
          var promiseResolve = __webpack_require__(44);
          $export($export.P + $export.R, "Promise", { "finally": function(onFinally) {
            var C = speciesConstructor(this, core.Promise || global2.Promise);
            var isFunction2 = typeof onFinally == "function";
            return this.then(
              isFunction2 ? function(x2) {
                return promiseResolve(C, onFinally()).then(function() {
                  return x2;
                });
              } : onFinally,
              isFunction2 ? function(e) {
                return promiseResolve(C, onFinally()).then(function() {
                  throw e;
                });
              } : onFinally
            );
          } });
        },
        /* 117 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var $export = __webpack_require__(20);
          var newPromiseCapability = __webpack_require__(28);
          var perform = __webpack_require__(43);
          $export($export.S, "Promise", { "try": function(callbackfn) {
            var promiseCapability = newPromiseCapability.f(this);
            var result = perform(callbackfn);
            (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
            return promiseCapability.promise;
          } });
        },
        /* 118 */
        /***/
        function(module3, exports2, __webpack_require__) {
          __webpack_require__(112);
          var global2 = __webpack_require__(0);
          var hide = __webpack_require__(6);
          var Iterators = __webpack_require__(14);
          var TO_STRING_TAG = __webpack_require__(1)("toStringTag");
          var DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
          for (var i2 = 0; i2 < DOMIterables.length; i2++) {
            var NAME = DOMIterables[i2];
            var Collection = global2[NAME];
            var proto2 = Collection && Collection.prototype;
            if (proto2 && !proto2[TO_STRING_TAG])
              hide(proto2, TO_STRING_TAG, NAME);
            Iterators[NAME] = Iterators.Array;
          }
        },
        /* 119 */
        /***/
        function(module3, exports2, __webpack_require__) {
          exports2 = module3.exports = __webpack_require__(120)();
          exports2.push([module3.i, ".video-list[data-v-49ef9b35]{background:#f5f5f5;height:auto;display:flex;flex-direction:row;justify-content:center;flex-wrap:wrap}.video-list div[data-v-49ef9b35]{padding:0}.video-item[data-v-49ef9b35]{background:#c5c4c4;display:inline-block}", ""]);
        },
        /* 120 */
        /***/
        function(module3, exports2) {
          module3.exports = function() {
            var list = [];
            list.toString = function toString2() {
              var result = [];
              for (var i2 = 0; i2 < this.length; i2++) {
                var item = this[i2];
                if (item[2]) {
                  result.push("@media " + item[2] + "{" + item[1] + "}");
                } else {
                  result.push(item[1]);
                }
              }
              return result.join("");
            };
            list.i = function(modules, mediaQuery) {
              if (typeof modules === "string")
                modules = [[null, modules, ""]];
              var alreadyImportedModules = {};
              for (var i2 = 0; i2 < this.length; i2++) {
                var id = this[i2][0];
                if (typeof id === "number")
                  alreadyImportedModules[id] = true;
              }
              for (i2 = 0; i2 < modules.length; i2++) {
                var item = modules[i2];
                if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                  if (mediaQuery && !item[2]) {
                    item[2] = mediaQuery;
                  } else if (mediaQuery) {
                    item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                  }
                  list.push(item);
                }
              }
            };
            return list;
          };
        },
        /* 121 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var fingerprint = __webpack_require__(122);
          var pad = __webpack_require__(51);
          var getRandomValue = __webpack_require__(123);
          var c = 0, blockSize = 4, base = 36, discreteValues = Math.pow(base, blockSize);
          function randomBlock() {
            return pad((getRandomValue() * discreteValues << 0).toString(base), blockSize);
          }
          function safeCounter() {
            c = c < discreteValues ? c : 0;
            c++;
            return c - 1;
          }
          function cuid() {
            var letter = "c", timestamp = (/* @__PURE__ */ new Date()).getTime().toString(base), counter = pad(safeCounter().toString(base), blockSize), print = fingerprint(), random = randomBlock() + randomBlock();
            return letter + timestamp + counter + print + random;
          }
          cuid.slug = function slug() {
            var date2 = (/* @__PURE__ */ new Date()).getTime().toString(36), counter = safeCounter().toString(36).slice(-4), print = fingerprint().slice(0, 1) + fingerprint().slice(-1), random = randomBlock().slice(-2);
            return date2.slice(-2) + counter + print + random;
          };
          cuid.isCuid = function isCuid(stringToCheck) {
            if (typeof stringToCheck !== "string")
              return false;
            if (stringToCheck.startsWith("c"))
              return true;
            return false;
          };
          cuid.isSlug = function isSlug(stringToCheck) {
            if (typeof stringToCheck !== "string")
              return false;
            var stringLength = stringToCheck.length;
            if (stringLength >= 7 && stringLength <= 10)
              return true;
            return false;
          };
          cuid.fingerprint = fingerprint;
          module3.exports = cuid;
        },
        /* 122 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var pad = __webpack_require__(51);
          var env = typeof window === "object" ? window : self;
          var globalCount = Object.keys(env).length;
          var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
          var clientId = pad((mimeTypesLength + navigator.userAgent.length).toString(36) + globalCount.toString(36), 4);
          module3.exports = function fingerprint() {
            return clientId;
          };
        },
        /* 123 */
        /***/
        function(module3, exports2) {
          var getRandomValue;
          var crypto2 = typeof window !== "undefined" && (window.crypto || window.msCrypto) || typeof self !== "undefined" && self.crypto;
          if (crypto2) {
            var lim = Math.pow(2, 32) - 1;
            getRandomValue = function() {
              return Math.abs(crypto2.getRandomValues(new Uint32Array(1))[0] / lim);
            };
          } else {
            getRandomValue = Math.random;
          }
          module3.exports = getRandomValue;
        },
        /* 124 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const Socket3 = __webpack_require__(125);
          module3.exports = (uri, opts) => new Socket3(uri, opts);
          module3.exports.Socket = Socket3;
          module3.exports.protocol = Socket3.protocol;
          module3.exports.Transport = __webpack_require__(33);
          module3.exports.transports = __webpack_require__(52);
          module3.exports.parser = __webpack_require__(16);
        },
        /* 125 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const transports2 = __webpack_require__(52);
          const Emitter2 = __webpack_require__(11);
          const debug = __webpack_require__(15)("engine.io-client:socket");
          const parser2 = __webpack_require__(16);
          const parseuri = __webpack_require__(59);
          const parseqs = __webpack_require__(35);
          class Socket3 extends Emitter2 {
            /**
             * Socket constructor.
             *
             * @param {String|Object} uri or options
             * @param {Object} options
             * @api public
             */
            constructor(uri, opts = {}) {
              super();
              if (uri && "object" === typeof uri) {
                opts = uri;
                uri = null;
              }
              if (uri) {
                uri = parseuri(uri);
                opts.hostname = uri.host;
                opts.secure = uri.protocol === "https" || uri.protocol === "wss";
                opts.port = uri.port;
                if (uri.query)
                  opts.query = uri.query;
              } else if (opts.host) {
                opts.hostname = parseuri(opts.host).host;
              }
              this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
              if (opts.hostname && !opts.port) {
                opts.port = this.secure ? "443" : "80";
              }
              this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
              this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
              this.transports = opts.transports || ["polling", "websocket"];
              this.readyState = "";
              this.writeBuffer = [];
              this.prevBufferLen = 0;
              this.opts = Object.assign(
                {
                  path: "/engine.io",
                  agent: false,
                  withCredentials: false,
                  upgrade: true,
                  jsonp: true,
                  timestampParam: "t",
                  rememberUpgrade: false,
                  rejectUnauthorized: true,
                  perMessageDeflate: {
                    threshold: 1024
                  },
                  transportOptions: {},
                  closeOnBeforeunload: true
                },
                opts
              );
              this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
              if (typeof this.opts.query === "string") {
                this.opts.query = parseqs.decode(this.opts.query);
              }
              this.id = null;
              this.upgrades = null;
              this.pingInterval = null;
              this.pingTimeout = null;
              this.pingTimeoutTimer = null;
              if (typeof addEventListener === "function") {
                if (this.opts.closeOnBeforeunload) {
                  addEventListener(
                    "beforeunload",
                    () => {
                      if (this.transport) {
                        this.transport.removeAllListeners();
                        this.transport.close();
                      }
                    },
                    false
                  );
                }
                if (this.hostname !== "localhost") {
                  this.offlineEventListener = () => {
                    this.onClose("transport close");
                  };
                  addEventListener("offline", this.offlineEventListener, false);
                }
              }
              this.open();
            }
            /**
             * Creates transport of the given type.
             *
             * @param {String} transport name
             * @return {Transport}
             * @api private
             */
            createTransport(name) {
              debug('creating transport "%s"', name);
              const query = clone2(this.opts.query);
              query.EIO = parser2.protocol;
              query.transport = name;
              if (this.id)
                query.sid = this.id;
              const opts = Object.assign(
                {},
                this.opts.transportOptions[name],
                this.opts,
                {
                  query,
                  socket: this,
                  hostname: this.hostname,
                  secure: this.secure,
                  port: this.port
                }
              );
              debug("options: %j", opts);
              return new transports2[name](opts);
            }
            /**
             * Initializes transport to use and starts probe.
             *
             * @api private
             */
            open() {
              let transport;
              if (this.opts.rememberUpgrade && Socket3.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
                transport = "websocket";
              } else if (0 === this.transports.length) {
                setTimeout(() => {
                  this.emit("error", "No transports available");
                }, 0);
                return;
              } else {
                transport = this.transports[0];
              }
              this.readyState = "opening";
              try {
                transport = this.createTransport(transport);
              } catch (e) {
                debug("error while creating transport: %s", e);
                this.transports.shift();
                this.open();
                return;
              }
              transport.open();
              this.setTransport(transport);
            }
            /**
             * Sets the current transport. Disables the existing one (if any).
             *
             * @api private
             */
            setTransport(transport) {
              debug("setting transport %s", transport.name);
              if (this.transport) {
                debug("clearing existing transport %s", this.transport.name);
                this.transport.removeAllListeners();
              }
              this.transport = transport;
              transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", () => {
                this.onClose("transport close");
              });
            }
            /**
             * Probes a transport.
             *
             * @param {String} transport name
             * @api private
             */
            probe(name) {
              debug('probing transport "%s"', name);
              let transport = this.createTransport(name, { probe: 1 });
              let failed = false;
              Socket3.priorWebsocketSuccess = false;
              const onTransportOpen = () => {
                if (failed)
                  return;
                debug('probe transport "%s" opened', name);
                transport.send([{ type: "ping", data: "probe" }]);
                transport.once("packet", (msg) => {
                  if (failed)
                    return;
                  if ("pong" === msg.type && "probe" === msg.data) {
                    debug('probe transport "%s" pong', name);
                    this.upgrading = true;
                    this.emit("upgrading", transport);
                    if (!transport)
                      return;
                    Socket3.priorWebsocketSuccess = "websocket" === transport.name;
                    debug('pausing current transport "%s"', this.transport.name);
                    this.transport.pause(() => {
                      if (failed)
                        return;
                      if ("closed" === this.readyState)
                        return;
                      debug("changing transport and sending upgrade packet");
                      cleanup();
                      this.setTransport(transport);
                      transport.send([{ type: "upgrade" }]);
                      this.emit("upgrade", transport);
                      transport = null;
                      this.upgrading = false;
                      this.flush();
                    });
                  } else {
                    debug('probe transport "%s" failed', name);
                    const err = new Error("probe error");
                    err.transport = transport.name;
                    this.emit("upgradeError", err);
                  }
                });
              };
              function freezeTransport() {
                if (failed)
                  return;
                failed = true;
                cleanup();
                transport.close();
                transport = null;
              }
              const onerror = (err) => {
                const error = new Error("probe error: " + err);
                error.transport = transport.name;
                freezeTransport();
                debug('probe transport "%s" failed because of error: %s', name, err);
                this.emit("upgradeError", error);
              };
              function onTransportClose() {
                onerror("transport closed");
              }
              function onclose() {
                onerror("socket closed");
              }
              function onupgrade(to2) {
                if (transport && to2.name !== transport.name) {
                  debug('"%s" works - aborting "%s"', to2.name, transport.name);
                  freezeTransport();
                }
              }
              const cleanup = () => {
                transport.removeListener("open", onTransportOpen);
                transport.removeListener("error", onerror);
                transport.removeListener("close", onTransportClose);
                this.removeListener("close", onclose);
                this.removeListener("upgrading", onupgrade);
              };
              transport.once("open", onTransportOpen);
              transport.once("error", onerror);
              transport.once("close", onTransportClose);
              this.once("close", onclose);
              this.once("upgrading", onupgrade);
              transport.open();
            }
            /**
             * Called when connection is deemed open.
             *
             * @api public
             */
            onOpen() {
              debug("socket open");
              this.readyState = "open";
              Socket3.priorWebsocketSuccess = "websocket" === this.transport.name;
              this.emit("open");
              this.flush();
              if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
                debug("starting upgrade probes");
                let i2 = 0;
                const l = this.upgrades.length;
                for (; i2 < l; i2++) {
                  this.probe(this.upgrades[i2]);
                }
              }
            }
            /**
             * Handles a packet.
             *
             * @api private
             */
            onPacket(packet) {
              if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
                this.emit("packet", packet);
                this.emit("heartbeat");
                switch (packet.type) {
                  case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                  case "ping":
                    this.resetPingTimeout();
                    this.sendPacket("pong");
                    this.emit("pong");
                    break;
                  case "error":
                    const err = new Error("server error");
                    err.code = packet.data;
                    this.onError(err);
                    break;
                  case "message":
                    this.emit("data", packet.data);
                    this.emit("message", packet.data);
                    break;
                }
              } else {
                debug('packet received with socket readyState "%s"', this.readyState);
              }
            }
            /**
             * Called upon handshake completion.
             *
             * @param {Object} handshake obj
             * @api private
             */
            onHandshake(data2) {
              this.emit("handshake", data2);
              this.id = data2.sid;
              this.transport.query.sid = data2.sid;
              this.upgrades = this.filterUpgrades(data2.upgrades);
              this.pingInterval = data2.pingInterval;
              this.pingTimeout = data2.pingTimeout;
              this.onOpen();
              if ("closed" === this.readyState)
                return;
              this.resetPingTimeout();
            }
            /**
             * Sets and resets ping timeout timer based on server pings.
             *
             * @api private
             */
            resetPingTimeout() {
              clearTimeout(this.pingTimeoutTimer);
              this.pingTimeoutTimer = setTimeout(() => {
                this.onClose("ping timeout");
              }, this.pingInterval + this.pingTimeout);
              if (this.opts.autoUnref) {
                this.pingTimeoutTimer.unref();
              }
            }
            /**
             * Called on `drain` event
             *
             * @api private
             */
            onDrain() {
              this.writeBuffer.splice(0, this.prevBufferLen);
              this.prevBufferLen = 0;
              if (0 === this.writeBuffer.length) {
                this.emit("drain");
              } else {
                this.flush();
              }
            }
            /**
             * Flush write buffers.
             *
             * @api private
             */
            flush() {
              if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
                debug("flushing %d packets in socket", this.writeBuffer.length);
                this.transport.send(this.writeBuffer);
                this.prevBufferLen = this.writeBuffer.length;
                this.emit("flush");
              }
            }
            /**
             * Sends a message.
             *
             * @param {String} message.
             * @param {Function} callback function.
             * @param {Object} options.
             * @return {Socket} for chaining.
             * @api public
             */
            write(msg, options, fn) {
              this.sendPacket("message", msg, options, fn);
              return this;
            }
            send(msg, options, fn) {
              this.sendPacket("message", msg, options, fn);
              return this;
            }
            /**
             * Sends a packet.
             *
             * @param {String} packet type.
             * @param {String} data.
             * @param {Object} options.
             * @param {Function} callback function.
             * @api private
             */
            sendPacket(type, data2, options, fn) {
              if ("function" === typeof data2) {
                fn = data2;
                data2 = void 0;
              }
              if ("function" === typeof options) {
                fn = options;
                options = null;
              }
              if ("closing" === this.readyState || "closed" === this.readyState) {
                return;
              }
              options = options || {};
              options.compress = false !== options.compress;
              const packet = {
                type,
                data: data2,
                options
              };
              this.emit("packetCreate", packet);
              this.writeBuffer.push(packet);
              if (fn)
                this.once("flush", fn);
              this.flush();
            }
            /**
             * Closes the connection.
             *
             * @api private
             */
            close() {
              const close = () => {
                this.onClose("forced close");
                debug("socket closing - telling transport to close");
                this.transport.close();
              };
              const cleanupAndClose = () => {
                this.removeListener("upgrade", cleanupAndClose);
                this.removeListener("upgradeError", cleanupAndClose);
                close();
              };
              const waitForUpgrade = () => {
                this.once("upgrade", cleanupAndClose);
                this.once("upgradeError", cleanupAndClose);
              };
              if ("opening" === this.readyState || "open" === this.readyState) {
                this.readyState = "closing";
                if (this.writeBuffer.length) {
                  this.once("drain", () => {
                    if (this.upgrading) {
                      waitForUpgrade();
                    } else {
                      close();
                    }
                  });
                } else if (this.upgrading) {
                  waitForUpgrade();
                } else {
                  close();
                }
              }
              return this;
            }
            /**
             * Called upon transport error
             *
             * @api private
             */
            onError(err) {
              debug("socket error %j", err);
              Socket3.priorWebsocketSuccess = false;
              this.emit("error", err);
              this.onClose("transport error", err);
            }
            /**
             * Called upon transport close.
             *
             * @api private
             */
            onClose(reason, desc) {
              if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                debug('socket close with reason: "%s"', reason);
                clearTimeout(this.pingIntervalTimer);
                clearTimeout(this.pingTimeoutTimer);
                this.transport.removeAllListeners("close");
                this.transport.close();
                this.transport.removeAllListeners();
                if (typeof removeEventListener === "function") {
                  removeEventListener("offline", this.offlineEventListener, false);
                }
                this.readyState = "closed";
                this.id = null;
                this.emit("close", reason, desc);
                this.writeBuffer = [];
                this.prevBufferLen = 0;
              }
            }
            /**
             * Filters upgrades, returning only those matching client transports.
             *
             * @param {Array} server upgrades
             * @api private
             *
             */
            filterUpgrades(upgrades) {
              const filteredUpgrades = [];
              let i2 = 0;
              const j2 = upgrades.length;
              for (; i2 < j2; i2++) {
                if (~this.transports.indexOf(upgrades[i2]))
                  filteredUpgrades.push(upgrades[i2]);
              }
              return filteredUpgrades;
            }
          }
          Socket3.priorWebsocketSuccess = false;
          Socket3.protocol = parser2.protocol;
          function clone2(obj) {
            const o = {};
            for (let i2 in obj) {
              if (obj.hasOwnProperty(i2)) {
                o[i2] = obj[i2];
              }
            }
            return o;
          }
          module3.exports = Socket3;
        },
        /* 126 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const Polling2 = __webpack_require__(53);
          const globalThis2 = __webpack_require__(23);
          const rNewline = /\n/g;
          const rEscapedNewline = /\\n/g;
          let callbacks;
          class JSONPPolling extends Polling2 {
            /**
             * JSONP Polling constructor.
             *
             * @param {Object} opts.
             * @api public
             */
            constructor(opts) {
              super(opts);
              this.query = this.query || {};
              if (!callbacks) {
                callbacks = globalThis2.___eio = globalThis2.___eio || [];
              }
              this.index = callbacks.length;
              callbacks.push(this.onData.bind(this));
              this.query.j = this.index;
            }
            /**
             * JSONP only supports binary as base64 encoded strings
             */
            get supportsBinary() {
              return false;
            }
            /**
             * Closes the socket.
             *
             * @api private
             */
            doClose() {
              if (this.script) {
                this.script.onerror = () => {
                };
                this.script.parentNode.removeChild(this.script);
                this.script = null;
              }
              if (this.form) {
                this.form.parentNode.removeChild(this.form);
                this.form = null;
                this.iframe = null;
              }
              super.doClose();
            }
            /**
             * Starts a poll cycle.
             *
             * @api private
             */
            doPoll() {
              const script = document.createElement("script");
              if (this.script) {
                this.script.parentNode.removeChild(this.script);
                this.script = null;
              }
              script.async = true;
              script.src = this.uri();
              script.onerror = (e) => {
                this.onError("jsonp poll error", e);
              };
              const insertAt = document.getElementsByTagName("script")[0];
              if (insertAt) {
                insertAt.parentNode.insertBefore(script, insertAt);
              } else {
                (document.head || document.body).appendChild(script);
              }
              this.script = script;
              const isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
              if (isUAgecko) {
                setTimeout(function() {
                  const iframe = document.createElement("iframe");
                  document.body.appendChild(iframe);
                  document.body.removeChild(iframe);
                }, 100);
              }
            }
            /**
             * Writes with a hidden iframe.
             *
             * @param {String} data to send
             * @param {Function} called upon flush.
             * @api private
             */
            doWrite(data2, fn) {
              let iframe;
              if (!this.form) {
                const form = document.createElement("form");
                const area = document.createElement("textarea");
                const id = this.iframeId = "eio_iframe_" + this.index;
                form.className = "socketio";
                form.style.position = "absolute";
                form.style.top = "-1000px";
                form.style.left = "-1000px";
                form.target = id;
                form.method = "POST";
                form.setAttribute("accept-charset", "utf-8");
                area.name = "d";
                form.appendChild(area);
                document.body.appendChild(form);
                this.form = form;
                this.area = area;
              }
              this.form.action = this.uri();
              function complete() {
                initIframe();
                fn();
              }
              const initIframe = () => {
                if (this.iframe) {
                  try {
                    this.form.removeChild(this.iframe);
                  } catch (e) {
                    this.onError("jsonp polling iframe removal error", e);
                  }
                }
                try {
                  const html = '<iframe src="javascript:0" name="' + this.iframeId + '">';
                  iframe = document.createElement(html);
                } catch (e) {
                  iframe = document.createElement("iframe");
                  iframe.name = this.iframeId;
                  iframe.src = "javascript:0";
                }
                iframe.id = this.iframeId;
                this.form.appendChild(iframe);
                this.iframe = iframe;
              };
              initIframe();
              data2 = data2.replace(rEscapedNewline, "\\\n");
              this.area.value = data2.replace(rNewline, "\\n");
              try {
                this.form.submit();
              } catch (e) {
              }
              if (this.iframe.attachEvent) {
                this.iframe.onreadystatechange = () => {
                  if (this.iframe.readyState === "complete") {
                    complete();
                  }
                };
              } else {
                this.iframe.onload = complete;
              }
            }
          }
          module3.exports = JSONPPolling;
        },
        /* 127 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const XMLHttpRequest2 = __webpack_require__(55);
          const Polling2 = __webpack_require__(53);
          const Emitter2 = __webpack_require__(11);
          const { pick: pick2 } = __webpack_require__(54);
          const globalThis2 = __webpack_require__(23);
          const debug = __webpack_require__(15)("engine.io-client:polling-xhr");
          function empty2() {
          }
          const hasXHR22 = function() {
            const xhr2 = new XMLHttpRequest2({ xdomain: false });
            return null != xhr2.responseType;
          }();
          class XHR2 extends Polling2 {
            /**
             * XHR Polling constructor.
             *
             * @param {Object} opts
             * @api public
             */
            constructor(opts) {
              super(opts);
              if (typeof location !== "undefined") {
                const isSSL = "https:" === location.protocol;
                let port = location.port;
                if (!port) {
                  port = isSSL ? 443 : 80;
                }
                this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
                this.xs = opts.secure !== isSSL;
              }
              const forceBase64 = opts && opts.forceBase64;
              this.supportsBinary = hasXHR22 && !forceBase64;
            }
            /**
             * Creates a request.
             *
             * @param {String} method
             * @api private
             */
            request(opts = {}) {
              Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
              return new Request2(this.uri(), opts);
            }
            /**
             * Sends data.
             *
             * @param {String} data to send.
             * @param {Function} called upon flush.
             * @api private
             */
            doWrite(data2, fn) {
              const req = this.request({
                method: "POST",
                data: data2
              });
              req.on("success", fn);
              req.on("error", (err) => {
                this.onError("xhr post error", err);
              });
            }
            /**
             * Starts a poll cycle.
             *
             * @api private
             */
            doPoll() {
              debug("xhr poll");
              const req = this.request();
              req.on("data", this.onData.bind(this));
              req.on("error", (err) => {
                this.onError("xhr poll error", err);
              });
              this.pollXhr = req;
            }
          }
          class Request2 extends Emitter2 {
            /**
             * Request constructor
             *
             * @param {Object} options
             * @api public
             */
            constructor(uri, opts) {
              super();
              this.opts = opts;
              this.method = opts.method || "GET";
              this.uri = uri;
              this.async = false !== opts.async;
              this.data = void 0 !== opts.data ? opts.data : null;
              this.create();
            }
            /**
             * Creates the XHR object and sends the request.
             *
             * @api private
             */
            create() {
              const opts = pick2(
                this.opts,
                "agent",
                "enablesXDR",
                "pfx",
                "key",
                "passphrase",
                "cert",
                "ca",
                "ciphers",
                "rejectUnauthorized",
                "autoUnref"
              );
              opts.xdomain = !!this.opts.xd;
              opts.xscheme = !!this.opts.xs;
              const xhr2 = this.xhr = new XMLHttpRequest2(opts);
              try {
                debug("xhr open %s: %s", this.method, this.uri);
                xhr2.open(this.method, this.uri, this.async);
                try {
                  if (this.opts.extraHeaders) {
                    xhr2.setDisableHeaderCheck && xhr2.setDisableHeaderCheck(true);
                    for (let i2 in this.opts.extraHeaders) {
                      if (this.opts.extraHeaders.hasOwnProperty(i2)) {
                        xhr2.setRequestHeader(i2, this.opts.extraHeaders[i2]);
                      }
                    }
                  }
                } catch (e) {
                }
                if ("POST" === this.method) {
                  try {
                    xhr2.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                  } catch (e) {
                  }
                }
                try {
                  xhr2.setRequestHeader("Accept", "*/*");
                } catch (e) {
                }
                if ("withCredentials" in xhr2) {
                  xhr2.withCredentials = this.opts.withCredentials;
                }
                if (this.opts.requestTimeout) {
                  xhr2.timeout = this.opts.requestTimeout;
                }
                if (this.hasXDR()) {
                  xhr2.onload = () => {
                    this.onLoad();
                  };
                  xhr2.onerror = () => {
                    this.onError(xhr2.responseText);
                  };
                } else {
                  xhr2.onreadystatechange = () => {
                    if (4 !== xhr2.readyState)
                      return;
                    if (200 === xhr2.status || 1223 === xhr2.status) {
                      this.onLoad();
                    } else {
                      setTimeout(() => {
                        this.onError(typeof xhr2.status === "number" ? xhr2.status : 0);
                      }, 0);
                    }
                  };
                }
                debug("xhr data %s", this.data);
                xhr2.send(this.data);
              } catch (e) {
                setTimeout(() => {
                  this.onError(e);
                }, 0);
                return;
              }
              if (typeof document !== "undefined") {
                this.index = Request2.requestsCount++;
                Request2.requests[this.index] = this;
              }
            }
            /**
             * Called upon successful response.
             *
             * @api private
             */
            onSuccess() {
              this.emit("success");
              this.cleanup();
            }
            /**
             * Called if we have data.
             *
             * @api private
             */
            onData(data2) {
              this.emit("data", data2);
              this.onSuccess();
            }
            /**
             * Called upon error.
             *
             * @api private
             */
            onError(err) {
              this.emit("error", err);
              this.cleanup(true);
            }
            /**
             * Cleans up house.
             *
             * @api private
             */
            cleanup(fromError) {
              if ("undefined" === typeof this.xhr || null === this.xhr) {
                return;
              }
              if (this.hasXDR()) {
                this.xhr.onload = this.xhr.onerror = empty2;
              } else {
                this.xhr.onreadystatechange = empty2;
              }
              if (fromError) {
                try {
                  this.xhr.abort();
                } catch (e) {
                }
              }
              if (typeof document !== "undefined") {
                delete Request2.requests[this.index];
              }
              this.xhr = null;
            }
            /**
             * Called upon load.
             *
             * @api private
             */
            onLoad() {
              const data2 = this.xhr.responseText;
              if (data2 !== null) {
                this.onData(data2);
              }
            }
            /**
             * Check if it has XDomainRequest.
             *
             * @api private
             */
            hasXDR() {
              return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
            }
            /**
             * Aborts the request.
             *
             * @api public
             */
            abort() {
              this.cleanup();
            }
          }
          Request2.requestsCount = 0;
          Request2.requests = {};
          if (typeof document !== "undefined") {
            if (typeof attachEvent === "function") {
              attachEvent("onunload", unloadHandler2);
            } else if (typeof addEventListener === "function") {
              const terminationEvent = "onpagehide" in globalThis2 ? "pagehide" : "unload";
              addEventListener(terminationEvent, unloadHandler2, false);
            }
          }
          function unloadHandler2() {
            for (let i2 in Request2.requests) {
              if (Request2.requests.hasOwnProperty(i2)) {
                Request2.requests[i2].abort();
              }
            }
          }
          module3.exports = XHR2;
          module3.exports.Request = Request2;
        },
        /* 128 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const globalThis2 = __webpack_require__(23);
          module3.exports = {
            WebSocket: globalThis2.WebSocket || globalThis2.MozWebSocket,
            usingBrowserWebSocket: true,
            defaultBinaryType: "arraybuffer"
          };
        },
        /* 129 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(Buffer2) {
            const Transport2 = __webpack_require__(33);
            const parser2 = __webpack_require__(16);
            const parseqs = __webpack_require__(35);
            const yeast2 = __webpack_require__(72);
            const { pick: pick2 } = __webpack_require__(54);
            const {
              WebSocket: WebSocket2,
              usingBrowserWebSocket: usingBrowserWebSocket2,
              defaultBinaryType: defaultBinaryType2
            } = __webpack_require__(128);
            const debug = __webpack_require__(15)("engine.io-client:websocket");
            const isReactNative2 = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
            class WS2 extends Transport2 {
              /**
               * WebSocket transport constructor.
               *
               * @api {Object} connection options
               * @api public
               */
              constructor(opts) {
                super(opts);
                this.supportsBinary = !opts.forceBase64;
              }
              /**
               * Transport name.
               *
               * @api public
               */
              get name() {
                return "websocket";
              }
              /**
               * Opens socket.
               *
               * @api private
               */
              doOpen() {
                if (!this.check()) {
                  return;
                }
                const uri = this.uri();
                const protocols = this.opts.protocols;
                const opts = isReactNative2 ? {} : pick2(
                  this.opts,
                  "agent",
                  "perMessageDeflate",
                  "pfx",
                  "key",
                  "passphrase",
                  "cert",
                  "ca",
                  "ciphers",
                  "rejectUnauthorized",
                  "localAddress",
                  "protocolVersion",
                  "origin",
                  "maxPayload",
                  "family",
                  "checkServerIdentity"
                );
                if (this.opts.extraHeaders) {
                  opts.headers = this.opts.extraHeaders;
                }
                try {
                  this.ws = usingBrowserWebSocket2 && !isReactNative2 ? protocols ? new WebSocket2(uri, protocols) : new WebSocket2(uri) : new WebSocket2(uri, protocols, opts);
                } catch (err) {
                  return this.emit("error", err);
                }
                this.ws.binaryType = this.socket.binaryType || defaultBinaryType2;
                this.addEventListeners();
              }
              /**
               * Adds event listeners to the socket
               *
               * @api private
               */
              addEventListeners() {
                this.ws.onopen = () => {
                  if (this.opts.autoUnref) {
                    this.ws._socket.unref();
                  }
                  this.onOpen();
                };
                this.ws.onclose = this.onClose.bind(this);
                this.ws.onmessage = (ev) => this.onData(ev.data);
                this.ws.onerror = (e) => this.onError("websocket error", e);
              }
              /**
               * Writes data to socket.
               *
               * @param {Array} array of packets.
               * @api private
               */
              write(packets) {
                this.writable = false;
                for (let i2 = 0; i2 < packets.length; i2++) {
                  const packet = packets[i2];
                  const lastPacket = i2 === packets.length - 1;
                  parser2.encodePacket(packet, this.supportsBinary, (data2) => {
                    const opts = {};
                    if (!usingBrowserWebSocket2) {
                      if (packet.options) {
                        opts.compress = packet.options.compress;
                      }
                      if (this.opts.perMessageDeflate) {
                        const len = "string" === typeof data2 ? Buffer2.byteLength(data2) : data2.length;
                        if (len < this.opts.perMessageDeflate.threshold) {
                          opts.compress = false;
                        }
                      }
                    }
                    try {
                      if (usingBrowserWebSocket2) {
                        this.ws.send(data2);
                      } else {
                        this.ws.send(data2, opts);
                      }
                    } catch (e) {
                      debug("websocket closed before onclose event");
                    }
                    if (lastPacket) {
                      setTimeout(() => {
                        this.writable = true;
                        this.emit("drain");
                      }, 0);
                    }
                  });
                }
              }
              /**
               * Called upon close
               *
               * @api private
               */
              onClose() {
                Transport2.prototype.onClose.call(this);
              }
              /**
               * Closes socket.
               *
               * @api private
               */
              doClose() {
                if (typeof this.ws !== "undefined") {
                  this.ws.close();
                  this.ws = null;
                }
              }
              /**
               * Generates uri for connection.
               *
               * @api private
               */
              uri() {
                let query = this.query || {};
                const schema = this.opts.secure ? "wss" : "ws";
                let port = "";
                if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
                  port = ":" + this.opts.port;
                }
                if (this.opts.timestampRequests) {
                  query[this.opts.timestampParam] = yeast2();
                }
                if (!this.supportsBinary) {
                  query.b64 = 1;
                }
                query = parseqs.encode(query);
                if (query.length) {
                  query = "?" + query;
                }
                const ipv6 = this.opts.hostname.indexOf(":") !== -1;
                return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
              }
              /**
               * Feature detection for WebSocket.
               *
               * @return {Boolean} whether this transport is available.
               * @api public
               */
              check() {
                return !!WebSocket2 && !("__initialize" in WebSocket2 && this.name === WS2.prototype.name);
              }
            }
            module3.exports = WS2;
          }).call(exports2, __webpack_require__(5).Buffer);
        },
        /* 130 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(131);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key) => {
              createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
              let hash = 0;
              for (let i2 = 0; i2 < namespace.length; i2++) {
                hash = (hash << 5) - hash + namespace.charCodeAt(i2);
                hash |= 0;
              }
              return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
              let prevTime;
              let enableOverride = null;
              function debug(...args) {
                if (!debug.enabled) {
                  return;
                }
                const self2 = debug;
                const curr = Number(/* @__PURE__ */ new Date());
                const ms = curr - (prevTime || curr);
                self2.diff = ms;
                self2.prev = prevTime;
                self2.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== "string") {
                  args.unshift("%O");
                }
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                  if (match === "%%") {
                    return "%";
                  }
                  index++;
                  const formatter = createDebug.formatters[format2];
                  if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self2, val);
                    args.splice(index, 1);
                    index--;
                  }
                  return match;
                });
                createDebug.formatArgs.call(self2, args);
                const logFn = self2.log || createDebug.log;
                logFn.apply(self2, args);
              }
              debug.namespace = namespace;
              debug.useColors = createDebug.useColors();
              debug.color = createDebug.selectColor(namespace);
              debug.extend = extend2;
              debug.destroy = createDebug.destroy;
              Object.defineProperty(debug, "enabled", {
                enumerable: true,
                configurable: false,
                get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
                set: (v) => {
                  enableOverride = v;
                }
              });
              if (typeof createDebug.init === "function") {
                createDebug.init(debug);
              }
              return debug;
            }
            function extend2(namespace, delimiter) {
              const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
              newDebug.log = this.log;
              return newDebug;
            }
            function enable(namespaces) {
              createDebug.save(namespaces);
              createDebug.names = [];
              createDebug.skips = [];
              let i2;
              const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
              const len = split.length;
              for (i2 = 0; i2 < len; i2++) {
                if (!split[i2]) {
                  continue;
                }
                namespaces = split[i2].replace(/\*/g, ".*?");
                if (namespaces[0] === "-") {
                  createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
                } else {
                  createDebug.names.push(new RegExp("^" + namespaces + "$"));
                }
              }
            }
            function disable() {
              const namespaces = [
                ...createDebug.names.map(toNamespace),
                ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
              ].join(",");
              createDebug.enable("");
              return namespaces;
            }
            function enabled(name) {
              if (name[name.length - 1] === "*") {
                return true;
              }
              let i2;
              let len;
              for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
                if (createDebug.skips[i2].test(name)) {
                  return false;
                }
              }
              for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
                if (createDebug.names[i2].test(name)) {
                  return true;
                }
              }
              return false;
            }
            function toNamespace(regexp) {
              return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function coerce(val) {
              if (val instanceof Error) {
                return val.stack || val.message;
              }
              return val;
            }
            function destroy() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
          }
          module3.exports = setup;
        },
        /* 131 */
        /***/
        function(module3, exports2) {
          var s = 1e3;
          var m = s * 60;
          var h2 = m * 60;
          var d = h2 * 24;
          var w2 = d * 7;
          var y = d * 365.25;
          module3.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
              return parse2(val);
            } else if (type === "number" && isFinite(val)) {
              return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error(
              "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
            );
          };
          function parse2(str) {
            str = String(str);
            if (str.length > 100) {
              return;
            }
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              str
            );
            if (!match) {
              return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;
              case "weeks":
              case "week":
              case "w":
                return n * w2;
              case "days":
              case "day":
              case "d":
                return n * d;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h2;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;
              default:
                return void 0;
            }
          }
          function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return Math.round(ms / d) + "d";
            }
            if (msAbs >= h2) {
              return Math.round(ms / h2) + "h";
            }
            if (msAbs >= m) {
              return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
              return Math.round(ms / s) + "s";
            }
            return ms + "ms";
          }
          function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h2) {
              return plural(ms, msAbs, h2, "hour");
            }
            if (msAbs >= m) {
              return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
              return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
          }
          function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
          }
        },
        /* 132 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const { PACKET_TYPES_REVERSE: PACKET_TYPES_REVERSE2, ERROR_PACKET: ERROR_PACKET2 } = __webpack_require__(56);
          const withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
          let base64decoder;
          if (withNativeArrayBuffer2) {
            base64decoder = __webpack_require__(81);
          }
          const decodePacket2 = (encodedPacket, binaryType) => {
            if (typeof encodedPacket !== "string") {
              return {
                type: "message",
                data: mapBinary2(encodedPacket, binaryType)
              };
            }
            const type = encodedPacket.charAt(0);
            if (type === "b") {
              return {
                type: "message",
                data: decodeBase64Packet2(encodedPacket.substring(1), binaryType)
              };
            }
            const packetType = PACKET_TYPES_REVERSE2[type];
            if (!packetType) {
              return ERROR_PACKET2;
            }
            return encodedPacket.length > 1 ? {
              type: PACKET_TYPES_REVERSE2[type],
              data: encodedPacket.substring(1)
            } : {
              type: PACKET_TYPES_REVERSE2[type]
            };
          };
          const decodeBase64Packet2 = (data2, binaryType) => {
            if (base64decoder) {
              const decoded = base64decoder.decode(data2);
              return mapBinary2(decoded, binaryType);
            } else {
              return { base64: true, data: data2 };
            }
          };
          const mapBinary2 = (data2, binaryType) => {
            switch (binaryType) {
              case "blob":
                return data2 instanceof ArrayBuffer ? new Blob([data2]) : data2;
              case "arraybuffer":
              default:
                return data2;
            }
          };
          module3.exports = decodePacket2;
        },
        /* 133 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const { PACKET_TYPES: PACKET_TYPES2 } = __webpack_require__(56);
          const withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
          const withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
          const isView2 = (obj) => {
            return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
          };
          const encodePacket2 = ({ type, data: data2 }, supportsBinary, callback) => {
            if (withNativeBlob2 && data2 instanceof Blob) {
              if (supportsBinary) {
                return callback(data2);
              } else {
                return encodeBlobAsBase642(data2, callback);
              }
            } else if (withNativeArrayBuffer2 && (data2 instanceof ArrayBuffer || isView2(data2))) {
              if (supportsBinary) {
                return callback(data2 instanceof ArrayBuffer ? data2 : data2.buffer);
              } else {
                return encodeBlobAsBase642(new Blob([data2]), callback);
              }
            }
            return callback(PACKET_TYPES2[type] + (data2 || ""));
          };
          const encodeBlobAsBase642 = (data2, callback) => {
            const fileReader = new FileReader();
            fileReader.onload = function() {
              const content = fileReader.result.split(",")[1];
              callback("b" + content);
            };
            return fileReader.readAsDataURL(data2);
          };
          module3.exports = encodePacket2;
        },
        /* 134 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function assign2(obj, props) {
            for (const key in props) {
              Object.defineProperty(obj, key, {
                value: props[key],
                enumerable: true,
                configurable: true
              });
            }
            return obj;
          }
          function createError(err, code, props) {
            if (!err || typeof err === "string") {
              throw new TypeError("Please pass an Error to err-code");
            }
            if (!props) {
              props = {};
            }
            if (typeof code === "object") {
              props = code;
              code = "";
            }
            if (code) {
              props.code = code;
            }
            try {
              return assign2(err, props);
            } catch (_) {
              props.message = err.message;
              props.stack = err.stack;
              const ErrClass = function() {
              };
              ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
              const output = assign2(new ErrClass(), props);
              return output;
            }
          }
          module3.exports = createError;
        },
        /* 135 */
        /***/
        function(module3, exports2) {
          module3.exports = function getBrowserRTC() {
            if (typeof globalThis === "undefined")
              return null;
            var wrtc = {
              RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
              RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
              RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
            };
            if (!wrtc.RTCPeerConnection)
              return null;
            return wrtc;
          };
        },
        /* 136 */
        /***/
        function(module3, exports2) {
          try {
            module3.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
          } catch (err) {
            module3.exports = false;
          }
        },
        /* 137 */
        /***/
        function(module3, exports2) {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
          exports2.read = function(buffer, offset2, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i2 = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset2 + i2];
            i2 += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset2 + i2], i2 += d, nBits -= 8) {
            }
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset2 + i2], i2 += d, nBits -= 8) {
            }
            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };
          exports2.write = function(buffer, value2, offset2, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i2 = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
            value2 = Math.abs(value2);
            if (isNaN(value2) || value2 === Infinity) {
              m = isNaN(value2) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value2) / Math.LN2);
              if (value2 * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value2 += rt / c;
              } else {
                value2 += rt * Math.pow(2, 1 - eBias);
              }
              if (value2 * c >= 2) {
                e++;
                c /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value2 * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (; mLen >= 8; buffer[offset2 + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
            }
            e = e << mLen | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset2 + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
            }
            buffer[offset2 + i2 - d] |= s * 128;
          };
        },
        /* 138 */
        /***/
        function(module3, exports2) {
          var toString2 = {}.toString;
          module3.exports = Array.isArray || function(arr) {
            return toString2.call(arr) == "[object Array]";
          };
        },
        /* 139 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var splice = __webpack_require__(152);
          var nanotiming = __webpack_require__(141);
          var assert = __webpack_require__(34);
          module3.exports = Nanobus;
          function Nanobus(name) {
            if (!(this instanceof Nanobus))
              return new Nanobus(name);
            this._name = name || "nanobus";
            this._starListeners = [];
            this._listeners = {};
          }
          Nanobus.prototype.emit = function(eventName2) {
            assert.ok(typeof eventName2 === "string" || typeof eventName2 === "symbol", "nanobus.emit: eventName should be type string or symbol");
            var data2 = [];
            for (var i2 = 1, len = arguments.length; i2 < len; i2++) {
              data2.push(arguments[i2]);
            }
            var emitTiming = nanotiming(this._name + "('" + eventName2.toString() + "')");
            var listeners = this._listeners[eventName2];
            if (listeners && listeners.length > 0) {
              this._emit(this._listeners[eventName2], data2);
            }
            if (this._starListeners.length > 0) {
              this._emit(this._starListeners, eventName2, data2, emitTiming.uuid);
            }
            emitTiming();
            return this;
          };
          Nanobus.prototype.on = Nanobus.prototype.addListener = function(eventName2, listener) {
            assert.ok(typeof eventName2 === "string" || typeof eventName2 === "symbol", "nanobus.on: eventName should be type string or symbol");
            assert.equal(typeof listener, "function", "nanobus.on: listener should be type function");
            if (eventName2 === "*") {
              this._starListeners.push(listener);
            } else {
              if (!this._listeners[eventName2])
                this._listeners[eventName2] = [];
              this._listeners[eventName2].push(listener);
            }
            return this;
          };
          Nanobus.prototype.prependListener = function(eventName2, listener) {
            assert.ok(typeof eventName2 === "string" || typeof eventName2 === "symbol", "nanobus.prependListener: eventName should be type string or symbol");
            assert.equal(typeof listener, "function", "nanobus.prependListener: listener should be type function");
            if (eventName2 === "*") {
              this._starListeners.unshift(listener);
            } else {
              if (!this._listeners[eventName2])
                this._listeners[eventName2] = [];
              this._listeners[eventName2].unshift(listener);
            }
            return this;
          };
          Nanobus.prototype.once = function(eventName2, listener) {
            assert.ok(typeof eventName2 === "string" || typeof eventName2 === "symbol", "nanobus.once: eventName should be type string or symbol");
            assert.equal(typeof listener, "function", "nanobus.once: listener should be type function");
            var self2 = this;
            this.on(eventName2, once);
            function once() {
              listener.apply(self2, arguments);
              self2.removeListener(eventName2, once);
            }
            return this;
          };
          Nanobus.prototype.prependOnceListener = function(eventName2, listener) {
            assert.ok(typeof eventName2 === "string" || typeof eventName2 === "symbol", "nanobus.prependOnceListener: eventName should be type string or symbol");
            assert.equal(typeof listener, "function", "nanobus.prependOnceListener: listener should be type function");
            var self2 = this;
            this.prependListener(eventName2, once);
            function once() {
              listener.apply(self2, arguments);
              self2.removeListener(eventName2, once);
            }
            return this;
          };
          Nanobus.prototype.removeListener = function(eventName2, listener) {
            assert.ok(typeof eventName2 === "string" || typeof eventName2 === "symbol", "nanobus.removeListener: eventName should be type string or symbol");
            assert.equal(typeof listener, "function", "nanobus.removeListener: listener should be type function");
            if (eventName2 === "*") {
              this._starListeners = this._starListeners.slice();
              return remove2(this._starListeners, listener);
            } else {
              if (typeof this._listeners[eventName2] !== "undefined") {
                this._listeners[eventName2] = this._listeners[eventName2].slice();
              }
              return remove2(this._listeners[eventName2], listener);
            }
            function remove2(arr, listener2) {
              if (!arr)
                return;
              var index = arr.indexOf(listener2);
              if (index !== -1) {
                splice(arr, index, 1);
                return true;
              }
            }
          };
          Nanobus.prototype.removeAllListeners = function(eventName2) {
            if (eventName2) {
              if (eventName2 === "*") {
                this._starListeners = [];
              } else {
                this._listeners[eventName2] = [];
              }
            } else {
              this._starListeners = [];
              this._listeners = {};
            }
            return this;
          };
          Nanobus.prototype.listeners = function(eventName2) {
            var listeners = eventName2 !== "*" ? this._listeners[eventName2] : this._starListeners;
            var ret = [];
            if (listeners) {
              var ilength = listeners.length;
              for (var i2 = 0; i2 < ilength; i2++)
                ret.push(listeners[i2]);
            }
            return ret;
          };
          Nanobus.prototype._emit = function(arr, eventName2, data2, uuid) {
            if (typeof arr === "undefined")
              return;
            if (arr.length === 0)
              return;
            if (data2 === void 0) {
              data2 = eventName2;
              eventName2 = null;
            }
            if (eventName2) {
              if (uuid !== void 0) {
                data2 = [eventName2].concat(data2, uuid);
              } else {
                data2 = [eventName2].concat(data2);
              }
            }
            var length2 = arr.length;
            for (var i2 = 0; i2 < length2; i2++) {
              var listener = arr[i2];
              listener.apply(listener, data2);
            }
          };
        },
        /* 140 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var assert = __webpack_require__(34);
          var hasWindow = typeof window !== "undefined";
          function createScheduler() {
            var scheduler;
            if (hasWindow) {
              if (!window._nanoScheduler)
                window._nanoScheduler = new NanoScheduler(true);
              scheduler = window._nanoScheduler;
            } else {
              scheduler = new NanoScheduler();
            }
            return scheduler;
          }
          function NanoScheduler(hasWindow2) {
            this.hasWindow = hasWindow2;
            this.hasIdle = this.hasWindow && window.requestIdleCallback;
            this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout;
            this.scheduled = false;
            this.queue = [];
          }
          NanoScheduler.prototype.push = function(cb) {
            assert.equal(typeof cb, "function", "nanoscheduler.push: cb should be type function");
            this.queue.push(cb);
            this.schedule();
          };
          NanoScheduler.prototype.schedule = function() {
            if (this.scheduled)
              return;
            this.scheduled = true;
            var self2 = this;
            this.method(function(idleDeadline) {
              var cb;
              while (self2.queue.length && idleDeadline.timeRemaining() > 0) {
                cb = self2.queue.shift();
                cb(idleDeadline);
              }
              self2.scheduled = false;
              if (self2.queue.length)
                self2.schedule();
            });
          };
          NanoScheduler.prototype.setTimeout = function(cb) {
            setTimeout(cb, 0, {
              timeRemaining: function() {
                return 1;
              }
            });
          };
          module3.exports = createScheduler;
        },
        /* 141 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var scheduler = __webpack_require__(140)();
          var assert = __webpack_require__(34);
          var perf2;
          nanotiming.disabled = true;
          try {
            perf2 = window.performance;
            nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === "true" || !perf2.mark;
          } catch (e) {
          }
          module3.exports = nanotiming;
          function nanotiming(name) {
            assert.equal(typeof name, "string", "nanotiming: name should be type string");
            if (nanotiming.disabled)
              return noop2;
            var uuid = (perf2.now() * 1e4).toFixed() % Number.MAX_SAFE_INTEGER;
            var startName = "start-" + uuid + "-" + name;
            perf2.mark(startName);
            function end(cb) {
              var endName = "end-" + uuid + "-" + name;
              perf2.mark(endName);
              scheduler.push(function() {
                var err = null;
                try {
                  var measureName = name + " [" + uuid + "]";
                  perf2.measure(measureName, startName, endName);
                  perf2.clearMarks(startName);
                  perf2.clearMarks(endName);
                } catch (e) {
                  err = e;
                }
                if (cb)
                  cb(err, name);
              });
            }
            end.uuid = uuid;
            return end;
          }
          function noop2(cb) {
            if (cb) {
              scheduler.push(function() {
                cb(new Error("nanotiming: performance API unavailable"));
              });
            }
          }
        },
        /* 142 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(global2) {
            /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
            let promise;
            module3.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global2) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
              throw err;
            }, 0));
          }).call(exports2, __webpack_require__(10));
        },
        /* 143 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(global2, process2) {
            var MAX_BYTES = 65536;
            var MAX_UINT32 = 4294967295;
            function oldBrowser() {
              throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            }
            var Buffer2 = __webpack_require__(66).Buffer;
            var crypto2 = global2.crypto || global2.msCrypto;
            if (crypto2 && crypto2.getRandomValues) {
              module3.exports = randomBytes;
            } else {
              module3.exports = oldBrowser;
            }
            function randomBytes(size2, cb) {
              if (size2 > MAX_UINT32)
                throw new RangeError("requested too many random bytes");
              var bytes = Buffer2.allocUnsafe(size2);
              if (size2 > 0) {
                if (size2 > MAX_BYTES) {
                  for (var generated = 0; generated < size2; generated += MAX_BYTES) {
                    crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
                  }
                } else {
                  crypto2.getRandomValues(bytes);
                }
              }
              if (typeof cb === "function") {
                return process2.nextTick(function() {
                  cb(null, bytes);
                });
              }
              return bytes;
            }
          }).call(exports2, __webpack_require__(10), __webpack_require__(2));
        },
        /* 144 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = PassThrough;
          var Transform = __webpack_require__(61);
          __webpack_require__(7)(PassThrough, Transform);
          function PassThrough(options) {
            if (!(this instanceof PassThrough))
              return new PassThrough(options);
            Transform.call(this, options);
          }
          PassThrough.prototype._transform = function(chunk2, encoding, cb) {
            cb(null, chunk2);
          };
        },
        /* 145 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            var _Object$setPrototypeO;
            function _defineProperty(obj, key, value2) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value2;
              }
              return obj;
            }
            var finished = __webpack_require__(36);
            var kLastResolve = Symbol("lastResolve");
            var kLastReject = Symbol("lastReject");
            var kError = Symbol("error");
            var kEnded = Symbol("ended");
            var kLastPromise = Symbol("lastPromise");
            var kHandlePromise = Symbol("handlePromise");
            var kStream = Symbol("stream");
            function createIterResult(value2, done) {
              return {
                value: value2,
                done
              };
            }
            function readAndResolve(iter) {
              var resolve2 = iter[kLastResolve];
              if (resolve2 !== null) {
                var data2 = iter[kStream].read();
                if (data2 !== null) {
                  iter[kLastPromise] = null;
                  iter[kLastResolve] = null;
                  iter[kLastReject] = null;
                  resolve2(createIterResult(data2, false));
                }
              }
            }
            function onReadable(iter) {
              process2.nextTick(readAndResolve, iter);
            }
            function wrapForNext(lastPromise, iter) {
              return function(resolve2, reject) {
                lastPromise.then(function() {
                  if (iter[kEnded]) {
                    resolve2(createIterResult(void 0, true));
                    return;
                  }
                  iter[kHandlePromise](resolve2, reject);
                }, reject);
              };
            }
            var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
            });
            var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
              get stream() {
                return this[kStream];
              },
              next: function next() {
                var _this = this;
                var error = this[kError];
                if (error !== null) {
                  return Promise.reject(error);
                }
                if (this[kEnded]) {
                  return Promise.resolve(createIterResult(void 0, true));
                }
                if (this[kStream].destroyed) {
                  return new Promise(function(resolve2, reject) {
                    process2.nextTick(function() {
                      if (_this[kError]) {
                        reject(_this[kError]);
                      } else {
                        resolve2(createIterResult(void 0, true));
                      }
                    });
                  });
                }
                var lastPromise = this[kLastPromise];
                var promise;
                if (lastPromise) {
                  promise = new Promise(wrapForNext(lastPromise, this));
                } else {
                  var data2 = this[kStream].read();
                  if (data2 !== null) {
                    return Promise.resolve(createIterResult(data2, false));
                  }
                  promise = new Promise(this[kHandlePromise]);
                }
                this[kLastPromise] = promise;
                return promise;
              }
            }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
              return this;
            }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
              var _this2 = this;
              return new Promise(function(resolve2, reject) {
                _this2[kStream].destroy(null, function(err) {
                  if (err) {
                    reject(err);
                    return;
                  }
                  resolve2(createIterResult(void 0, true));
                });
              });
            }), _Object$setPrototypeO), AsyncIteratorPrototype);
            var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
              var _Object$create;
              var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                value: stream,
                writable: true
              }), _defineProperty(_Object$create, kLastResolve, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kLastReject, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kError, {
                value: null,
                writable: true
              }), _defineProperty(_Object$create, kEnded, {
                value: stream._readableState.endEmitted,
                writable: true
              }), _defineProperty(_Object$create, kHandlePromise, {
                value: function value2(resolve2, reject) {
                  var data2 = iterator[kStream].read();
                  if (data2) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve2(createIterResult(data2, false));
                  } else {
                    iterator[kLastResolve] = resolve2;
                    iterator[kLastReject] = reject;
                  }
                },
                writable: true
              }), _Object$create));
              iterator[kLastPromise] = null;
              finished(stream, function(err) {
                if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                  var reject = iterator[kLastReject];
                  if (reject !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    reject(err);
                  }
                  iterator[kError] = err;
                  return;
                }
                var resolve2 = iterator[kLastResolve];
                if (resolve2 !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve2(createIterResult(void 0, true));
                }
                iterator[kEnded] = true;
              });
              stream.on("readable", onReadable.bind(null, iterator));
              return iterator;
            };
            module3.exports = createReadableStreamAsyncIterator;
          }).call(exports2, __webpack_require__(2));
        },
        /* 146 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function ownKeys2(object, enumerableOnly) {
            var keys2 = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys2.push.apply(keys2, symbols);
            }
            return keys2;
          }
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              if (i2 % 2) {
                ownKeys2(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys2(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value2) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value2;
            }
            return obj;
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          var _require = __webpack_require__(5), Buffer2 = _require.Buffer;
          var _require2 = __webpack_require__(173), inspect2 = _require2.inspect;
          var custom = inspect2 && inspect2.custom || "inspect";
          function copyBuffer(src, target, offset2) {
            Buffer2.prototype.copy.call(src, target, offset2);
          }
          module3.exports = /* @__PURE__ */ function() {
            function BufferList() {
              _classCallCheck(this, BufferList);
              this.head = null;
              this.tail = null;
              this.length = 0;
            }
            _createClass(BufferList, [{
              key: "push",
              value: function push(v) {
                var entry = {
                  data: v,
                  next: null
                };
                if (this.length > 0)
                  this.tail.next = entry;
                else
                  this.head = entry;
                this.tail = entry;
                ++this.length;
              }
            }, {
              key: "unshift",
              value: function unshift(v) {
                var entry = {
                  data: v,
                  next: this.head
                };
                if (this.length === 0)
                  this.tail = entry;
                this.head = entry;
                ++this.length;
              }
            }, {
              key: "shift",
              value: function shift() {
                if (this.length === 0)
                  return;
                var ret = this.head.data;
                if (this.length === 1)
                  this.head = this.tail = null;
                else
                  this.head = this.head.next;
                --this.length;
                return ret;
              }
            }, {
              key: "clear",
              value: function clear2() {
                this.head = this.tail = null;
                this.length = 0;
              }
            }, {
              key: "join",
              value: function join(s) {
                if (this.length === 0)
                  return "";
                var p2 = this.head;
                var ret = "" + p2.data;
                while (p2 = p2.next) {
                  ret += s + p2.data;
                }
                return ret;
              }
            }, {
              key: "concat",
              value: function concat(n) {
                if (this.length === 0)
                  return Buffer2.alloc(0);
                var ret = Buffer2.allocUnsafe(n >>> 0);
                var p2 = this.head;
                var i2 = 0;
                while (p2) {
                  copyBuffer(p2.data, ret, i2);
                  i2 += p2.data.length;
                  p2 = p2.next;
                }
                return ret;
              }
              // Consumes a specified amount of bytes or characters from the buffered data.
            }, {
              key: "consume",
              value: function consume(n, hasStrings) {
                var ret;
                if (n < this.head.data.length) {
                  ret = this.head.data.slice(0, n);
                  this.head.data = this.head.data.slice(n);
                } else if (n === this.head.data.length) {
                  ret = this.shift();
                } else {
                  ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                }
                return ret;
              }
            }, {
              key: "first",
              value: function first() {
                return this.head.data;
              }
              // Consumes a specified amount of characters from the buffered data.
            }, {
              key: "_getString",
              value: function _getString(n) {
                var p2 = this.head;
                var c = 1;
                var ret = p2.data;
                n -= ret.length;
                while (p2 = p2.next) {
                  var str = p2.data;
                  var nb = n > str.length ? str.length : n;
                  if (nb === str.length)
                    ret += str;
                  else
                    ret += str.slice(0, n);
                  n -= nb;
                  if (n === 0) {
                    if (nb === str.length) {
                      ++c;
                      if (p2.next)
                        this.head = p2.next;
                      else
                        this.head = this.tail = null;
                    } else {
                      this.head = p2;
                      p2.data = str.slice(nb);
                    }
                    break;
                  }
                  ++c;
                }
                this.length -= c;
                return ret;
              }
              // Consumes a specified amount of bytes from the buffered data.
            }, {
              key: "_getBuffer",
              value: function _getBuffer(n) {
                var ret = Buffer2.allocUnsafe(n);
                var p2 = this.head;
                var c = 1;
                p2.data.copy(ret);
                n -= p2.data.length;
                while (p2 = p2.next) {
                  var buf = p2.data;
                  var nb = n > buf.length ? buf.length : n;
                  buf.copy(ret, ret.length - n, 0, nb);
                  n -= nb;
                  if (n === 0) {
                    if (nb === buf.length) {
                      ++c;
                      if (p2.next)
                        this.head = p2.next;
                      else
                        this.head = this.tail = null;
                    } else {
                      this.head = p2;
                      p2.data = buf.slice(nb);
                    }
                    break;
                  }
                  ++c;
                }
                this.length -= c;
                return ret;
              }
              // Make sure the linked list only shows the minimal necessary information.
            }, {
              key: custom,
              value: function value2(_, options) {
                return inspect2(this, _objectSpread({}, options, {
                  // Only inspect one level.
                  depth: 0,
                  // It should not recurse.
                  customInspect: false
                }));
              }
            }]);
            return BufferList;
          }();
        },
        /* 147 */
        /***/
        function(module3, exports2) {
          module3.exports = function() {
            throw new Error("Readable.from is not available in the browser");
          };
        },
        /* 148 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var eos;
          function once(callback) {
            var called = false;
            return function() {
              if (called)
                return;
              called = true;
              callback.apply(void 0, arguments);
            };
          }
          var _require$codes = __webpack_require__(8).codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
          function noop2(err) {
            if (err)
              throw err;
          }
          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          }
          function destroyer(stream, reading, writing, callback) {
            callback = once(callback);
            var closed = false;
            stream.on("close", function() {
              closed = true;
            });
            if (eos === void 0)
              eos = __webpack_require__(36);
            eos(stream, {
              readable: reading,
              writable: writing
            }, function(err) {
              if (err)
                return callback(err);
              closed = true;
              callback();
            });
            var destroyed = false;
            return function(err) {
              if (closed)
                return;
              if (destroyed)
                return;
              destroyed = true;
              if (isRequest(stream))
                return stream.abort();
              if (typeof stream.destroy === "function")
                return stream.destroy();
              callback(err || new ERR_STREAM_DESTROYED("pipe"));
            };
          }
          function call(fn) {
            fn();
          }
          function pipe(from2, to2) {
            return from2.pipe(to2);
          }
          function popCallback(streams) {
            if (!streams.length)
              return noop2;
            if (typeof streams[streams.length - 1] !== "function")
              return noop2;
            return streams.pop();
          }
          function pipeline() {
            for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
              streams[_key] = arguments[_key];
            }
            var callback = popCallback(streams);
            if (Array.isArray(streams[0]))
              streams = streams[0];
            if (streams.length < 2) {
              throw new ERR_MISSING_ARGS("streams");
            }
            var error;
            var destroys = streams.map(function(stream, i2) {
              var reading = i2 < streams.length - 1;
              var writing = i2 > 0;
              return destroyer(stream, reading, writing, function(err) {
                if (!error)
                  error = err;
                if (err)
                  destroys.forEach(call);
                if (reading)
                  return;
                destroys.forEach(call);
                callback(error);
              });
            });
            return streams.reduce(pipe);
          }
          module3.exports = pipeline;
        },
        /* 149 */
        /***/
        function(module3, exports2, __webpack_require__) {
          exports2 = module3.exports = __webpack_require__(60);
          exports2.Stream = exports2;
          exports2.Readable = exports2;
          exports2.Writable = __webpack_require__(62);
          exports2.Duplex = __webpack_require__(9);
          exports2.Transform = __webpack_require__(61);
          exports2.PassThrough = __webpack_require__(144);
          exports2.finished = __webpack_require__(36);
          exports2.pipeline = __webpack_require__(148);
        },
        /* 150 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var g = function() {
            return this;
          }() || Function("return this")();
          var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
          var oldRuntime = hadRuntime && g.regeneratorRuntime;
          g.regeneratorRuntime = void 0;
          module3.exports = __webpack_require__(151);
          if (hadRuntime) {
            g.regeneratorRuntime = oldRuntime;
          } else {
            try {
              delete g.regeneratorRuntime;
            } catch (e) {
              g.regeneratorRuntime = void 0;
            }
          }
        },
        /* 151 */
        /***/
        function(module3, exports2) {
          !function(global2) {
            var Op = Object.prototype;
            var hasOwn2 = Op.hasOwnProperty;
            var undefined$1;
            var $Symbol = typeof Symbol === "function" ? Symbol : {};
            var iteratorSymbol = $Symbol.iterator || "@@iterator";
            var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
            var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
            var inModule = typeof module3 === "object";
            var runtime = global2.regeneratorRuntime;
            if (runtime) {
              if (inModule) {
                module3.exports = runtime;
              }
              return;
            }
            runtime = global2.regeneratorRuntime = inModule ? module3.exports : {};
            function wrap(innerFn, outerFn, self2, tryLocsList) {
              var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
              var generator = Object.create(protoGenerator.prototype);
              var context = new Context(tryLocsList || []);
              generator._invoke = makeInvokeMethod(innerFn, self2, context);
              return generator;
            }
            runtime.wrap = wrap;
            function tryCatch(fn, obj, arg) {
              try {
                return { type: "normal", arg: fn.call(obj, arg) };
              } catch (err) {
                return { type: "throw", arg: err };
              }
            }
            var GenStateSuspendedStart = "suspendedStart";
            var GenStateSuspendedYield = "suspendedYield";
            var GenStateExecuting = "executing";
            var GenStateCompleted = "completed";
            var ContinueSentinel = {};
            function Generator() {
            }
            function GeneratorFunction() {
            }
            function GeneratorFunctionPrototype() {
            }
            var IteratorPrototype = {};
            IteratorPrototype[iteratorSymbol] = function() {
              return this;
            };
            var getProto2 = Object.getPrototypeOf;
            var NativeIteratorPrototype = getProto2 && getProto2(getProto2(values([])));
            if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol)) {
              IteratorPrototype = NativeIteratorPrototype;
            }
            var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
            GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
            GeneratorFunctionPrototype.constructor = GeneratorFunction;
            GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
            function defineIteratorMethods(prototype2) {
              ["next", "throw", "return"].forEach(function(method) {
                prototype2[method] = function(arg) {
                  return this._invoke(method, arg);
                };
              });
            }
            runtime.isGeneratorFunction = function(genFun) {
              var ctor = typeof genFun === "function" && genFun.constructor;
              return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
              // do is to check its .name property.
              (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
            };
            runtime.mark = function(genFun) {
              if (Object.setPrototypeOf) {
                Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
              } else {
                genFun.__proto__ = GeneratorFunctionPrototype;
                if (!(toStringTagSymbol in genFun)) {
                  genFun[toStringTagSymbol] = "GeneratorFunction";
                }
              }
              genFun.prototype = Object.create(Gp);
              return genFun;
            };
            runtime.awrap = function(arg) {
              return { __await: arg };
            };
            function AsyncIterator(generator) {
              function invoke(method, arg, resolve2, reject) {
                var record = tryCatch(generator[method], generator, arg);
                if (record.type === "throw") {
                  reject(record.arg);
                } else {
                  var result = record.arg;
                  var value2 = result.value;
                  if (value2 && typeof value2 === "object" && hasOwn2.call(value2, "__await")) {
                    return Promise.resolve(value2.__await).then(function(value3) {
                      invoke("next", value3, resolve2, reject);
                    }, function(err) {
                      invoke("throw", err, resolve2, reject);
                    });
                  }
                  return Promise.resolve(value2).then(function(unwrapped) {
                    result.value = unwrapped;
                    resolve2(result);
                  }, reject);
                }
              }
              var previousPromise;
              function enqueue(method, arg) {
                function callInvokeWithMethodAndArg() {
                  return new Promise(function(resolve2, reject) {
                    invoke(method, arg, resolve2, reject);
                  });
                }
                return previousPromise = // If enqueue has been called before, then we want to wait until
                // all previous Promises have been resolved before calling invoke,
                // so that results are always delivered in the correct order. If
                // enqueue has not been called before, then it is important to
                // call invoke immediately, without waiting on a callback to fire,
                // so that the async generator function has the opportunity to do
                // any necessary setup in a predictable way. This predictability
                // is why the Promise constructor synchronously invokes its
                // executor callback, and why async functions synchronously
                // execute code before the first await. Since we implement simple
                // async functions in terms of async generators, it is especially
                // important to get this right, even though it requires care.
                previousPromise ? previousPromise.then(
                  callInvokeWithMethodAndArg,
                  // Avoid propagating failures to Promises returned by later
                  // invocations of the iterator.
                  callInvokeWithMethodAndArg
                ) : callInvokeWithMethodAndArg();
              }
              this._invoke = enqueue;
            }
            defineIteratorMethods(AsyncIterator.prototype);
            AsyncIterator.prototype[asyncIteratorSymbol] = function() {
              return this;
            };
            runtime.AsyncIterator = AsyncIterator;
            runtime.async = function(innerFn, outerFn, self2, tryLocsList) {
              var iter = new AsyncIterator(
                wrap(innerFn, outerFn, self2, tryLocsList)
              );
              return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
                return result.done ? result.value : iter.next();
              });
            };
            function makeInvokeMethod(innerFn, self2, context) {
              var state2 = GenStateSuspendedStart;
              return function invoke(method, arg) {
                if (state2 === GenStateExecuting) {
                  throw new Error("Generator is already running");
                }
                if (state2 === GenStateCompleted) {
                  if (method === "throw") {
                    throw arg;
                  }
                  return doneResult();
                }
                context.method = method;
                context.arg = arg;
                while (true) {
                  var delegate = context.delegate;
                  if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                      if (delegateResult === ContinueSentinel)
                        continue;
                      return delegateResult;
                    }
                  }
                  if (context.method === "next") {
                    context.sent = context._sent = context.arg;
                  } else if (context.method === "throw") {
                    if (state2 === GenStateSuspendedStart) {
                      state2 = GenStateCompleted;
                      throw context.arg;
                    }
                    context.dispatchException(context.arg);
                  } else if (context.method === "return") {
                    context.abrupt("return", context.arg);
                  }
                  state2 = GenStateExecuting;
                  var record = tryCatch(innerFn, self2, context);
                  if (record.type === "normal") {
                    state2 = context.done ? GenStateCompleted : GenStateSuspendedYield;
                    if (record.arg === ContinueSentinel) {
                      continue;
                    }
                    return {
                      value: record.arg,
                      done: context.done
                    };
                  } else if (record.type === "throw") {
                    state2 = GenStateCompleted;
                    context.method = "throw";
                    context.arg = record.arg;
                  }
                }
              };
            }
            function maybeInvokeDelegate(delegate, context) {
              var method = delegate.iterator[context.method];
              if (method === undefined$1) {
                context.delegate = null;
                if (context.method === "throw") {
                  if (delegate.iterator.return) {
                    context.method = "return";
                    context.arg = undefined$1;
                    maybeInvokeDelegate(delegate, context);
                    if (context.method === "throw") {
                      return ContinueSentinel;
                    }
                  }
                  context.method = "throw";
                  context.arg = new TypeError(
                    "The iterator does not provide a 'throw' method"
                  );
                }
                return ContinueSentinel;
              }
              var record = tryCatch(method, delegate.iterator, context.arg);
              if (record.type === "throw") {
                context.method = "throw";
                context.arg = record.arg;
                context.delegate = null;
                return ContinueSentinel;
              }
              var info = record.arg;
              if (!info) {
                context.method = "throw";
                context.arg = new TypeError("iterator result is not an object");
                context.delegate = null;
                return ContinueSentinel;
              }
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
                if (context.method !== "return") {
                  context.method = "next";
                  context.arg = undefined$1;
                }
              } else {
                return info;
              }
              context.delegate = null;
              return ContinueSentinel;
            }
            defineIteratorMethods(Gp);
            Gp[toStringTagSymbol] = "Generator";
            Gp[iteratorSymbol] = function() {
              return this;
            };
            Gp.toString = function() {
              return "[object Generator]";
            };
            function pushTryEntry(locs) {
              var entry = { tryLoc: locs[0] };
              if (1 in locs) {
                entry.catchLoc = locs[1];
              }
              if (2 in locs) {
                entry.finallyLoc = locs[2];
                entry.afterLoc = locs[3];
              }
              this.tryEntries.push(entry);
            }
            function resetTryEntry(entry) {
              var record = entry.completion || {};
              record.type = "normal";
              delete record.arg;
              entry.completion = record;
            }
            function Context(tryLocsList) {
              this.tryEntries = [{ tryLoc: "root" }];
              tryLocsList.forEach(pushTryEntry, this);
              this.reset(true);
            }
            runtime.keys = function(object) {
              var keys2 = [];
              for (var key in object) {
                keys2.push(key);
              }
              keys2.reverse();
              return function next() {
                while (keys2.length) {
                  var key2 = keys2.pop();
                  if (key2 in object) {
                    next.value = key2;
                    next.done = false;
                    return next;
                  }
                }
                next.done = true;
                return next;
              };
            };
            function values(iterable) {
              if (iterable) {
                var iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) {
                  return iteratorMethod.call(iterable);
                }
                if (typeof iterable.next === "function") {
                  return iterable;
                }
                if (!isNaN(iterable.length)) {
                  var i2 = -1, next = function next2() {
                    while (++i2 < iterable.length) {
                      if (hasOwn2.call(iterable, i2)) {
                        next2.value = iterable[i2];
                        next2.done = false;
                        return next2;
                      }
                    }
                    next2.value = undefined$1;
                    next2.done = true;
                    return next2;
                  };
                  return next.next = next;
                }
              }
              return { next: doneResult };
            }
            runtime.values = values;
            function doneResult() {
              return { value: undefined$1, done: true };
            }
            Context.prototype = {
              constructor: Context,
              reset: function(skipTempReset) {
                this.prev = 0;
                this.next = 0;
                this.sent = this._sent = undefined$1;
                this.done = false;
                this.delegate = null;
                this.method = "next";
                this.arg = undefined$1;
                this.tryEntries.forEach(resetTryEntry);
                if (!skipTempReset) {
                  for (var name in this) {
                    if (name.charAt(0) === "t" && hasOwn2.call(this, name) && !isNaN(+name.slice(1))) {
                      this[name] = undefined$1;
                    }
                  }
                }
              },
              stop: function() {
                this.done = true;
                var rootEntry = this.tryEntries[0];
                var rootRecord = rootEntry.completion;
                if (rootRecord.type === "throw") {
                  throw rootRecord.arg;
                }
                return this.rval;
              },
              dispatchException: function(exception) {
                if (this.done) {
                  throw exception;
                }
                var context = this;
                function handle(loc, caught) {
                  record.type = "throw";
                  record.arg = exception;
                  context.next = loc;
                  if (caught) {
                    context.method = "next";
                    context.arg = undefined$1;
                  }
                  return !!caught;
                }
                for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
                  var entry = this.tryEntries[i2];
                  var record = entry.completion;
                  if (entry.tryLoc === "root") {
                    return handle("end");
                  }
                  if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn2.call(entry, "catchLoc");
                    var hasFinally = hasOwn2.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                      if (this.prev < entry.catchLoc) {
                        return handle(entry.catchLoc, true);
                      } else if (this.prev < entry.finallyLoc) {
                        return handle(entry.finallyLoc);
                      }
                    } else if (hasCatch) {
                      if (this.prev < entry.catchLoc) {
                        return handle(entry.catchLoc, true);
                      }
                    } else if (hasFinally) {
                      if (this.prev < entry.finallyLoc) {
                        return handle(entry.finallyLoc);
                      }
                    } else {
                      throw new Error("try statement without catch or finally");
                    }
                  }
                }
              },
              abrupt: function(type, arg) {
                for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
                  var entry = this.tryEntries[i2];
                  if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                  }
                }
                if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                  finallyEntry = null;
                }
                var record = finallyEntry ? finallyEntry.completion : {};
                record.type = type;
                record.arg = arg;
                if (finallyEntry) {
                  this.method = "next";
                  this.next = finallyEntry.finallyLoc;
                  return ContinueSentinel;
                }
                return this.complete(record);
              },
              complete: function(record, afterLoc) {
                if (record.type === "throw") {
                  throw record.arg;
                }
                if (record.type === "break" || record.type === "continue") {
                  this.next = record.arg;
                } else if (record.type === "return") {
                  this.rval = this.arg = record.arg;
                  this.method = "return";
                  this.next = "end";
                } else if (record.type === "normal" && afterLoc) {
                  this.next = afterLoc;
                }
                return ContinueSentinel;
              },
              finish: function(finallyLoc) {
                for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
                  var entry = this.tryEntries[i2];
                  if (entry.finallyLoc === finallyLoc) {
                    this.complete(entry.completion, entry.afterLoc);
                    resetTryEntry(entry);
                    return ContinueSentinel;
                  }
                }
              },
              "catch": function(tryLoc) {
                for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
                  var entry = this.tryEntries[i2];
                  if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if (record.type === "throw") {
                      var thrown = record.arg;
                      resetTryEntry(entry);
                    }
                    return thrown;
                  }
                }
                throw new Error("illegal catch attempt");
              },
              delegateYield: function(iterable, resultName, nextLoc) {
                this.delegate = {
                  iterator: values(iterable),
                  resultName,
                  nextLoc
                };
                if (this.method === "next") {
                  this.arg = undefined$1;
                }
                return ContinueSentinel;
              }
            };
          }(
            // In sloppy mode, unbound `this` refers to the global object, fallback to
            // Function constructor if we're in global strict mode. That is sadly a form
            // of indirect eval which violates Content Security Policy.
            function() {
              return this;
            }() || Function("return this")()
          );
        },
        /* 152 */
        /***/
        function(module3, exports2, __webpack_require__) {
          module3.exports = function removeItems(arr, startIdx, removeCount) {
            var i2, length2 = arr.length;
            if (startIdx >= length2 || removeCount === 0) {
              return;
            }
            removeCount = startIdx + removeCount > length2 ? length2 - startIdx : removeCount;
            var len = length2 - removeCount;
            for (i2 = startIdx; i2 < len; ++i2) {
              arr[i2] = arr[i2 + removeCount];
            }
            arr.length = len;
          };
        },
        /* 153 */
        /***/
        function(module3, exports2, __webpack_require__) {
          /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
          const debug = __webpack_require__(154)("simple-peer");
          const getBrowserRTC = __webpack_require__(135);
          const randombytes = __webpack_require__(143);
          const stream = __webpack_require__(149);
          const queueMicrotask2 = __webpack_require__(142);
          const errCode = __webpack_require__(134);
          const { Buffer: Buffer2 } = __webpack_require__(5);
          const MAX_BUFFERED_AMOUNT = 64 * 1024;
          const ICECOMPLETE_TIMEOUT = 5 * 1e3;
          const CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
          function filterTrickle(sdp) {
            return sdp.replace(/a=ice-options:trickle\s\n/g, "");
          }
          function warn2(message) {
            console.warn(message);
          }
          class Peer extends stream.Duplex {
            constructor(opts) {
              opts = Object.assign({
                allowHalfOpen: false
              }, opts);
              super(opts);
              this._id = randombytes(4).toString("hex").slice(0, 7);
              this._debug("new peer %o", opts);
              this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
              this.initiator = opts.initiator || false;
              this.channelConfig = opts.channelConfig || Peer.channelConfig;
              this.channelNegotiated = this.channelConfig.negotiated;
              this.config = Object.assign({}, Peer.config, opts.config);
              this.offerOptions = opts.offerOptions || {};
              this.answerOptions = opts.answerOptions || {};
              this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
              this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
              this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
              this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
              this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
              this.destroyed = false;
              this.destroying = false;
              this._connected = false;
              this.remoteAddress = void 0;
              this.remoteFamily = void 0;
              this.remotePort = void 0;
              this.localAddress = void 0;
              this.localFamily = void 0;
              this.localPort = void 0;
              this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
              if (!this._wrtc) {
                if (typeof window === "undefined") {
                  throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
                } else {
                  throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
                }
              }
              this._pcReady = false;
              this._channelReady = false;
              this._iceComplete = false;
              this._iceCompleteTimer = null;
              this._channel = null;
              this._pendingCandidates = [];
              this._isNegotiating = false;
              this._firstNegotiation = true;
              this._batchedNegotiation = false;
              this._queuedNegotiation = false;
              this._sendersAwaitingStable = [];
              this._senderMap = /* @__PURE__ */ new Map();
              this._closingInterval = null;
              this._remoteTracks = [];
              this._remoteStreams = [];
              this._chunk = null;
              this._cb = null;
              this._interval = null;
              try {
                this._pc = new this._wrtc.RTCPeerConnection(this.config);
              } catch (err) {
                this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
                return;
              }
              this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
              this._pc.oniceconnectionstatechange = () => {
                this._onIceStateChange();
              };
              this._pc.onicegatheringstatechange = () => {
                this._onIceStateChange();
              };
              this._pc.onconnectionstatechange = () => {
                this._onConnectionStateChange();
              };
              this._pc.onsignalingstatechange = () => {
                this._onSignalingStateChange();
              };
              this._pc.onicecandidate = (event) => {
                this._onIceCandidate(event);
              };
              if (typeof this._pc.peerIdentity === "object") {
                this._pc.peerIdentity.catch((err) => {
                  this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
                });
              }
              if (this.initiator || this.channelNegotiated) {
                this._setupData({
                  channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
                });
              } else {
                this._pc.ondatachannel = (event) => {
                  this._setupData(event);
                };
              }
              if (this.streams) {
                this.streams.forEach((stream2) => {
                  this.addStream(stream2);
                });
              }
              this._pc.ontrack = (event) => {
                this._onTrack(event);
              };
              this._debug("initial negotiation");
              this._needsNegotiation();
              this._onFinishBound = () => {
                this._onFinish();
              };
              this.once("finish", this._onFinishBound);
            }
            get bufferSize() {
              return this._channel && this._channel.bufferedAmount || 0;
            }
            // HACK: it's possible channel.readyState is "closing" before peer.destroy() fires
            // https://bugs.chromium.org/p/chromium/issues/detail?id=882743
            get connected() {
              return this._connected && this._channel.readyState === "open";
            }
            address() {
              return { port: this.localPort, family: this.localFamily, address: this.localAddress };
            }
            signal(data2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
              if (typeof data2 === "string") {
                try {
                  data2 = JSON.parse(data2);
                } catch (err) {
                  data2 = {};
                }
              }
              this._debug("signal()");
              if (data2.renegotiate && this.initiator) {
                this._debug("got request to renegotiate");
                this._needsNegotiation();
              }
              if (data2.transceiverRequest && this.initiator) {
                this._debug("got request for transceiver");
                this.addTransceiver(data2.transceiverRequest.kind, data2.transceiverRequest.init);
              }
              if (data2.candidate) {
                if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
                  this._addIceCandidate(data2.candidate);
                } else {
                  this._pendingCandidates.push(data2.candidate);
                }
              }
              if (data2.sdp) {
                this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data2)).then(() => {
                  if (this.destroyed)
                    return;
                  this._pendingCandidates.forEach((candidate) => {
                    this._addIceCandidate(candidate);
                  });
                  this._pendingCandidates = [];
                  if (this._pc.remoteDescription.type === "offer")
                    this._createAnswer();
                }).catch((err) => {
                  this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
                });
              }
              if (!data2.sdp && !data2.candidate && !data2.renegotiate && !data2.transceiverRequest) {
                this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
              }
            }
            _addIceCandidate(candidate) {
              const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
              this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
                if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
                  warn2("Ignoring unsupported ICE candidate.");
                } else {
                  this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
                }
              });
            }
            /**
             * Send text/binary data to the remote peer.
             * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk
             */
            send(chunk2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
              this._channel.send(chunk2);
            }
            /**
             * Add a Transceiver to the connection.
             * @param {String} kind
             * @param {Object} init
             */
            addTransceiver(kind, init) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addTransceiver()");
              if (this.initiator) {
                try {
                  this._pc.addTransceiver(kind, init);
                  this._needsNegotiation();
                } catch (err) {
                  this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
                }
              } else {
                this.emit("signal", {
                  // request initiator to renegotiate
                  type: "transceiverRequest",
                  transceiverRequest: { kind, init }
                });
              }
            }
            /**
             * Add a MediaStream to the connection.
             * @param {MediaStream} stream
             */
            addStream(stream2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addStream()");
              stream2.getTracks().forEach((track2) => {
                this.addTrack(track2, stream2);
              });
            }
            /**
             * Add a MediaStreamTrack to the connection.
             * @param {MediaStreamTrack} track
             * @param {MediaStream} stream
             */
            addTrack(track2, stream2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addTrack()");
              const submap = this._senderMap.get(track2) || /* @__PURE__ */ new Map();
              let sender = submap.get(stream2);
              if (!sender) {
                sender = this._pc.addTrack(track2, stream2);
                submap.set(stream2, sender);
                this._senderMap.set(track2, submap);
                this._needsNegotiation();
              } else if (sender.removed) {
                throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
              } else {
                throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
              }
            }
            /**
             * Replace a MediaStreamTrack by another in the connection.
             * @param {MediaStreamTrack} oldTrack
             * @param {MediaStreamTrack} newTrack
             * @param {MediaStream} stream
             */
            replaceTrack(oldTrack, newTrack, stream2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
              this._debug("replaceTrack()");
              const submap = this._senderMap.get(oldTrack);
              const sender = submap ? submap.get(stream2) : null;
              if (!sender) {
                throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
              }
              if (newTrack)
                this._senderMap.set(newTrack, submap);
              if (sender.replaceTrack != null) {
                sender.replaceTrack(newTrack);
              } else {
                this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
              }
            }
            /**
             * Remove a MediaStreamTrack from the connection.
             * @param {MediaStreamTrack} track
             * @param {MediaStream} stream
             */
            removeTrack(track2, stream2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSender()");
              const submap = this._senderMap.get(track2);
              const sender = submap ? submap.get(stream2) : null;
              if (!sender) {
                throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
              }
              try {
                sender.removed = true;
                this._pc.removeTrack(sender);
              } catch (err) {
                if (err.name === "NS_ERROR_UNEXPECTED") {
                  this._sendersAwaitingStable.push(sender);
                } else {
                  this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
                }
              }
              this._needsNegotiation();
            }
            /**
             * Remove a MediaStream from the connection.
             * @param {MediaStream} stream
             */
            removeStream(stream2) {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSenders()");
              stream2.getTracks().forEach((track2) => {
                this.removeTrack(track2, stream2);
              });
            }
            _needsNegotiation() {
              this._debug("_needsNegotiation");
              if (this._batchedNegotiation)
                return;
              this._batchedNegotiation = true;
              queueMicrotask2(() => {
                this._batchedNegotiation = false;
                if (this.initiator || !this._firstNegotiation) {
                  this._debug("starting batched negotiation");
                  this.negotiate();
                } else {
                  this._debug("non-initiator initial negotiation request discarded");
                }
                this._firstNegotiation = false;
              });
            }
            negotiate() {
              if (this.destroying)
                return;
              if (this.destroyed)
                throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
              if (this.initiator) {
                if (this._isNegotiating) {
                  this._queuedNegotiation = true;
                  this._debug("already negotiating, queueing");
                } else {
                  this._debug("start negotiation");
                  setTimeout(() => {
                    this._createOffer();
                  }, 0);
                }
              } else {
                if (this._isNegotiating) {
                  this._queuedNegotiation = true;
                  this._debug("already negotiating, queueing");
                } else {
                  this._debug("requesting negotiation from initiator");
                  this.emit("signal", {
                    // request initiator to renegotiate
                    type: "renegotiate",
                    renegotiate: true
                  });
                }
              }
              this._isNegotiating = true;
            }
            // TODO: Delete this method once readable-stream is updated to contain a default
            // implementation of destroy() that automatically calls _destroy()
            // See: https://github.com/nodejs/readable-stream/issues/283
            destroy(err) {
              this._destroy(err, () => {
              });
            }
            _destroy(err, cb) {
              if (this.destroyed || this.destroying)
                return;
              this.destroying = true;
              this._debug("destroying (error: %s)", err && (err.message || err));
              queueMicrotask2(() => {
                this.destroyed = true;
                this.destroying = false;
                this._debug("destroy (error: %s)", err && (err.message || err));
                this.readable = this.writable = false;
                if (!this._readableState.ended)
                  this.push(null);
                if (!this._writableState.finished)
                  this.end();
                this._connected = false;
                this._pcReady = false;
                this._channelReady = false;
                this._remoteTracks = null;
                this._remoteStreams = null;
                this._senderMap = null;
                clearInterval(this._closingInterval);
                this._closingInterval = null;
                clearInterval(this._interval);
                this._interval = null;
                this._chunk = null;
                this._cb = null;
                if (this._onFinishBound)
                  this.removeListener("finish", this._onFinishBound);
                this._onFinishBound = null;
                if (this._channel) {
                  try {
                    this._channel.close();
                  } catch (err2) {
                  }
                  this._channel.onmessage = null;
                  this._channel.onopen = null;
                  this._channel.onclose = null;
                  this._channel.onerror = null;
                }
                if (this._pc) {
                  try {
                    this._pc.close();
                  } catch (err2) {
                  }
                  this._pc.oniceconnectionstatechange = null;
                  this._pc.onicegatheringstatechange = null;
                  this._pc.onsignalingstatechange = null;
                  this._pc.onicecandidate = null;
                  this._pc.ontrack = null;
                  this._pc.ondatachannel = null;
                }
                this._pc = null;
                this._channel = null;
                if (err)
                  this.emit("error", err);
                this.emit("close");
                cb();
              });
            }
            _setupData(event) {
              if (!event.channel) {
                return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
              }
              this._channel = event.channel;
              this._channel.binaryType = "arraybuffer";
              if (typeof this._channel.bufferedAmountLowThreshold === "number") {
                this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
              }
              this.channelName = this._channel.label;
              this._channel.onmessage = (event2) => {
                this._onChannelMessage(event2);
              };
              this._channel.onbufferedamountlow = () => {
                this._onChannelBufferedAmountLow();
              };
              this._channel.onopen = () => {
                this._onChannelOpen();
              };
              this._channel.onclose = () => {
                this._onChannelClose();
              };
              this._channel.onerror = (event2) => {
                const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
                this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
              };
              let isClosing = false;
              this._closingInterval = setInterval(() => {
                if (this._channel && this._channel.readyState === "closing") {
                  if (isClosing)
                    this._onChannelClose();
                  isClosing = true;
                } else {
                  isClosing = false;
                }
              }, CHANNEL_CLOSING_TIMEOUT);
            }
            _read() {
            }
            _write(chunk2, encoding, cb) {
              if (this.destroyed)
                return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
              if (this._connected) {
                try {
                  this.send(chunk2);
                } catch (err) {
                  return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
                }
                if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                  this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
                  this._cb = cb;
                } else {
                  cb(null);
                }
              } else {
                this._debug("write before connect");
                this._chunk = chunk2;
                this._cb = cb;
              }
            }
            // When stream finishes writing, close socket. Half open connections are not
            // supported.
            _onFinish() {
              if (this.destroyed)
                return;
              const destroySoon = () => {
                setTimeout(() => this.destroy(), 1e3);
              };
              if (this._connected) {
                destroySoon();
              } else {
                this.once("connect", destroySoon);
              }
            }
            _startIceCompleteTimeout() {
              if (this.destroyed)
                return;
              if (this._iceCompleteTimer)
                return;
              this._debug("started iceComplete timeout");
              this._iceCompleteTimer = setTimeout(() => {
                if (!this._iceComplete) {
                  this._iceComplete = true;
                  this._debug("iceComplete timeout completed");
                  this.emit("iceTimeout");
                  this.emit("_iceComplete");
                }
              }, this.iceCompleteTimeout);
            }
            _createOffer() {
              if (this.destroyed)
                return;
              this._pc.createOffer(this.offerOptions).then((offer) => {
                if (this.destroyed)
                  return;
                if (!this.trickle && !this.allowHalfTrickle)
                  offer.sdp = filterTrickle(offer.sdp);
                offer.sdp = this.sdpTransform(offer.sdp);
                const sendOffer = () => {
                  if (this.destroyed)
                    return;
                  const signal = this._pc.localDescription || offer;
                  this._debug("signal");
                  this.emit("signal", {
                    type: signal.type,
                    sdp: signal.sdp
                  });
                };
                const onSuccess = () => {
                  this._debug("createOffer success");
                  if (this.destroyed)
                    return;
                  if (this.trickle || this._iceComplete)
                    sendOffer();
                  else
                    this.once("_iceComplete", sendOffer);
                };
                const onError = (err) => {
                  this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
                };
                this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
              }).catch((err) => {
                this.destroy(errCode(err, "ERR_CREATE_OFFER"));
              });
            }
            _requestMissingTransceivers() {
              if (this._pc.getTransceivers) {
                this._pc.getTransceivers().forEach((transceiver) => {
                  if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
                    transceiver.requested = true;
                    this.addTransceiver(transceiver.sender.track.kind);
                  }
                });
              }
            }
            _createAnswer() {
              if (this.destroyed)
                return;
              this._pc.createAnswer(this.answerOptions).then((answer) => {
                if (this.destroyed)
                  return;
                if (!this.trickle && !this.allowHalfTrickle)
                  answer.sdp = filterTrickle(answer.sdp);
                answer.sdp = this.sdpTransform(answer.sdp);
                const sendAnswer = () => {
                  if (this.destroyed)
                    return;
                  const signal = this._pc.localDescription || answer;
                  this._debug("signal");
                  this.emit("signal", {
                    type: signal.type,
                    sdp: signal.sdp
                  });
                  if (!this.initiator)
                    this._requestMissingTransceivers();
                };
                const onSuccess = () => {
                  if (this.destroyed)
                    return;
                  if (this.trickle || this._iceComplete)
                    sendAnswer();
                  else
                    this.once("_iceComplete", sendAnswer);
                };
                const onError = (err) => {
                  this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
                };
                this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
              }).catch((err) => {
                this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
              });
            }
            _onConnectionStateChange() {
              if (this.destroyed)
                return;
              if (this._pc.connectionState === "failed") {
                this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
              }
            }
            _onIceStateChange() {
              if (this.destroyed)
                return;
              const iceConnectionState = this._pc.iceConnectionState;
              const iceGatheringState = this._pc.iceGatheringState;
              this._debug(
                "iceStateChange (connection: %s) (gathering: %s)",
                iceConnectionState,
                iceGatheringState
              );
              this.emit("iceStateChange", iceConnectionState, iceGatheringState);
              if (iceConnectionState === "connected" || iceConnectionState === "completed") {
                this._pcReady = true;
                this._maybeReady();
              }
              if (iceConnectionState === "failed") {
                this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
              }
              if (iceConnectionState === "closed") {
                this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
              }
            }
            getStats(cb) {
              const flattenValues = (report) => {
                if (Object.prototype.toString.call(report.values) === "[object Array]") {
                  report.values.forEach((value2) => {
                    Object.assign(report, value2);
                  });
                }
                return report;
              };
              if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
                this._pc.getStats().then((res) => {
                  const reports = [];
                  res.forEach((report) => {
                    reports.push(flattenValues(report));
                  });
                  cb(null, reports);
                }, (err) => cb(err));
              } else if (this._pc.getStats.length > 0) {
                this._pc.getStats((res) => {
                  if (this.destroyed)
                    return;
                  const reports = [];
                  res.result().forEach((result) => {
                    const report = {};
                    result.names().forEach((name) => {
                      report[name] = result.stat(name);
                    });
                    report.id = result.id;
                    report.type = result.type;
                    report.timestamp = result.timestamp;
                    reports.push(flattenValues(report));
                  });
                  cb(null, reports);
                }, (err) => cb(err));
              } else {
                cb(null, []);
              }
            }
            _maybeReady() {
              this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
              if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
                return;
              this._connecting = true;
              const findCandidatePair = () => {
                if (this.destroyed)
                  return;
                this.getStats((err, items) => {
                  if (this.destroyed)
                    return;
                  if (err)
                    items = [];
                  const remoteCandidates = {};
                  const localCandidates = {};
                  const candidatePairs = {};
                  let foundSelectedCandidatePair = false;
                  items.forEach((item) => {
                    if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                      remoteCandidates[item.id] = item;
                    }
                    if (item.type === "localcandidate" || item.type === "local-candidate") {
                      localCandidates[item.id] = item;
                    }
                    if (item.type === "candidatepair" || item.type === "candidate-pair") {
                      candidatePairs[item.id] = item;
                    }
                  });
                  const setSelectedCandidatePair = (selectedCandidatePair) => {
                    foundSelectedCandidatePair = true;
                    let local = localCandidates[selectedCandidatePair.localCandidateId];
                    if (local && (local.ip || local.address)) {
                      this.localAddress = local.ip || local.address;
                      this.localPort = Number(local.port);
                    } else if (local && local.ipAddress) {
                      this.localAddress = local.ipAddress;
                      this.localPort = Number(local.portNumber);
                    } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                      local = selectedCandidatePair.googLocalAddress.split(":");
                      this.localAddress = local[0];
                      this.localPort = Number(local[1]);
                    }
                    if (this.localAddress) {
                      this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
                    }
                    let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
                    if (remote && (remote.ip || remote.address)) {
                      this.remoteAddress = remote.ip || remote.address;
                      this.remotePort = Number(remote.port);
                    } else if (remote && remote.ipAddress) {
                      this.remoteAddress = remote.ipAddress;
                      this.remotePort = Number(remote.portNumber);
                    } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                      remote = selectedCandidatePair.googRemoteAddress.split(":");
                      this.remoteAddress = remote[0];
                      this.remotePort = Number(remote[1]);
                    }
                    if (this.remoteAddress) {
                      this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
                    }
                    this._debug(
                      "connect local: %s:%s remote: %s:%s",
                      this.localAddress,
                      this.localPort,
                      this.remoteAddress,
                      this.remotePort
                    );
                  };
                  items.forEach((item) => {
                    if (item.type === "transport" && item.selectedCandidatePairId) {
                      setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
                    }
                    if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                      setSelectedCandidatePair(item);
                    }
                  });
                  if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
                    setTimeout(findCandidatePair, 100);
                    return;
                  } else {
                    this._connecting = false;
                    this._connected = true;
                  }
                  if (this._chunk) {
                    try {
                      this.send(this._chunk);
                    } catch (err2) {
                      return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
                    }
                    this._chunk = null;
                    this._debug('sent chunk from "write before connect"');
                    const cb = this._cb;
                    this._cb = null;
                    cb(null);
                  }
                  if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
                    this._interval = setInterval(() => this._onInterval(), 150);
                    if (this._interval.unref)
                      this._interval.unref();
                  }
                  this._debug("connect");
                  this.emit("connect");
                });
              };
              findCandidatePair();
            }
            _onInterval() {
              if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                return;
              }
              this._onChannelBufferedAmountLow();
            }
            _onSignalingStateChange() {
              if (this.destroyed)
                return;
              if (this._pc.signalingState === "stable") {
                this._isNegotiating = false;
                this._debug("flushing sender queue", this._sendersAwaitingStable);
                this._sendersAwaitingStable.forEach((sender) => {
                  this._pc.removeTrack(sender);
                  this._queuedNegotiation = true;
                });
                this._sendersAwaitingStable = [];
                if (this._queuedNegotiation) {
                  this._debug("flushing negotiation queue");
                  this._queuedNegotiation = false;
                  this._needsNegotiation();
                } else {
                  this._debug("negotiated");
                  this.emit("negotiated");
                }
              }
              this._debug("signalingStateChange %s", this._pc.signalingState);
              this.emit("signalingStateChange", this._pc.signalingState);
            }
            _onIceCandidate(event) {
              if (this.destroyed)
                return;
              if (event.candidate && this.trickle) {
                this.emit("signal", {
                  type: "candidate",
                  candidate: {
                    candidate: event.candidate.candidate,
                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                    sdpMid: event.candidate.sdpMid
                  }
                });
              } else if (!event.candidate && !this._iceComplete) {
                this._iceComplete = true;
                this.emit("_iceComplete");
              }
              if (event.candidate) {
                this._startIceCompleteTimeout();
              }
            }
            _onChannelMessage(event) {
              if (this.destroyed)
                return;
              let data2 = event.data;
              if (data2 instanceof ArrayBuffer)
                data2 = Buffer2.from(data2);
              this.push(data2);
            }
            _onChannelBufferedAmountLow() {
              if (this.destroyed || !this._cb)
                return;
              this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              const cb = this._cb;
              this._cb = null;
              cb(null);
            }
            _onChannelOpen() {
              if (this._connected || this.destroyed)
                return;
              this._debug("on channel open");
              this._channelReady = true;
              this._maybeReady();
            }
            _onChannelClose() {
              if (this.destroyed)
                return;
              this._debug("on channel close");
              this.destroy();
            }
            _onTrack(event) {
              if (this.destroyed)
                return;
              event.streams.forEach((eventStream) => {
                this._debug("on track");
                this.emit("track", event.track, eventStream);
                this._remoteTracks.push({
                  track: event.track,
                  stream: eventStream
                });
                if (this._remoteStreams.some((remoteStream) => {
                  return remoteStream.id === eventStream.id;
                }))
                  return;
                this._remoteStreams.push(eventStream);
                queueMicrotask2(() => {
                  this._debug("on stream");
                  this.emit("stream", eventStream);
                });
              });
            }
            _debug() {
              const args = [].slice.call(arguments);
              args[0] = "[" + this._id + "] " + args[0];
              debug.apply(null, args);
            }
          }
          Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
          Peer.config = {
            iceServers: [
              {
                urls: [
                  "stun:stun.l.google.com:19302",
                  "stun:global.stun.twilio.com:3478"
                ]
              }
            ],
            sdpSemantics: "unified-plan"
          };
          Peer.channelConfig = {};
          module3.exports = Peer;
        },
        /* 154 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            exports2.formatArgs = formatArgs;
            exports2.save = save;
            exports2.load = load;
            exports2.useColors = useColors;
            exports2.storage = localstorage();
            exports2.destroy = (() => {
              let warned = false;
              return () => {
                if (!warned) {
                  warned = true;
                  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
              };
            })();
            exports2.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33"
            ];
            function useColors() {
              if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
              }
              if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
              }
              return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
              typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
              // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            function formatArgs(args) {
              args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff);
              if (!this.useColors) {
                return;
              }
              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              let index = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index++;
                if (match === "%c") {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }
            exports2.log = console.debug || console.log || (() => {
            });
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports2.storage.setItem("debug", namespaces);
                } else {
                  exports2.storage.removeItem("debug");
                }
              } catch (error) {
              }
            }
            function load() {
              let r;
              try {
                r = exports2.storage.getItem("debug");
              } catch (error) {
              }
              if (!r && typeof process2 !== "undefined" && "env" in process2) {
                r = __webpack_require__.i({ "NODE_ENV": "production" }).DEBUG;
              }
              return r;
            }
            function localstorage() {
              try {
                return localStorage;
              } catch (error) {
              }
            }
            module3.exports = __webpack_require__(155)(exports2);
            const { formatters } = module3.exports;
            formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(exports2, __webpack_require__(2));
        },
        /* 155 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(156);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key) => {
              createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
              let hash = 0;
              for (let i2 = 0; i2 < namespace.length; i2++) {
                hash = (hash << 5) - hash + namespace.charCodeAt(i2);
                hash |= 0;
              }
              return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
              let prevTime;
              let enableOverride = null;
              function debug(...args) {
                if (!debug.enabled) {
                  return;
                }
                const self2 = debug;
                const curr = Number(/* @__PURE__ */ new Date());
                const ms = curr - (prevTime || curr);
                self2.diff = ms;
                self2.prev = prevTime;
                self2.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== "string") {
                  args.unshift("%O");
                }
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                  if (match === "%%") {
                    return "%";
                  }
                  index++;
                  const formatter = createDebug.formatters[format2];
                  if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self2, val);
                    args.splice(index, 1);
                    index--;
                  }
                  return match;
                });
                createDebug.formatArgs.call(self2, args);
                const logFn = self2.log || createDebug.log;
                logFn.apply(self2, args);
              }
              debug.namespace = namespace;
              debug.useColors = createDebug.useColors();
              debug.color = createDebug.selectColor(namespace);
              debug.extend = extend2;
              debug.destroy = createDebug.destroy;
              Object.defineProperty(debug, "enabled", {
                enumerable: true,
                configurable: false,
                get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
                set: (v) => {
                  enableOverride = v;
                }
              });
              if (typeof createDebug.init === "function") {
                createDebug.init(debug);
              }
              return debug;
            }
            function extend2(namespace, delimiter) {
              const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
              newDebug.log = this.log;
              return newDebug;
            }
            function enable(namespaces) {
              createDebug.save(namespaces);
              createDebug.names = [];
              createDebug.skips = [];
              let i2;
              const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
              const len = split.length;
              for (i2 = 0; i2 < len; i2++) {
                if (!split[i2]) {
                  continue;
                }
                namespaces = split[i2].replace(/\*/g, ".*?");
                if (namespaces[0] === "-") {
                  createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
                } else {
                  createDebug.names.push(new RegExp("^" + namespaces + "$"));
                }
              }
            }
            function disable() {
              const namespaces = [
                ...createDebug.names.map(toNamespace),
                ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
              ].join(",");
              createDebug.enable("");
              return namespaces;
            }
            function enabled(name) {
              if (name[name.length - 1] === "*") {
                return true;
              }
              let i2;
              let len;
              for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
                if (createDebug.skips[i2].test(name)) {
                  return false;
                }
              }
              for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
                if (createDebug.names[i2].test(name)) {
                  return true;
                }
              }
              return false;
            }
            function toNamespace(regexp) {
              return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function coerce(val) {
              if (val instanceof Error) {
                return val.stack || val.message;
              }
              return val;
            }
            function destroy() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
          }
          module3.exports = setup;
        },
        /* 156 */
        /***/
        function(module3, exports2) {
          var s = 1e3;
          var m = s * 60;
          var h2 = m * 60;
          var d = h2 * 24;
          var w2 = d * 7;
          var y = d * 365.25;
          module3.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
              return parse2(val);
            } else if (type === "number" && isFinite(val)) {
              return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error(
              "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
            );
          };
          function parse2(str) {
            str = String(str);
            if (str.length > 100) {
              return;
            }
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              str
            );
            if (!match) {
              return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;
              case "weeks":
              case "week":
              case "w":
                return n * w2;
              case "days":
              case "day":
              case "d":
                return n * d;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h2;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;
              default:
                return void 0;
            }
          }
          function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return Math.round(ms / d) + "d";
            }
            if (msAbs >= h2) {
              return Math.round(ms / h2) + "h";
            }
            if (msAbs >= m) {
              return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
              return Math.round(ms / s) + "s";
            }
            return ms + "ms";
          }
          function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h2) {
              return plural(ms, msAbs, h2, "hour");
            }
            if (msAbs >= m) {
              return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
              return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
          }
          function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
          }
        },
        /* 157 */
        /***/
        function(module3, exports2, __webpack_require__) {
          const cuid = __webpack_require__(121);
          const inherits2 = __webpack_require__(7);
          const EventEmitter = __webpack_require__(139);
          const SimplePeer = __webpack_require__(153);
          inherits2(SimpleSignalClient, EventEmitter);
          const ERR_CONNECTION_TIMEOUT = "ERR_CONNECTION_TIMEOUT";
          const ERR_PREMATURE_CLOSE = "ERR_PREMATURE_CLOSE";
          function SimpleSignalClient(socket2, options = {}) {
            if (!(this instanceof SimpleSignalClient))
              return new SimpleSignalClient(socket2);
            EventEmitter.call(this);
            const { connectionTimeout = 10 * 1e3 } = options;
            this.id = null;
            this.socket = socket2;
            this._connectionTimeout = connectionTimeout;
            this._peers = {};
            this._sessionQueues = {};
            this._timers = /* @__PURE__ */ new Map();
            this.socket.on("simple-signal[discover]", this._onDiscover.bind(this));
            this.socket.on("simple-signal[offer]", this._onOffer.bind(this));
            this.socket.on("simple-signal[signal]", this._onSignal.bind(this));
            this.socket.on("simple-signal[reject]", this._onReject.bind(this));
          }
          SimpleSignalClient.prototype._onDiscover = function(data2) {
            this.id = data2.id;
            this.emit("discover", data2.discoveryData);
          };
          SimpleSignalClient.prototype._onOffer = function({ initiator, metadata, sessionId, signal }) {
            this._sessionQueues[sessionId] = [signal];
            const request2 = { initiator, metadata, sessionId };
            request2.accept = this._accept.bind(this, request2);
            request2.reject = this._reject.bind(this, request2);
            this.emit("request", request2);
          };
          SimpleSignalClient.prototype._accept = function(request2, metadata = {}, peerOptions = {}) {
            peerOptions.initiator = false;
            const peer = this._peers[request2.sessionId] = new SimplePeer(peerOptions);
            peer.on("signal", (signal) => {
              this.socket.emit("simple-signal[signal]", {
                signal,
                metadata,
                sessionId: request2.sessionId,
                target: request2.initiator
              });
            });
            peer.once("close", () => {
              this._closePeer(request2.sessionId);
            });
            this._sessionQueues[request2.sessionId].forEach((signal) => {
              peer.signal(signal);
            });
            delete this._sessionQueues[request2.sessionId];
            return new Promise((resolve2, reject) => {
              this._onSafeConnect(peer, () => {
                this._clearTimer(request2.sessionId);
                resolve2({ peer, metadata: request2.metadata });
              });
              peer.once("close", () => {
                reject({ metadata: { code: ERR_PREMATURE_CLOSE } });
              });
              this._startTimer(request2.sessionId, (metadata2) => {
                reject({ metadata: metadata2 });
                this._closePeer(request2.sessionId);
              });
            });
          };
          SimpleSignalClient.prototype._reject = function(request2, metadata = {}) {
            delete this._sessionQueues[request2.sessionId];
            this._clearTimer(request2.sessionId);
            this.socket.emit("simple-signal[reject]", {
              metadata,
              sessionId: request2.sessionId,
              target: request2.initiator
            });
          };
          SimpleSignalClient.prototype._onReject = function({ sessionId, metadata }) {
            const peer = this._peers[sessionId];
            if (peer)
              peer.reject(metadata);
          };
          SimpleSignalClient.prototype._onSignal = function({ sessionId, signal, metadata }) {
            const peer = this._peers[sessionId];
            if (peer) {
              peer.signal(signal);
              if (metadata !== void 0 && peer.resolveMetadata)
                peer.resolveMetadata(metadata);
            } else {
              this._sessionQueues[sessionId] = this._sessionQueues[sessionId] || [];
              this._sessionQueues[sessionId].push(signal);
            }
          };
          SimpleSignalClient.prototype.connect = function(target, metadata = {}, peerOptions = {}) {
            if (!this.id)
              throw new Error("Must complete discovery first.");
            peerOptions.initiator = true;
            const sessionId = cuid();
            var firstOffer = true;
            const peer = this._peers[sessionId] = new SimplePeer(peerOptions);
            peer.once("close", () => {
              this._closePeer(sessionId);
            });
            peer.on("signal", (signal) => {
              const messageType = signal.sdp && firstOffer ? "simple-signal[offer]" : "simple-signal[signal]";
              if (signal.sdp)
                firstOffer = false;
              this.socket.emit(messageType, {
                signal,
                metadata,
                sessionId,
                target
              });
            });
            return new Promise((resolve2, reject) => {
              peer.resolveMetadata = (metadata2) => {
                peer.resolveMetadata = null;
                this._onSafeConnect(peer, () => {
                  this._clearTimer(sessionId);
                  resolve2({ peer, metadata: metadata2 });
                });
              };
              peer.reject = (metadata2) => {
                reject({ metadata: metadata2 });
                this._closePeer(sessionId);
              };
              peer.once("close", () => {
                reject({ metadata: { code: ERR_PREMATURE_CLOSE } });
              });
              this._startTimer(sessionId, (metadata2) => peer.reject(metadata2));
            });
          };
          SimpleSignalClient.prototype._onSafeConnect = function(peer, callback) {
            const cachedEvents = [];
            function streamHandler(stream) {
              cachedEvents.push({ name: "stream", args: [stream] });
            }
            function trackHandler(track2, stream) {
              cachedEvents.push({ name: "track", args: [track2, stream] });
            }
            peer.on("stream", streamHandler);
            peer.on("track", trackHandler);
            peer.once("connect", () => {
              setTimeout(() => {
                peer.emit("connect");
                setTimeout(() => {
                  cachedEvents.forEach(({ name, args }) => {
                    peer.emit(name, ...args);
                  });
                }, 0);
              }, 0);
              peer.removeListener("stream", streamHandler);
              peer.removeListener("track", trackHandler);
              callback(peer);
            });
          };
          SimpleSignalClient.prototype._closePeer = function(sessionId) {
            const peer = this._peers[sessionId];
            this._clearTimer(sessionId);
            delete this._peers[sessionId];
            if (peer)
              peer.destroy();
          };
          SimpleSignalClient.prototype._startTimer = function(sessionId, cb) {
            if (this._connectionTimeout !== -1) {
              const timer = setTimeout(() => {
                this._clearTimer(sessionId);
                cb({ code: ERR_CONNECTION_TIMEOUT });
              }, this._connectionTimeout);
              this._timers.set(sessionId, timer);
            }
          };
          SimpleSignalClient.prototype._clearTimer = function(sessionId) {
            if (this._timers.has(sessionId)) {
              clearTimeout(this._timers.get(sessionId));
              this._timers.delete(sessionId);
            }
          };
          SimpleSignalClient.prototype.discover = function(discoveryData = {}) {
            this.socket.emit("simple-signal[discover]", discoveryData);
          };
          SimpleSignalClient.prototype.peers = function() {
            return Object.values(this._peers);
          };
          SimpleSignalClient.prototype.destroy = function() {
            this.socket.close();
            this.peers().forEach((peer) => peer.destroy());
            this.id = null;
            this.socket = null;
            this._peers = null;
            this._sessionQueues = null;
          };
          module3.exports = SimpleSignalClient;
          module3.exports.SimplePeer = SimplePeer;
          module3.exports.ERR_CONNECTION_TIMEOUT = ERR_CONNECTION_TIMEOUT;
          module3.exports.ERR_PREMATURE_CLOSE = ERR_PREMATURE_CLOSE;
        },
        /* 158 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.io = exports2.Socket = exports2.Manager = exports2.protocol = void 0;
          const url_1 = __webpack_require__(159);
          const manager_1 = __webpack_require__(67);
          const debug = __webpack_require__(24)("socket.io-client");
          module3.exports = exports2 = lookup2;
          const cache2 = exports2.managers = {};
          function lookup2(uri, opts) {
            if (typeof uri === "object") {
              opts = uri;
              uri = void 0;
            }
            opts = opts || {};
            const parsed = url_1.url(uri, opts.path || "/socket.io");
            const source = parsed.source;
            const id = parsed.id;
            const path = parsed.path;
            const sameNamespace = cache2[id] && path in cache2[id]["nsps"];
            const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
            let io;
            if (newConnection) {
              debug("ignoring socket cache for %s", source);
              io = new manager_1.Manager(source, opts);
            } else {
              if (!cache2[id]) {
                debug("new io instance for %s", source);
                cache2[id] = new manager_1.Manager(source, opts);
              }
              io = cache2[id];
            }
            if (parsed.query && !opts.query) {
              opts.query = parsed.queryKey;
            }
            return io.socket(parsed.path, opts);
          }
          exports2.io = lookup2;
          var socket_io_parser_1 = __webpack_require__(37);
          Object.defineProperty(exports2, "protocol", { enumerable: true, get: function() {
            return socket_io_parser_1.protocol;
          } });
          exports2.connect = lookup2;
          var manager_2 = __webpack_require__(67);
          Object.defineProperty(exports2, "Manager", { enumerable: true, get: function() {
            return manager_2.Manager;
          } });
          var socket_1 = __webpack_require__(69);
          Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
            return socket_1.Socket;
          } });
          exports2.default = lookup2;
        },
        /* 159 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.url = void 0;
          const parseuri = __webpack_require__(59);
          const debug = __webpack_require__(24)("socket.io-client:url");
          function url2(uri, path = "", loc) {
            let obj = uri;
            loc = loc || typeof location !== "undefined" && location;
            if (null == uri)
              uri = loc.protocol + "//" + loc.host;
            if (typeof uri === "string") {
              if ("/" === uri.charAt(0)) {
                if ("/" === uri.charAt(1)) {
                  uri = loc.protocol + uri;
                } else {
                  uri = loc.host + uri;
                }
              }
              if (!/^(https?|wss?):\/\//.test(uri)) {
                debug("protocol-less url %s", uri);
                if ("undefined" !== typeof loc) {
                  uri = loc.protocol + "//" + uri;
                } else {
                  uri = "https://" + uri;
                }
              }
              debug("parse %s", uri);
              obj = parseuri(uri);
            }
            if (!obj.port) {
              if (/^(http|ws)$/.test(obj.protocol)) {
                obj.port = "80";
              } else if (/^(http|ws)s$/.test(obj.protocol)) {
                obj.port = "443";
              }
            }
            obj.path = obj.path || "/";
            const ipv6 = obj.host.indexOf(":") !== -1;
            const host = ipv6 ? "[" + obj.host + "]" : obj.host;
            obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
            obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
            return obj;
          }
          exports2.url = url2;
        },
        /* 160 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(161);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key) => {
              createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
              let hash = 0;
              for (let i2 = 0; i2 < namespace.length; i2++) {
                hash = (hash << 5) - hash + namespace.charCodeAt(i2);
                hash |= 0;
              }
              return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
              let prevTime;
              let enableOverride = null;
              function debug(...args) {
                if (!debug.enabled) {
                  return;
                }
                const self2 = debug;
                const curr = Number(/* @__PURE__ */ new Date());
                const ms = curr - (prevTime || curr);
                self2.diff = ms;
                self2.prev = prevTime;
                self2.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== "string") {
                  args.unshift("%O");
                }
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                  if (match === "%%") {
                    return "%";
                  }
                  index++;
                  const formatter = createDebug.formatters[format2];
                  if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self2, val);
                    args.splice(index, 1);
                    index--;
                  }
                  return match;
                });
                createDebug.formatArgs.call(self2, args);
                const logFn = self2.log || createDebug.log;
                logFn.apply(self2, args);
              }
              debug.namespace = namespace;
              debug.useColors = createDebug.useColors();
              debug.color = createDebug.selectColor(namespace);
              debug.extend = extend2;
              debug.destroy = createDebug.destroy;
              Object.defineProperty(debug, "enabled", {
                enumerable: true,
                configurable: false,
                get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
                set: (v) => {
                  enableOverride = v;
                }
              });
              if (typeof createDebug.init === "function") {
                createDebug.init(debug);
              }
              return debug;
            }
            function extend2(namespace, delimiter) {
              const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
              newDebug.log = this.log;
              return newDebug;
            }
            function enable(namespaces) {
              createDebug.save(namespaces);
              createDebug.names = [];
              createDebug.skips = [];
              let i2;
              const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
              const len = split.length;
              for (i2 = 0; i2 < len; i2++) {
                if (!split[i2]) {
                  continue;
                }
                namespaces = split[i2].replace(/\*/g, ".*?");
                if (namespaces[0] === "-") {
                  createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
                } else {
                  createDebug.names.push(new RegExp("^" + namespaces + "$"));
                }
              }
            }
            function disable() {
              const namespaces = [
                ...createDebug.names.map(toNamespace),
                ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
              ].join(",");
              createDebug.enable("");
              return namespaces;
            }
            function enabled(name) {
              if (name[name.length - 1] === "*") {
                return true;
              }
              let i2;
              let len;
              for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
                if (createDebug.skips[i2].test(name)) {
                  return false;
                }
              }
              for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
                if (createDebug.names[i2].test(name)) {
                  return true;
                }
              }
              return false;
            }
            function toNamespace(regexp) {
              return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function coerce(val) {
              if (val instanceof Error) {
                return val.stack || val.message;
              }
              return val;
            }
            function destroy() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
          }
          module3.exports = setup;
        },
        /* 161 */
        /***/
        function(module3, exports2) {
          var s = 1e3;
          var m = s * 60;
          var h2 = m * 60;
          var d = h2 * 24;
          var w2 = d * 7;
          var y = d * 365.25;
          module3.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
              return parse2(val);
            } else if (type === "number" && isFinite(val)) {
              return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error(
              "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
            );
          };
          function parse2(str) {
            str = String(str);
            if (str.length > 100) {
              return;
            }
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              str
            );
            if (!match) {
              return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;
              case "weeks":
              case "week":
              case "w":
                return n * w2;
              case "days":
              case "day":
              case "d":
                return n * d;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h2;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;
              default:
                return void 0;
            }
          }
          function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return Math.round(ms / d) + "d";
            }
            if (msAbs >= h2) {
              return Math.round(ms / h2) + "h";
            }
            if (msAbs >= m) {
              return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
              return Math.round(ms / s) + "s";
            }
            return ms + "ms";
          }
          function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h2) {
              return plural(ms, msAbs, h2, "hour");
            }
            if (msAbs >= m) {
              return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
              return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
          }
          function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
          }
        },
        /* 162 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.reconstructPacket = exports2.deconstructPacket = void 0;
          const is_binary_1 = __webpack_require__(71);
          function deconstructPacket2(packet) {
            const buffers = [];
            const packetData = packet.data;
            const pack = packet;
            pack.data = _deconstructPacket2(packetData, buffers);
            pack.attachments = buffers.length;
            return { packet: pack, buffers };
          }
          exports2.deconstructPacket = deconstructPacket2;
          function _deconstructPacket2(data2, buffers) {
            if (!data2)
              return data2;
            if (is_binary_1.isBinary(data2)) {
              const placeholder = { _placeholder: true, num: buffers.length };
              buffers.push(data2);
              return placeholder;
            } else if (Array.isArray(data2)) {
              const newData = new Array(data2.length);
              for (let i2 = 0; i2 < data2.length; i2++) {
                newData[i2] = _deconstructPacket2(data2[i2], buffers);
              }
              return newData;
            } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
              const newData = {};
              for (const key in data2) {
                if (data2.hasOwnProperty(key)) {
                  newData[key] = _deconstructPacket2(data2[key], buffers);
                }
              }
              return newData;
            }
            return data2;
          }
          function reconstructPacket2(packet, buffers) {
            packet.data = _reconstructPacket2(packet.data, buffers);
            packet.attachments = void 0;
            return packet;
          }
          exports2.reconstructPacket = reconstructPacket2;
          function _reconstructPacket2(data2, buffers) {
            if (!data2)
              return data2;
            if (data2 && data2._placeholder) {
              return buffers[data2.num];
            } else if (Array.isArray(data2)) {
              for (let i2 = 0; i2 < data2.length; i2++) {
                data2[i2] = _reconstructPacket2(data2[i2], buffers);
              }
            } else if (typeof data2 === "object") {
              for (const key in data2) {
                if (data2.hasOwnProperty(key)) {
                  data2[key] = _reconstructPacket2(data2[key], buffers);
                }
              }
            }
            return data2;
          }
        },
        /* 163 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(process2) {
            exports2.formatArgs = formatArgs;
            exports2.save = save;
            exports2.load = load;
            exports2.useColors = useColors;
            exports2.storage = localstorage();
            exports2.destroy = (() => {
              let warned = false;
              return () => {
                if (!warned) {
                  warned = true;
                  console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                }
              };
            })();
            exports2.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33"
            ];
            function useColors() {
              if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                return true;
              }
              if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                return false;
              }
              return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
              typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
              // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
              typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }
            function formatArgs(args) {
              args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module3.exports.humanize(this.diff);
              if (!this.useColors) {
                return;
              }
              const c = "color: " + this.color;
              args.splice(1, 0, c, "color: inherit");
              let index = 0;
              let lastC = 0;
              args[0].replace(/%[a-zA-Z%]/g, (match) => {
                if (match === "%%") {
                  return;
                }
                index++;
                if (match === "%c") {
                  lastC = index;
                }
              });
              args.splice(lastC, 0, c);
            }
            exports2.log = console.debug || console.log || (() => {
            });
            function save(namespaces) {
              try {
                if (namespaces) {
                  exports2.storage.setItem("debug", namespaces);
                } else {
                  exports2.storage.removeItem("debug");
                }
              } catch (error) {
              }
            }
            function load() {
              let r;
              try {
                r = exports2.storage.getItem("debug");
              } catch (error) {
              }
              if (!r && typeof process2 !== "undefined" && "env" in process2) {
                r = __webpack_require__.i({ "NODE_ENV": "production" }).DEBUG;
              }
              return r;
            }
            function localstorage() {
              try {
                return localStorage;
              } catch (error) {
              }
            }
            module3.exports = __webpack_require__(164)(exports2);
            const { formatters } = module3.exports;
            formatters.j = function(v) {
              try {
                return JSON.stringify(v);
              } catch (error) {
                return "[UnexpectedJSONParseError]: " + error.message;
              }
            };
          }).call(exports2, __webpack_require__(2));
        },
        /* 164 */
        /***/
        function(module3, exports2, __webpack_require__) {
          function setup(env) {
            createDebug.debug = createDebug;
            createDebug.default = createDebug;
            createDebug.coerce = coerce;
            createDebug.disable = disable;
            createDebug.enable = enable;
            createDebug.enabled = enabled;
            createDebug.humanize = __webpack_require__(165);
            createDebug.destroy = destroy;
            Object.keys(env).forEach((key) => {
              createDebug[key] = env[key];
            });
            createDebug.names = [];
            createDebug.skips = [];
            createDebug.formatters = {};
            function selectColor(namespace) {
              let hash = 0;
              for (let i2 = 0; i2 < namespace.length; i2++) {
                hash = (hash << 5) - hash + namespace.charCodeAt(i2);
                hash |= 0;
              }
              return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            createDebug.selectColor = selectColor;
            function createDebug(namespace) {
              let prevTime;
              let enableOverride = null;
              function debug(...args) {
                if (!debug.enabled) {
                  return;
                }
                const self2 = debug;
                const curr = Number(/* @__PURE__ */ new Date());
                const ms = curr - (prevTime || curr);
                self2.diff = ms;
                self2.prev = prevTime;
                self2.curr = curr;
                prevTime = curr;
                args[0] = createDebug.coerce(args[0]);
                if (typeof args[0] !== "string") {
                  args.unshift("%O");
                }
                let index = 0;
                args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                  if (match === "%%") {
                    return "%";
                  }
                  index++;
                  const formatter = createDebug.formatters[format2];
                  if (typeof formatter === "function") {
                    const val = args[index];
                    match = formatter.call(self2, val);
                    args.splice(index, 1);
                    index--;
                  }
                  return match;
                });
                createDebug.formatArgs.call(self2, args);
                const logFn = self2.log || createDebug.log;
                logFn.apply(self2, args);
              }
              debug.namespace = namespace;
              debug.useColors = createDebug.useColors();
              debug.color = createDebug.selectColor(namespace);
              debug.extend = extend2;
              debug.destroy = createDebug.destroy;
              Object.defineProperty(debug, "enabled", {
                enumerable: true,
                configurable: false,
                get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
                set: (v) => {
                  enableOverride = v;
                }
              });
              if (typeof createDebug.init === "function") {
                createDebug.init(debug);
              }
              return debug;
            }
            function extend2(namespace, delimiter) {
              const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
              newDebug.log = this.log;
              return newDebug;
            }
            function enable(namespaces) {
              createDebug.save(namespaces);
              createDebug.names = [];
              createDebug.skips = [];
              let i2;
              const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
              const len = split.length;
              for (i2 = 0; i2 < len; i2++) {
                if (!split[i2]) {
                  continue;
                }
                namespaces = split[i2].replace(/\*/g, ".*?");
                if (namespaces[0] === "-") {
                  createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
                } else {
                  createDebug.names.push(new RegExp("^" + namespaces + "$"));
                }
              }
            }
            function disable() {
              const namespaces = [
                ...createDebug.names.map(toNamespace),
                ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
              ].join(",");
              createDebug.enable("");
              return namespaces;
            }
            function enabled(name) {
              if (name[name.length - 1] === "*") {
                return true;
              }
              let i2;
              let len;
              for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
                if (createDebug.skips[i2].test(name)) {
                  return false;
                }
              }
              for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
                if (createDebug.names[i2].test(name)) {
                  return true;
                }
              }
              return false;
            }
            function toNamespace(regexp) {
              return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function coerce(val) {
              if (val instanceof Error) {
                return val.stack || val.message;
              }
              return val;
            }
            function destroy() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            createDebug.enable(createDebug.load());
            return createDebug;
          }
          module3.exports = setup;
        },
        /* 165 */
        /***/
        function(module3, exports2) {
          var s = 1e3;
          var m = s * 60;
          var h2 = m * 60;
          var d = h2 * 24;
          var w2 = d * 7;
          var y = d * 365.25;
          module3.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if (type === "string" && val.length > 0) {
              return parse2(val);
            } else if (type === "number" && isFinite(val)) {
              return options.long ? fmtLong(val) : fmtShort(val);
            }
            throw new Error(
              "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
            );
          };
          function parse2(str) {
            str = String(str);
            if (str.length > 100) {
              return;
            }
            var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              str
            );
            if (!match) {
              return;
            }
            var n = parseFloat(match[1]);
            var type = (match[2] || "ms").toLowerCase();
            switch (type) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return n * y;
              case "weeks":
              case "week":
              case "w":
                return n * w2;
              case "days":
              case "day":
              case "d":
                return n * d;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return n * h2;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return n * m;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return n * s;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return n;
              default:
                return void 0;
            }
          }
          function fmtShort(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return Math.round(ms / d) + "d";
            }
            if (msAbs >= h2) {
              return Math.round(ms / h2) + "h";
            }
            if (msAbs >= m) {
              return Math.round(ms / m) + "m";
            }
            if (msAbs >= s) {
              return Math.round(ms / s) + "s";
            }
            return ms + "ms";
          }
          function fmtLong(ms) {
            var msAbs = Math.abs(ms);
            if (msAbs >= d) {
              return plural(ms, msAbs, d, "day");
            }
            if (msAbs >= h2) {
              return plural(ms, msAbs, h2, "hour");
            }
            if (msAbs >= m) {
              return plural(ms, msAbs, m, "minute");
            }
            if (msAbs >= s) {
              return plural(ms, msAbs, s, "second");
            }
            return ms + " ms";
          }
          function plural(ms, msAbs, n, name) {
            var isPlural = msAbs >= n * 1.5;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
          }
        },
        /* 166 */
        /***/
        function(module3, exports2, __webpack_require__) {
          (function(global2) {
            module3.exports = deprecate2;
            function deprecate2(fn, msg) {
              if (config("noDeprecation")) {
                return fn;
              }
              var warned = false;
              function deprecated() {
                if (!warned) {
                  if (config("throwDeprecation")) {
                    throw new Error(msg);
                  } else if (config("traceDeprecation")) {
                    console.trace(msg);
                  } else {
                    console.warn(msg);
                  }
                  warned = true;
                }
                return fn.apply(this, arguments);
              }
              return deprecated;
            }
            function config(name) {
              try {
                if (!global2.localStorage)
                  return false;
              } catch (_) {
                return false;
              }
              var val = global2.localStorage[name];
              if (null == val)
                return false;
              return String(val).toLowerCase() === "true";
            }
          }).call(exports2, __webpack_require__(10));
        },
        /* 167 */
        /***/
        function(module3, exports2) {
          module3.exports = function normalizeComponent(rawScriptExports, compiledTemplate, scopeId, cssModules) {
            var esModule;
            var scriptExports = rawScriptExports = rawScriptExports || {};
            var type = typeof rawScriptExports.default;
            if (type === "object" || type === "function") {
              esModule = rawScriptExports;
              scriptExports = rawScriptExports.default;
            }
            var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
            if (compiledTemplate) {
              options.render = compiledTemplate.render;
              options.staticRenderFns = compiledTemplate.staticRenderFns;
            }
            if (scopeId) {
              options._scopeId = scopeId;
            }
            if (cssModules) {
              var computed2 = Object.create(options.computed || null);
              Object.keys(cssModules).forEach(function(key) {
                var module4 = cssModules[key];
                computed2[key] = function() {
                  return module4;
                };
              });
              options.computed = computed2;
            }
            return {
              esModule,
              exports: scriptExports,
              options
            };
          };
        },
        /* 168 */
        /***/
        function(module3, exports2) {
          module3.exports = { render: function() {
            var _vm = this;
            var _h = _vm.$createElement;
            var _c = _vm._self._c || _h;
            return _c("div", {
              staticClass: "video-list"
            }, _vm._l(_vm.videoList, function(item) {
              return _c("div", {
                key: item.id,
                staticClass: "video-item",
                attrs: {
                  "video": item
                }
              }, [_c("video", {
                ref: "videos",
                refInFor: true,
                attrs: {
                  "controls": "",
                  "autoplay": "",
                  "playsinline": "",
                  "height": _vm.cameraHeight,
                  "id": item.id
                },
                domProps: {
                  "muted": item.muted
                }
              })]);
            }), 0);
          }, staticRenderFns: [] };
        },
        /* 169 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var content = __webpack_require__(119);
          if (typeof content === "string")
            content = [[module3.i, content, ""]];
          if (content.locals)
            module3.exports = content.locals;
          __webpack_require__(170)("62bb3ac2", content, true);
        },
        /* 170 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var hasDocument = typeof document !== "undefined";
          if (typeof DEBUG !== "undefined" && DEBUG) {
            if (!hasDocument) {
              throw new Error(
                "vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
              );
            }
          }
          var listToStyles = __webpack_require__(171);
          var stylesInDom = {
            /*
              [id: number]: {
                id: number,
                refs: number,
                parts: Array<(obj?: StyleObjectPart) => void>
              }
            */
          };
          var head = hasDocument && (document.head || document.getElementsByTagName("head")[0]);
          var singletonElement = null;
          var singletonCounter = 0;
          var isProduction = false;
          var noop2 = function() {
          };
          var isOldIE = typeof navigator !== "undefined" && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
          module3.exports = function(parentId, list, _isProduction) {
            isProduction = _isProduction;
            var styles = listToStyles(parentId, list);
            addStylesToDom(styles);
            return function update3(newList) {
              var mayRemove = [];
              for (var i2 = 0; i2 < styles.length; i2++) {
                var item = styles[i2];
                var domStyle = stylesInDom[item.id];
                domStyle.refs--;
                mayRemove.push(domStyle);
              }
              if (newList) {
                styles = listToStyles(parentId, newList);
                addStylesToDom(styles);
              } else {
                styles = [];
              }
              for (var i2 = 0; i2 < mayRemove.length; i2++) {
                var domStyle = mayRemove[i2];
                if (domStyle.refs === 0) {
                  for (var j2 = 0; j2 < domStyle.parts.length; j2++) {
                    domStyle.parts[j2]();
                  }
                  delete stylesInDom[domStyle.id];
                }
              }
            };
          };
          function addStylesToDom(styles) {
            for (var i2 = 0; i2 < styles.length; i2++) {
              var item = styles[i2];
              var domStyle = stylesInDom[item.id];
              if (domStyle) {
                domStyle.refs++;
                for (var j2 = 0; j2 < domStyle.parts.length; j2++) {
                  domStyle.parts[j2](item.parts[j2]);
                }
                for (; j2 < item.parts.length; j2++) {
                  domStyle.parts.push(addStyle(item.parts[j2]));
                }
                if (domStyle.parts.length > item.parts.length) {
                  domStyle.parts.length = item.parts.length;
                }
              } else {
                var parts2 = [];
                for (var j2 = 0; j2 < item.parts.length; j2++) {
                  parts2.push(addStyle(item.parts[j2]));
                }
                stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts2 };
              }
            }
          }
          function createStyleElement() {
            var styleElement = document.createElement("style");
            styleElement.type = "text/css";
            head.appendChild(styleElement);
            return styleElement;
          }
          function addStyle(obj) {
            var update3, remove2;
            var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]');
            if (styleElement) {
              if (isProduction) {
                return noop2;
              } else {
                styleElement.parentNode.removeChild(styleElement);
              }
            }
            if (isOldIE) {
              var styleIndex = singletonCounter++;
              styleElement = singletonElement || (singletonElement = createStyleElement());
              update3 = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
              remove2 = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
            } else {
              styleElement = createStyleElement();
              update3 = applyToTag.bind(null, styleElement);
              remove2 = function() {
                styleElement.parentNode.removeChild(styleElement);
              };
            }
            update3(obj);
            return function updateStyle(newObj) {
              if (newObj) {
                if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                  return;
                }
                update3(obj = newObj);
              } else {
                remove2();
              }
            };
          }
          var replaceText = function() {
            var textStore = [];
            return function(index, replacement) {
              textStore[index] = replacement;
              return textStore.filter(Boolean).join("\n");
            };
          }();
          function applyToSingletonTag(styleElement, index, remove2, obj) {
            var css = remove2 ? "" : obj.css;
            if (styleElement.styleSheet) {
              styleElement.styleSheet.cssText = replaceText(index, css);
            } else {
              var cssNode = document.createTextNode(css);
              var childNodes = styleElement.childNodes;
              if (childNodes[index])
                styleElement.removeChild(childNodes[index]);
              if (childNodes.length) {
                styleElement.insertBefore(cssNode, childNodes[index]);
              } else {
                styleElement.appendChild(cssNode);
              }
            }
          }
          function applyToTag(styleElement, obj) {
            var css = obj.css;
            var media = obj.media;
            var sourceMap = obj.sourceMap;
            if (media) {
              styleElement.setAttribute("media", media);
            }
            if (sourceMap) {
              css += "\n/*# sourceURL=" + sourceMap.sources[0] + " */";
              css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
            }
            if (styleElement.styleSheet) {
              styleElement.styleSheet.cssText = css;
            } else {
              while (styleElement.firstChild) {
                styleElement.removeChild(styleElement.firstChild);
              }
              styleElement.appendChild(document.createTextNode(css));
            }
          }
        },
        /* 171 */
        /***/
        function(module3, exports2) {
          module3.exports = function listToStyles(parentId, list) {
            var styles = [];
            var newStyles = {};
            for (var i2 = 0; i2 < list.length; i2++) {
              var item = list[i2];
              var id = item[0];
              var css = item[1];
              var media = item[2];
              var sourceMap = item[3];
              var part = {
                id: parentId + ":" + i2,
                css,
                media,
                sourceMap
              };
              if (!newStyles[id]) {
                styles.push(newStyles[id] = { id, parts: [part] });
              } else {
                newStyles[id].parts.push(part);
              }
            }
            return styles;
          };
        },
        /* 172 */
        /***/
        function(module3, exports2) {
        },
        /* 173 */
        /***/
        function(module3, exports2) {
        }
        /******/
      ])
    );
  });
})(dist);
var distExports = dist.exports;
const WebRTC = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
var vueCountDownTimer_common = { exports: {} };
(function(module2) {
  module2.exports = /******/
  function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) {
        return installedModules[moduleId].exports;
      }
      var module3 = installedModules[moduleId] = {
        /******/
        i: moduleId,
        /******/
        l: false,
        /******/
        exports: {}
        /******/
      };
      modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
      module3.l = true;
      return module3.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
      if (!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, { enumerable: true, get: getter });
      }
    };
    __webpack_require__.r = function(exports) {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      }
      Object.defineProperty(exports, "__esModule", { value: true });
    };
    __webpack_require__.t = function(value2, mode) {
      if (mode & 1)
        value2 = __webpack_require__(value2);
      if (mode & 8)
        return value2;
      if (mode & 4 && typeof value2 === "object" && value2 && value2.__esModule)
        return value2;
      var ns = /* @__PURE__ */ Object.create(null);
      __webpack_require__.r(ns);
      Object.defineProperty(ns, "default", { enumerable: true, value: value2 });
      if (mode & 2 && typeof value2 != "string")
        for (var key in value2)
          __webpack_require__.d(ns, key, function(key2) {
            return value2[key2];
          }.bind(null, key));
      return ns;
    };
    __webpack_require__.n = function(module3) {
      var getter = module3 && module3.__esModule ? (
        /******/
        function getDefault() {
          return module3["default"];
        }
      ) : (
        /******/
        function getModuleExports() {
          return module3;
        }
      );
      __webpack_require__.d(getter, "a", getter);
      return getter;
    };
    __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = "fb15");
  }({
    /***/
    "014b": (
      /***/
      function(module3, exports, __webpack_require__) {
        var global2 = __webpack_require__("e53d");
        var has2 = __webpack_require__("07e3");
        var DESCRIPTORS = __webpack_require__("8e60");
        var $export = __webpack_require__("63b6");
        var redefine = __webpack_require__("9138");
        var META = __webpack_require__("ebfd").KEY;
        var $fails = __webpack_require__("294c");
        var shared = __webpack_require__("dbdb");
        var setToStringTag = __webpack_require__("45f2");
        var uid2 = __webpack_require__("62a0");
        var wks = __webpack_require__("5168");
        var wksExt = __webpack_require__("ccb9");
        var wksDefine = __webpack_require__("6718");
        var enumKeys = __webpack_require__("47ee");
        var isArray2 = __webpack_require__("9003");
        var anObject = __webpack_require__("e4ae");
        var isObject2 = __webpack_require__("f772");
        var toIObject = __webpack_require__("36c3");
        var toPrimitive = __webpack_require__("1bc3");
        var createDesc = __webpack_require__("aebd");
        var _create = __webpack_require__("a159");
        var gOPNExt = __webpack_require__("0395");
        var $GOPD = __webpack_require__("bf0b");
        var $DP = __webpack_require__("d9f6");
        var $keys = __webpack_require__("c3a1");
        var gOPD = $GOPD.f;
        var dP = $DP.f;
        var gOPN = gOPNExt.f;
        var $Symbol = global2.Symbol;
        var $JSON = global2.JSON;
        var _stringify = $JSON && $JSON.stringify;
        var PROTOTYPE = "prototype";
        var HIDDEN = wks("_hidden");
        var TO_PRIMITIVE = wks("toPrimitive");
        var isEnum = {}.propertyIsEnumerable;
        var SymbolRegistry = shared("symbol-registry");
        var AllSymbols = shared("symbols");
        var OPSymbols = shared("op-symbols");
        var ObjectProto = Object[PROTOTYPE];
        var USE_NATIVE = typeof $Symbol == "function";
        var QObject = global2.QObject;
        var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
        var setSymbolDesc = DESCRIPTORS && $fails(function() {
          return _create(dP({}, "a", {
            get: function() {
              return dP(this, "a", { value: 7 }).a;
            }
          })).a != 7;
        }) ? function(it, key, D) {
          var protoDesc = gOPD(ObjectProto, key);
          if (protoDesc)
            delete ObjectProto[key];
          dP(it, key, D);
          if (protoDesc && it !== ObjectProto)
            dP(ObjectProto, key, protoDesc);
        } : dP;
        var wrap = function(tag) {
          var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
          sym._k = tag;
          return sym;
        };
        var isSymbol2 = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(it) {
          return typeof it == "symbol";
        } : function(it) {
          return it instanceof $Symbol;
        };
        var $defineProperty = function defineProperty(it, key, D) {
          if (it === ObjectProto)
            $defineProperty(OPSymbols, key, D);
          anObject(it);
          key = toPrimitive(key, true);
          anObject(D);
          if (has2(AllSymbols, key)) {
            if (!D.enumerable) {
              if (!has2(it, HIDDEN))
                dP(it, HIDDEN, createDesc(1, {}));
              it[HIDDEN][key] = true;
            } else {
              if (has2(it, HIDDEN) && it[HIDDEN][key])
                it[HIDDEN][key] = false;
              D = _create(D, { enumerable: createDesc(0, false) });
            }
            return setSymbolDesc(it, key, D);
          }
          return dP(it, key, D);
        };
        var $defineProperties = function defineProperties(it, P) {
          anObject(it);
          var keys2 = enumKeys(P = toIObject(P));
          var i2 = 0;
          var l = keys2.length;
          var key;
          while (l > i2)
            $defineProperty(it, key = keys2[i2++], P[key]);
          return it;
        };
        var $create = function create(it, P) {
          return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(key) {
          var E = isEnum.call(this, key = toPrimitive(key, true));
          if (this === ObjectProto && has2(AllSymbols, key) && !has2(OPSymbols, key))
            return false;
          return E || !has2(this, key) || !has2(AllSymbols, key) || has2(this, HIDDEN) && this[HIDDEN][key] ? E : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
          it = toIObject(it);
          key = toPrimitive(key, true);
          if (it === ObjectProto && has2(AllSymbols, key) && !has2(OPSymbols, key))
            return;
          var D = gOPD(it, key);
          if (D && has2(AllSymbols, key) && !(has2(it, HIDDEN) && it[HIDDEN][key]))
            D.enumerable = true;
          return D;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(it) {
          var names = gOPN(toIObject(it));
          var result = [];
          var i2 = 0;
          var key;
          while (names.length > i2) {
            if (!has2(AllSymbols, key = names[i2++]) && key != HIDDEN && key != META)
              result.push(key);
          }
          return result;
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
          var IS_OP = it === ObjectProto;
          var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
          var result = [];
          var i2 = 0;
          var key;
          while (names.length > i2) {
            if (has2(AllSymbols, key = names[i2++]) && (IS_OP ? has2(ObjectProto, key) : true))
              result.push(AllSymbols[key]);
          }
          return result;
        };
        if (!USE_NATIVE) {
          $Symbol = function Symbol2() {
            if (this instanceof $Symbol)
              throw TypeError("Symbol is not a constructor!");
            var tag = uid2(arguments.length > 0 ? arguments[0] : void 0);
            var $set = function(value2) {
              if (this === ObjectProto)
                $set.call(OPSymbols, value2);
              if (has2(this, HIDDEN) && has2(this[HIDDEN], tag))
                this[HIDDEN][tag] = false;
              setSymbolDesc(this, tag, createDesc(1, value2));
            };
            if (DESCRIPTORS && setter)
              setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
            return wrap(tag);
          };
          redefine($Symbol[PROTOTYPE], "toString", function toString2() {
            return this._k;
          });
          $GOPD.f = $getOwnPropertyDescriptor;
          $DP.f = $defineProperty;
          __webpack_require__("6abf").f = gOPNExt.f = $getOwnPropertyNames;
          __webpack_require__("355d").f = $propertyIsEnumerable;
          __webpack_require__("9aa9").f = $getOwnPropertySymbols;
          if (DESCRIPTORS && !__webpack_require__("b8e3")) {
            redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
          }
          wksExt.f = function(name) {
            return wrap(wks(name));
          };
        }
        $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
        for (var es6Symbols = (
          // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
          "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(",")
        ), j2 = 0; es6Symbols.length > j2; )
          wks(es6Symbols[j2++]);
        for (var wellKnownSymbols = $keys(wks.store), k2 = 0; wellKnownSymbols.length > k2; )
          wksDefine(wellKnownSymbols[k2++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
          // 19.4.2.1 Symbol.for(key)
          "for": function(key) {
            return has2(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
          },
          // 19.4.2.5 Symbol.keyFor(sym)
          keyFor: function keyFor(sym) {
            if (!isSymbol2(sym))
              throw TypeError(sym + " is not a symbol!");
            for (var key in SymbolRegistry)
              if (SymbolRegistry[key] === sym)
                return key;
          },
          useSetter: function() {
            setter = true;
          },
          useSimple: function() {
            setter = false;
          }
        });
        $export($export.S + $export.F * !USE_NATIVE, "Object", {
          // 19.1.2.2 Object.create(O [, Properties])
          create: $create,
          // 19.1.2.4 Object.defineProperty(O, P, Attributes)
          defineProperty: $defineProperty,
          // 19.1.2.3 Object.defineProperties(O, Properties)
          defineProperties: $defineProperties,
          // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
          // 19.1.2.7 Object.getOwnPropertyNames(O)
          getOwnPropertyNames: $getOwnPropertyNames,
          // 19.1.2.8 Object.getOwnPropertySymbols(O)
          getOwnPropertySymbols: $getOwnPropertySymbols
        });
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
          var S = $Symbol();
          return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
        })), "JSON", {
          stringify: function stringify(it) {
            var args = [it];
            var i2 = 1;
            var replacer2, $replacer;
            while (arguments.length > i2)
              args.push(arguments[i2++]);
            $replacer = replacer2 = args[1];
            if (!isObject2(replacer2) && it === void 0 || isSymbol2(it))
              return;
            if (!isArray2(replacer2))
              replacer2 = function(key, value2) {
                if (typeof $replacer == "function")
                  value2 = $replacer.call(this, key, value2);
                if (!isSymbol2(value2))
                  return value2;
              };
            args[1] = replacer2;
            return _stringify.apply($JSON, args);
          }
        });
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__("35e8")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
        setToStringTag($Symbol, "Symbol");
        setToStringTag(Math, "Math", true);
        setToStringTag(global2.JSON, "JSON", true);
      }
    ),
    /***/
    "0395": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toIObject = __webpack_require__("36c3");
        var gOPN = __webpack_require__("6abf").f;
        var toString2 = {}.toString;
        var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        var getWindowNames = function(it) {
          try {
            return gOPN(it);
          } catch (e) {
            return windowNames.slice();
          }
        };
        module3.exports.f = function getOwnPropertyNames(it) {
          return windowNames && toString2.call(it) == "[object Window]" ? getWindowNames(it) : gOPN(toIObject(it));
        };
      }
    ),
    /***/
    "07e3": (
      /***/
      function(module3, exports) {
        var hasOwnProperty2 = {}.hasOwnProperty;
        module3.exports = function(it, key) {
          return hasOwnProperty2.call(it, key);
        };
      }
    ),
    /***/
    "0d58": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $keys = __webpack_require__("ce10");
        var enumBugKeys = __webpack_require__("e11e");
        module3.exports = Object.keys || function keys2(O) {
          return $keys(O, enumBugKeys);
        };
      }
    ),
    /***/
    "0fc9": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toInteger = __webpack_require__("3a38");
        var max2 = Math.max;
        var min2 = Math.min;
        module3.exports = function(index, length2) {
          index = toInteger(index);
          return index < 0 ? max2(index + length2, 0) : min2(index, length2);
        };
      }
    ),
    /***/
    "11e9": (
      /***/
      function(module3, exports, __webpack_require__) {
        var pIE = __webpack_require__("52a7");
        var createDesc = __webpack_require__("4630");
        var toIObject = __webpack_require__("6821");
        var toPrimitive = __webpack_require__("6a99");
        var has2 = __webpack_require__("69a8");
        var IE8_DOM_DEFINE = __webpack_require__("c69a");
        var gOPD = Object.getOwnPropertyDescriptor;
        exports.f = __webpack_require__("9e1e") ? gOPD : function getOwnPropertyDescriptor(O, P) {
          O = toIObject(O);
          P = toPrimitive(P, true);
          if (IE8_DOM_DEFINE)
            try {
              return gOPD(O, P);
            } catch (e) {
            }
          if (has2(O, P))
            return createDesc(!pIE.f.call(O, P), O[P]);
        };
      }
    ),
    /***/
    "1495": (
      /***/
      function(module3, exports, __webpack_require__) {
        var dP = __webpack_require__("86cc");
        var anObject = __webpack_require__("cb7c");
        var getKeys = __webpack_require__("0d58");
        module3.exports = __webpack_require__("9e1e") ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys2 = getKeys(Properties);
          var length2 = keys2.length;
          var i2 = 0;
          var P;
          while (length2 > i2)
            dP.f(O, P = keys2[i2++], Properties[P]);
          return O;
        };
      }
    ),
    /***/
    "1691": (
      /***/
      function(module3, exports) {
        module3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }
    ),
    /***/
    "1bc3": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("f772");
        module3.exports = function(it, S) {
          if (!isObject2(it))
            return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
            return val;
          if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it)))
            return val;
          if (!S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      }
    ),
    /***/
    "1ec9": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("f772");
        var document2 = __webpack_require__("e53d").document;
        var is = isObject2(document2) && isObject2(document2.createElement);
        module3.exports = function(it) {
          return is ? document2.createElement(it) : {};
        };
      }
    ),
    /***/
    "230e": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("d3f4");
        var document2 = __webpack_require__("7726").document;
        var is = isObject2(document2) && isObject2(document2.createElement);
        module3.exports = function(it) {
          return is ? document2.createElement(it) : {};
        };
      }
    ),
    /***/
    "241e": (
      /***/
      function(module3, exports, __webpack_require__) {
        var defined = __webpack_require__("25eb");
        module3.exports = function(it) {
          return Object(defined(it));
        };
      }
    ),
    /***/
    "25eb": (
      /***/
      function(module3, exports) {
        module3.exports = function(it) {
          if (it == void 0)
            throw TypeError("Can't call method on  " + it);
          return it;
        };
      }
    ),
    /***/
    "268f": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = __webpack_require__("fde4");
      }
    ),
    /***/
    "294c": (
      /***/
      function(module3, exports) {
        module3.exports = function(exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
      }
    ),
    /***/
    "2aba": (
      /***/
      function(module3, exports, __webpack_require__) {
        var global2 = __webpack_require__("7726");
        var hide = __webpack_require__("32e9");
        var has2 = __webpack_require__("69a8");
        var SRC = __webpack_require__("ca5a")("src");
        var $toString = __webpack_require__("fa5b");
        var TO_STRING = "toString";
        var TPL = ("" + $toString).split(TO_STRING);
        __webpack_require__("8378").inspectSource = function(it) {
          return $toString.call(it);
        };
        (module3.exports = function(O, key, val, safe) {
          var isFunction2 = typeof val == "function";
          if (isFunction2)
            has2(val, "name") || hide(val, "name", key);
          if (O[key] === val)
            return;
          if (isFunction2)
            has2(val, SRC) || hide(val, SRC, O[key] ? "" + O[key] : TPL.join(String(key)));
          if (O === global2) {
            O[key] = val;
          } else if (!safe) {
            delete O[key];
            hide(O, key, val);
          } else if (O[key]) {
            O[key] = val;
          } else {
            hide(O, key, val);
          }
        })(Function.prototype, TO_STRING, function toString2() {
          return typeof this == "function" && this[SRC] || $toString.call(this);
        });
      }
    ),
    /***/
    "2aeb": (
      /***/
      function(module3, exports, __webpack_require__) {
        var anObject = __webpack_require__("cb7c");
        var dPs = __webpack_require__("1495");
        var enumBugKeys = __webpack_require__("e11e");
        var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
        var Empty = function() {
        };
        var PROTOTYPE = "prototype";
        var createDict = function() {
          var iframe = __webpack_require__("230e")("iframe");
          var i2 = enumBugKeys.length;
          var lt = "<";
          var gt2 = ">";
          var iframeDocument;
          iframe.style.display = "none";
          __webpack_require__("fab2").appendChild(iframe);
          iframe.src = "javascript:";
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + "script" + gt2 + "document.F=Object" + lt + "/script" + gt2);
          iframeDocument.close();
          createDict = iframeDocument.F;
          while (i2--)
            delete createDict[PROTOTYPE][enumBugKeys[i2]];
          return createDict();
        };
        module3.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = createDict();
          return Properties === void 0 ? result : dPs(result, Properties);
        };
      }
    ),
    /***/
    "2b4c": (
      /***/
      function(module3, exports, __webpack_require__) {
        var store2 = __webpack_require__("5537")("wks");
        var uid2 = __webpack_require__("ca5a");
        var Symbol2 = __webpack_require__("7726").Symbol;
        var USE_SYMBOL = typeof Symbol2 == "function";
        var $exports = module3.exports = function(name) {
          return store2[name] || (store2[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid2)("Symbol." + name));
        };
        $exports.store = store2;
      }
    ),
    /***/
    "2d00": (
      /***/
      function(module3, exports) {
        module3.exports = false;
      }
    ),
    /***/
    "2d95": (
      /***/
      function(module3, exports) {
        var toString2 = {}.toString;
        module3.exports = function(it) {
          return toString2.call(it).slice(8, -1);
        };
      }
    ),
    /***/
    "2fdb": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $export = __webpack_require__("5ca1");
        var context = __webpack_require__("d2c8");
        var INCLUDES = "includes";
        $export($export.P + $export.F * __webpack_require__("5147")(INCLUDES), "String", {
          includes: function includes2(searchString) {
            return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
      }
    ),
    /***/
    "32a6": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toObject2 = __webpack_require__("241e");
        var $keys = __webpack_require__("c3a1");
        __webpack_require__("ce7e")("keys", function() {
          return function keys2(it) {
            return $keys(toObject2(it));
          };
        });
      }
    ),
    /***/
    "32e9": (
      /***/
      function(module3, exports, __webpack_require__) {
        var dP = __webpack_require__("86cc");
        var createDesc = __webpack_require__("4630");
        module3.exports = __webpack_require__("9e1e") ? function(object, key, value2) {
          return dP.f(object, key, createDesc(1, value2));
        } : function(object, key, value2) {
          object[key] = value2;
          return object;
        };
      }
    ),
    /***/
    "32fc": (
      /***/
      function(module3, exports, __webpack_require__) {
        var document2 = __webpack_require__("e53d").document;
        module3.exports = document2 && document2.documentElement;
      }
    ),
    /***/
    "335c": (
      /***/
      function(module3, exports, __webpack_require__) {
        var cof = __webpack_require__("6b4c");
        module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
          return cof(it) == "String" ? it.split("") : Object(it);
        };
      }
    ),
    /***/
    "355d": (
      /***/
      function(module3, exports) {
        exports.f = {}.propertyIsEnumerable;
      }
    ),
    /***/
    "35e8": (
      /***/
      function(module3, exports, __webpack_require__) {
        var dP = __webpack_require__("d9f6");
        var createDesc = __webpack_require__("aebd");
        module3.exports = __webpack_require__("8e60") ? function(object, key, value2) {
          return dP.f(object, key, createDesc(1, value2));
        } : function(object, key, value2) {
          object[key] = value2;
          return object;
        };
      }
    ),
    /***/
    "36c3": (
      /***/
      function(module3, exports, __webpack_require__) {
        var IObject = __webpack_require__("335c");
        var defined = __webpack_require__("25eb");
        module3.exports = function(it) {
          return IObject(defined(it));
        };
      }
    ),
    /***/
    "3a38": (
      /***/
      function(module3, exports) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module3.exports = function(it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
      }
    ),
    /***/
    "454f": (
      /***/
      function(module3, exports, __webpack_require__) {
        __webpack_require__("46a7");
        var $Object = __webpack_require__("584a").Object;
        module3.exports = function defineProperty(it, key, desc) {
          return $Object.defineProperty(it, key, desc);
        };
      }
    ),
    /***/
    "4588": (
      /***/
      function(module3, exports) {
        var ceil = Math.ceil;
        var floor = Math.floor;
        module3.exports = function(it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
      }
    ),
    /***/
    "45f2": (
      /***/
      function(module3, exports, __webpack_require__) {
        var def2 = __webpack_require__("d9f6").f;
        var has2 = __webpack_require__("07e3");
        var TAG = __webpack_require__("5168")("toStringTag");
        module3.exports = function(it, tag, stat) {
          if (it && !has2(it = stat ? it : it.prototype, TAG))
            def2(it, TAG, { configurable: true, value: tag });
        };
      }
    ),
    /***/
    "4630": (
      /***/
      function(module3, exports) {
        module3.exports = function(bitmap, value2) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value2
          };
        };
      }
    ),
    /***/
    "46a7": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $export = __webpack_require__("63b6");
        $export($export.S + $export.F * !__webpack_require__("8e60"), "Object", { defineProperty: __webpack_require__("d9f6").f });
      }
    ),
    /***/
    "47ee": (
      /***/
      function(module3, exports, __webpack_require__) {
        var getKeys = __webpack_require__("c3a1");
        var gOPS = __webpack_require__("9aa9");
        var pIE = __webpack_require__("355d");
        module3.exports = function(it) {
          var result = getKeys(it);
          var getSymbols = gOPS.f;
          if (getSymbols) {
            var symbols = getSymbols(it);
            var isEnum = pIE.f;
            var i2 = 0;
            var key;
            while (symbols.length > i2)
              if (isEnum.call(it, key = symbols[i2++]))
                result.push(key);
          }
          return result;
        };
      }
    ),
    /***/
    "5147": (
      /***/
      function(module3, exports, __webpack_require__) {
        var MATCH = __webpack_require__("2b4c")("match");
        module3.exports = function(KEY) {
          var re2 = /./;
          try {
            "/./"[KEY](re2);
          } catch (e) {
            try {
              re2[MATCH] = false;
              return !"/./"[KEY](re2);
            } catch (f) {
            }
          }
          return true;
        };
      }
    ),
    /***/
    "5168": (
      /***/
      function(module3, exports, __webpack_require__) {
        var store2 = __webpack_require__("dbdb")("wks");
        var uid2 = __webpack_require__("62a0");
        var Symbol2 = __webpack_require__("e53d").Symbol;
        var USE_SYMBOL = typeof Symbol2 == "function";
        var $exports = module3.exports = function(name) {
          return store2[name] || (store2[name] = USE_SYMBOL && Symbol2[name] || (USE_SYMBOL ? Symbol2 : uid2)("Symbol." + name));
        };
        $exports.store = store2;
      }
    ),
    /***/
    "52a7": (
      /***/
      function(module3, exports) {
        exports.f = {}.propertyIsEnumerable;
      }
    ),
    /***/
    "5537": (
      /***/
      function(module3, exports, __webpack_require__) {
        var core = __webpack_require__("8378");
        var global2 = __webpack_require__("7726");
        var SHARED = "__core-js_shared__";
        var store2 = global2[SHARED] || (global2[SHARED] = {});
        (module3.exports = function(key, value2) {
          return store2[key] || (store2[key] = value2 !== void 0 ? value2 : {});
        })("versions", []).push({
          version: core.version,
          mode: __webpack_require__("2d00") ? "pure" : "global",
          copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
        });
      }
    ),
    /***/
    "5559": (
      /***/
      function(module3, exports, __webpack_require__) {
        var shared = __webpack_require__("dbdb")("keys");
        var uid2 = __webpack_require__("62a0");
        module3.exports = function(key) {
          return shared[key] || (shared[key] = uid2(key));
        };
      }
    ),
    /***/
    "584a": (
      /***/
      function(module3, exports) {
        var core = module3.exports = { version: "2.6.5" };
        if (typeof __e == "number")
          __e = core;
      }
    ),
    /***/
    "5b4e": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toIObject = __webpack_require__("36c3");
        var toLength = __webpack_require__("b447");
        var toAbsoluteIndex = __webpack_require__("0fc9");
        module3.exports = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIObject($this);
            var length2 = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length2);
            var value2;
            if (IS_INCLUDES && el != el)
              while (length2 > index) {
                value2 = O[index++];
                if (value2 != value2)
                  return true;
              }
            else
              for (; length2 > index; index++)
                if (IS_INCLUDES || index in O) {
                  if (O[index] === el)
                    return IS_INCLUDES || index || 0;
                }
            return !IS_INCLUDES && -1;
          };
        };
      }
    ),
    /***/
    "5ca1": (
      /***/
      function(module3, exports, __webpack_require__) {
        var global2 = __webpack_require__("7726");
        var core = __webpack_require__("8378");
        var hide = __webpack_require__("32e9");
        var redefine = __webpack_require__("2aba");
        var ctx = __webpack_require__("9b43");
        var PROTOTYPE = "prototype";
        var $export = function(type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] || (global2[name] = {}) : (global2[name] || {})[PROTOTYPE];
          var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
          var key, own, out, exp;
          if (IS_GLOBAL)
            source = name;
          for (key in source) {
            own = !IS_FORCED && target && target[key] !== void 0;
            out = (own ? target : source)[key];
            exp = IS_BIND && own ? ctx(out, global2) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
            if (target)
              redefine(target, key, out, type & $export.U);
            if (exports2[key] != out)
              hide(exports2, key, exp);
            if (IS_PROTO && expProto[key] != out)
              expProto[key] = out;
          }
        };
        global2.core = core;
        $export.F = 1;
        $export.G = 2;
        $export.S = 4;
        $export.P = 8;
        $export.B = 16;
        $export.W = 32;
        $export.U = 64;
        $export.R = 128;
        module3.exports = $export;
      }
    ),
    /***/
    "5dbc": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("d3f4");
        var setPrototypeOf = __webpack_require__("8b97").set;
        module3.exports = function(that, target, C) {
          var S = target.constructor;
          var P;
          if (S !== C && typeof S == "function" && (P = S.prototype) !== C.prototype && isObject2(P) && setPrototypeOf) {
            setPrototypeOf(that, P);
          }
          return that;
        };
      }
    ),
    /***/
    "613b": (
      /***/
      function(module3, exports, __webpack_require__) {
        var shared = __webpack_require__("5537")("keys");
        var uid2 = __webpack_require__("ca5a");
        module3.exports = function(key) {
          return shared[key] || (shared[key] = uid2(key));
        };
      }
    ),
    /***/
    "626a": (
      /***/
      function(module3, exports, __webpack_require__) {
        var cof = __webpack_require__("2d95");
        module3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
          return cof(it) == "String" ? it.split("") : Object(it);
        };
      }
    ),
    /***/
    "62a0": (
      /***/
      function(module3, exports) {
        var id = 0;
        var px = Math.random();
        module3.exports = function(key) {
          return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
        };
      }
    ),
    /***/
    "63b6": (
      /***/
      function(module3, exports, __webpack_require__) {
        var global2 = __webpack_require__("e53d");
        var core = __webpack_require__("584a");
        var ctx = __webpack_require__("d864");
        var hide = __webpack_require__("35e8");
        var has2 = __webpack_require__("07e3");
        var PROTOTYPE = "prototype";
        var $export = function(type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var IS_WRAP = type & $export.W;
          var exports2 = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports2[PROTOTYPE];
          var target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE];
          var key, own, out;
          if (IS_GLOBAL)
            source = name;
          for (key in source) {
            own = !IS_FORCED && target && target[key] !== void 0;
            if (own && has2(exports2, key))
              continue;
            out = own ? target[key] : source[key];
            exports2[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? function(C) {
              var F2 = function(a, b, c) {
                if (this instanceof C) {
                  switch (arguments.length) {
                    case 0:
                      return new C();
                    case 1:
                      return new C(a);
                    case 2:
                      return new C(a, b);
                  }
                  return new C(a, b, c);
                }
                return C.apply(this, arguments);
              };
              F2[PROTOTYPE] = C[PROTOTYPE];
              return F2;
            }(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
            if (IS_PROTO) {
              (exports2.virtual || (exports2.virtual = {}))[key] = out;
              if (type & $export.R && expProto && !expProto[key])
                hide(expProto, key, out);
            }
          }
        };
        $export.F = 1;
        $export.G = 2;
        $export.S = 4;
        $export.P = 8;
        $export.B = 16;
        $export.W = 32;
        $export.U = 64;
        $export.R = 128;
        module3.exports = $export;
      }
    ),
    /***/
    "6718": (
      /***/
      function(module3, exports, __webpack_require__) {
        var global2 = __webpack_require__("e53d");
        var core = __webpack_require__("584a");
        var LIBRARY = __webpack_require__("b8e3");
        var wksExt = __webpack_require__("ccb9");
        var defineProperty = __webpack_require__("d9f6").f;
        module3.exports = function(name) {
          var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global2.Symbol || {});
          if (name.charAt(0) != "_" && !(name in $Symbol))
            defineProperty($Symbol, name, { value: wksExt.f(name) });
        };
      }
    ),
    /***/
    "6762": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $export = __webpack_require__("5ca1");
        var $includes = __webpack_require__("c366")(true);
        $export($export.P, "Array", {
          includes: function includes2(el) {
            return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
          }
        });
        __webpack_require__("9c6c")("includes");
      }
    ),
    /***/
    "6821": (
      /***/
      function(module3, exports, __webpack_require__) {
        var IObject = __webpack_require__("626a");
        var defined = __webpack_require__("be13");
        module3.exports = function(it) {
          return IObject(defined(it));
        };
      }
    ),
    /***/
    "69a8": (
      /***/
      function(module3, exports) {
        var hasOwnProperty2 = {}.hasOwnProperty;
        module3.exports = function(it, key) {
          return hasOwnProperty2.call(it, key);
        };
      }
    ),
    /***/
    "6a99": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("d3f4");
        module3.exports = function(it, S) {
          if (!isObject2(it))
            return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
            return val;
          if (typeof (fn = it.valueOf) == "function" && !isObject2(val = fn.call(it)))
            return val;
          if (!S && typeof (fn = it.toString) == "function" && !isObject2(val = fn.call(it)))
            return val;
          throw TypeError("Can't convert object to primitive value");
        };
      }
    ),
    /***/
    "6abf": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $keys = __webpack_require__("e6f3");
        var hiddenKeys = __webpack_require__("1691").concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return $keys(O, hiddenKeys);
        };
      }
    ),
    /***/
    "6b4c": (
      /***/
      function(module3, exports) {
        var toString2 = {}.toString;
        module3.exports = function(it) {
          return toString2.call(it).slice(8, -1);
        };
      }
    ),
    /***/
    "7726": (
      /***/
      function(module3, exports) {
        var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number")
          __g = global2;
      }
    ),
    /***/
    "77f1": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toInteger = __webpack_require__("4588");
        var max2 = Math.max;
        var min2 = Math.min;
        module3.exports = function(index, length2) {
          index = toInteger(index);
          return index < 0 ? max2(index + length2, 0) : min2(index, length2);
        };
      }
    ),
    /***/
    "794b": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = !__webpack_require__("8e60") && !__webpack_require__("294c")(function() {
          return Object.defineProperty(__webpack_require__("1ec9")("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }
    ),
    /***/
    "79aa": (
      /***/
      function(module3, exports) {
        module3.exports = function(it) {
          if (typeof it != "function")
            throw TypeError(it + " is not a function!");
          return it;
        };
      }
    ),
    /***/
    "79e5": (
      /***/
      function(module3, exports) {
        module3.exports = function(exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };
      }
    ),
    /***/
    "7e90": (
      /***/
      function(module3, exports, __webpack_require__) {
        var dP = __webpack_require__("d9f6");
        var anObject = __webpack_require__("e4ae");
        var getKeys = __webpack_require__("c3a1");
        module3.exports = __webpack_require__("8e60") ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys2 = getKeys(Properties);
          var length2 = keys2.length;
          var i2 = 0;
          var P;
          while (length2 > i2)
            dP.f(O, P = keys2[i2++], Properties[P]);
          return O;
        };
      }
    ),
    /***/
    "8378": (
      /***/
      function(module3, exports) {
        var core = module3.exports = { version: "2.6.5" };
        if (typeof __e == "number")
          __e = core;
      }
    ),
    /***/
    "85f2": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = __webpack_require__("454f");
      }
    ),
    /***/
    "86cc": (
      /***/
      function(module3, exports, __webpack_require__) {
        var anObject = __webpack_require__("cb7c");
        var IE8_DOM_DEFINE = __webpack_require__("c69a");
        var toPrimitive = __webpack_require__("6a99");
        var dP = Object.defineProperty;
        exports.f = __webpack_require__("9e1e") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return dP(O, P, Attributes);
            } catch (e) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError("Accessors not supported!");
          if ("value" in Attributes)
            O[P] = Attributes.value;
          return O;
        };
      }
    ),
    /***/
    "8aae": (
      /***/
      function(module3, exports, __webpack_require__) {
        __webpack_require__("32a6");
        module3.exports = __webpack_require__("584a").Object.keys;
      }
    ),
    /***/
    "8b97": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("d3f4");
        var anObject = __webpack_require__("cb7c");
        var check = function(O, proto2) {
          anObject(O);
          if (!isObject2(proto2) && proto2 !== null)
            throw TypeError(proto2 + ": can't set as prototype!");
        };
        module3.exports = {
          set: Object.setPrototypeOf || ("__proto__" in {} ? (
            // eslint-disable-line
            function(test, buggy, set2) {
              try {
                set2 = __webpack_require__("9b43")(Function.call, __webpack_require__("11e9").f(Object.prototype, "__proto__").set, 2);
                set2(test, []);
                buggy = !(test instanceof Array);
              } catch (e) {
                buggy = true;
              }
              return function setPrototypeOf(O, proto2) {
                check(O, proto2);
                if (buggy)
                  O.__proto__ = proto2;
                else
                  set2(O, proto2);
                return O;
              };
            }({}, false)
          ) : void 0),
          check
        };
      }
    ),
    /***/
    "8e60": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = !__webpack_require__("294c")(function() {
          return Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }
    ),
    /***/
    "9003": (
      /***/
      function(module3, exports, __webpack_require__) {
        var cof = __webpack_require__("6b4c");
        module3.exports = Array.isArray || function isArray2(arg) {
          return cof(arg) == "Array";
        };
      }
    ),
    /***/
    "9093": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $keys = __webpack_require__("ce10");
        var hiddenKeys = __webpack_require__("e11e").concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return $keys(O, hiddenKeys);
        };
      }
    ),
    /***/
    "9138": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = __webpack_require__("35e8");
      }
    ),
    /***/
    "9aa9": (
      /***/
      function(module3, exports) {
        exports.f = Object.getOwnPropertySymbols;
      }
    ),
    /***/
    "9b43": (
      /***/
      function(module3, exports, __webpack_require__) {
        var aFunction = __webpack_require__("d8e8");
        module3.exports = function(fn, that, length2) {
          aFunction(fn);
          if (that === void 0)
            return fn;
          switch (length2) {
            case 1:
              return function(a) {
                return fn.call(that, a);
              };
            case 2:
              return function(a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function(a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function() {
            return fn.apply(that, arguments);
          };
        };
      }
    ),
    /***/
    "9c6c": (
      /***/
      function(module3, exports, __webpack_require__) {
        var UNSCOPABLES = __webpack_require__("2b4c")("unscopables");
        var ArrayProto = Array.prototype;
        if (ArrayProto[UNSCOPABLES] == void 0)
          __webpack_require__("32e9")(ArrayProto, UNSCOPABLES, {});
        module3.exports = function(key) {
          ArrayProto[UNSCOPABLES][key] = true;
        };
      }
    ),
    /***/
    "9def": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toInteger = __webpack_require__("4588");
        var min2 = Math.min;
        module3.exports = function(it) {
          return it > 0 ? min2(toInteger(it), 9007199254740991) : 0;
        };
      }
    ),
    /***/
    "9e1e": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = !__webpack_require__("79e5")(function() {
          return Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }
    ),
    /***/
    "a159": (
      /***/
      function(module3, exports, __webpack_require__) {
        var anObject = __webpack_require__("e4ae");
        var dPs = __webpack_require__("7e90");
        var enumBugKeys = __webpack_require__("1691");
        var IE_PROTO = __webpack_require__("5559")("IE_PROTO");
        var Empty = function() {
        };
        var PROTOTYPE = "prototype";
        var createDict = function() {
          var iframe = __webpack_require__("1ec9")("iframe");
          var i2 = enumBugKeys.length;
          var lt = "<";
          var gt2 = ">";
          var iframeDocument;
          iframe.style.display = "none";
          __webpack_require__("32fc").appendChild(iframe);
          iframe.src = "javascript:";
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + "script" + gt2 + "document.F=Object" + lt + "/script" + gt2);
          iframeDocument.close();
          createDict = iframeDocument.F;
          while (i2--)
            delete createDict[PROTOTYPE][enumBugKeys[i2]];
          return createDict();
        };
        module3.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null;
            result[IE_PROTO] = O;
          } else
            result = createDict();
          return Properties === void 0 ? result : dPs(result, Properties);
        };
      }
    ),
    /***/
    "a4bb": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = __webpack_require__("8aae");
      }
    ),
    /***/
    "a6c0": (
      /***/
      function(module3, exports, __webpack_require__) {
      }
    ),
    /***/
    "aa77": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $export = __webpack_require__("5ca1");
        var defined = __webpack_require__("be13");
        var fails = __webpack_require__("79e5");
        var spaces = __webpack_require__("fdef");
        var space = "[" + spaces + "]";
        var non = "​";
        var ltrim = RegExp("^" + space + space + "*");
        var rtrim = RegExp(space + space + "*$");
        var exporter = function(KEY, exec, ALIAS) {
          var exp = {};
          var FORCE = fails(function() {
            return !!spaces[KEY]() || non[KEY]() != non;
          });
          var fn = exp[KEY] = FORCE ? exec(trim2) : spaces[KEY];
          if (ALIAS)
            exp[ALIAS] = fn;
          $export($export.P + $export.F * FORCE, "String", exp);
        };
        var trim2 = exporter.trim = function(string, TYPE) {
          string = String(defined(string));
          if (TYPE & 1)
            string = string.replace(ltrim, "");
          if (TYPE & 2)
            string = string.replace(rtrim, "");
          return string;
        };
        module3.exports = exporter;
      }
    ),
    /***/
    "aae3": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("d3f4");
        var cof = __webpack_require__("2d95");
        var MATCH = __webpack_require__("2b4c")("match");
        module3.exports = function(it) {
          var isRegExp;
          return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : cof(it) == "RegExp");
        };
      }
    ),
    /***/
    "aebd": (
      /***/
      function(module3, exports) {
        module3.exports = function(bitmap, value2) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value2
          };
        };
      }
    ),
    /***/
    "b447": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toInteger = __webpack_require__("3a38");
        var min2 = Math.min;
        module3.exports = function(it) {
          return it > 0 ? min2(toInteger(it), 9007199254740991) : 0;
        };
      }
    ),
    /***/
    "b8e3": (
      /***/
      function(module3, exports) {
        module3.exports = true;
      }
    ),
    /***/
    "be13": (
      /***/
      function(module3, exports) {
        module3.exports = function(it) {
          if (it == void 0)
            throw TypeError("Can't call method on  " + it);
          return it;
        };
      }
    ),
    /***/
    "bf0b": (
      /***/
      function(module3, exports, __webpack_require__) {
        var pIE = __webpack_require__("355d");
        var createDesc = __webpack_require__("aebd");
        var toIObject = __webpack_require__("36c3");
        var toPrimitive = __webpack_require__("1bc3");
        var has2 = __webpack_require__("07e3");
        var IE8_DOM_DEFINE = __webpack_require__("794b");
        var gOPD = Object.getOwnPropertyDescriptor;
        exports.f = __webpack_require__("8e60") ? gOPD : function getOwnPropertyDescriptor(O, P) {
          O = toIObject(O);
          P = toPrimitive(P, true);
          if (IE8_DOM_DEFINE)
            try {
              return gOPD(O, P);
            } catch (e) {
            }
          if (has2(O, P))
            return createDesc(!pIE.f.call(O, P), O[P]);
        };
      }
    ),
    /***/
    "bf90": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toIObject = __webpack_require__("36c3");
        var $getOwnPropertyDescriptor = __webpack_require__("bf0b").f;
        __webpack_require__("ce7e")("getOwnPropertyDescriptor", function() {
          return function getOwnPropertyDescriptor(it, key) {
            return $getOwnPropertyDescriptor(toIObject(it), key);
          };
        });
      }
    ),
    /***/
    "c366": (
      /***/
      function(module3, exports, __webpack_require__) {
        var toIObject = __webpack_require__("6821");
        var toLength = __webpack_require__("9def");
        var toAbsoluteIndex = __webpack_require__("77f1");
        module3.exports = function(IS_INCLUDES) {
          return function($this, el, fromIndex) {
            var O = toIObject($this);
            var length2 = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length2);
            var value2;
            if (IS_INCLUDES && el != el)
              while (length2 > index) {
                value2 = O[index++];
                if (value2 != value2)
                  return true;
              }
            else
              for (; length2 > index; index++)
                if (IS_INCLUDES || index in O) {
                  if (O[index] === el)
                    return IS_INCLUDES || index || 0;
                }
            return !IS_INCLUDES && -1;
          };
        };
      }
    ),
    /***/
    "c3a1": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $keys = __webpack_require__("e6f3");
        var enumBugKeys = __webpack_require__("1691");
        module3.exports = Object.keys || function keys2(O) {
          return $keys(O, enumBugKeys);
        };
      }
    ),
    /***/
    "c5f6": (
      /***/
      function(module3, exports, __webpack_require__) {
        var global2 = __webpack_require__("7726");
        var has2 = __webpack_require__("69a8");
        var cof = __webpack_require__("2d95");
        var inheritIfRequired = __webpack_require__("5dbc");
        var toPrimitive = __webpack_require__("6a99");
        var fails = __webpack_require__("79e5");
        var gOPN = __webpack_require__("9093").f;
        var gOPD = __webpack_require__("11e9").f;
        var dP = __webpack_require__("86cc").f;
        var $trim = __webpack_require__("aa77").trim;
        var NUMBER = "Number";
        var $Number = global2[NUMBER];
        var Base = $Number;
        var proto2 = $Number.prototype;
        var BROKEN_COF = cof(__webpack_require__("2aeb")(proto2)) == NUMBER;
        var TRIM = "trim" in String.prototype;
        var toNumber2 = function(argument) {
          var it = toPrimitive(argument, false);
          if (typeof it == "string" && it.length > 2) {
            it = TRIM ? it.trim() : $trim(it, 3);
            var first = it.charCodeAt(0);
            var third, radix, maxCode;
            if (first === 43 || first === 45) {
              third = it.charCodeAt(2);
              if (third === 88 || third === 120)
                return NaN;
            } else if (first === 48) {
              switch (it.charCodeAt(1)) {
                case 66:
                case 98:
                  radix = 2;
                  maxCode = 49;
                  break;
                case 79:
                case 111:
                  radix = 8;
                  maxCode = 55;
                  break;
                default:
                  return +it;
              }
              for (var digits = it.slice(2), i2 = 0, l = digits.length, code; i2 < l; i2++) {
                code = digits.charCodeAt(i2);
                if (code < 48 || code > maxCode)
                  return NaN;
              }
              return parseInt(digits, radix);
            }
          }
          return +it;
        };
        if (!$Number(" 0o1") || !$Number("0b1") || $Number("+0x1")) {
          $Number = function Number2(value2) {
            var it = arguments.length < 1 ? 0 : value2;
            var that = this;
            return that instanceof $Number && (BROKEN_COF ? fails(function() {
              proto2.valueOf.call(that);
            }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber2(it)), that, $Number) : toNumber2(it);
          };
          for (var keys2 = __webpack_require__("9e1e") ? gOPN(Base) : (
            // ES3:
            "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(",")
          ), j2 = 0, key; keys2.length > j2; j2++) {
            if (has2(Base, key = keys2[j2]) && !has2($Number, key)) {
              dP($Number, key, gOPD(Base, key));
            }
          }
          $Number.prototype = proto2;
          proto2.constructor = $Number;
          __webpack_require__("2aba")(global2, NUMBER, $Number);
        }
      }
    ),
    /***/
    "c69a": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = !__webpack_require__("9e1e") && !__webpack_require__("79e5")(function() {
          return Object.defineProperty(__webpack_require__("230e")("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      }
    ),
    /***/
    "ca5a": (
      /***/
      function(module3, exports) {
        var id = 0;
        var px = Math.random();
        module3.exports = function(key) {
          return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
        };
      }
    ),
    /***/
    "cb7c": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("d3f4");
        module3.exports = function(it) {
          if (!isObject2(it))
            throw TypeError(it + " is not an object!");
          return it;
        };
      }
    ),
    /***/
    "ccb9": (
      /***/
      function(module3, exports, __webpack_require__) {
        exports.f = __webpack_require__("5168");
      }
    ),
    /***/
    "ce10": (
      /***/
      function(module3, exports, __webpack_require__) {
        var has2 = __webpack_require__("69a8");
        var toIObject = __webpack_require__("6821");
        var arrayIndexOf = __webpack_require__("c366")(false);
        var IE_PROTO = __webpack_require__("613b")("IE_PROTO");
        module3.exports = function(object, names) {
          var O = toIObject(object);
          var i2 = 0;
          var result = [];
          var key;
          for (key in O)
            if (key != IE_PROTO)
              has2(O, key) && result.push(key);
          while (names.length > i2)
            if (has2(O, key = names[i2++])) {
              ~arrayIndexOf(result, key) || result.push(key);
            }
          return result;
        };
      }
    ),
    /***/
    "ce7e": (
      /***/
      function(module3, exports, __webpack_require__) {
        var $export = __webpack_require__("63b6");
        var core = __webpack_require__("584a");
        var fails = __webpack_require__("294c");
        module3.exports = function(KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export($export.S + $export.F * fails(function() {
            fn(1);
          }), "Object", exp);
        };
      }
    ),
    /***/
    "d2c8": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isRegExp = __webpack_require__("aae3");
        var defined = __webpack_require__("be13");
        module3.exports = function(that, searchString, NAME) {
          if (isRegExp(searchString))
            throw TypeError("String#" + NAME + " doesn't accept regex!");
          return String(defined(that));
        };
      }
    ),
    /***/
    "d3f4": (
      /***/
      function(module3, exports) {
        module3.exports = function(it) {
          return typeof it === "object" ? it !== null : typeof it === "function";
        };
      }
    ),
    /***/
    "d864": (
      /***/
      function(module3, exports, __webpack_require__) {
        var aFunction = __webpack_require__("79aa");
        module3.exports = function(fn, that, length2) {
          aFunction(fn);
          if (that === void 0)
            return fn;
          switch (length2) {
            case 1:
              return function(a) {
                return fn.call(that, a);
              };
            case 2:
              return function(a, b) {
                return fn.call(that, a, b);
              };
            case 3:
              return function(a, b, c) {
                return fn.call(that, a, b, c);
              };
          }
          return function() {
            return fn.apply(that, arguments);
          };
        };
      }
    ),
    /***/
    "d8e8": (
      /***/
      function(module3, exports) {
        module3.exports = function(it) {
          if (typeof it != "function")
            throw TypeError(it + " is not a function!");
          return it;
        };
      }
    ),
    /***/
    "d9f6": (
      /***/
      function(module3, exports, __webpack_require__) {
        var anObject = __webpack_require__("e4ae");
        var IE8_DOM_DEFINE = __webpack_require__("794b");
        var toPrimitive = __webpack_require__("1bc3");
        var dP = Object.defineProperty;
        exports.f = __webpack_require__("8e60") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE)
            try {
              return dP(O, P, Attributes);
            } catch (e) {
            }
          if ("get" in Attributes || "set" in Attributes)
            throw TypeError("Accessors not supported!");
          if ("value" in Attributes)
            O[P] = Attributes.value;
          return O;
        };
      }
    ),
    /***/
    "dbb4": (
      /***/
      function(module3, __webpack_exports__, __webpack_require__) {
        var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CircularCountDownTimer_vue_vue_type_style_index_0_id_5998f914_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a6c0");
        var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CircularCountDownTimer_vue_vue_type_style_index_0_id_5998f914_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CircularCountDownTimer_vue_vue_type_style_index_0_id_5998f914_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
        _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_index_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_CircularCountDownTimer_vue_vue_type_style_index_0_id_5998f914_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a;
      }
    ),
    /***/
    "dbdb": (
      /***/
      function(module3, exports, __webpack_require__) {
        var core = __webpack_require__("584a");
        var global2 = __webpack_require__("e53d");
        var SHARED = "__core-js_shared__";
        var store2 = global2[SHARED] || (global2[SHARED] = {});
        (module3.exports = function(key, value2) {
          return store2[key] || (store2[key] = value2 !== void 0 ? value2 : {});
        })("versions", []).push({
          version: core.version,
          mode: __webpack_require__("b8e3") ? "pure" : "global",
          copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
        });
      }
    ),
    /***/
    "e11e": (
      /***/
      function(module3, exports) {
        module3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }
    ),
    /***/
    "e265": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = __webpack_require__("ed33");
      }
    ),
    /***/
    "e4ae": (
      /***/
      function(module3, exports, __webpack_require__) {
        var isObject2 = __webpack_require__("f772");
        module3.exports = function(it) {
          if (!isObject2(it))
            throw TypeError(it + " is not an object!");
          return it;
        };
      }
    ),
    /***/
    "e53d": (
      /***/
      function(module3, exports) {
        var global2 = module3.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number")
          __g = global2;
      }
    ),
    /***/
    "e6f3": (
      /***/
      function(module3, exports, __webpack_require__) {
        var has2 = __webpack_require__("07e3");
        var toIObject = __webpack_require__("36c3");
        var arrayIndexOf = __webpack_require__("5b4e")(false);
        var IE_PROTO = __webpack_require__("5559")("IE_PROTO");
        module3.exports = function(object, names) {
          var O = toIObject(object);
          var i2 = 0;
          var result = [];
          var key;
          for (key in O)
            if (key != IE_PROTO)
              has2(O, key) && result.push(key);
          while (names.length > i2)
            if (has2(O, key = names[i2++])) {
              ~arrayIndexOf(result, key) || result.push(key);
            }
          return result;
        };
      }
    ),
    /***/
    "ebfd": (
      /***/
      function(module3, exports, __webpack_require__) {
        var META = __webpack_require__("62a0")("meta");
        var isObject2 = __webpack_require__("f772");
        var has2 = __webpack_require__("07e3");
        var setDesc = __webpack_require__("d9f6").f;
        var id = 0;
        var isExtensible = Object.isExtensible || function() {
          return true;
        };
        var FREEZE = !__webpack_require__("294c")(function() {
          return isExtensible(Object.preventExtensions({}));
        });
        var setMeta = function(it) {
          setDesc(it, META, { value: {
            i: "O" + ++id,
            // object ID
            w: {}
            // weak collections IDs
          } });
        };
        var fastKey = function(it, create) {
          if (!isObject2(it))
            return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
          if (!has2(it, META)) {
            if (!isExtensible(it))
              return "F";
            if (!create)
              return "E";
            setMeta(it);
          }
          return it[META].i;
        };
        var getWeak = function(it, create) {
          if (!has2(it, META)) {
            if (!isExtensible(it))
              return true;
            if (!create)
              return false;
            setMeta(it);
          }
          return it[META].w;
        };
        var onFreeze = function(it) {
          if (FREEZE && meta.NEED && isExtensible(it) && !has2(it, META))
            setMeta(it);
          return it;
        };
        var meta = module3.exports = {
          KEY: META,
          NEED: false,
          fastKey,
          getWeak,
          onFreeze
        };
      }
    ),
    /***/
    "ed33": (
      /***/
      function(module3, exports, __webpack_require__) {
        __webpack_require__("014b");
        module3.exports = __webpack_require__("584a").Object.getOwnPropertySymbols;
      }
    ),
    /***/
    "f6fd": (
      /***/
      function(module3, exports) {
        (function(document2) {
          var currentScript = "currentScript", scripts = document2.getElementsByTagName("script");
          if (!(currentScript in document2)) {
            Object.defineProperty(document2, currentScript, {
              get: function() {
                try {
                  throw new Error();
                } catch (err) {
                  var i2, res = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack) || [false])[1];
                  for (i2 in scripts) {
                    if (scripts[i2].src == res || scripts[i2].readyState == "interactive") {
                      return scripts[i2];
                    }
                  }
                  return null;
                }
              }
            });
          }
        })(document);
      }
    ),
    /***/
    "f772": (
      /***/
      function(module3, exports) {
        module3.exports = function(it) {
          return typeof it === "object" ? it !== null : typeof it === "function";
        };
      }
    ),
    /***/
    "fa5b": (
      /***/
      function(module3, exports, __webpack_require__) {
        module3.exports = __webpack_require__("5537")("native-function-to-string", Function.toString);
      }
    ),
    /***/
    "fab2": (
      /***/
      function(module3, exports, __webpack_require__) {
        var document2 = __webpack_require__("7726").document;
        module3.exports = document2 && document2.documentElement;
      }
    ),
    /***/
    "fb15": (
      /***/
      function(module3, __webpack_exports__, __webpack_require__) {
        __webpack_require__.r(__webpack_exports__);
        if (typeof window !== "undefined") {
          {
            __webpack_require__("f6fd");
          }
          var setPublicPath_i;
          if ((setPublicPath_i = window.document.currentScript) && (setPublicPath_i = setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))) {
            __webpack_require__.p = setPublicPath_i[1];
          }
        }
        var render = function() {
          var _vm = this;
          var _h = _vm.$createElement;
          var _c = _vm._self._c || _h;
          return _c("div", { ref: "wrapper", style: { width: "auto", height: _vm.container_height + "px", boxSizing: "border-box", display: "flex", justifyContent: "center", "alignItems": "center" }, attrs: { "id": "wrapper" } }, [_c("div", { style: { width: _vm.container_width + "px", height: _vm.container_height + "px", paddingTop: _vm.padding + "px", margin: "0 auto", boxSizing: "border-box" }, attrs: { "id": "container" } }, [!_vm.is_single && _vm.showHour ? _c("div", { staticClass: "item", style: { width: _vm.inner_size + "px", height: _vm.inner_size + "px", paddingLeft: _vm.padding + "px", paddingRight: _vm.padding + "px", float: "left", direction: "ltr", position: "relative" } }, [_c("div", { style: { width: _vm.inner_size + "px", height: _vm.inner_size + "px", lineHeight: _vm.inner_size + "px", position: "absolute", fontSize: _vm.number_font_size + "px" } }, [_vm._v("\n                " + _vm._s(_vm.factor * _vm.hours) + "\n            ")]), _c("svg", { attrs: { "width": _vm.inner_size, "height": _vm.inner_size, "xmlns": "http://www.w3.org/2000/svg" } }, [_c("circle", { attrs: { "r": _vm.r, "cy": _vm.cx, "cx": _vm.cy, "stroke-width": _vm.strokeWidth, "stroke": _vm.underneathStrokeColor, "fill": _vm.hoursFillColor } }), _c("circle", { staticClass: "circle_animation", style: { strokeDasharray: _vm.stroke_dasharray_hour, strokeDashoffset: _vm.stroke_dashoffset_hour }, attrs: { "transform": "rotate(-90, " + _vm.cx + ", " + _vm.cy + ")", "r": _vm.r, "cy": _vm.cx, "cx": _vm.cy, "stroke-width": _vm.strokeWidth, "stroke": _vm.hoursStrokeColor, "fill": "transparent" } })]), _vm.hourLabel ? _c("div", { ref: "label", style: { height: _vm.label_font_size + "px", fontSize: _vm.label_font_size + "px" } }, [_vm._v("\n                " + _vm._s(_vm.hourLabel) + "\n            ")]) : _vm._e()]) : _vm._e(), !_vm.is_single && _vm.showMinute ? _c("div", { staticClass: "item", style: { width: _vm.inner_size + "px", height: _vm.inner_size + "px", paddingLeft: _vm.padding + "px", paddingRight: _vm.padding + "px", float: "left", direction: "ltr", position: "relative" } }, [_c("div", { style: { width: _vm.inner_size + "px", height: _vm.inner_size + "px", lineHeight: _vm.inner_size + "px", position: "absolute", fontSize: _vm.number_font_size + "px" } }, [_vm._v("\n                " + _vm._s(_vm.factor * _vm.minutes) + "\n            ")]), _c("svg", { attrs: { "width": _vm.inner_size, "height": _vm.inner_size, "xmlns": "http://www.w3.org/2000/svg" } }, [_c("circle", { attrs: { "r": _vm.r, "cy": _vm.cx, "cx": _vm.cy, "stroke-width": _vm.strokeWidth, "stroke": _vm.underneathStrokeColor, "fill": _vm.minutesFillColor } }), _c("circle", { staticClass: "circle_animation", style: { strokeDasharray: _vm.stroke_dasharray_minute, strokeDashoffset: _vm.stroke_dashoffset_minute }, attrs: { "transform": "rotate(-90, " + _vm.cx + ", " + _vm.cy + ")", "r": _vm.r, "cy": _vm.cx, "cx": _vm.cy, "stroke-width": _vm.strokeWidth, "stroke": _vm.minutesStrokeColor, "fill": "transparent" } })]), _vm.minuteLabel ? _c("div", { style: { fontSize: _vm.label_font_size + "px" } }, [_vm._v("\n                " + _vm._s(_vm.minuteLabel) + "\n            ")]) : _vm._e()]) : _vm._e(), _vm.showSecond ? _c("div", { staticClass: "item", style: { width: _vm.inner_size + "px", height: _vm.inner_size + "px", paddingLeft: _vm.padding + "px", paddingRight: _vm.padding + "px", float: "left", direction: "ltr", position: "relative" } }, [_c("div", { style: { width: _vm.inner_size + "px", height: _vm.inner_size + "px", lineHeight: _vm.inner_size + "px", position: "absolute", fontSize: _vm.number_font_size + "px" } }, [_vm._v("\n                " + _vm._s(_vm.factor * _vm.seconds) + "\n            ")]), _c("svg", { attrs: { "width": _vm.inner_size, "height": _vm.inner_size, "xmlns": "http://www.w3.org/2000/svg" } }, [_c("circle", { attrs: { "r": _vm.r, "cy": _vm.cx, "cx": _vm.cy, "stroke-width": _vm.strokeWidth, "stroke": _vm.underneathStrokeColor, "fill": _vm.secondsFillColor } }), _c("circle", { staticClass: "circle_animation", style: { strokeDasharray: _vm.stroke_dasharray_second, strokeDashoffset: _vm.stroke_dashoffset_second }, attrs: { "transform": "rotate(-90, " + _vm.cx + ", " + _vm.cy + ")", "r": _vm.r, "cy": _vm.cx, "cx": _vm.cy, "stroke-width": _vm.strokeWidth, "stroke": _vm.secondsStrokeColor, "fill": "transparent" } })]), _vm.secondLabel ? _c("div", { style: { fontSize: _vm.label_font_size + "px" } }, [_vm._v("\n                " + _vm._s(_vm.secondLabel) + "\n            ")]) : _vm._e()]) : _vm._e()])]);
        };
        var staticRenderFns = [];
        var get_own_property_descriptor = __webpack_require__("268f");
        var get_own_property_descriptor_default = /* @__PURE__ */ __webpack_require__.n(get_own_property_descriptor);
        var get_own_property_symbols = __webpack_require__("e265");
        var get_own_property_symbols_default = /* @__PURE__ */ __webpack_require__.n(get_own_property_symbols);
        var keys2 = __webpack_require__("a4bb");
        var keys_default = /* @__PURE__ */ __webpack_require__.n(keys2);
        var define_property = __webpack_require__("85f2");
        var define_property_default = /* @__PURE__ */ __webpack_require__.n(define_property);
        function _defineProperty(obj, key, value2) {
          if (key in obj) {
            define_property_default()(obj, key, {
              value: value2,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value2;
          }
          return obj;
        }
        function _objectSpread(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2] != null ? arguments[i2] : {};
            var ownKeys2 = keys_default()(source);
            if (typeof get_own_property_symbols_default.a === "function") {
              ownKeys2 = ownKeys2.concat(get_own_property_symbols_default()(source).filter(function(sym) {
                return get_own_property_descriptor_default()(source, sym).enumerable;
              }));
            }
            ownKeys2.forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          }
          return target;
        }
        __webpack_require__("6762");
        __webpack_require__("2fdb");
        __webpack_require__("c5f6");
        var CircularCountDownTimervue_type_script_lang_js_ = {
          props: {
            initialValue: {
              type: Number,
              required: true,
              default: 0
            },
            strokeWidth: {
              type: Number,
              default: 5
            },
            secondsStrokeColor: {
              type: String,
              default: "#acdb28"
            },
            minutesStrokeColor: {
              type: String,
              default: "#729adb"
            },
            hoursStrokeColor: {
              type: String,
              default: "#db47a0"
            },
            underneathStrokeColor: {
              type: String,
              default: "#eee"
            },
            secondsFillColor: {
              type: String,
              default: "none"
            },
            minutesFillColor: {
              type: String,
              default: "none"
            },
            hoursFillColor: {
              type: String,
              default: "none"
            },
            size: {
              type: Number,
              default: 0
            },
            padding: {
              type: Number,
              default: 5
            },
            hourLabel: {
              type: String,
              default: "hours"
            },
            minuteLabel: {
              type: String,
              default: "minutes"
            },
            secondLabel: {
              type: String,
              default: "seconds"
            },
            showSecond: {
              type: Boolean,
              default: true
            },
            showMinute: {
              type: Boolean,
              default: true
            },
            showHour: {
              type: Boolean,
              default: true
            },
            showNegatives: {
              type: Boolean,
              default: false
            },
            steps: {
              type: Number,
              default: void 0
            },
            paused: {
              type: Boolean,
              default: false
            },
            notifyEvery: {
              type: String,
              default: "second",
              validator: function validator2(val) {
                return ["second", "minute", "hour", "none"].includes(val);
              }
            }
          },
          data: function data2() {
            return {
              isMounted: false,
              value: this.initialValue,
              labelFontRatio: 0.15,
              numberFontRatio: 0.2,
              baseTime: 0
            };
          },
          computed: {
            seconds_step: function seconds_step() {
              return this.is_single ? this.steps ? Math.max(this.steps, this.initialValue) : this.initialValue : 60;
            },
            is_single: function is_single() {
              return this.steps !== void 0 || !this.showHour && !this.showMinute;
            },
            hours: function hours2() {
              return Math.floor(Math.abs(this.value) / 3600);
            },
            minutes: function minutes2() {
              return Math.floor((Math.abs(this.value) - this.hours * 3600) / 60);
            },
            seconds: function seconds2() {
              return this.is_single ? this.value : Math.abs(this.value) % 60;
            },
            factor: function factor() {
              return this.value >= 0 ? 1 : -1;
            },
            circle_length: function circle_length() {
              return 2 * Math.PI * this.r;
            },
            hour_step_length: function hour_step_length() {
              return this.circle_length / 24;
            },
            minute_step_length: function minute_step_length() {
              return this.circle_length / 60;
            },
            second_step_length: function second_step_length() {
              return this.circle_length / this.seconds_step;
            },
            stroke_dasharray_hour: function stroke_dasharray_hour() {
              return this.circle_length;
            },
            stroke_dasharray_minute: function stroke_dasharray_minute() {
              return this.circle_length;
            },
            stroke_dasharray_second: function stroke_dasharray_second() {
              return this.circle_length;
            },
            stroke_dashoffset_hour: function stroke_dashoffset_hour() {
              return this.circle_length - this.hours * this.hour_step_length;
            },
            stroke_dashoffset_minute: function stroke_dashoffset_minute() {
              return this.circle_length - this.minutes * this.minute_step_length;
            },
            stroke_dashoffset_second: function stroke_dashoffset_second() {
              return this.circle_length - this.seconds * this.second_step_length;
            },
            cx: function cx() {
              return this.inner_size / 2;
            },
            cy: function cy() {
              return this.inner_size / 2;
            },
            r: function r() {
              return (this.inner_size - this.strokeWidth) / 2;
            },
            inner_size: function inner_size() {
              return this.circle_size - this.padding * 2;
            },
            circle_size: function circle_size() {
              var size2 = this.size === 0 && this.isMounted ? this.$refs.wrapper.parentElement.clientHeight : this.size;
              return this.has_label ? size2 - size2 * this.labelFontRatio : size2;
            },
            container_height: function container_height() {
              return this.size === 0 && this.isMounted ? this.$refs.wrapper.parentElement.clientHeight : this.size;
            },
            container_width: function container_width() {
              var circles = 0;
              if (this.showSecond) {
                circles++;
              }
              if (!this.is_single && this.showMinute) {
                circles++;
              }
              if (!this.is_single && this.showHour) {
                circles++;
              }
              return this.inner_size * circles + this.padding * (circles * 2);
            },
            has_label: function has_label() {
              return this.hourLabel !== "" || this.minuteLabel !== "" || this.secondLabel !== "";
            },
            label_font_size: function label_font_size() {
              return this.circle_size * this.labelFontRatio;
            },
            number_font_size: function number_font_size() {
              return this.circle_size * this.numberFontRatio;
            }
          },
          methods: {
            notifyChange: function notifyChange() {
              var output = {
                value: this.value
              };
              if (!this.is_single) {
                output = _objectSpread({}, output, {
                  seconds: this.seconds,
                  minutes: this.minutes,
                  hours: this.hours
                });
              }
              this.$emit("update", output);
            },
            updateTime: function updateTime(seconds2) {
              if (this.value)
                this.value += seconds2;
              if (this.value < 0) {
                this.$emit("finish");
              }
            }
          },
          watch: {
            seconds: function seconds2() {
              if (this.notifyEvery === "second") {
                this.notifyChange();
              }
            },
            minutes: function minutes2() {
              if (this.notifyEvery === "minute" && !this.is_single) {
                this.notifyChange();
              }
            },
            hours: function hours2() {
              if (this.notifyEvery === "hour" && !this.is_single) {
                this.notifyChange();
              }
            }
          },
          mounted: function mounted2() {
            var _this = this;
            this.$nextTick(function() {
              _this.isMounted = true;
              if (_this.value) {
                var interval = setInterval(function() {
                  if (this.paused) {
                    return;
                  }
                  var delta2 = 1;
                  this.value -= delta2;
                  if (this.value === 0) {
                    this.$emit("finish");
                  }
                  if (this.value <= 0 && !this.showNegatives) {
                    this.value = 0;
                    clearInterval(interval);
                  }
                }.bind(_this), 1e3);
              }
            });
          }
        };
        var components_CircularCountDownTimervue_type_script_lang_js_ = CircularCountDownTimervue_type_script_lang_js_;
        __webpack_require__("dbb4");
        function normalizeComponent(scriptExports, render2, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
          var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
          if (render2) {
            options.render = render2;
            options.staticRenderFns = staticRenderFns2;
            options._compiled = true;
          }
          if (functionalTemplate) {
            options.functional = true;
          }
          if (scopeId) {
            options._scopeId = "data-v-" + scopeId;
          }
          var hook;
          if (moduleIdentifier) {
            hook = function(context) {
              context = context || // cached call
              this.$vnode && this.$vnode.ssrContext || // stateful
              this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
              if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
                context = __VUE_SSR_CONTEXT__;
              }
              if (injectStyles) {
                injectStyles.call(this, context);
              }
              if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
              }
            };
            options._ssrRegister = hook;
          } else if (injectStyles) {
            hook = shadowMode ? function() {
              injectStyles.call(this, this.$root.$options.shadowRoot);
            } : injectStyles;
          }
          if (hook) {
            if (options.functional) {
              options._injectStyles = hook;
              var originalRender = options.render;
              options.render = function renderWithStyleInjection(h2, context) {
                hook.call(context);
                return originalRender(h2, context);
              };
            } else {
              var existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
            }
          }
          return {
            exports: scriptExports,
            options
          };
        }
        var component = normalizeComponent(
          components_CircularCountDownTimervue_type_script_lang_js_,
          render,
          staticRenderFns,
          false,
          null,
          "5998f914",
          null
        );
        var CircularCountDownTimer2 = component.exports;
        var components = {
          install: function install2(Vue, options) {
            Vue.component("circular-count-down-timer", CircularCountDownTimer2);
          }
        };
        __webpack_exports__["default"] = components;
      }
    ),
    /***/
    "fde4": (
      /***/
      function(module3, exports, __webpack_require__) {
        __webpack_require__("bf90");
        var $Object = __webpack_require__("584a").Object;
        module3.exports = function getOwnPropertyDescriptor(it, key) {
          return $Object.getOwnPropertyDescriptor(it, key);
        };
      }
    ),
    /***/
    "fdef": (
      /***/
      function(module3, exports) {
        module3.exports = "	\n\v\f\r   ᠎             　\u2028\u2029\uFEFF";
      }
    )
    /******/
  });
})(vueCountDownTimer_common);
var vueCountDownTimer_commonExports = vueCountDownTimer_common.exports;
const CircularCountDownTimer = /* @__PURE__ */ getDefaultExportFromCjs(vueCountDownTimer_commonExports);
(function() {
  var o;
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.nonce = (o = document.head.querySelector("meta[property=csp-nonce]")) == null ? void 0 : o.content, e.appendChild(document.createTextNode(".vue-notification-group{display:block;position:fixed;z-index:5000}.vue-notification-wrapper{display:block;overflow:hidden;width:100%;margin:0;padding:0}.notification-title{font-weight:600}.vue-notification-template{display:block;box-sizing:border-box;background:white;text-align:left}.vue-notification{display:block;box-sizing:border-box;text-align:left;font-size:12px;padding:10px;margin:0 5px 5px;color:#fff;background:#44A4FC;border-left:5px solid #187FE7}.vue-notification.warn{background:#ffb648;border-left-color:#f48a06}.vue-notification.error{background:#E54D42;border-left-color:#b82e24}.vue-notification.success{background:#68CD86;border-left-color:#42a85f}.vn-fade-enter-active,.vn-fade-leave-active,.vn-fade-move{transition:all .5s}.vn-fade-enter-from,.vn-fade-leave-to{opacity:0}")), document.head.appendChild(e);
    }
  } catch (i2) {
    console.error("vite-plugin-css-injected-by-js", i2);
  }
})();
const F = /* @__PURE__ */ new Map();
class pt {
  constructor(o, n, s) {
    this.remaining = n, this.callback = o, this.notifyItem = s, this.resume();
  }
  pause() {
    clearTimeout(this.notifyItem.timer), this.remaining -= Date.now() - this.start;
  }
  resume() {
    this.start = Date.now(), clearTimeout(this.notifyItem.timer), this.notifyItem.timer = setTimeout(this.callback, this.remaining);
  }
}
function dt(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(o, n) {
    var s = e.get(o);
    s ? s.push(n) : e.set(o, [n]);
  }, off: function(o, n) {
    var s = e.get(o);
    s && (n ? s.splice(s.indexOf(n) >>> 0, 1) : e.set(o, []));
  }, emit: function(o, n) {
    var s = e.get(o);
    s && s.slice().map(function(r) {
      r(n);
    }), (s = e.get("*")) && s.slice().map(function(r) {
      r(o, n);
    });
  } };
}
const x = dt(), w = "[-+]?[0-9]*.?[0-9]+", G = [
  {
    name: "px",
    regexp: new RegExp(`^${w}px$`)
  },
  {
    name: "%",
    regexp: new RegExp(`^${w}%$`)
  },
  /**
   * Fallback option
   * If no suffix specified, assigning "px"
   */
  {
    name: "px",
    regexp: new RegExp(`^${w}$`)
  }
], mt = (e) => {
  if (e === "auto")
    return {
      type: e,
      value: 0
    };
  for (let o = 0; o < G.length; o++) {
    const n = G[o];
    if (n.regexp.test(e))
      return {
        type: n.name,
        value: parseFloat(e)
      };
  }
  return {
    type: "",
    value: e
  };
}, yt = (e) => {
  switch (typeof e) {
    case "number":
      return { type: "px", value: e };
    case "string":
      return mt(e);
    default:
      return { type: "", value: e };
  }
}, j = {
  x: /* @__PURE__ */ new Set(["left", "center", "right"]),
  y: /* @__PURE__ */ new Set(["top", "bottom"])
}, ht = ((e) => () => e++)(0), gt = (e) => typeof e != "string" ? [] : e.split(/\s+/gi).filter(Boolean), vt = (e) => {
  typeof e == "string" && (e = gt(e));
  let o = null, n = null;
  return e.forEach((s) => {
    j.y.has(s) && (n = s), j.x.has(s) && (o = s);
  }), { x: o, y: n };
}, k = {
  position: ["top", "right"],
  cssAnimation: "vn-fade",
  velocityAnimation: {
    enter: (e) => ({
      height: [e.clientHeight, 0],
      opacity: [1, 0]
    }),
    leave: {
      height: 0,
      opacity: [0, 1]
    }
  }
}, _t = /* @__PURE__ */ defineComponent$1({
  __name: "VelocityGroup",
  emits: ["enter", "leave", "after-leave"],
  setup(e, { emit: o }) {
    const n = (c, f) => {
      o("enter", c, f);
    }, s = (c, f) => {
      o("leave", c, f);
    }, r = () => {
      o("after-leave");
    };
    return (c, f) => (openBlock(), createBlock(TransitionGroup, {
      tag: "span",
      css: false,
      onEnter: n,
      onLeave: s,
      onAfterLeave: r
    }, {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }));
  }
}), xt = /* @__PURE__ */ defineComponent$1({
  inheritAttrs: false,
  __name: "CssGroup",
  props: {
    name: {}
  },
  setup(e) {
    return (o, n) => (openBlock(), createBlock(TransitionGroup, {
      tag: "span",
      name: o.name
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["name"]));
  }
}), Tt = ["data-id"], Dt = ["onClick"], Et = ["innerHTML"], wt = ["innerHTML"], kt = {
  key: 0,
  class: "notification-title"
}, $t = { class: "notification-content" }, At = /* @__PURE__ */ defineComponent$1({
  __name: "Notifications",
  props: {
    group: { default: "" },
    width: { default: 300 },
    reverse: { type: Boolean, default: false },
    position: { default: k.position },
    classes: { default: "vue-notification" },
    animationType: { default: "css" },
    animation: { default: k.velocityAnimation },
    animationName: { default: k.cssAnimation },
    speed: { default: 300 },
    duration: { default: 3e3 },
    delay: { default: 0 },
    max: { default: 1 / 0 },
    ignoreDuplicates: { type: Boolean, default: false },
    closeOnClick: { type: Boolean, default: true },
    pauseOnHover: { type: Boolean, default: false },
    dangerouslySetInnerHtml: { type: Boolean, default: false }
  },
  emits: ["click", "destroy", "start"],
  setup(e, { emit: o }) {
    const n = e, s = {
      IDLE: 0,
      DESTROYED: 2
    }, r = ref([]), c = ref(null), f = ref(F.get("velocity")), v = computed(() => n.animationType === "velocity"), W = computed(() => v.value ? _t : xt), p2 = computed(() => r.value.filter((t) => t.state !== s.DESTROYED)), S = computed(() => yt(n.width)), C = computed(() => {
      const { x: t, y: a } = vt(n.position), i2 = S.value.value, u = S.value.type, h2 = {
        width: i2 + u
      };
      return a && (h2[a] = "0px"), t && (t === "center" ? h2.left = `calc(50% - ${+i2 / 2}${u})` : h2[t] = "0px"), h2;
    }), O = computed(() => "bottom" in C.value), P = (t) => {
      o("click", t), n.closeOnClick && y(t);
    }, q = () => {
      var t;
      n.pauseOnHover && ((t = c.value) == null || t.pause());
    }, J = () => {
      var t;
      n.pauseOnHover && ((t = c.value) == null || t.resume());
    }, K = (t = {}) => {
      if (t.group || (t.group = ""), t.data || (t.data = {}), n.group !== t.group)
        return;
      if (t.clean || t.clear) {
        tt();
        return;
      }
      const a = typeof t.duration == "number" ? t.duration : n.duration, i2 = typeof t.speed == "number" ? t.speed : n.speed, u = typeof t.ignoreDuplicates == "boolean" ? t.ignoreDuplicates : n.ignoreDuplicates, { title: h2, text: ot, type: it, data: st, id: at } = t, d = {
        id: at || ht(),
        title: h2,
        text: ot,
        type: it,
        state: s.IDLE,
        speed: i2,
        length: a + 2 * i2,
        data: st
      };
      a >= 0 && (c.value = new pt(() => y(d), d.length, d));
      const rt = n.reverse ? !O.value : O.value;
      let _ = -1;
      const lt = p2.value.some((N) => N.title === t.title && N.text === t.text);
      (!u || !lt) && (rt ? (r.value.push(d), o("start", d), p2.value.length > n.max && (_ = 0)) : (r.value.unshift(d), o("start", d), p2.value.length > n.max && (_ = p2.value.length - 1)), _ !== -1 && y(p2.value[_]));
    }, Q = (t) => {
      Z(t);
    }, U = (t) => [
      "vue-notification-template",
      n.classes,
      t.type || ""
    ], X = (t) => v.value ? void 0 : { transition: `all ${t.speed}ms` }, y = (t) => {
      clearTimeout(t.timer), t.state = s.DESTROYED, H(), o("destroy", t);
    }, Z = (t) => {
      const a = r.value.find((i2) => i2.id === t);
      a && y(a);
    }, tt = () => {
      p2.value.forEach(y);
    }, B = (t, a) => {
      var u;
      const i2 = (u = n.animation) == null ? void 0 : u[t];
      return typeof i2 == "function" ? i2(a) : i2;
    }, et = (t, a) => {
      if (!v.value)
        return;
      const i2 = B("enter", t);
      f.value(t, i2, {
        duration: n.speed,
        complete: a
      });
    }, nt = (t, a) => {
      if (!v.value)
        return;
      const i2 = B("leave", t);
      f.value(t, i2, {
        duration: n.speed,
        complete: a
      });
    };
    function H() {
      r.value = r.value.filter((t) => t.state !== s.DESTROYED);
    }
    return onMounted(() => {
      x.on("add", K), x.on("close", Q);
    }), (t, a) => (openBlock(), createElementBlock("div", {
      class: "vue-notification-group",
      style: normalizeStyle(C.value)
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(W.value), {
        name: t.animationName,
        onEnter: et,
        onLeave: nt,
        onAfterLeave: H
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(p2.value, (i2) => (openBlock(), createElementBlock("div", {
            key: i2.id,
            class: "vue-notification-wrapper",
            style: normalizeStyle(X(i2)),
            "data-id": i2.id,
            onMouseenter: q,
            onMouseleave: J
          }, [
            renderSlot(t.$slots, "body", {
              class: normalizeClass([t.classes, i2.type]),
              item: i2,
              close: () => y(i2)
            }, () => [
              createBaseVNode("div", {
                class: normalizeClass(U(i2)),
                onClick: (u) => P(i2)
              }, [
                t.dangerouslySetInnerHtml ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  i2.title ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "notification-title",
                    innerHTML: i2.title
                  }, null, 8, Et)) : createCommentVNode("", true),
                  createBaseVNode("div", {
                    class: "notification-content",
                    innerHTML: i2.text
                  }, null, 8, wt)
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  i2.title ? (openBlock(), createElementBlock("div", kt, toDisplayString(i2.title), 1)) : createCommentVNode("", true),
                  createBaseVNode("div", $t, toDisplayString(i2.text), 1)
                ], 64))
              ], 10, Dt)
            ])
          ], 44, Tt))), 128))
        ]),
        _: 3
      }, 40, ["name"]))
    ], 4));
  }
});
const L = (e) => {
  typeof e == "string" && (e = { title: "", text: e }), typeof e == "object" && x.emit("add", e);
};
L.close = (e) => {
  x.emit("close", e);
};
function It(e, o = {}) {
  Object.entries(o).forEach((s) => F.set(...s));
  const n = o.name || "notify";
  e.config.globalProperties["$" + n] = L, e.component(o.componentName || "Notifications", At);
}
const Ct = {
  install: It
};
const main = "";
const firstDay = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function getWeekArray(date2, locale2) {
  const weeks2 = [];
  let currentWeek = [];
  const firstDayOfMonth = startOfMonth(date2);
  const lastDayOfMonth = endOfMonth(date2);
  const firstDayWeekIndex = firstDayOfMonth.getDay() - firstDay[locale2.slice(-2).toUpperCase()];
  const lastDayWeekIndex = lastDayOfMonth.getDay() - firstDay[locale2.slice(-2).toUpperCase()];
  for (let i2 = 0; i2 < firstDayWeekIndex; i2++) {
    const adjacentDay = new Date(firstDayOfMonth);
    adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i2));
    currentWeek.push(adjacentDay);
  }
  for (let i2 = 1; i2 <= lastDayOfMonth.getDate(); i2++) {
    const day = new Date(date2.getFullYear(), date2.getMonth(), i2);
    currentWeek.push(day);
    if (currentWeek.length === 7) {
      weeks2.push(currentWeek);
      currentWeek = [];
    }
  }
  for (let i2 = 1; i2 < 7 - lastDayWeekIndex; i2++) {
    const adjacentDay = new Date(lastDayOfMonth);
    adjacentDay.setDate(adjacentDay.getDate() + i2);
    currentWeek.push(adjacentDay);
  }
  weeks2.push(currentWeek);
  return weeks2;
}
function startOfMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), 1);
}
function endOfMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
}
function parseLocalDate(value2) {
  const parts2 = value2.split("-").map(Number);
  return new Date(parts2[0], parts2[1] - 1, parts2[2]);
}
const _YYYMMDD = /([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))/;
function date(value2) {
  if (value2 == null)
    return /* @__PURE__ */ new Date();
  if (value2 instanceof Date)
    return value2;
  if (typeof value2 === "string") {
    let parsed;
    if (_YYYMMDD.test(value2)) {
      return parseLocalDate(value2);
    } else {
      parsed = Date.parse(value2);
    }
    if (!isNaN(parsed))
      return new Date(parsed);
  }
  return null;
}
const sundayJanuarySecond2000 = new Date(2e3, 0, 2);
function getWeekdays(locale2) {
  const daysFromSunday = firstDay[locale2.slice(-2).toUpperCase()];
  return createRange(7).map((i2) => {
    const weekday = new Date(sundayJanuarySecond2000);
    weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i2);
    return new Intl.DateTimeFormat(locale2, {
      weekday: "narrow"
    }).format(weekday);
  });
}
function format(value2, formatString, locale2) {
  const date2 = new Date(value2);
  let options = {};
  switch (formatString) {
    case "fullDateWithWeekday":
      options = {
        weekday: "long",
        day: "numeric",
        month: "long",
        year: "numeric"
      };
      break;
    case "normalDateWithWeekday":
      options = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "keyboardDate":
      options = {};
      break;
    case "monthAndDate":
      options = {
        month: "long",
        day: "numeric"
      };
      break;
    case "monthAndYear":
      options = {
        month: "long",
        year: "numeric"
      };
      break;
    case "dayOfMonth":
      options = {
        day: "numeric"
      };
      break;
    case "shortDate":
      options = {
        year: "numeric"
      };
      break;
    default:
      options = {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(locale2, options).format(date2);
}
function addDays(date2, amount) {
  const d = new Date(date2);
  d.setDate(d.getDate() + amount);
  return d;
}
function addMonths(date2, amount) {
  const d = new Date(date2);
  d.setMonth(d.getMonth() + amount);
  return d;
}
function getYear(date2) {
  return date2.getFullYear();
}
function getMonth(date2) {
  return date2.getMonth();
}
function startOfYear(date2) {
  return new Date(date2.getFullYear(), 0, 1);
}
function endOfYear(date2) {
  return new Date(date2.getFullYear(), 11, 31);
}
function isWithinRange(date2, range) {
  return isAfter(date2, range[0]) && isBefore(date2, range[1]);
}
function isValid(date2) {
  if (!date2 || date2 == null)
    return false;
  const d = new Date(date2);
  return d instanceof Date && !isNaN(d.getTime());
}
function isAfter(date2, comparing) {
  return date2.getTime() > comparing.getTime();
}
function isBefore(date2, comparing) {
  return date2.getTime() < comparing.getTime();
}
function isEqual(date2, comparing) {
  return date2.getTime() === comparing.getTime();
}
function isSameDay(date2, comparing) {
  return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
}
function isSameMonth(date2, comparing) {
  return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
}
function getDiff(date2, comparing, unit) {
  const d = new Date(date2);
  const c = new Date(comparing);
  if (unit === "month") {
    return d.getMonth() - c.getMonth() + (d.getFullYear() - c.getFullYear()) * 12;
  }
  return Math.floor((d.getTime() - c.getTime()) / (1e3 * 60 * 60 * 24));
}
function setYear(date2, year) {
  const d = new Date(date2);
  d.setFullYear(year);
  return d;
}
function startOfDay(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
}
function endOfDay(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
}
class VuetifyDateAdapter {
  constructor(options) {
    this.locale = options.locale;
  }
  date(value2) {
    return date(value2);
  }
  toJsDate(date2) {
    return date2;
  }
  addDays(date2, amount) {
    return addDays(date2, amount);
  }
  addMonths(date2, amount) {
    return addMonths(date2, amount);
  }
  getWeekArray(date2) {
    return getWeekArray(date2, this.locale);
  }
  startOfMonth(date2) {
    return startOfMonth(date2);
  }
  endOfMonth(date2) {
    return endOfMonth(date2);
  }
  format(date2, formatString) {
    return format(date2, formatString, this.locale);
  }
  isEqual(date2, comparing) {
    return isEqual(date2, comparing);
  }
  isValid(date2) {
    return isValid(date2);
  }
  isWithinRange(date2, range) {
    return isWithinRange(date2, range);
  }
  isAfter(date2, comparing) {
    return isAfter(date2, comparing);
  }
  isBefore(date2, comparing) {
    return !isAfter(date2, comparing) && !isEqual(date2, comparing);
  }
  isSameDay(date2, comparing) {
    return isSameDay(date2, comparing);
  }
  isSameMonth(date2, comparing) {
    return isSameMonth(date2, comparing);
  }
  setYear(date2, year) {
    return setYear(date2, year);
  }
  getDiff(date2, comparing, unit) {
    return getDiff(date2, comparing, unit);
  }
  getWeekdays() {
    return getWeekdays(this.locale);
  }
  getYear(date2) {
    return getYear(date2);
  }
  getMonth(date2) {
    return getMonth(date2);
  }
  startOfDay(date2) {
    return startOfDay(date2);
  }
  endOfDay(date2) {
    return endOfDay(date2);
  }
  startOfYear(date2) {
    return startOfYear(date2);
  }
  endOfYear(date2) {
    return endOfYear(date2);
  }
}
const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
function createDate(options) {
  return mergeDeep({
    adapter: VuetifyDateAdapter,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "nn-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, options);
}
function useDate() {
  const date2 = inject$1(DateAdapterSymbol);
  const locale2 = useLocale();
  if (!date2)
    throw new Error("[Vuetify] Could not find injected date");
  const instance = reactive(typeof date2.adapter === "function" ? new date2.adapter({
    locale: date2.locale?.[locale2.current.value] ?? locale2.current.value
  }) : date2.adapter);
  watch(locale2.current, (value2) => {
    const newLocale = date2.locale ? date2.locale[value2] : value2;
    instance.locale = newLocale ?? instance.locale;
  });
  return instance;
}
function toIso(adapter, value2) {
  const date2 = adapter.toJsDate(value2);
  return `${date2.getFullYear()}-${date2.getMonth() + 1}-${date2.getDate()}`;
}
function getMondayOfFirstWeekOfYear(year) {
  return new Date(year, 0, 1);
}
function getWeek(adapter, value2) {
  const date2 = adapter.toJsDate(value2);
  let year = date2.getFullYear();
  let d1w1 = getMondayOfFirstWeekOfYear(year);
  if (date2 < d1w1) {
    year = year - 1;
    d1w1 = getMondayOfFirstWeekOfYear(year);
  } else {
    const tv = getMondayOfFirstWeekOfYear(year + 1);
    if (date2 >= tv) {
      year = year + 1;
      d1w1 = tv;
    }
  }
  const diffTime = Math.abs(date2.getTime() - d1w1.getTime());
  const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
  return Math.floor(diffDays / 7) + 1;
}
function createVuetify() {
  let vuetify2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint,
    ...rest
  } = vuetify2;
  const options = mergeDeep(blueprint, rest);
  const {
    aliases: aliases2 = {},
    components = {},
    directives = {}
  } = options;
  const defaults2 = createDefaults(options.defaults);
  const display = createDisplay(options.display, options.ssr);
  const theme = createTheme(options.theme);
  const icons = createIcons(options.icons);
  const locale2 = createLocale(options.locale);
  const date2 = createDate(options.date);
  const install2 = (app2) => {
    for (const key in directives) {
      app2.directive(key, directives[key]);
    }
    for (const key in components) {
      app2.component(key, components[key]);
    }
    for (const key in aliases2) {
      app2.component(key, defineComponent({
        ...aliases2[key],
        name: key,
        aliasName: aliases2[key].name
      }));
    }
    theme.install(app2);
    app2.provide(DefaultsSymbol, defaults2);
    app2.provide(DisplaySymbol, display);
    app2.provide(ThemeSymbol, theme);
    app2.provide(IconSymbol, icons);
    app2.provide(LocaleSymbol, locale2);
    app2.provide(DateAdapterSymbol, date2);
    if (IN_BROWSER && options.ssr) {
      if (app2.$nuxt) {
        app2.$nuxt.hook("app:suspense:resolve", () => {
          display.update();
        });
      } else {
        const {
          mount
        } = app2;
        app2.mount = function() {
          const vm = mount(...arguments);
          nextTick$1(() => display.update());
          app2.mount = mount;
          return vm;
        };
      }
    }
    getUid.reset();
    {
      app2.mixin({
        computed: {
          $vuetify() {
            return reactive({
              defaults: inject.call(this, DefaultsSymbol),
              display: inject.call(this, DisplaySymbol),
              theme: inject.call(this, ThemeSymbol),
              icons: inject.call(this, IconSymbol),
              locale: inject.call(this, LocaleSymbol),
              date: inject.call(this, DateAdapterSymbol)
            });
          }
        }
      });
    }
  };
  return {
    install: install2,
    defaults: defaults2,
    display,
    theme,
    icons,
    locale: locale2,
    date: date2
  };
}
const version = "3.3.17";
createVuetify.version = version;
function inject(key) {
  const vm = this.$;
  const provides = vm.parent?.provides ?? vm.vnode.appContext?.provides;
  if (provides && key in provides) {
    return provides[key];
  }
}
const VDatePickerControls$1 = "";
const makeVDatePickerControlsProps = propsFactory({
  displayDate: String,
  disabled: {
    type: [Boolean, String, Array],
    default: false
  },
  nextIcon: {
    type: [String],
    default: "$next"
  },
  prevIcon: {
    type: [String],
    default: "$prev"
  },
  modeIcon: {
    type: [String],
    default: "$subgroup"
  },
  variant: {
    type: String,
    default: "modern"
  },
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls");
const VDatePickerControls = genericComponent()({
  name: "VDatePickerControls",
  props: makeVDatePickerControlsProps(),
  emits: {
    "click:mode": () => true,
    "click:prev": () => true,
    "click:next": () => true
  },
  setup(props, _ref) {
    let {
      emit: emit2
    } = _ref;
    const disableMode = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("mode") : !!props.disabled;
    });
    const disablePrev = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("prev") : !!props.disabled;
    });
    const disableNext = computed(() => {
      return Array.isArray(props.disabled) ? props.disabled.includes("next") : !!props.disabled;
    });
    function onClickPrev() {
      emit2("click:prev");
    }
    function onClickNext() {
      emit2("click:next");
    }
    function onClickMode() {
      emit2("click:mode");
    }
    useRender(() => {
      const displayDate = createVNode("div", {
        "class": "v-date-picker-controls__date"
      }, [props.displayDate]);
      return createVNode("div", {
        "class": ["v-date-picker-controls", `v-date-picker-controls--variant-${props.variant}`]
      }, [props.variant === "modern" && createVNode(Fragment, null, [displayDate, createVNode(VBtn, {
        "key": "mode-btn",
        "disabled": disableMode.value,
        "density": "comfortable",
        "icon": props.modeIcon,
        "variant": "text",
        "onClick": onClickMode
      }, null), createVNode(VSpacer, {
        "key": "mode-spacer"
      }, null)]), createVNode("div", {
        "key": "month-buttons",
        "class": "v-date-picker-controls__month"
      }, [createVNode(VBtn, {
        "disabled": disablePrev.value,
        "icon": props.prevIcon,
        "variant": "text",
        "onClick": onClickPrev
      }, null), props.variant === "classic" && displayDate, createVNode(VBtn, {
        "disabled": disableNext.value,
        "icon": props.nextIcon,
        "variant": "text",
        "onClick": onClickNext
      }, null)])]);
    });
    return {};
  }
});
const VDatePickerMonth$1 = "";
const makeDateProps = propsFactory({
  modelValue: {
    type: null,
    default: () => []
  },
  displayDate: {
    type: null,
    default: null
  },
  inputMode: {
    type: String,
    default: "calendar"
  },
  viewMode: {
    type: String,
    default: "month"
  },
  format: String
}, "date");
const dateEmits = {
  "update:modelValue": (date2) => true,
  "update:displayDate": (date2) => true,
  "update:focused": (focused) => true,
  "update:inputMode": (inputMode) => true,
  "update:viewMode": (viewMode) => true
};
function createDateInput(props, isRange) {
  const adapter = useDate();
  const model = useProxiedModel(props, "modelValue", [], (v) => {
    if (v == null)
      return [];
    const arr = wrapInArray(v).filter((v2) => !!v2);
    return arr.map(adapter.date);
  }, (v) => {
    const arr = wrapInArray(v);
    const formatted = props.format ? arr.map((d) => adapter.format(d, props.format)) : arr;
    if (isRange)
      return formatted;
    return formatted[0];
  });
  const inputMode = useProxiedModel(props, "inputMode");
  const viewMode = useProxiedModel(props, "viewMode");
  const displayDate = useProxiedModel(props, "displayDate", model.value.length ? model.value[0] : adapter.date());
  function parseKeyboardDate(input, fallback) {
    const date2 = adapter.date(input);
    return adapter.isValid(date2) ? date2 : fallback;
  }
  function isEqual2(model2, comparing) {
    if (model2.length !== comparing.length)
      return false;
    for (let i2 = 0; i2 < model2.length; i2++) {
      if (comparing[i2] && !adapter.isEqual(model2[i2], comparing[i2])) {
        return false;
      }
    }
    return true;
  }
  return {
    model,
    adapter,
    inputMode,
    viewMode,
    displayDate,
    parseKeyboardDate,
    isEqual: isEqual2
  };
}
const DatePickerSymbol = Symbol.for("vuetify:date-picker");
function createDatePicker(props) {
  const hoverDate = ref();
  const hoverMonth = ref();
  const isDragging = ref(false);
  const dragHandle = ref(null);
  const hasScrolled = ref(false);
  provide(DatePickerSymbol, {
    hoverDate,
    hoverMonth,
    isDragging,
    dragHandle,
    hasScrolled
  });
  const {
    model,
    displayDate,
    viewMode,
    inputMode,
    isEqual: isEqual2
  } = createDateInput(props, !!props.multiple);
  return {
    hoverDate,
    hoverMonth,
    isDragging,
    dragHandle,
    hasScrolled,
    model,
    displayDate,
    viewMode,
    inputMode,
    isEqual: isEqual2
  };
}
function useDatePicker() {
  const datePicker = inject$1(DatePickerSymbol);
  if (!datePicker)
    throw new Error("foo");
  return datePicker;
}
const makeVDatePickerMonthProps = propsFactory({
  color: String,
  showAdjacentMonths: Boolean,
  hideWeekdays: Boolean,
  showWeek: Boolean,
  hoverDate: null,
  multiple: Boolean,
  side: {
    type: String
  },
  min: [Number, String, Date],
  max: [Number, String, Date],
  ...omit(makeDateProps(), ["inputMode", "viewMode"])
}, "VDatePickerMonth");
const VDatePickerMonth = genericComponent()({
  name: "VDatePickerMonth",
  props: makeVDatePickerMonthProps({
    color: "surface-variant"
  }),
  emits: {
    ...omit(dateEmits, ["update:inputMode", "update:viewMode"]),
    "update:hoverDate": (date2) => true
  },
  setup(props, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      isDragging,
      dragHandle,
      hasScrolled
    } = useDatePicker();
    const month = computed(() => props.displayDate);
    const findClosestDate = (date2, dates) => {
      const {
        isSameDay: isSameDay2,
        getDiff: getDiff2
      } = adapter;
      const [startDate, endDate] = dates;
      if (isSameDay2(startDate, endDate)) {
        return getDiff2(date2, startDate, "days") > 0 ? endDate : startDate;
      }
      const distStart = Math.abs(getDiff2(date2, startDate));
      const distEnd = Math.abs(getDiff2(date2, endDate));
      return distStart < distEnd ? startDate : endDate;
    };
    const weeksInMonth = computed(() => {
      const weeks3 = adapter.getWeekArray(month.value);
      const days2 = weeks3.flat();
      const daysInMonth3 = 6 * 7;
      if (days2.length < daysInMonth3 && props.showAdjacentMonths) {
        const lastDay = days2[days2.length - 1];
        let week = [];
        for (let day = 1; day <= daysInMonth3 - days2.length; day++) {
          week.push(adapter.addDays(lastDay, day));
          if (day % 7 === 0) {
            weeks3.push(week);
            week = [];
          }
        }
      }
      return weeks3;
    });
    const daysInMonth2 = computed(() => {
      const validDates = props.modelValue.filter((v) => !!v);
      const isRange = validDates.length > 1;
      const days2 = weeksInMonth.value.flat();
      const today = adapter.date();
      const startDate = validDates[0];
      const endDate = validDates[1];
      return days2.map((date2, index) => {
        const isDisabled = !!(props.min && adapter.isAfter(props.min, date2) || props.max && adapter.isAfter(date2, props.max));
        const isStart = startDate && adapter.isSameDay(date2, startDate);
        const isEnd = endDate && adapter.isSameDay(date2, endDate);
        const isAdjacent = !adapter.isSameMonth(date2, month.value);
        const isSame2 = validDates.length === 2 && adapter.isSameDay(startDate, endDate);
        return {
          date: date2,
          isoDate: toIso(adapter, date2),
          formatted: adapter.format(date2, "keyboardDate"),
          year: adapter.getYear(date2),
          month: adapter.getMonth(date2),
          isDisabled,
          isWeekStart: index % 7 === 0,
          isWeekEnd: index % 7 === 6,
          isSelected: isStart || isEnd,
          isStart,
          isEnd,
          isToday: adapter.isSameDay(date2, today),
          isAdjacent,
          isHidden: isAdjacent && !props.showAdjacentMonths,
          inRange: isRange && !isSame2 && (isStart || isEnd || validDates.length === 2 && adapter.isWithinRange(date2, validDates)),
          // isHovered: props.hoverDate === date,
          // inHover: hoverRange.value && isWithinRange(date, hoverRange.value),
          isHovered: false,
          inHover: false,
          localized: adapter.format(date2, "dayOfMonth")
        };
      });
    });
    const weeks2 = computed(() => {
      return weeksInMonth.value.map((week) => {
        return getWeek(adapter, week[0]);
      });
    });
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    function selectDate(date2) {
      let newModel = props.modelValue.slice();
      if (props.multiple) {
        if (isDragging.value && dragHandle.value != null) {
          const otherIndex = (dragHandle.value + 1) % 2;
          const fn = otherIndex === 0 ? "isBefore" : "isAfter";
          if (adapter[fn](date2, newModel[otherIndex])) {
            newModel[dragHandle.value] = newModel[otherIndex];
            newModel[otherIndex] = date2;
            dragHandle.value = otherIndex;
          } else {
            newModel[dragHandle.value] = date2;
          }
        } else {
          if (newModel.find((d) => adapter.isSameDay(d, date2))) {
            newModel = newModel.filter((v) => !adapter.isSameDay(v, date2));
          } else if (newModel.length === 2) {
            let index;
            if (!props.side || adapter.isSameMonth(newModel[0], newModel[1])) {
              const closest = findClosestDate(date2, newModel);
              index = newModel.indexOf(closest);
            } else {
              index = props.side === "start" ? 0 : props.side === "end" ? 1 : void 0;
            }
            newModel = newModel.map((v, i2) => i2 === index ? date2 : v);
          } else {
            if (newModel[0] && adapter.isBefore(newModel[0], date2)) {
              newModel = [newModel[0], date2];
            } else {
              newModel = [date2, newModel[0]];
            }
          }
        }
      } else {
        newModel = [date2];
      }
      emit2("update:modelValue", newModel.filter((v) => !!v));
    }
    const daysRef = ref();
    function findElement(el) {
      if (!el || el === daysRef.value)
        return null;
      if ("vDate" in el.dataset) {
        return adapter.date(el.dataset.vDate);
      }
      return findElement(el.parentElement);
    }
    function findDate(e) {
      const x2 = "changedTouches" in e ? e.changedTouches[0]?.clientX : e.clientX;
      const y = "changedTouches" in e ? e.changedTouches[0]?.clientY : e.clientY;
      const el = document.elementFromPoint(x2, y);
      return findElement(el);
    }
    let canDrag = false;
    function handleMousedown(e) {
      hasScrolled.value = false;
      const selected = findDate(e);
      if (!selected)
        return;
      const modelIndex = props.modelValue.findIndex((d) => adapter.isEqual(d, selected));
      if (modelIndex >= 0) {
        canDrag = true;
        dragHandle.value = modelIndex;
        window.addEventListener("touchmove", handleTouchmove, {
          passive: false
        });
        window.addEventListener("mousemove", handleTouchmove, {
          passive: false
        });
        e.preventDefault();
      }
      window.addEventListener("touchend", handleTouchend, {
        passive: false
      });
      window.addEventListener("mouseup", handleTouchend, {
        passive: false
      });
    }
    function handleTouchmove(e) {
      if (!canDrag)
        return;
      e.preventDefault();
      isDragging.value = true;
      const over = findDate(e);
      if (!over)
        return;
      selectDate(over);
    }
    function handleTouchend(e) {
      if (e.cancelable)
        e.preventDefault();
      window.removeEventListener("touchmove", handleTouchmove);
      window.removeEventListener("mousemove", handleTouchmove);
      window.removeEventListener("touchend", handleTouchend);
      window.removeEventListener("mouseup", handleTouchend);
      const end = findDate(e);
      if (!end)
        return;
      if (!hasScrolled.value) {
        selectDate(end);
      }
      isDragging.value = false;
      dragHandle.value = null;
      canDrag = false;
    }
    return () => createVNode("div", {
      "class": "v-date-picker-month"
    }, [props.showWeek && createVNode("div", {
      "key": "weeks",
      "class": "v-date-picker-month__weeks"
    }, [!props.hideWeekdays && createVNode("div", {
      "key": "hide-week-days",
      "class": "v-date-picker-month__day"
    }, [createTextVNode(" ")]), weeks2.value.map((week) => createVNode("div", {
      "class": ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
    }, [week]))]), createVNode("div", {
      "ref": daysRef,
      "class": "v-date-picker-month__days",
      "onMousedown": handleMousedown,
      "onTouchstart": handleMousedown
    }, [!props.hideWeekdays && adapter.getWeekdays().map((weekDay) => createVNode("div", {
      "class": ["v-date-picker-month__day", "v-date-picker-month__weekday"]
    }, [weekDay])), daysInMonth2.value.map((item, index) => {
      const color = item.isSelected || item.isToday ? props.color : item.isHovered || item.isDisabled ? void 0 : "transparent";
      const variant = item.isDisabled ? "text" : (item.isToday || item.isHovered) && !item.isSelected ? "outlined" : "flat";
      return createVNode("div", {
        "class": ["v-date-picker-month__day", {
          "v-date-picker-month__day--selected": item.isSelected,
          "v-date-picker-month__day--start": item.isStart,
          "v-date-picker-month__day--end": item.isEnd,
          "v-date-picker-month__day--adjacent": item.isAdjacent,
          "v-date-picker-month__day--hide-adjacent": item.isHidden,
          "v-date-picker-month__day--week-start": item.isWeekStart,
          "v-date-picker-month__day--week-end": item.isWeekEnd,
          "v-date-picker-month__day--hovered": item.isHovered
        }],
        "data-v-date": !item.isHidden && !item.isDisabled ? item.isoDate : void 0
      }, [item.inRange && createVNode("div", {
        "key": "in-range",
        "class": ["v-date-picker-month__day--range", backgroundColorClasses.value],
        "style": backgroundColorStyles.value
      }, null), item.inHover && !item.isStart && !item.isEnd && !item.isHovered && !item.inRange && createVNode("div", {
        "key": "in-hover",
        "class": "v-date-picker-month__day--hover"
      }, null), (props.showAdjacentMonths || !item.isAdjacent) && createVNode(VBtn, {
        "color": !item.isToday || item.isSelected ? color : void 0,
        "disabled": item.isDisabled,
        "icon": true,
        "ripple": false,
        "variant": variant
      }, {
        default: () => [item.localized]
      })]);
    })])]);
  }
});
const VDatePickerYears$1 = "";
const makeVDatePickerYearsProps = propsFactory({
  color: String,
  height: [String, Number],
  displayDate: null,
  min: [Number, String, Date],
  max: [Number, String, Date]
}, "VDatePickerYears");
const VDatePickerYears = genericComponent()({
  name: "VDatePickerYears",
  props: makeVDatePickerYearsProps(),
  emits: {
    "update:displayDate": (date2) => true,
    "click:mode": () => true
  },
  setup(props, _ref) {
    let {
      emit: emit2
    } = _ref;
    const adapter = useDate();
    const displayYear = computed(() => adapter.getYear(props.displayDate ?? /* @__PURE__ */ new Date()));
    const years2 = computed(() => {
      const min2 = props.min ? adapter.date(props.min).getFullYear() : displayYear.value - 100;
      const max2 = props.max ? adapter.date(props.max).getFullYear() : displayYear.value + 50;
      return createRange(max2 - min2 + 1, min2);
    });
    const yearRef = ref();
    onMounted(() => {
      yearRef.value?.$el.scrollIntoView({
        block: "center"
      });
    });
    useRender(() => createVNode("div", {
      "class": "v-date-picker-years",
      "style": {
        height: convertToUnit(props.height)
      }
    }, [createVNode("div", {
      "class": "v-date-picker-years__content"
    }, [years2.value.map((year) => {
      function onClick() {
        emit2("update:displayDate", adapter.setYear(props.displayDate, year));
        emit2("click:mode");
      }
      return createVNode(VBtn, {
        "ref": year === displayYear.value ? yearRef : void 0,
        "active": year === displayYear.value,
        "color": year === displayYear.value ? props.color : void 0,
        "rounded": "xl",
        "text": String(year),
        "variant": year === displayYear.value ? "flat" : "text",
        "onClick": onClick
      }, null);
    })])]));
    return {};
  }
});
const VDatePicker$1 = "";
const VDatePickerHeader$1 = "";
const makeVDatePickerHeaderProps = propsFactory({
  appendIcon: String,
  color: String,
  header: String,
  transition: String,
  onClick: EventProp()
}, "VDatePickerHeader");
const VDatePickerHeader = genericComponent()({
  name: "VDatePickerHeader",
  props: makeVDatePickerHeaderProps(),
  emits: {
    click: () => true,
    "click:append": () => true
  },
  setup(props, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props, "color");
    function onClick() {
      emit2("click");
    }
    function onClickAppend() {
      emit2("click:append");
    }
    useRender(() => {
      const hasContent = !!(slots.default || props.header);
      const hasAppend = !!(slots.append || props.appendIcon);
      return createVNode("div", {
        "class": ["v-date-picker-header", {
          "v-date-picker-header--clickable": !!props.onClick
        }, backgroundColorClasses.value],
        "style": backgroundColorStyles.value,
        "onClick": onClick
      }, [slots.prepend && createVNode("div", {
        "key": "prepend",
        "class": "v-date-picker-header__prepend"
      }, [slots.prepend()]), hasContent && createVNode(MaybeTransition, {
        "key": "content",
        "name": props.transition
      }, {
        default: () => [createVNode("div", {
          "key": props.header,
          "class": "v-date-picker-header__content"
        }, [slots.default?.() ?? props.header])]
      }), hasAppend && createVNode("div", {
        "class": "v-date-picker-header__append"
      }, [!slots.append ? createVNode(VBtn, {
        "key": "append-btn",
        "icon": props.appendIcon,
        "variant": "text",
        "onClick": onClickAppend
      }, null) : createVNode(VDefaultsProvider, {
        "key": "append-defaults",
        "disabled": !props.appendIcon,
        "defaults": {
          VBtn: {
            icon: props.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => [slots.append?.()]
      })])]);
    });
    return {};
  }
});
const VPicker$1 = "";
const VPickerTitle = createSimpleFunctional("v-picker-title");
const makeVPickerProps = propsFactory({
  bgColor: String,
  landscape: Boolean,
  title: String,
  ...makeVSheetProps()
}, "VPicker");
const VPicker = genericComponent()({
  name: "VPicker",
  props: makeVPickerProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    useRender(() => {
      const [sheetProps] = VSheet.filterProps(props);
      const hasTitle = !!(props.title || slots.title);
      return createVNode(VSheet, mergeProps(sheetProps, {
        "color": props.bgColor,
        "class": ["v-picker", {
          "v-picker--landscape": props.landscape,
          "v-picker--with-actions": !!slots.actions
        }, props.class],
        "style": props.style
      }), {
        default: () => [createVNode("div", {
          "class": [backgroundColorClasses.value],
          "style": [backgroundColorStyles.value]
        }, [hasTitle && createVNode(VPickerTitle, {
          "key": "picker-title"
        }, {
          default: () => [slots.title?.() ?? props.title]
        }), slots.header && createVNode("div", {
          "class": "v-picker__header"
        }, [slots.header()])]), createVNode("div", {
          "class": "v-picker__body"
        }, [slots.default?.()]), slots.actions?.()[0]?.children && createVNode("div", {
          "class": "v-picker__actions"
        }, [slots.actions()])]
      });
    });
    return {};
  }
});
const makeVDatePickerProps = propsFactory({
  calendarIcon: {
    type: String,
    default: "$calendar"
  },
  keyboardIcon: {
    type: String,
    default: "$edit"
  },
  cancelText: {
    type: String,
    default: "$vuetify.datePicker.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.datePicker.ok"
  },
  inputText: {
    type: String,
    default: "$vuetify.datePicker.input.placeholder"
  },
  inputPlaceholder: {
    type: String,
    default: "dd/mm/yyyy"
  },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  hideActions: Boolean,
  ...makeDateProps(),
  ...makeVDatePickerControlsProps(),
  ...makeVDatePickerMonthProps(),
  ...makeVDatePickerYearsProps(),
  ...makeVPickerProps({
    title: "$vuetify.datePicker.title"
  })
}, "VDatePicker");
const VDatePicker = genericComponent()({
  name: "VDatePicker",
  props: makeVDatePickerProps(),
  emits: {
    "click:cancel": () => true,
    "click:save": () => true,
    ...dateEmits
  },
  setup(props, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      t
    } = useLocale();
    const {
      model,
      displayDate,
      viewMode,
      inputMode,
      isEqual: isEqual2
    } = createDatePicker(props);
    const isReversing = shallowRef(false);
    const inputModel = ref(model.value.map((date2) => adapter.format(date2, "keyboardDate")));
    const temporaryModel = ref(model.value);
    const title = computed(() => {
      return props.variant === "modern" ? t(props.title) : adapter.format(displayDate.value, "shortDate");
    });
    const header = computed(() => model.value.length ? adapter.format(model.value[0], "normalDateWithWeekday") : t(props.header));
    const headerIcon = computed(() => inputMode.value === "calendar" ? props.keyboardIcon : props.calendarIcon);
    const headerTransition = computed(() => `date-picker-header${isReversing.value ? "-reverse" : ""}-transition`);
    const minDate = computed(() => props.min && adapter.isValid(props.min) ? adapter.date(props.min) : null);
    const maxDate = computed(() => props.max && adapter.isValid(props.max) ? adapter.date(props.max) : null);
    const disabled = computed(() => {
      if (!minDate.value && !maxDate.value)
        return false;
      const targets = [];
      if (minDate.value) {
        const date2 = adapter.addDays(adapter.startOfMonth(displayDate.value), -1);
        adapter.isAfter(minDate.value, date2) && targets.push("prev");
      }
      if (maxDate.value) {
        const date2 = adapter.addDays(adapter.endOfMonth(displayDate.value), 1);
        adapter.isAfter(date2, maxDate.value) && targets.push("next");
      }
      if (minDate.value?.getFullYear() === maxDate.value?.getFullYear()) {
        targets.push("mode");
      }
      return targets;
    });
    watch(model, (val) => {
      if (!isEqual2(val, temporaryModel.value)) {
        temporaryModel.value = val;
      }
      inputModel.value = val.map((date2) => adapter.format(date2, "keyboardDate"));
    });
    watch(temporaryModel, (val, oldVal) => {
      if (props.hideActions && !isEqual2(val, model.value)) {
        model.value = val;
      }
      if (val[0] && oldVal[0]) {
        isReversing.value = adapter.isBefore(val[0], oldVal[0]);
      }
    });
    function updateFromInput(input, index) {
      const {
        isValid: isValid2,
        date: date2,
        isAfter: isAfter2
      } = adapter;
      const inputDate = date2(input);
      if (isValid2(input) && (!minDate.value || !isAfter2(minDate.value, inputDate)) && (!maxDate.value || !isAfter2(inputDate, maxDate.value))) {
        const newModel = model.value.slice();
        newModel[index] = date2(input);
        if (props.hideActions) {
          model.value = newModel;
        } else {
          temporaryModel.value = newModel;
        }
      }
    }
    function onClickCancel() {
      emit2("click:cancel");
    }
    function onClickSave() {
      emit2("click:save");
      model.value = temporaryModel.value;
    }
    function onClickAppend() {
      inputMode.value = inputMode.value === "calendar" ? "keyboard" : "calendar";
    }
    function onClickNext() {
      displayDate.value = adapter.addMonths(displayDate.value, 1);
    }
    function onClickPrev() {
      displayDate.value = adapter.addMonths(displayDate.value, -1);
    }
    function onClickMode() {
      viewMode.value = viewMode.value === "month" ? "year" : "month";
    }
    function onClickHeader() {
      viewMode.value = "month";
    }
    const headerSlotProps = computed(() => ({
      header: header.value,
      appendIcon: headerIcon.value,
      transition: headerTransition.value,
      "onClick:append": onClickAppend
    }));
    useRender(() => {
      const [pickerProps] = VPicker.filterProps(props);
      const [datePickerControlsProps] = VDatePickerControls.filterProps(props);
      const [datePickerMonthProps] = VDatePickerMonth.filterProps(props);
      const [datePickerYearsProps] = VDatePickerYears.filterProps(props);
      return createVNode(VPicker, mergeProps(pickerProps, {
        "class": ["v-date-picker", `v-date-picker--${viewMode.value}`, props.class],
        "style": props.style,
        "width": props.showWeek ? 408 : 360
      }), {
        title: () => slots.title?.() ?? createVNode("div", {
          "class": "v-date-picker__title",
          "onClick": props.variant === "classic" ? onClickMode : void 0
        }, [title.value]),
        header: () => slots.header?.(headerSlotProps.value) ?? createVNode(VDatePickerHeader, mergeProps({
          "key": "header"
        }, headerSlotProps.value, {
          "onClick": viewMode.value === "year" ? onClickHeader : void 0
        }), null),
        default: () => inputMode.value === "calendar" ? createVNode(Fragment, null, [(props.variant !== "classic" || viewMode.value !== "year") && createVNode(VDatePickerControls, mergeProps(datePickerControlsProps, {
          "disabled": disabled.value,
          "displayDate": adapter.format(displayDate.value, "monthAndYear"),
          "onClick:next": onClickNext,
          "onClick:prev": onClickPrev,
          "onClick:mode": onClickMode
        }), null), createVNode(VFadeTransition, {
          "hideOnLeave": true
        }, {
          default: () => [viewMode.value === "month" ? createVNode(VDatePickerMonth, mergeProps({
            "key": "date-picker-month"
          }, datePickerMonthProps, {
            "modelValue": temporaryModel.value,
            "onUpdate:modelValue": ($event) => temporaryModel.value = $event,
            "displayDate": displayDate.value,
            "min": minDate.value,
            "max": maxDate.value
          }), null) : createVNode(VDatePickerYears, mergeProps({
            "key": "date-picker-years"
          }, datePickerYearsProps, {
            "displayDate": displayDate.value,
            "onUpdate:displayDate": ($event) => displayDate.value = $event,
            "min": minDate.value,
            "max": maxDate.value,
            "onClick:mode": onClickMode
          }), null)]
        })]) : createVNode("div", {
          "class": "v-date-picker__input"
        }, [createVNode(VTextField, {
          "modelValue": inputModel.value[0],
          "onUpdate:modelValue": (v) => updateFromInput(v, 0),
          "label": t(props.inputText),
          "placeholder": props.inputPlaceholder
        }, null)]),
        actions: () => !props.hideActions ? createVNode("div", null, [createVNode(VBtn, {
          "variant": "text",
          "color": props.color,
          "onClick": onClickCancel,
          "text": t(props.cancelText)
        }, null), createVNode(VBtn, {
          "variant": "text",
          "color": props.color,
          "onClick": onClickSave,
          "text": t(props.okText)
        }, null)]) : void 0
      });
    });
    return {};
  }
});
const materialdesignicons = "";
const vuetify = createVuetify({
  icons: {
    defaultSet: "mdi",
    aliases,
    sets: {
      mdi
    }
  },
  components: {
    VDatePicker
  }
});
const sweetalert2_min = "";
const store = createStore();
const app = createApp(App);
app.use(router);
app.use(store);
app.use(vuetify);
const options1 = {
  confirmButtonColor: "#ADE2F8",
  cancelButtonColor: "#ff7674"
};
app.use(VueSweetalert2, options1);
app.use(WebRTC);
app.use(Ct);
app.use(CircularCountDownTimer);
app.config.productionTip = false;
router.beforeEach((to2, from2, next) => {
  const idAssistant = localStorage.getItem("idAssistant");
  if (idAssistant || to2.name === "login") {
    next();
  } else {
    next({ name: "login" });
  }
});
app.mount("#app");
export {
  commonjsGlobal$1 as c,
  getDefaultExportFromCjs as g
};
